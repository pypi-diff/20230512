# Comparing `tmp/chython-1.64.tar.gz` & `tmp/chython-1.8.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "chython-1.64.tar", last modified: Wed May 10 15:23:30 2023, max compression
+gzip compressed data, was "chython-1.8.tar", last modified: Fri Nov 12 15:45:40 2021, max compression
```

## Comparing `chython-1.64.tar` & `chython-1.8.tar`

### file list

```diff
@@ -1,155 +1,133 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.202132 chython-1.64/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/INCHI/
--rw-r--r--   0 runner    (1001) docker     (123)  1297408 2023-05-10 15:23:11.432634 chython-1.64/INCHI/libinchi.dll
--rwxr-xr-x   0 runner    (1001) docker     (123)  1335296 2023-05-10 15:23:11.448635 chython-1.64/INCHI/libinchi.dynlib
--rw-r--r--   0 runner    (1001) docker     (123)  1353400 2023-05-10 15:23:11.460636 chython-1.64/INCHI/libinchi.so
--rw-r--r--   0 runner    (1001) docker     (123)     3228 2023-05-10 15:23:30.202132 chython-1.64/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     1767 2023-05-10 15:23:11.460636 chython-1.64/README.rst
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/
--rw-r--r--   0 runner    (1001) docker     (123)     1258 2023-05-10 15:23:11.460636 chython-1.64/chython/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2276 2023-05-10 15:23:11.460636 chython-1.64/chython/_functions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)      788 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)   946720 2023-05-10 15:23:26.985875 chython-1.64/chython/algorithms/_isomorphism.c
--rw-r--r--   0 runner    (1001) docker     (123)     7323 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/_isomorphism.pyx
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/algorithms/aromatics/
--rw-r--r--   0 runner    (1001) docker     (123)      912 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/aromatics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2993 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/aromatics/_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)    23489 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/aromatics/kekule.py
--rw-r--r--   0 runner    (1001) docker     (123)     8838 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/aromatics/thiele.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/algorithms/calculate2d/
--rw-r--r--   0 runner    (1001) docker     (123)     6952 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/calculate2d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    92275 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/calculate2d/clean2d.js
--rw-r--r--   0 runner    (1001) docker     (123)    24779 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/depict.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/algorithms/fingerprints/
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/fingerprints/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6617 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/fingerprints/linear.py
--rw-r--r--   0 runner    (1001) docker     (123)     3874 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/fingerprints/morgan.py
--rw-r--r--   0 runner    (1001) docker     (123)    22895 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/isomorphism.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/algorithms/mapping/
--rw-r--r--   0 runner    (1001) docker     (123)      972 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/mapping/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2657 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/mapping/_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     2418 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/mapping/_reactions.py
--rw-r--r--   0 runner    (1001) docker     (123)     7403 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/mapping/attention.py
--rw-r--r--   0 runner    (1001) docker     (123)     3030 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/mapping/fixmapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     5186 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/mapping/groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     7142 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/mcs.py
--rw-r--r--   0 runner    (1001) docker     (123)     2930 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/morgan.py
--rw-r--r--   0 runner    (1001) docker     (123)    20222 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/rings.py
--rw-r--r--   0 runner    (1001) docker     (123)    23580 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/smiles.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/algorithms/standardize/
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/standardize/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4019 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/standardize/_charged.py
--rw-r--r--   0 runner    (1001) docker     (123)    37919 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/standardize/_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     6202 2023-05-10 15:23:11.460636 chython-1.64/chython/algorithms/standardize/_metal_organics.py
--rw-r--r--   0 runner    (1001) docker     (123)     1369 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/standardize/_reagents.py
--rw-r--r--   0 runner    (1001) docker     (123)     1949 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/standardize/_salts.py
--rw-r--r--   0 runner    (1001) docker     (123)    19436 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/standardize/molecule.py
--rw-r--r--   0 runner    (1001) docker     (123)    15203 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/standardize/reaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     7628 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/standardize/resonance.py
--rw-r--r--   0 runner    (1001) docker     (123)     4609 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/standardize/salts.py
--rw-r--r--   0 runner    (1001) docker     (123)    15884 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/standardize/saturation.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.194131 chython-1.64/chython/algorithms/stereo/
--rw-r--r--   0 runner    (1001) docker     (123)      869 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/stereo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    16677 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/stereo/graph.py
--rw-r--r--   0 runner    (1001) docker     (123)    32184 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/stereo/molecule.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/algorithms/tautomers/
--rw-r--r--   0 runner    (1001) docker     (123)    10141 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1524 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/_acid.py
--rw-r--r--   0 runner    (1001) docker     (123)     2854 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     2538 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/_keto_enol.py
--rw-r--r--   0 runner    (1001) docker     (123)     7698 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/acid_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     3703 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/heteroarenes.py
--rw-r--r--   0 runner    (1001) docker     (123)     5776 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/keto_enol.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/algorithms/tautomers/test/
--rw-r--r--   0 runner    (1001) docker     (123)      783 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3611 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/tautomers/test/test_tautomers.py
--rw-r--r--   0 runner    (1001) docker     (123)    16555 2023-05-10 15:23:11.464636 chython-1.64/chython/algorithms/x3dom.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/containers/
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)   862541 2023-05-10 15:23:27.949952 chython-1.64/chython/containers/_cpack.c
--rw-r--r--   0 runner    (1001) docker     (123)   275805 2023-05-10 15:23:28.069962 chython-1.64/chython/containers/_pack.c
--rw-r--r--   0 runner    (1001) docker     (123)     9761 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/_pack.pyx
--rw-r--r--   0 runner    (1001) docker     (123)   899973 2023-05-10 15:23:29.222054 chython-1.64/chython/containers/_unpack.c
--rw-r--r--   0 runner    (1001) docker     (123)    12461 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/_unpack.pyx
--rw-r--r--   0 runner    (1001) docker     (123)     8073 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/bonds.py
--rw-r--r--   0 runner    (1001) docker     (123)     5400 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/cgr.py
--rw-r--r--   0 runner    (1001) docker     (123)     9269 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/graph.py
--rw-r--r--   0 runner    (1001) docker     (123)    43829 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/molecule.py
--rw-r--r--   0 runner    (1001) docker     (123)    13544 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/query.py
--rw-r--r--   0 runner    (1001) docker     (123)    11839 2023-05-10 15:23:11.464636 chython-1.64/chython/containers/reaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     2454 2023-05-10 15:23:11.464636 chython-1.64/chython/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/files/
--rw-r--r--   0 runner    (1001) docker     (123)    19912 2023-05-10 15:23:11.464636 chython-1.64/chython/files/MRVrw.py
--rw-r--r--   0 runner    (1001) docker     (123)    10403 2023-05-10 15:23:11.464636 chython-1.64/chython/files/PDBrw.py
--rw-r--r--   0 runner    (1001) docker     (123)    13279 2023-05-10 15:23:11.464636 chython-1.64/chython/files/RDFrw.py
--rw-r--r--   0 runner    (1001) docker     (123)     9079 2023-05-10 15:23:11.464636 chython-1.64/chython/files/SDFrw.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-10 15:23:11.464636 chython-1.64/chython/files/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4175 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_convert.py
--rw-r--r--   0 runner    (1001) docker     (123)     4231 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mapping.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/files/_mdl/
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6740 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/emol.py
--rw-r--r--   0 runner    (1001) docker     (123)     2414 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/erxn.py
--rw-r--r--   0 runner    (1001) docker     (123)     6962 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/mol.py
--rw-r--r--   0 runner    (1001) docker     (123)     8100 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/read.py
--rw-r--r--   0 runner    (1001) docker     (123)     2369 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/rxn.py
--rw-r--r--   0 runner    (1001) docker     (123)     3709 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/stereo.py
--rw-r--r--   0 runner    (1001) docker     (123)     5861 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_mdl/write.py
--rw-r--r--   0 runner    (1001) docker     (123)   808716 2023-05-10 15:23:30.186131 chython-1.64/chython/files/_xyz.c
--rw-r--r--   0 runner    (1001) docker     (123)     2480 2023-05-10 15:23:11.464636 chython-1.64/chython/files/_xyz.pyx
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/files/daylight/
--rw-r--r--   0 runner    (1001) docker     (123)      916 2023-05-10 15:23:11.464636 chython-1.64/chython/files/daylight/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6657 2023-05-10 15:23:11.464636 chython-1.64/chython/files/daylight/parser.py
--rw-r--r--   0 runner    (1001) docker     (123)     4547 2023-05-10 15:23:11.464636 chython-1.64/chython/files/daylight/smarts.py
--rw-r--r--   0 runner    (1001) docker     (123)    14284 2023-05-10 15:23:11.464636 chython-1.64/chython/files/daylight/smiles.py
--rw-r--r--   0 runner    (1001) docker     (123)    14797 2023-05-10 15:23:11.464636 chython-1.64/chython/files/daylight/tokenize.py
--rw-r--r--   0 runner    (1001) docker     (123)    23351 2023-05-10 15:23:11.468637 chython-1.64/chython/files/inchi.py
--rw-r--r--   0 runner    (1001) docker     (123)     2909 2023-05-10 15:23:11.468637 chython-1.64/chython/files/xyz.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/periodictable/
--rw-r--r--   0 runner    (1001) docker     (123)     2291 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/periodictable/element/
--rw-r--r--   0 runner    (1001) docker     (123)     1103 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/element/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3010 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/element/core.py
--rw-r--r--   0 runner    (1001) docker     (123)     3591 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/element/dynamic.py
--rw-r--r--   0 runner    (1001) docker     (123)    12970 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/element/element.py
--rw-r--r--   0 runner    (1001) docker     (123)    12197 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/element/query.py
--rw-r--r--   0 runner    (1001) docker     (123)     4698 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupI.py
--rw-r--r--   0 runner    (1001) docker     (123)     4882 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupII.py
--rw-r--r--   0 runner    (1001) docker     (123)    25391 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     6765 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupIV.py
--rw-r--r--   0 runner    (1001) docker     (123)     5972 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupIX.py
--rw-r--r--   0 runner    (1001) docker     (123)     5570 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupV.py
--rw-r--r--   0 runner    (1001) docker     (123)     5349 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupVI.py
--rw-r--r--   0 runner    (1001) docker     (123)     3751 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupVII.py
--rw-r--r--   0 runner    (1001) docker     (123)     4166 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupVIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     4207 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupX.py
--rw-r--r--   0 runner    (1001) docker     (123)     3851 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXI.py
--rw-r--r--   0 runner    (1001) docker     (123)     3878 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXII.py
--rw-r--r--   0 runner    (1001) docker     (123)     5375 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     5889 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXIV.py
--rw-r--r--   0 runner    (1001) docker     (123)     5847 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXV.py
--rw-r--r--   0 runner    (1001) docker     (123)    16618 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXVI.py
--rw-r--r--   0 runner    (1001) docker     (123)     8665 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXVII.py
--rw-r--r--   0 runner    (1001) docker     (123)     5795 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groupXVIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     1447 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     1047 2023-05-10 15:23:11.468637 chython-1.64/chython/periodictable/periods.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/reactor/
--rw-r--r--   0 runner    (1001) docker     (123)      989 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    11323 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/base.py
--rw-r--r--   0 runner    (1001) docker     (123)    19713 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/deprotection.py
--rw-r--r--   0 runner    (1001) docker     (123)     5630 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/reactions.py
--rw-r--r--   0 runner    (1001) docker     (123)     8091 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/reactor.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.198132 chython-1.64/chython/reactor/test/
--rw-r--r--   0 runner    (1001) docker     (123)      784 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1832 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/test/test_deprotection.py
--rw-r--r--   0 runner    (1001) docker     (123)     2663 2023-05-10 15:23:11.468637 chython-1.64/chython/reactor/transformer.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:23:30.202132 chython-1.64/chython/utils/
--rw-r--r--   0 runner    (1001) docker     (123)     1716 2023-05-10 15:23:11.468637 chython-1.64/chython/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3830 2023-05-10 15:23:11.468637 chython-1.64/chython/utils/free_wilson.py
--rw-r--r--   0 runner    (1001) docker     (123)     1757 2023-05-10 15:23:11.468637 chython-1.64/chython/utils/functional_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     4461 2023-05-10 15:23:11.468637 chython-1.64/chython/utils/grid.py
--rw-r--r--   0 runner    (1001) docker     (123)     6369 2023-05-10 15:23:11.468637 chython-1.64/chython/utils/rdkit.py
--rw-r--r--   0 runner    (1001) docker     (123)     4500 2023-05-10 15:23:11.468637 chython-1.64/chython/utils/retro.py
--rw-r--r--   0 runner    (1001) docker     (123)     1907 2023-05-10 15:23:11.468637 chython-1.64/chython/utils/svg.py
--rw-r--r--   0 runner    (1001) docker     (123)     4712 2023-05-10 15:23:11.472637 chython-1.64/setup.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.351194 chython-1.8/
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.204187 chython-1.8/INCHI/
+-rw-rw-rw-   0        0        0  1297408 2021-10-01 15:03:36.041446 chython-1.8/INCHI/libinchi.dll
+-rw-rw-rw-   0        0        0  1335296 2021-10-01 15:03:36.057122 chython-1.8/INCHI/libinchi.dynlib
+-rw-rw-rw-   0        0        0  1353400 2021-10-01 15:03:36.072748 chython-1.8/INCHI/libinchi.so
+-rw-rw-rw-   0        0        0     2937 2021-11-12 15:45:40.351194 chython-1.8/PKG-INFO
+-rw-rw-rw-   0        0        0     1910 2021-10-01 15:03:36.088321 chython-1.8/README.rst
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.208188 chython-1.8/chython/
+-rw-rw-rw-   0        0        0     1379 2021-10-01 15:03:36.088321 chython-1.8/chython/__init__.py
+-rw-rw-rw-   0        0        0     2345 2021-10-01 15:03:36.088321 chython-1.8/chython/_functions.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.224188 chython-1.8/chython/algorithms/
+-rw-rw-rw-   0        0        0      806 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/__init__.py
+-rw-rw-rw-   0        0        0   932678 2021-10-18 19:02:47.667603 chython-1.8/chython/algorithms/_isomorphism.c
+-rw-rw-rw-   0        0        0     7215 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/_isomorphism.pyx
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.229187 chython-1.8/chython/algorithms/aromatics/
+-rw-rw-rw-   0        0        0      939 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/aromatics/__init__.py
+-rw-rw-rw-   0        0        0     4530 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/aromatics/_rules.py
+-rw-rw-rw-   0        0        0    20981 2021-10-21 13:10:51.279065 chython-1.8/chython/algorithms/aromatics/kekule.py
+-rw-rw-rw-   0        0        0     8680 2021-10-11 09:51:11.184900 chython-1.8/chython/algorithms/aromatics/thiele.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.232188 chython-1.8/chython/algorithms/calculate2d/
+-rw-rw-rw-   0        0        0     8719 2021-10-08 10:55:30.023916 chython-1.8/chython/algorithms/calculate2d/__init__.py
+-rw-rw-rw-   0        0        0   106510 2021-10-01 15:03:36.119572 chython-1.8/chython/algorithms/calculate2d/clean2d.js
+-rw-rw-rw-   0        0        0    59367 2021-10-01 15:39:44.329425 chython-1.8/chython/algorithms/depict.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.235188 chython-1.8/chython/algorithms/fingerprints/
+-rw-rw-rw-   0        0        0     1067 2021-10-01 15:03:36.126098 chython-1.8/chython/algorithms/fingerprints/__init__.py
+-rw-rw-rw-   0        0        0     7940 2021-10-01 15:03:36.126098 chython-1.8/chython/algorithms/fingerprints/linear.py
+-rw-rw-rw-   0        0        0     5129 2021-10-01 15:03:36.126098 chython-1.8/chython/algorithms/fingerprints/morgan.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.236188 chython-1.8/chython/algorithms/fingerprints/pharmacophore/
+-rw-rw-rw-   0        0        0     3682 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/fingerprints/pharmacophore/__init__.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.237188 chython-1.8/chython/algorithms/fingerprints/pharmacophore/test/
+-rw-rw-rw-   0        0        0      861 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/fingerprints/pharmacophore/test/__init__.py
+-rw-rw-rw-   0        0        0     3712 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/huckel.py
+-rw-rw-rw-   0        0        0    11117 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/isomorphism.py
+-rw-rw-rw-   0        0        0     7344 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/mcs.py
+-rw-rw-rw-   0        0        0     2970 2021-10-01 15:03:36.157358 chython-1.8/chython/algorithms/morgan.py
+-rw-rw-rw-   0        0        0    20611 2021-10-01 15:03:36.157358 chython-1.8/chython/algorithms/rings.py
+-rw-rw-rw-   0        0        0    18757 2021-10-25 08:03:55.083423 chython-1.8/chython/algorithms/smiles.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.251189 chython-1.8/chython/algorithms/standardize/
+-rw-rw-rw-   0        0        0     1054 2021-11-09 10:50:29.396153 chython-1.8/chython/algorithms/standardize/__init__.py
+-rw-rw-rw-   0        0        0     9094 2021-10-01 15:03:36.157358 chython-1.8/chython/algorithms/standardize/_charged.py
+-rw-rw-rw-   0        0        0    33550 2021-11-07 15:58:14.990364 chython-1.8/chython/algorithms/standardize/_groups.py
+-rw-rw-rw-   0        0        0     5521 2021-10-01 15:03:36.172982 chython-1.8/chython/algorithms/standardize/_mapping.py
+-rw-rw-rw-   0        0        0     7920 2021-10-21 13:10:51.303064 chython-1.8/chython/algorithms/standardize/_metal_organics.py
+-rw-rw-rw-   0        0        0    16775 2021-11-09 10:50:29.421143 chython-1.8/chython/algorithms/standardize/molecule.py
+-rw-rw-rw-   0        0        0    18949 2021-10-11 09:21:45.299426 chython-1.8/chython/algorithms/standardize/reaction.py
+-rw-rw-rw-   0        0        0     6851 2021-11-09 13:12:25.581393 chython-1.8/chython/algorithms/standardize/resonance.py
+-rw-rw-rw-   0        0        0    16017 2021-11-10 13:40:22.321112 chython-1.8/chython/algorithms/standardize/saturation.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.254189 chython-1.8/chython/algorithms/stereo/
+-rw-rw-rw-   0        0        0      892 2021-10-01 15:03:36.188608 chython-1.8/chython/algorithms/stereo/__init__.py
+-rw-rw-rw-   0        0        0    16935 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/stereo/graph.py
+-rw-rw-rw-   0        0        0    30479 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/stereo/molecule.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.259206 chython-1.8/chython/algorithms/tautomers/
+-rw-rw-rw-   0        0        0    24062 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/tautomers/__init__.py
+-rw-rw-rw-   0        0        0     2319 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/tautomers/_acid.py
+-rw-rw-rw-   0        0        0     5639 2021-10-01 15:03:36.219858 chython-1.8/chython/algorithms/tautomers/_base.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.263189 chython-1.8/chython/algorithms/tautomers/test/
+-rw-rw-rw-   0        0        0      801 2021-10-01 15:03:36.226363 chython-1.8/chython/algorithms/tautomers/test/__init__.py
+-rw-rw-rw-   0        0        0     3705 2021-10-01 15:03:36.226363 chython-1.8/chython/algorithms/tautomers/test/test_tautomers.py
+-rw-rw-rw-   0        0        0    67036 2021-10-01 15:03:36.226363 chython-1.8/chython/algorithms/x3dom.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.274190 chython-1.8/chython/containers/
+-rw-rw-rw-   0        0        0      962 2021-10-01 15:03:36.226363 chython-1.8/chython/containers/__init__.py
+-rw-rw-rw-   0        0        0   841821 2021-11-06 12:09:30.148048 chython-1.8/chython/containers/_unpack.c
+-rw-rw-rw-   0        0        0     6572 2021-11-06 12:09:19.720644 chython-1.8/chython/containers/_unpack.pyx
+-rw-rw-rw-   0        0        0     6306 2021-10-01 15:03:36.241998 chython-1.8/chython/containers/bonds.py
+-rw-rw-rw-   0        0        0     7279 2021-10-11 09:30:21.431589 chython-1.8/chython/containers/cgr.py
+-rw-rw-rw-   0        0        0     8112 2021-10-01 15:03:36.241998 chython-1.8/chython/containers/graph.py
+-rw-rw-rw-   0        0        0    46832 2021-11-09 10:50:29.382138 chython-1.8/chython/containers/molecule.py
+-rw-rw-rw-   0        0        0    23441 2021-10-21 13:10:51.313065 chython-1.8/chython/containers/query.py
+-rw-rw-rw-   0        0        0    10122 2021-11-06 12:09:19.658135 chython-1.8/chython/containers/reaction.py
+-rw-rw-rw-   0        0        0     1794 2021-10-01 15:03:36.257623 chython-1.8/chython/exceptions.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.286191 chython-1.8/chython/files/
+-rw-rw-rw-   0        0        0    28760 2021-10-01 15:03:36.691780 chython-1.8/chython/files/INCHIrw.py
+-rw-rw-rw-   0        0        0    19149 2021-10-01 15:03:36.691780 chython-1.8/chython/files/MRVrw.py
+-rw-rw-rw-   0        0        0     9982 2021-10-01 15:03:36.706614 chython-1.8/chython/files/PDBrw.py
+-rw-rw-rw-   0        0        0    15072 2021-10-01 15:03:36.706614 chython-1.8/chython/files/RDFrw.py
+-rw-rw-rw-   0        0        0    12214 2021-10-01 15:03:36.706614 chython-1.8/chython/files/SDFrw.py
+-rw-rw-rw-   0        0        0    36198 2021-10-01 15:03:36.722209 chython-1.8/chython/files/SMILESrw.py
+-rw-rw-rw-   0        0        0    10227 2021-10-01 15:03:36.737557 chython-1.8/chython/files/XYZrw.py
+-rw-rw-rw-   0        0        0     1093 2021-10-21 13:10:51.322075 chython-1.8/chython/files/__init__.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.300191 chython-1.8/chython/files/_mdl/
+-rw-rw-rw-   0        0        0     1090 2021-10-01 15:03:36.737557 chython-1.8/chython/files/_mdl/__init__.py
+-rw-rw-rw-   0        0        0     2192 2021-10-01 15:03:36.737557 chython-1.8/chython/files/_mdl/_write.py
+-rw-rw-rw-   0        0        0     9399 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/emol.py
+-rw-rw-rw-   0        0        0     3893 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/erxn.py
+-rw-rw-rw-   0        0        0     3556 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/ewrite.py
+-rw-rw-rw-   0        0        0     7672 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/mol.py
+-rw-rw-rw-   0        0        0     8066 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/parser.py
+-rw-rw-rw-   0        0        0     7260 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/read.py
+-rw-rw-rw-   0        0        0     3830 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/rxn.py
+-rw-rw-rw-   0        0        0     3185 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/stereo.py
+-rw-rw-rw-   0        0        0     4847 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/write.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.302191 chython-1.8/chython/files/test/
+-rw-rw-rw-   0        0        0      801 2021-10-01 15:03:36.784485 chython-1.8/chython/files/test/__init__.py
+-rw-rw-rw-   0        0        0     2958 2021-10-01 15:03:36.784485 chython-1.8/chython/files/test/test_smilesrw.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.331193 chython-1.8/chython/periodictable/
+-rw-rw-rw-   0        0        0     2350 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/__init__.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.338193 chython-1.8/chython/periodictable/element/
+-rw-rw-rw-   0        0        0     1130 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/element/__init__.py
+-rw-rw-rw-   0        0        0     3899 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/element/core.py
+-rw-rw-rw-   0        0        0     3696 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/element/dynamic.py
+-rw-rw-rw-   0        0        0    12481 2021-11-09 09:30:23.683866 chython-1.8/chython/periodictable/element/element.py
+-rw-rw-rw-   0        0        0    14928 2021-10-21 13:10:51.330267 chython-1.8/chython/periodictable/element/query.py
+-rw-rw-rw-   0        0        0     4918 2021-10-01 15:03:36.800069 chython-1.8/chython/periodictable/groupI.py
+-rw-rw-rw-   0        0        0     5081 2021-10-21 13:10:51.339246 chython-1.8/chython/periodictable/groupII.py
+-rw-rw-rw-   0        0        0    26418 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupIII.py
+-rw-rw-rw-   0        0        0     7031 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupIV.py
+-rw-rw-rw-   0        0        0     6723 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupIX.py
+-rw-rw-rw-   0        0        0     5746 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupV.py
+-rw-rw-rw-   0        0        0     5516 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupVI.py
+-rw-rw-rw-   0        0        0     3897 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupVII.py
+-rw-rw-rw-   0        0        0     4054 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupVIII.py
+-rw-rw-rw-   0        0        0     4625 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupX.py
+-rw-rw-rw-   0        0        0     4094 2021-10-21 13:10:51.347937 chython-1.8/chython/periodictable/groupXI.py
+-rw-rw-rw-   0        0        0     4801 2021-10-01 15:03:36.844445 chython-1.8/chython/periodictable/groupXII.py
+-rw-rw-rw-   0        0        0     5481 2021-10-01 15:03:36.844445 chython-1.8/chython/periodictable/groupXIII.py
+-rw-rw-rw-   0        0        0     6025 2021-10-01 15:03:36.844445 chython-1.8/chython/periodictable/groupXIV.py
+-rw-rw-rw-   0        0        0     5584 2021-11-06 16:24:23.470725 chython-1.8/chython/periodictable/groupXV.py
+-rw-rw-rw-   0        0        0    14740 2021-10-21 13:10:51.363938 chython-1.8/chython/periodictable/groupXVI.py
+-rw-rw-rw-   0        0        0     8800 2021-10-21 13:10:51.373354 chython-1.8/chython/periodictable/groupXVII.py
+-rw-rw-rw-   0        0        0     6027 2021-10-01 15:03:36.860036 chython-1.8/chython/periodictable/groupXVIII.py
+-rw-rw-rw-   0        0        0     1537 2021-10-01 15:03:36.860036 chython-1.8/chython/periodictable/groups.py
+-rw-rw-rw-   0        0        0     1093 2021-10-01 15:03:36.860036 chython-1.8/chython/periodictable/periods.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.345193 chython-1.8/chython/reactor/
+-rw-rw-rw-   0        0        0      911 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/__init__.py
+-rw-rw-rw-   0        0        0     8568 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/base.py
+-rw-rw-rw-   0        0        0     8392 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/reactor.py
+-rw-rw-rw-   0        0        0     2469 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/transformer.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.350194 chython-1.8/chython/utils/
+-rw-rw-rw-   0        0        0     1097 2021-10-01 15:03:36.875654 chython-1.8/chython/utils/__init__.py
+-rw-rw-rw-   0        0        0     1810 2021-10-01 15:03:36.875654 chython-1.8/chython/utils/functional_groups.py
+-rw-rw-rw-   0        0        0     2844 2021-10-01 15:03:36.891319 chython-1.8/chython/utils/grid.py
+-rw-rw-rw-   0        0        0     6071 2021-10-01 15:03:36.891319 chython-1.8/chython/utils/rdkit.py
+-rw-rw-rw-   0        0        0     4631 2021-11-09 09:58:26.156698 chython-1.8/setup.py
```

### Comparing `chython-1.64/INCHI/libinchi.dll` & `chython-1.8/INCHI/libinchi.dll`

 * *Files identical despite different names*

### Comparing `chython-1.64/INCHI/libinchi.dynlib` & `chython-1.8/INCHI/libinchi.dynlib`

 * *Files identical despite different names*

### Comparing `chython-1.64/INCHI/libinchi.so` & `chython-1.8/INCHI/libinchi.so`

 * *Files identical despite different names*

### Comparing `chython-1.64/PKG-INFO` & `chython-1.8/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,82 +1,92 @@
-Metadata-Version: 2.1
-Name: chython
-Version: 1.64
-Summary: UNKNOWN
-Home-page: https://github.com/chython/chython
-Author: Dr. Ramil Nugmanov
-Author-email: nougmanoff@protonmail.com
-License: LGPLv3
-Description: Chython [ˈkʌɪθ(ə)n]
-        ===================
-        
-        Library for processing molecules and reactions in python way.
-        
-        Features:
-           - Read/write/convert formats: MDL .RDF (.RXN) and .SDF (.MOL), .MRV, SMILES, INCHI (inchi-trust library), .XYZ, .PDB
-           - Standardize molecules and reactions and valid structures checker
-           - Supported python-magic
-           - Tetrahedron, Allene and CIS-TRANS stereo supported
-           - Perform subgraph search
-           - Build/edit molecules and reactions with Python API
-           - Produce template based reactions and molecules
-           - Atom-to-atom mapping, checking and rule-based fixing
-           - Perform MCS search
-           - 2d coordinates generation (based on `SmilesDrawer <https://github.com/reymond-group/smilesDrawer>`_)
-           - 2d/3d depiction with Jupyter support
-           - SMARTS parser with restrictions
-           - Protective groups remover
-           - Common reaction templates collection
-        
-        Full documentation can be found `here <https://chython.readthedocs.io>`_.
-        
-        Chython is fork of `CGRtools <https://github.com/stsouko/CGRtools>`_.
-        
-        Install
-        =======
-        
-        Only python 3.8+.
-        
-        Note: for using `clean2d` install NodeJS into system.
-        
-        * **stable version available through PyPI**::
-        
-            pip install chython
-        
-        * Install chython library DEV version for features that are not well tested::
-        
-            pip install -U git+https://github.com/chython/chython.git@master#egg=chython
-        
-        Copyright
-        =========
-        
-        * 2014-2023 Ramil Nugmanov nougmanoff@protonmail.com main developer
-        
-        Contributors
-        ============
-        
-        * Adelia Fatykhova adelik21979@gmail.com
-        * Aleksandr Sizov murkyrussian@gmail.com
-        * Dinar Batyrshin batyrshin-dinar@mail.ru
-        * Dmitrij Zanadvornykh zandmitrij@gmail.com
-        * Ravil Mukhametgaleev sonic-mc@mail.ru
-        * Tagir Akhmetshin tagirshin@gmail.com
-        * Timur Gimadiev timur.gimadiev@gmail.com
-        * Zarina Ibragimova
-        
-Platform: UNKNOWN
-Classifier: Environment :: Plugins
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)
-Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Chemistry
-Classifier: Topic :: Scientific/Engineering :: Information Analysis
-Classifier: Topic :: Software Development
-Classifier: Topic :: Software Development :: Libraries
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Requires-Python: >=3.8
-Provides-Extra: pytest
-Provides-Extra: mapping
+Metadata-Version: 2.1
+Name: chython
+Version: 1.8
+Summary: UNKNOWN
+Home-page: https://github.com/chython/chython
+Author: Dr. Ramil Nugmanov
+Author-email: nougmanoff@protonmail.com
+License: LGPLv3
+Platform: UNKNOWN
+Classifier: Environment :: Plugins
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Chemistry
+Classifier: Topic :: Scientific/Engineering :: Information Analysis
+Classifier: Topic :: Software Development
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+Requires-Python: >=3.8
+Provides-Extra: pytest
+License-File: LICENSE
+
+Chython [ˈkʌɪθ(ə)n]
+===================
+
+Library for processing molecules and reactions in python way.
+
+Features:
+   - Read/write/convert formats: MDL .RDF (.RXN) and .SDF (.MOL), .MRV, SMILES, INCHI (inchi-trust library), .XYZ, .PDB
+   - Standardize molecules and reactions and valid structures checker
+   - Supported python-magic
+   - Tetrahedron, Allene and CIS-TRANS stereo supporting
+   - Perform subgraph search
+   - Build/edit molecules and reactions
+   - Produce template based reactions and molecules
+   - Atom-to-atom mapping checker and rule-based fixer
+   - Perform MCS search
+   - 2d coordinates generation (based on `SmilesDrawer <https://github.com/reymond-group/smilesDrawer>`_)
+   - 2d/3d depiction
+   - Produce CGRs (Condensed Graph of Reaction)
+
+Full documentation can be found `here <https://chython.readthedocs.io>`_.
+
+Chython is fork of `CGRtools <https://github.com/stsouko/CGRtools>`_.
+
+
+INSTALL
+=======
+
+Only python 3.8+.
+
+Note: for using `clean2d` install NodeJS into system.
+
+* **stable version available through PyPI**::
+
+    pip install chython
+
+* Install chython library DEV version for features that are not well tested::
+
+    pip install -U git+https://github.com/chython/chython.git@master#egg=chython
+
+TESTS
+=====
+
+Run unit tests::
+
+    git clone https://github.com/chython/chython.git && cd chython  # skip if already got sources
+    pip install -e .
+    pytest --pyargs chython
+
+COPYRIGHT
+=========
+
+* 2014-2021 Ramil Nugmanov nougmanoff@protonmail.com main developer
+
+CONTRIBUTORS
+============
+
+* Adelia Fatykhova adelik21979@gmail.com
+* Aleksandr Sizov murkyrussian@gmail.com
+* Dinar Batyrshin batyrshin-dinar@mail.ru
+* Dmitrij Zanadvornykh zandmitrij@gmail.com
+* Ravil Mukhametgaleev sonic-mc@mail.ru
+* Tagir Akhmetshin tagirshin@gmail.com
+* Timur Gimadiev timur.gimadiev@gmail.com
+* Zarina Ibragimova
+
+
```

### Comparing `chython-1.64/chython/__init__.py` & `chython-1.8/chython/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,31 +1,38 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2014-2019 Timur Madzhidov tmadzhidov@gmail.com features and API discussion
-#  Copyright 2014-2019 Alexandre Varnek <varnek@unistra.fr> base idea of CGR approach
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .algorithms.depict import depict_settings
-from .containers import *
-from .files import *
-from .reactor import *
-from .utils import *
-
-
-pickle_cache = False  # store cached attributes in pickle
-torch_device = 'cpu'  # AAM model device. Change before first `reset_mapping` call!
-
-__all__ = []
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2014-2019 Timur Madzhidov tmadzhidov@gmail.com features and API discussion
+#  Copyright 2014-2019 Alexandre Varnek <varnek@unistra.fr> base idea of CGR approach
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .containers import *
+from .files import *
+from .reactor import *
+from .utils import *
+
+
+smiles = SMILESRead.create_parser(ignore=True, remap=False)
+xyz = XYZRead.create_parser()
+
+
+pickle_cache = False  # store cached attributes in pickle
+
+
+__all__ = ['smiles', 'xyz', 'mdl_mol']
+
+if 'INCHIRead' in locals():
+    inchi = INCHIRead.create_parser()
+    __all__.append('inchi')
```

### Comparing `chython-1.64/chython/_functions.py` & `chython-1.8/chython/_functions.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,69 +1,69 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from itertools import product
-
-
-# lazy itertools.product with diagonal combination precedence
-def lazy_product(*args):
-    if len(args) == 1:
-        for x in args[0]:
-            yield x,
-    elif not args:
-        yield ()
-    else:
-        gens = [iter(x) for x in args]
-        empty = [False] * len(args)
-        pools = [[] for _ in range(len(args))]
-        indices = set()
-
-        reached = 0
-        while True:
-            out = []
-            ind = []
-            for n, (p, g, e) in enumerate(zip(pools, gens, empty)):
-                if e:
-                    out.append(p[-1])
-                else:
-                    try:
-                        x = next(g)
-                    except StopIteration:
-                        if not p:  # one of gens empty
-                            return
-                        reached += 1
-                        if reached == len(args):
-                            break
-                        out.append(p[-1])
-                        empty[n] = True
-                    else:
-                        p.append(x)
-                        out.append(x)
-                ind.append(len(p) - 1)
-            else:
-                yield tuple(out)
-                indices.add(tuple(ind))
-                continue
-            break
-
-        for ind in product(*(range(len(p)) for p in pools)):
-            if ind in indices:
-                continue
-            yield tuple(p[x] for x, p in zip(ind, pools))
-
-
-__all__ = ['lazy_product']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from itertools import product
+
+
+# lazy itertools.product with diagonal combination precedence
+def lazy_product(*args):
+    if len(args) == 1:
+        for x in args[0]:
+            yield x,
+    elif not args:
+        yield ()
+    else:
+        gens = [iter(x) for x in args]
+        empty = [False] * len(args)
+        pools = [[] for _ in range(len(args))]
+        indices = set()
+
+        reached = 0
+        while True:
+            out = []
+            ind = []
+            for n, (p, g, e) in enumerate(zip(pools, gens, empty)):
+                if e:
+                    out.append(p[-1])
+                else:
+                    try:
+                        x = next(g)
+                    except StopIteration:
+                        if not p:  # one of gens empty
+                            return
+                        reached += 1
+                        if reached == len(args):
+                            break
+                        out.append(p[-1])
+                        empty[n] = True
+                    else:
+                        p.append(x)
+                        out.append(x)
+                ind.append(len(p) - 1)
+            else:
+                yield tuple(out)
+                indices.add(tuple(ind))
+                continue
+            break
+
+        for ind in product(*(range(len(p)) for p in pools)):
+            if ind in indices:
+                continue
+            yield tuple(p[x] for x, p in zip(ind, pools))
+
+
+__all__ = ['lazy_product']
```

### Comparing `chython-1.64/chython/algorithms/__init__.py` & `chython-1.8/chython/algorithms/tautomers/test/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.64/chython/algorithms/_isomorphism.c` & `chython-1.8/chython/algorithms/_isomorphism.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.34 */
+/* Generated by Cython 0.29.24 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-O3"
@@ -21,16 +21,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_34"
-#define CYTHON_HEX_VERSION 0x001D22F0
+#define CYTHON_ABI "0_29_24"
+#define CYTHON_HEX_VERSION 0x001D18F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -61,15 +61,14 @@
 #ifndef Py_HUGE_VAL
   #define Py_HUGE_VAL HUGE_VAL
 #endif
 #ifdef PYPY_VERSION
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
   #define CYTHON_USE_TYPE_SLOTS 0
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #if PY_VERSION_HEX < 0x03050000
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
@@ -98,22 +97,18 @@
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
 #elif defined(PYSTON_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #undef CYTHON_USE_ASYNC_SLOTS
   #define CYTHON_USE_ASYNC_SLOTS 0
@@ -143,67 +138,18 @@
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PY_NOGIL)
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 1
-  #ifndef CYTHON_USE_TYPE_SLOTS
-    #define CYTHON_USE_TYPE_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #ifndef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_INTERNALS
-    #define CYTHON_USE_UNICODE_INTERNALS 1
-  #endif
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #ifndef CYTHON_ASSUME_SAFE_MACROS
-    #define CYTHON_ASSUME_SAFE_MACROS 1
-  #endif
-  #ifndef CYTHON_UNPACK_METHODS
-    #define CYTHON_UNPACK_METHODS 1
-  #endif
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYTYPE_LOOKUP
     #define CYTHON_USE_PYTYPE_LOOKUP 0
   #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
@@ -215,72 +161,61 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
+    #define CYTHON_USE_PYLONG_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
-  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
+  #if PY_VERSION_HEX < 0x030300F0
     #undef CYTHON_USE_UNICODE_WRITER
     #define CYTHON_USE_UNICODE_WRITER 0
   #elif !defined(CYTHON_USE_UNICODE_WRITER)
     #define CYTHON_USE_UNICODE_WRITER 1
   #endif
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
-    #undef CYTHON_FAST_THREAD_STATE
-    #define CYTHON_FAST_THREAD_STATE 0
-  #elif !defined(CYTHON_FAST_THREAD_STATE)
+  #ifndef CYTHON_FAST_THREAD_STATE
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
   #ifndef CYTHON_FAST_PYCALL
-    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
+    #define CYTHON_FAST_PYCALL 1
   #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
+    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
   #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
-    #undef CYTHON_USE_EXC_INFO_STACK
-    #define CYTHON_USE_EXC_INFO_STACK 0
-  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
+  #ifndef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
-  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_MAJOR_VERSION < 3
-    #include "longintrepr.h"
-  #endif
+  #include "longintrepr.h"
   #undef SHIFT
   #undef BASE
   #undef MASK
   #ifdef SIZEOF_VOID_P
     enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
   #endif
 #endif
@@ -389,76 +324,17 @@
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
   #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-  #define __Pyx_DefaultClassType PyType_Type
-#if PY_VERSION_HEX >= 0x030B00A1
-    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
-                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
-                                                    PyObject *fv, PyObject *cell, PyObject* fn,
-                                                    PyObject *name, int fline, PyObject *lnos) {
-        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
-        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
-        const char *fn_cstr=NULL;
-        const char *name_cstr=NULL;
-        PyCodeObject* co=NULL;
-        PyObject *type, *value, *traceback;
-        PyErr_Fetch(&type, &value, &traceback);
-        if (!(kwds=PyDict_New())) goto end;
-        if (!(argcount=PyLong_FromLong(a))) goto end;
-        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
-        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
-        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
-        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
-        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
-        if (!(nlocals=PyLong_FromLong(l))) goto end;
-        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
-        if (!(stacksize=PyLong_FromLong(s))) goto end;
-        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
-        if (!(flags=PyLong_FromLong(f))) goto end;
-        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
-        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
-        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
-        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
-        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
-        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
-        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
-        Py_XDECREF((PyObject*)co);
-        co = (PyCodeObject*)call_result;
-        call_result = NULL;
-        if (0) {
-            cleanup_code_too:
-            Py_XDECREF((PyObject*)co);
-            co = NULL;
-        }
-        end:
-        Py_XDECREF(kwds);
-        Py_XDECREF(argcount);
-        Py_XDECREF(posonlyargcount);
-        Py_XDECREF(kwonlyargcount);
-        Py_XDECREF(nlocals);
-        Py_XDECREF(stacksize);
-        Py_XDECREF(replace);
-        Py_XDECREF(call_result);
-        Py_XDECREF(empty);
-        if (type) {
-            PyErr_Restore(type, value, traceback);
-        }
-        return co;
-    }
+#if PY_VERSION_HEX >= 0x030800A4 && PY_VERSION_HEX < 0x030800B2
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_New(a, 0, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #else
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
   #define __Pyx_DefaultClassType PyType_Type
 #endif
 #ifndef Py_TPFLAGS_CHECKTYPES
@@ -564,35 +440,35 @@
 #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
 #define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
 #else
 #define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
 #endif
 #if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
   #define CYTHON_PEP393_ENABLED 1
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_READY(op)       (0)
+  #if defined(PyUnicode_IS_READY)
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
   #else
-    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
-                                                0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_READY(op)       (0)
   #endif
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
   #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
   #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
   #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
   #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
   #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
+  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
+  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
   #else
-    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
-    #else
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
-    #endif
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
+  #endif
+  #else
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
   #endif
 #else
   #define CYTHON_PEP393_ENABLED 0
   #define PyUnicode_1BYTE_KIND  1
   #define PyUnicode_2BYTE_KIND  2
   #define PyUnicode_4BYTE_KIND  4
   #define __Pyx_PyUnicode_READY(op)       (0)
@@ -688,18 +564,18 @@
   #ifndef PyUnicode_InternFromString
     #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
   #endif
 #endif
 #if PY_VERSION_HEX < 0x030200A4
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
 #else
   #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
 #endif
 #if CYTHON_USE_ASYNC_SLOTS
@@ -716,18 +592,16 @@
     typedef struct {
         unaryfunc am_await;
         unaryfunc am_aiter;
         unaryfunc am_anext;
     } __Pyx_PyAsyncMethodsStruct;
 #endif
 
-#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
-  #if !defined(_USE_MATH_DEFINES)
-    #define _USE_MATH_DEFINES
-  #endif
+#if defined(WIN32) || defined(MS_WINDOWS)
+  #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
 #ifdef NAN
 #define __PYX_NAN() ((float) NAN)
 #else
 static CYTHON_INLINE float __PYX_NAN() {
   float value;
@@ -854,15 +728,14 @@
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
 #define __Pyx_PySequence_Tuple(obj)\
     (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
 #if CYTHON_ASSUME_SAFE_MACROS
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
 #else
 #define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
 #endif
 #define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
 #if PY_MAJOR_VERSION >= 3
@@ -967,15 +840,15 @@
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
 
 static const char *__pyx_f[] = {
-  "chython/algorithms/_isomorphism.pyx",
+  "chython\\algorithms\\_isomorphism.pyx",
   "stringsource",
 };
 /* MemviewSliceStruct.proto */
 struct __pyx_memoryview_obj;
 typedef struct {
   struct __pyx_memoryview_obj *memview;
   char *data;
@@ -986,47 +859,51 @@
 #define __Pyx_MemoryView_Len(m)  (m.shape[0])
 
 /* Atomics.proto */
 #include <pythread.h>
 #ifndef CYTHON_ATOMICS
     #define CYTHON_ATOMICS 1
 #endif
-#define __PYX_CYTHON_ATOMICS_ENABLED() CYTHON_ATOMICS
 #define __pyx_atomic_int_type int
-#if CYTHON_ATOMICS && (__GNUC__ >= 5 || (__GNUC__ == 4 &&\
-                    (__GNUC_MINOR__ > 1 ||\
-                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ >= 2))))
-    #define __pyx_atomic_incr_aligned(value) __sync_fetch_and_add(value, 1)
-    #define __pyx_atomic_decr_aligned(value) __sync_fetch_and_sub(value, 1)
+#if CYTHON_ATOMICS && __GNUC__ >= 4 && (__GNUC_MINOR__ > 1 ||\
+                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL >= 2)) &&\
+                    !defined(__i386__)
+    #define __pyx_atomic_incr_aligned(value, lock) __sync_fetch_and_add(value, 1)
+    #define __pyx_atomic_decr_aligned(value, lock) __sync_fetch_and_sub(value, 1)
     #ifdef __PYX_DEBUG_ATOMICS
         #warning "Using GNU atomics"
     #endif
-#elif CYTHON_ATOMICS && defined(_MSC_VER) && CYTHON_COMPILING_IN_NOGIL
-    #include <intrin.h>
+#elif CYTHON_ATOMICS && defined(_MSC_VER) && 0
+    #include <Windows.h>
     #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type long
-    #pragma intrinsic (_InterlockedExchangeAdd)
-    #define __pyx_atomic_incr_aligned(value) _InterlockedExchangeAdd(value, 1)
-    #define __pyx_atomic_decr_aligned(value) _InterlockedExchangeAdd(value, -1)
+    #define __pyx_atomic_int_type LONG
+    #define __pyx_atomic_incr_aligned(value, lock) InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) InterlockedDecrement(value)
     #ifdef __PYX_DEBUG_ATOMICS
         #pragma message ("Using MSVC atomics")
     #endif
+#elif CYTHON_ATOMICS && (defined(__ICC) || defined(__INTEL_COMPILER)) && 0
+    #define __pyx_atomic_incr_aligned(value, lock) _InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) _InterlockedDecrement(value)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Using Intel atomics"
+    #endif
 #else
     #undef CYTHON_ATOMICS
     #define CYTHON_ATOMICS 0
     #ifdef __PYX_DEBUG_ATOMICS
         #warning "Not using atomics"
     #endif
 #endif
 typedef volatile __pyx_atomic_int_type __pyx_atomic_int;
 #if CYTHON_ATOMICS
     #define __pyx_add_acquisition_count(memview)\
-             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview))
+             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
     #define __pyx_sub_acquisition_count(memview)\
-            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview))
+            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
 #else
     #define __pyx_add_acquisition_count(memview)\
             __pyx_add_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
     #define __pyx_sub_acquisition_count(memview)\
             __pyx_sub_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
 #endif
 
@@ -1092,15 +969,14 @@
  * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
  *                 unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
  *                 unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
  */
 struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping {
   PyObject_HEAD
   unsigned int __pyx_v_back;
-  unsigned PY_LONG_LONG __pyx_v_c_bond;
   unsigned int __pyx_v_closures_counter;
   unsigned int __pyx_v_closures_num;
   unsigned int __pyx_v_depth;
   unsigned int __pyx_v_front;
   unsigned int __pyx_v_i;
   unsigned int __pyx_v_j;
   unsigned int __pyx_v_m;
@@ -1116,15 +992,15 @@
   __Pyx_memviewslice __pyx_v_o_bonds;
   unsigned PY_LONG_LONG *__pyx_v_o_closures;
   __Pyx_memviewslice __pyx_v_o_from;
   __Pyx_memviewslice __pyx_v_o_indices;
   __Pyx_memviewslice __pyx_v_o_numbers;
   unsigned int __pyx_v_o_size;
   __Pyx_memviewslice __pyx_v_o_to;
-  unsigned int *__pyx_v_path;
+  int *__pyx_v_path;
   unsigned int __pyx_v_path_size;
   __Pyx_memviewslice __pyx_v_q_back;
   __Pyx_memviewslice __pyx_v_q_bonds;
   __Pyx_memviewslice __pyx_v_q_closures;
   __Pyx_memviewslice __pyx_v_q_from;
   __Pyx_memviewslice __pyx_v_q_indices;
   unsigned PY_LONG_LONG __pyx_v_q_mask1;
@@ -1137,20 +1013,20 @@
   __Pyx_memviewslice __pyx_v_q_masks4;
   __Pyx_memviewslice __pyx_v_q_numbers;
   unsigned int __pyx_v_q_size;
   unsigned int __pyx_v_q_size_dec;
   __Pyx_memviewslice __pyx_v_q_to;
   __Pyx_memviewslice __pyx_v_scope;
   unsigned int __pyx_v_stack;
-  unsigned int *__pyx_v_stack_depth;
-  unsigned int *__pyx_v_stack_index;
+  int *__pyx_v_stack_depth;
+  int *__pyx_v_stack_index;
 };
 
 
-/* "View.MemoryView":106
+/* "View.MemoryView":105
  * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 struct __pyx_array_obj {
@@ -1167,28 +1043,28 @@
   PyObject *_format;
   void (*callback_free_data)(void *);
   int free_data;
   int dtype_is_object;
 };
 
 
-/* "View.MemoryView":280
+/* "View.MemoryView":279
  * 
  * @cname('__pyx_MemviewEnum')
  * cdef class Enum(object):             # <<<<<<<<<<<<<<
  *     cdef object name
  *     def __init__(self, name):
  */
 struct __pyx_MemviewEnum_obj {
   PyObject_HEAD
   PyObject *name;
 };
 
 
-/* "View.MemoryView":331
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 struct __pyx_memoryview_obj {
@@ -1203,15 +1079,15 @@
   Py_buffer view;
   int flags;
   int dtype_is_object;
   __Pyx_TypeInfo *typeinfo;
 };
 
 
-/* "View.MemoryView":967
+/* "View.MemoryView":965
  * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 struct __pyx_memoryviewslice_obj {
@@ -1220,29 +1096,29 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
-/* "View.MemoryView":106
+/* "View.MemoryView":105
  * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 
 struct __pyx_vtabstruct_array {
   PyObject *(*get_memview)(struct __pyx_array_obj *);
 };
 static struct __pyx_vtabstruct_array *__pyx_vtabptr_array;
 
 
-/* "View.MemoryView":331
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 
@@ -1254,15 +1130,15 @@
   PyObject *(*setitem_indexed)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
   PyObject *(*convert_item_to_object)(struct __pyx_memoryview_obj *, char *);
   PyObject *(*assign_item_from_object)(struct __pyx_memoryview_obj *, char *, PyObject *);
 };
 static struct __pyx_vtabstruct_memoryview *__pyx_vtabptr_memoryview;
 
 
-/* "View.MemoryView":967
+/* "View.MemoryView":965
  * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 
@@ -1484,29 +1360,21 @@
 #define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
 #endif
 #define __Pyx_BUILD_ASSERT_EXPR(cond)\
     (sizeof(char [1 - 2*!(cond)]) - 1)
 #ifndef Py_MEMBER_SIZE
 #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
 #endif
-#if CYTHON_FAST_PYCALL
   static size_t __pyx_pyframe_localsplus_offset = 0;
   #include "frameobject.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
   #define __Pxy_PyFrame_Initialize_Offsets()\
     ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
      (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
   #define __Pyx_PyFrame_GetLocalsplus(frame)\
     (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
-#endif // CYTHON_FAST_PYCALL
 #endif
 
 /* PyObjectCall2Args.proto */
 static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
 
 /* PyObjectCallMethO.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
@@ -1528,15 +1396,15 @@
 /* StrEquals.proto */
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
 #else
 #define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
 #endif
 
-/* DivInt[Py_ssize_t].proto */
+/* None.proto */
 static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t, Py_ssize_t);
 
 /* UnaryNegOverflows.proto */
 #define UNARY_NEG_WOULD_OVERFLOW(x)\
         (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
 
 static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
@@ -1628,26 +1496,26 @@
 #define __PYX_GET_DICT_VERSION(dict)  (0)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
 #define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
 #endif
 
 /* GetModuleGlobalName.proto */
 #if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  do {\
+#define __Pyx_GetModuleGlobalName(var, name)  {\
     static PY_UINT64_T __pyx_dict_version = 0;\
     static PyObject *__pyx_dict_cached_value = NULL;\
     (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
         (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
         __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
+}
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
     PY_UINT64_T __pyx_dict_version;\
     PyObject *__pyx_dict_cached_value;\
     (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
+}
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
 #define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
@@ -1734,23 +1602,17 @@
 #else
 #define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
 /* None.proto */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
 
-/* DivInt[long].proto */
+/* None.proto */
 static CYTHON_INLINE long __Pyx_div_long(long, long);
 
-/* PySequenceContains.proto */
-static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
-    int result = PySequence_Contains(seq, item);
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
-
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
 /* HasAttr.proto */
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
 /* PyObject_GenericGetAttrNoDict.proto */
@@ -2122,15 +1984,14 @@
 static const char __pyx_k_front[] = "front";
 static const char __pyx_k_range[] = "range";
 static const char __pyx_k_scope[] = "scope";
 static const char __pyx_k_shape[] = "shape";
 static const char __pyx_k_stack[] = "stack";
 static const char __pyx_k_start[] = "start";
 static const char __pyx_k_throw[] = "throw";
-static const char __pyx_k_c_bond[] = "c_bond";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_format[] = "format";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_name_2[] = "__name__";
 static const char __pyx_k_o_bond[] = "o_bond";
 static const char __pyx_k_o_from[] = "o_from";
 static const char __pyx_k_o_size[] = "o_size";
@@ -2212,32 +2073,32 @@
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
 static const char __pyx_k_chython_algorithms__isomorphism[] = "chython.algorithms._isomorphism";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))";
+static const char __pyx_k_Incompatible_checksums_s_vs_0xb0[] = "Incompatible checksums (%s vs 0xb068931 = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
 static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension %d (got %d and %d)";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
-static const char __pyx_k_chython_algorithms__isomorphism_2[] = "chython/algorithms/_isomorphism.pyx";
+static const char __pyx_k_chython_algorithms__isomorphism_2[] = "chython\\algorithms\\_isomorphism.pyx";
 static PyObject *__pyx_n_s_ASCII;
 static PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
 static PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
 static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
 static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
 static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
 static PyObject *__pyx_n_s_Ellipsis;
 static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
-static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
+static PyObject *__pyx_kp_s_Incompatible_checksums_s_vs_0xb0;
 static PyObject *__pyx_n_s_IndexError;
 static PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
 static PyObject *__pyx_kp_s_Invalid_mode_expected_c_or_fortr;
 static PyObject *__pyx_kp_s_Invalid_shape_in_axis_d_d;
 static PyObject *__pyx_n_s_MemoryError;
 static PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
 static PyObject *__pyx_kp_s_MemoryView_of_r_object;
@@ -2250,15 +2111,14 @@
 static PyObject *__pyx_n_s_View_MemoryView;
 static PyObject *__pyx_n_s_allocate_buffer;
 static PyObject *__pyx_n_s_args;
 static PyObject *__pyx_n_s_back;
 static PyObject *__pyx_n_s_base;
 static PyObject *__pyx_n_s_c;
 static PyObject *__pyx_n_u_c;
-static PyObject *__pyx_n_s_c_bond;
 static PyObject *__pyx_n_s_chython_algorithms__isomorphism;
 static PyObject *__pyx_kp_s_chython_algorithms__isomorphism_2;
 static PyObject *__pyx_n_s_class;
 static PyObject *__pyx_n_s_cline_in_traceback;
 static PyObject *__pyx_n_s_close;
 static PyObject *__pyx_n_s_closures_counter;
 static PyObject *__pyx_n_s_closures_num;
@@ -2412,16 +2272,14 @@
 static PyObject *__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_int_0;
 static PyObject *__pyx_int_1;
-static PyObject *__pyx_int_112105877;
-static PyObject *__pyx_int_136983863;
 static PyObject *__pyx_int_184977713;
 static PyObject *__pyx_int_neg_1;
 static PyObject *__pyx_codeobj_;
 static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__4;
 static PyObject *__pyx_tuple__5;
@@ -2442,16 +2300,15 @@
 static PyObject *__pyx_tuple__20;
 static PyObject *__pyx_tuple__21;
 static PyObject *__pyx_tuple__22;
 static PyObject *__pyx_tuple__23;
 static PyObject *__pyx_tuple__24;
 static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__26;
-static PyObject *__pyx_tuple__27;
-static PyObject *__pyx_codeobj__28;
+static PyObject *__pyx_codeobj__27;
 /* Late includes */
 static PyObject *__pyx_gb_7chython_10algorithms_12_isomorphism_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
 
 /* "chython/algorithms/_isomorphism.pyx":30
  * @cython.boundscheck(False)
  * @cython.wraparound(False)
  * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
@@ -2889,23 +2746,24 @@
   size_t __pyx_t_8;
   PyObject *__pyx_t_9 = NULL;
   PyObject *__pyx_t_10 = NULL;
   size_t __pyx_t_11;
   unsigned int __pyx_t_12;
   unsigned int __pyx_t_13;
   unsigned int __pyx_t_14;
-  int __pyx_t_15;
+  size_t __pyx_t_15;
   int __pyx_t_16;
-  char const *__pyx_t_17;
-  PyObject *__pyx_t_18 = NULL;
+  int __pyx_t_17;
+  char const *__pyx_t_18;
   PyObject *__pyx_t_19 = NULL;
   PyObject *__pyx_t_20 = NULL;
   PyObject *__pyx_t_21 = NULL;
   PyObject *__pyx_t_22 = NULL;
   PyObject *__pyx_t_23 = NULL;
+  PyObject *__pyx_t_24 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("get_mapping", 0);
   switch (__pyx_generator->resume_label) {
     case 0: goto __pyx_L3_first_run;
@@ -2918,15 +2776,15 @@
   if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 30, __pyx_L1_error)
 
   /* "chython/algorithms/_isomorphism.pyx":42
  *                 unsigned int[::1] scope not None):
  *     # expected less than 2^16 atoms in structure.
  *     cdef unsigned int stack = 0, path_size = 0, q_size, q_size_dec, o_size, depth, front, back, closures_num             # <<<<<<<<<<<<<<
  *     cdef unsigned int n, m, o, i, j, closures_counter
- *     cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond, c_bond
+ *     cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond
  */
   __pyx_cur_scope->__pyx_v_stack = 0;
   __pyx_cur_scope->__pyx_v_path_size = 0;
 
   /* "chython/algorithms/_isomorphism.pyx":47
  *     cdef dict mapping
  * 
@@ -2938,66 +2796,66 @@
   __pyx_cur_scope->__pyx_v_q_size = __pyx_t_1;
 
   /* "chython/algorithms/_isomorphism.pyx":48
  * 
  *     q_size = len(q_numbers)
  *     q_size_dec = q_size - 1             # <<<<<<<<<<<<<<
  *     o_size = len(o_numbers)
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
  */
   __pyx_cur_scope->__pyx_v_q_size_dec = (__pyx_cur_scope->__pyx_v_q_size - 1);
 
   /* "chython/algorithms/_isomorphism.pyx":49
  *     q_size = len(q_numbers)
  *     q_size_dec = q_size - 1
  *     o_size = len(o_numbers)             # <<<<<<<<<<<<<<
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
  */
   __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_cur_scope->__pyx_v_o_numbers); 
   __pyx_cur_scope->__pyx_v_o_size = __pyx_t_1;
 
   /* "chython/algorithms/_isomorphism.pyx":50
  *     q_size_dec = q_size - 1
  *     o_size = len(o_numbers)
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))             # <<<<<<<<<<<<<<
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))             # <<<<<<<<<<<<<<
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
  */
-  __pyx_cur_scope->__pyx_v_path = ((unsigned int *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_q_size_dec * (sizeof(unsigned int)))));
+  __pyx_cur_scope->__pyx_v_path = ((int *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_q_size_dec * (sizeof(int)))));
 
   /* "chython/algorithms/_isomorphism.pyx":51
  *     o_size = len(o_numbers)
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))             # <<<<<<<<<<<<<<
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))             # <<<<<<<<<<<<<<
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
  *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
  */
-  __pyx_cur_scope->__pyx_v_stack_index = ((unsigned int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(unsigned int)))));
+  __pyx_cur_scope->__pyx_v_stack_index = ((int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(int)))));
 
   /* "chython/algorithms/_isomorphism.pyx":52
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))             # <<<<<<<<<<<<<<
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))             # <<<<<<<<<<<<<<
  *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
  *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
  */
-  __pyx_cur_scope->__pyx_v_stack_depth = ((unsigned int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(unsigned int)))));
+  __pyx_cur_scope->__pyx_v_stack_depth = ((int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(int)))));
 
   /* "chython/algorithms/_isomorphism.pyx":53
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
  *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))             # <<<<<<<<<<<<<<
  *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
  * 
  */
   __pyx_cur_scope->__pyx_v_matched = ((int *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_o_size * (sizeof(int)))));
 
   /* "chython/algorithms/_isomorphism.pyx":54
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
  *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
  *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))             # <<<<<<<<<<<<<<
  * 
  *     if not path or not stack_index or not stack_depth or not matched or not o_closures:
  */
   __pyx_cur_scope->__pyx_v_o_closures = ((unsigned PY_LONG_LONG *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_o_size * (sizeof(unsigned PY_LONG_LONG)))));
 
@@ -3114,69 +2972,69 @@
   __pyx_cur_scope->__pyx_v_q_mask4 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks4.data) + __pyx_t_4)) )));
 
   /* "chython/algorithms/_isomorphism.pyx":67
  *     q_mask3 = q_masks3[0]
  *     q_mask4 = q_masks4[0]
  *     for n in range(o_size):             # <<<<<<<<<<<<<<
  *         if (scope[n] and
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
+ *             q_mask1 & o_bits1[n] and
  */
   __pyx_t_5 = __pyx_cur_scope->__pyx_v_o_size;
   __pyx_t_6 = __pyx_t_5;
   for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
     __pyx_cur_scope->__pyx_v_n = __pyx_t_7;
 
     /* "chython/algorithms/_isomorphism.pyx":68
  *     q_mask4 = q_masks4[0]
  *     for n in range(o_size):
  *         if (scope[n] and             # <<<<<<<<<<<<<<
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
+ *             q_mask1 & o_bits1[n] and
  *             q_mask2 & o_bits2[n] == o_bits2[n] and
  */
     __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
     __pyx_t_3 = ((*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_scope.data) + __pyx_t_1)) ))) != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_2 = __pyx_t_3;
       goto __pyx_L13_bool_binop_done;
     }
 
     /* "chython/algorithms/_isomorphism.pyx":69
  *     for n in range(o_size):
  *         if (scope[n] and
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.             # <<<<<<<<<<<<<<
+ *             q_mask1 & o_bits1[n] and             # <<<<<<<<<<<<<<
  *             q_mask2 & o_bits2[n] == o_bits2[n] and
  *             q_mask3 & o_bits3[n] == o_bits3[n] and
  */
     __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
     __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask1 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits1.data) + __pyx_t_1)) )))) != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_2 = __pyx_t_3;
       goto __pyx_L13_bool_binop_done;
     }
 
     /* "chython/algorithms/_isomorphism.pyx":70
  *         if (scope[n] and
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
+ *             q_mask1 & o_bits1[n] and
  *             q_mask2 & o_bits2[n] == o_bits2[n] and             # <<<<<<<<<<<<<<
  *             q_mask3 & o_bits3[n] == o_bits3[n] and
  *             q_mask4 & o_bits4[n]):
  */
     __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
     __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
     __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask2 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_1)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_8)) )))) != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_2 = __pyx_t_3;
       goto __pyx_L13_bool_binop_done;
     }
 
     /* "chython/algorithms/_isomorphism.pyx":71
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
+ *             q_mask1 & o_bits1[n] and
  *             q_mask2 & o_bits2[n] == o_bits2[n] and
  *             q_mask3 & o_bits3[n] == o_bits3[n] and             # <<<<<<<<<<<<<<
  *             q_mask4 & o_bits4[n]):
  * 
  */
     __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
     __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
@@ -3199,15 +3057,15 @@
     __pyx_t_2 = __pyx_t_3;
     __pyx_L13_bool_binop_done:;
 
     /* "chython/algorithms/_isomorphism.pyx":68
  *     q_mask4 = q_masks4[0]
  *     for n in range(o_size):
  *         if (scope[n] and             # <<<<<<<<<<<<<<
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
+ *             q_mask1 & o_bits1[n] and
  *             q_mask2 & o_bits2[n] == o_bits2[n] and
  */
     if (__pyx_t_2) {
 
       /* "chython/algorithms/_isomorphism.pyx":74
  *             q_mask4 & o_bits4[n]):
  * 
@@ -3235,15 +3093,15 @@
  */
       __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
 
       /* "chython/algorithms/_isomorphism.pyx":68
  *     q_mask4 = q_masks4[0]
  *     for n in range(o_size):
  *         if (scope[n] and             # <<<<<<<<<<<<<<
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
+ *             q_mask1 & o_bits1[n] and
  *             q_mask2 & o_bits2[n] == o_bits2[n] and
  */
     }
   }
 
   /* "chython/algorithms/_isomorphism.pyx":78
  *             stack += 1
@@ -3331,16 +3189,16 @@
           /* "chython/algorithms/_isomorphism.pyx":87
  *                 mapping = _PyDict_NewPresized(q_size)
  *                 for i in range(depth):
  *                     mapping[q_numbers[i]] = o_numbers[path[i]]             # <<<<<<<<<<<<<<
  *                 mapping[q_numbers[depth]] = o_numbers[n]
  *                 yield mapping
  */
-          __pyx_t_1 = (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_i]);
-          __pyx_t_9 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_o_numbers.data) + __pyx_t_1)) )))); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 87, __pyx_L19_error)
+          __pyx_t_4 = (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_i]);
+          __pyx_t_9 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_o_numbers.data) + __pyx_t_4)) )))); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 87, __pyx_L19_error)
           __Pyx_GOTREF(__pyx_t_9);
           if (unlikely(__pyx_cur_scope->__pyx_v_mapping == Py_None)) {
             PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
             __PYX_ERR(0, 87, __pyx_L19_error)
           }
           __pyx_t_1 = __pyx_cur_scope->__pyx_v_i;
           __pyx_t_10 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_q_numbers.data) + __pyx_t_1)) )))); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 87, __pyx_L19_error)
@@ -3599,24 +3457,24 @@
           __pyx_cur_scope->__pyx_v_o_bond = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bonds.data) + __pyx_t_8)) )));
 
           /* "chython/algorithms/_isomorphism.pyx":114
  *                 for i in range(o_from[n], o_to[n]):
  *                     o_bond = o_bonds[i]
  *                     m = o_indices[i]             # <<<<<<<<<<<<<<
  *                     if (scope[m] and not matched[m] and
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
+ *                         q_mask1 & o_bond == o_bond and
  */
           __pyx_t_8 = __pyx_cur_scope->__pyx_v_i;
           __pyx_cur_scope->__pyx_v_m = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_8)) )));
 
           /* "chython/algorithms/_isomorphism.pyx":115
  *                     o_bond = o_bonds[i]
  *                     m = o_indices[i]
  *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
+ *                         q_mask1 & o_bond == o_bond and
  *                         q_mask2 & o_bits2[m] == o_bits2[m] and
  */
           __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
           __pyx_t_3 = ((*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_scope.data) + __pyx_t_8)) ))) != 0);
           if (__pyx_t_3) {
           } else {
             __pyx_t_2 = __pyx_t_3;
@@ -3628,43 +3486,43 @@
             __pyx_t_2 = __pyx_t_3;
             goto __pyx_L34_bool_binop_done;
           }
 
           /* "chython/algorithms/_isomorphism.pyx":116
  *                     m = o_indices[i]
  *                     if (scope[m] and not matched[m] and
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.             # <<<<<<<<<<<<<<
+ *                         q_mask1 & o_bond == o_bond and             # <<<<<<<<<<<<<<
  *                         q_mask2 & o_bits2[m] == o_bits2[m] and
  *                         q_mask3 & o_bits3[m] == o_bits3[m] and
  */
           __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask1 & __pyx_cur_scope->__pyx_v_o_bond) == __pyx_cur_scope->__pyx_v_o_bond) != 0);
           if (__pyx_t_3) {
           } else {
             __pyx_t_2 = __pyx_t_3;
             goto __pyx_L34_bool_binop_done;
           }
 
           /* "chython/algorithms/_isomorphism.pyx":117
  *                     if (scope[m] and not matched[m] and
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
+ *                         q_mask1 & o_bond == o_bond and
  *                         q_mask2 & o_bits2[m] == o_bits2[m] and             # <<<<<<<<<<<<<<
  *                         q_mask3 & o_bits3[m] == o_bits3[m] and
  *                         q_mask4 & o_bits4[m]):
  */
           __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
           __pyx_t_11 = __pyx_cur_scope->__pyx_v_m;
           __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask2 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_8)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_11)) )))) != 0);
           if (__pyx_t_3) {
           } else {
             __pyx_t_2 = __pyx_t_3;
             goto __pyx_L34_bool_binop_done;
           }
 
           /* "chython/algorithms/_isomorphism.pyx":118
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
+ *                         q_mask1 & o_bond == o_bond and
  *                         q_mask2 & o_bits2[m] == o_bits2[m] and
  *                         q_mask3 & o_bits3[m] == o_bits3[m] and             # <<<<<<<<<<<<<<
  *                         q_mask4 & o_bits4[m]):
  * 
  */
           __pyx_t_11 = __pyx_cur_scope->__pyx_v_m;
           __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
@@ -3687,15 +3545,15 @@
           __pyx_t_2 = __pyx_t_3;
           __pyx_L34_bool_binop_done:;
 
           /* "chython/algorithms/_isomorphism.pyx":115
  *                     o_bond = o_bonds[i]
  *                     m = o_indices[i]
  *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
+ *                         q_mask1 & o_bond == o_bond and
  *                         q_mask2 & o_bits2[m] == o_bits2[m] and
  */
           if (__pyx_t_2) {
 
             /* "chython/algorithms/_isomorphism.pyx":121
  *                         q_mask4 & o_bits4[m]):
  * 
@@ -3707,34 +3565,34 @@
             if (__pyx_t_2) {
 
               /* "chython/algorithms/_isomorphism.pyx":122
  * 
  *                         if closures_num:  # candidate atom should have same closures.
  *                             closures_counter = 0             # <<<<<<<<<<<<<<
  *                             # make a map of closures for o_n atom
- *                             # an index is a neighbor atom and a value is a bond between o_n and the neighbor
+ *                             # an index is an neighbor atom and an value is an bond between o_n and the neighbor
  */
               __pyx_cur_scope->__pyx_v_closures_counter = 0;
 
               /* "chython/algorithms/_isomorphism.pyx":125
  *                             # make a map of closures for o_n atom
- *                             # an index is a neighbor atom and a value is a bond between o_n and the neighbor
+ *                             # an index is an neighbor atom and an value is an bond between o_n and the neighbor
  *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
  *                                 o = o_indices[j]
  *                                 if o != n and matched[o]:
  */
               __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
               __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_8)) )));
               __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
               __pyx_t_13 = __pyx_t_12;
               for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
                 __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
 
                 /* "chython/algorithms/_isomorphism.pyx":126
- *                             # an index is a neighbor atom and a value is a bond between o_n and the neighbor
+ *                             # an index is an neighbor atom and an value is an bond between o_n and the neighbor
  *                             for j in range(o_from[m], o_to[m]):
  *                                 o = o_indices[j]             # <<<<<<<<<<<<<<
  *                                 if o != n and matched[o]:
  *                                     o_closures[o] = o_bonds[j]
  */
                 __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
                 __pyx_cur_scope->__pyx_v_o = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_11)) )));
@@ -3787,101 +3645,84 @@
               }
 
               /* "chython/algorithms/_isomorphism.pyx":131
  *                                     closures_counter += 1
  * 
  *                             if closures_counter == closures_num:             # <<<<<<<<<<<<<<
  *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
  */
               __pyx_t_2 = ((__pyx_cur_scope->__pyx_v_closures_counter == __pyx_cur_scope->__pyx_v_closures_num) != 0);
               if (__pyx_t_2) {
 
                 /* "chython/algorithms/_isomorphism.pyx":132
  * 
  *                             if closures_counter == closures_num:
  *                                 for j in range(q_from[front], q_to[front]):             # <<<<<<<<<<<<<<
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
+ *                                         break
  */
                 __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
                 __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_to.data) + __pyx_t_8)) )));
                 __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
                 __pyx_t_13 = __pyx_t_12;
                 for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
                   __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
 
                   /* "chython/algorithms/_isomorphism.pyx":133
  *                             if closures_counter == closures_num:
  *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]             # <<<<<<<<<<<<<<
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
- *                                         break
- */
-                  __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
-                  __pyx_cur_scope->__pyx_v_c_bond = (__pyx_cur_scope->__pyx_v_o_closures[(__pyx_cur_scope->__pyx_v_path[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_indices.data) + __pyx_t_11)) )))])]);
-
-                  /* "chython/algorithms/_isomorphism.pyx":134
- *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits             # <<<<<<<<<<<<<<
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough             # <<<<<<<<<<<<<<
  *                                         break
  *                                 else:
  */
-                  __pyx_t_3 = ((!(__pyx_cur_scope->__pyx_v_c_bond != 0)) != 0);
-                  if (!__pyx_t_3) {
-                  } else {
-                    __pyx_t_2 = __pyx_t_3;
-                    goto __pyx_L50_bool_binop_done;
-                  }
                   __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
-                  __pyx_t_3 = ((((*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_bonds.data) + __pyx_t_11)) ))) & __pyx_cur_scope->__pyx_v_c_bond) != __pyx_cur_scope->__pyx_v_c_bond) != 0);
-                  __pyx_t_2 = __pyx_t_3;
-                  __pyx_L50_bool_binop_done:;
+                  __pyx_t_15 = __pyx_cur_scope->__pyx_v_j;
+                  __pyx_t_2 = ((!(((*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_bonds.data) + __pyx_t_11)) ))) & (__pyx_cur_scope->__pyx_v_o_closures[(__pyx_cur_scope->__pyx_v_path[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_indices.data) + __pyx_t_15)) )))])])) != 0)) != 0);
                   if (__pyx_t_2) {
 
-                    /* "chython/algorithms/_isomorphism.pyx":135
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
+                    /* "chython/algorithms/_isomorphism.pyx":134
+ *                                 for j in range(q_from[front], q_to[front]):
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
  *                                         break             # <<<<<<<<<<<<<<
  *                                 else:
  *                                     stack_index[stack] = m
  */
                     goto __pyx_L48_break;
 
-                    /* "chython/algorithms/_isomorphism.pyx":134
+                    /* "chython/algorithms/_isomorphism.pyx":133
+ *                             if closures_counter == closures_num:
  *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits             # <<<<<<<<<<<<<<
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough             # <<<<<<<<<<<<<<
  *                                         break
  *                                 else:
  */
                   }
                 }
                 /*else*/ {
 
-                  /* "chython/algorithms/_isomorphism.pyx":137
+                  /* "chython/algorithms/_isomorphism.pyx":136
  *                                         break
  *                                 else:
  *                                     stack_index[stack] = m             # <<<<<<<<<<<<<<
  *                                     stack_depth[stack] = front
  *                                     stack += 1
  */
                   (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_m;
 
-                  /* "chython/algorithms/_isomorphism.pyx":138
+                  /* "chython/algorithms/_isomorphism.pyx":137
  *                                 else:
  *                                     stack_index[stack] = m
  *                                     stack_depth[stack] = front             # <<<<<<<<<<<<<<
  *                                     stack += 1
  * 
  */
                   (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_front;
 
-                  /* "chython/algorithms/_isomorphism.pyx":139
+                  /* "chython/algorithms/_isomorphism.pyx":138
  *                                     stack_index[stack] = m
  *                                     stack_depth[stack] = front
  *                                     stack += 1             # <<<<<<<<<<<<<<
  * 
  *                             # fill an array with nulls
  */
                   __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
@@ -3889,277 +3730,277 @@
                 __pyx_L48_break:;
 
                 /* "chython/algorithms/_isomorphism.pyx":131
  *                                     closures_counter += 1
  * 
  *                             if closures_counter == closures_num:             # <<<<<<<<<<<<<<
  *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
  */
               }
 
-              /* "chython/algorithms/_isomorphism.pyx":142
+              /* "chython/algorithms/_isomorphism.pyx":141
  * 
  *                             # fill an array with nulls
  *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
  *                                 o_closures[o_indices[j]] = 0
  *                         else:  # candidate atom should not have closures.
  */
               __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
               __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_8)) )));
               __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
               __pyx_t_13 = __pyx_t_12;
               for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
                 __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
 
-                /* "chython/algorithms/_isomorphism.pyx":143
+                /* "chython/algorithms/_isomorphism.pyx":142
  *                             # fill an array with nulls
  *                             for j in range(o_from[m], o_to[m]):
  *                                 o_closures[o_indices[j]] = 0             # <<<<<<<<<<<<<<
  *                         else:  # candidate atom should not have closures.
  *                             for j in range(o_from[m], o_to[m]):
  */
-                __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
-                (__pyx_cur_scope->__pyx_v_o_closures[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_11)) )))]) = 0;
+                __pyx_t_15 = __pyx_cur_scope->__pyx_v_j;
+                (__pyx_cur_scope->__pyx_v_o_closures[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_15)) )))]) = 0;
               }
 
               /* "chython/algorithms/_isomorphism.pyx":121
  *                         q_mask4 & o_bits4[m]):
  * 
  *                         if closures_num:  # candidate atom should have same closures.             # <<<<<<<<<<<<<<
  *                             closures_counter = 0
  *                             # make a map of closures for o_n atom
  */
               goto __pyx_L40;
             }
 
-            /* "chython/algorithms/_isomorphism.pyx":145
+            /* "chython/algorithms/_isomorphism.pyx":144
  *                                 o_closures[o_indices[j]] = 0
  *                         else:  # candidate atom should not have closures.
  *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
  *                                o = o_indices[j]
  *                                if o != n and matched[o]:
  */
             /*else*/ {
               __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
               __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_8)) )));
               __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
               __pyx_t_13 = __pyx_t_12;
               for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
                 __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
 
-                /* "chython/algorithms/_isomorphism.pyx":146
+                /* "chython/algorithms/_isomorphism.pyx":145
  *                         else:  # candidate atom should not have closures.
  *                             for j in range(o_from[m], o_to[m]):
  *                                o = o_indices[j]             # <<<<<<<<<<<<<<
  *                                if o != n and matched[o]:
  *                                    break  # found closure
  */
-                __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
-                __pyx_cur_scope->__pyx_v_o = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_11)) )));
+                __pyx_t_15 = __pyx_cur_scope->__pyx_v_j;
+                __pyx_cur_scope->__pyx_v_o = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_15)) )));
 
-                /* "chython/algorithms/_isomorphism.pyx":147
+                /* "chython/algorithms/_isomorphism.pyx":146
  *                             for j in range(o_from[m], o_to[m]):
  *                                o = o_indices[j]
  *                                if o != n and matched[o]:             # <<<<<<<<<<<<<<
  *                                    break  # found closure
  *                             else:
  */
                 __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_o != __pyx_cur_scope->__pyx_v_n) != 0);
                 if (__pyx_t_3) {
                 } else {
                   __pyx_t_2 = __pyx_t_3;
-                  goto __pyx_L57_bool_binop_done;
+                  goto __pyx_L55_bool_binop_done;
                 }
                 __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_o]) != 0);
                 __pyx_t_2 = __pyx_t_3;
-                __pyx_L57_bool_binop_done:;
+                __pyx_L55_bool_binop_done:;
                 if (__pyx_t_2) {
 
-                  /* "chython/algorithms/_isomorphism.pyx":148
+                  /* "chython/algorithms/_isomorphism.pyx":147
  *                                o = o_indices[j]
  *                                if o != n and matched[o]:
  *                                    break  # found closure             # <<<<<<<<<<<<<<
  *                             else:
  *                                 stack_index[stack] = m
  */
-                  goto __pyx_L55_break;
+                  goto __pyx_L53_break;
 
-                  /* "chython/algorithms/_isomorphism.pyx":147
+                  /* "chython/algorithms/_isomorphism.pyx":146
  *                             for j in range(o_from[m], o_to[m]):
  *                                o = o_indices[j]
  *                                if o != n and matched[o]:             # <<<<<<<<<<<<<<
  *                                    break  # found closure
  *                             else:
  */
                 }
               }
               /*else*/ {
 
-                /* "chython/algorithms/_isomorphism.pyx":150
+                /* "chython/algorithms/_isomorphism.pyx":149
  *                                    break  # found closure
  *                             else:
  *                                 stack_index[stack] = m             # <<<<<<<<<<<<<<
  *                                 stack_depth[stack] = front
  *                                 stack += 1
  */
                 (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_m;
 
-                /* "chython/algorithms/_isomorphism.pyx":151
+                /* "chython/algorithms/_isomorphism.pyx":150
  *                             else:
  *                                 stack_index[stack] = m
  *                                 stack_depth[stack] = front             # <<<<<<<<<<<<<<
  *                                 stack += 1
  *     finally:
  */
                 (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_front;
 
-                /* "chython/algorithms/_isomorphism.pyx":152
+                /* "chython/algorithms/_isomorphism.pyx":151
  *                                 stack_index[stack] = m
  *                                 stack_depth[stack] = front
  *                                 stack += 1             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(path)
  */
                 __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
               }
-              __pyx_L55_break:;
+              __pyx_L53_break:;
             }
             __pyx_L40:;
 
             /* "chython/algorithms/_isomorphism.pyx":115
  *                     o_bond = o_bonds[i]
  *                     m = o_indices[i]
  *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
+ *                         q_mask1 & o_bond == o_bond and
  *                         q_mask2 & o_bits2[m] == o_bits2[m] and
  */
           }
         }
       }
       __pyx_L23:;
     }
   }
 
-  /* "chython/algorithms/_isomorphism.pyx":154
+  /* "chython/algorithms/_isomorphism.pyx":153
  *                                 stack += 1
  *     finally:
  *         PyMem_Free(path)             # <<<<<<<<<<<<<<
  *         PyMem_Free(matched)
  *         PyMem_Free(stack_index)
  */
   /*finally:*/ {
     /*normal exit:*/{
       PyMem_Free(__pyx_cur_scope->__pyx_v_path);
 
-      /* "chython/algorithms/_isomorphism.pyx":155
+      /* "chython/algorithms/_isomorphism.pyx":154
  *     finally:
  *         PyMem_Free(path)
  *         PyMem_Free(matched)             # <<<<<<<<<<<<<<
  *         PyMem_Free(stack_index)
  *         PyMem_Free(stack_depth)
  */
       PyMem_Free(__pyx_cur_scope->__pyx_v_matched);
 
-      /* "chython/algorithms/_isomorphism.pyx":156
+      /* "chython/algorithms/_isomorphism.pyx":155
  *         PyMem_Free(path)
  *         PyMem_Free(matched)
  *         PyMem_Free(stack_index)             # <<<<<<<<<<<<<<
  *         PyMem_Free(stack_depth)
  *         PyMem_Free(o_closures)
  */
       PyMem_Free(__pyx_cur_scope->__pyx_v_stack_index);
 
-      /* "chython/algorithms/_isomorphism.pyx":157
+      /* "chython/algorithms/_isomorphism.pyx":156
  *         PyMem_Free(matched)
  *         PyMem_Free(stack_index)
  *         PyMem_Free(stack_depth)             # <<<<<<<<<<<<<<
  *         PyMem_Free(o_closures)
  */
       PyMem_Free(__pyx_cur_scope->__pyx_v_stack_depth);
 
-      /* "chython/algorithms/_isomorphism.pyx":158
+      /* "chython/algorithms/_isomorphism.pyx":157
  *         PyMem_Free(stack_index)
  *         PyMem_Free(stack_depth)
  *         PyMem_Free(o_closures)             # <<<<<<<<<<<<<<
  */
       PyMem_Free(__pyx_cur_scope->__pyx_v_o_closures);
       goto __pyx_L20;
     }
     __pyx_L19_error:;
     /*exception exit:*/{
       __Pyx_PyThreadState_assign
-      __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0;
+      __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0;
       __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
       __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
-      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_21, &__pyx_t_22, &__pyx_t_23);
-      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20) < 0)) __Pyx_ErrFetch(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20);
-      __Pyx_XGOTREF(__pyx_t_18);
+      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_22, &__pyx_t_23, &__pyx_t_24);
+      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21) < 0)) __Pyx_ErrFetch(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
       __Pyx_XGOTREF(__pyx_t_19);
       __Pyx_XGOTREF(__pyx_t_20);
       __Pyx_XGOTREF(__pyx_t_21);
       __Pyx_XGOTREF(__pyx_t_22);
       __Pyx_XGOTREF(__pyx_t_23);
-      __pyx_t_15 = __pyx_lineno; __pyx_t_16 = __pyx_clineno; __pyx_t_17 = __pyx_filename;
+      __Pyx_XGOTREF(__pyx_t_24);
+      __pyx_t_16 = __pyx_lineno; __pyx_t_17 = __pyx_clineno; __pyx_t_18 = __pyx_filename;
       {
 
-        /* "chython/algorithms/_isomorphism.pyx":154
+        /* "chython/algorithms/_isomorphism.pyx":153
  *                                 stack += 1
  *     finally:
  *         PyMem_Free(path)             # <<<<<<<<<<<<<<
  *         PyMem_Free(matched)
  *         PyMem_Free(stack_index)
  */
         PyMem_Free(__pyx_cur_scope->__pyx_v_path);
 
-        /* "chython/algorithms/_isomorphism.pyx":155
+        /* "chython/algorithms/_isomorphism.pyx":154
  *     finally:
  *         PyMem_Free(path)
  *         PyMem_Free(matched)             # <<<<<<<<<<<<<<
  *         PyMem_Free(stack_index)
  *         PyMem_Free(stack_depth)
  */
         PyMem_Free(__pyx_cur_scope->__pyx_v_matched);
 
-        /* "chython/algorithms/_isomorphism.pyx":156
+        /* "chython/algorithms/_isomorphism.pyx":155
  *         PyMem_Free(path)
  *         PyMem_Free(matched)
  *         PyMem_Free(stack_index)             # <<<<<<<<<<<<<<
  *         PyMem_Free(stack_depth)
  *         PyMem_Free(o_closures)
  */
         PyMem_Free(__pyx_cur_scope->__pyx_v_stack_index);
 
-        /* "chython/algorithms/_isomorphism.pyx":157
+        /* "chython/algorithms/_isomorphism.pyx":156
  *         PyMem_Free(matched)
  *         PyMem_Free(stack_index)
  *         PyMem_Free(stack_depth)             # <<<<<<<<<<<<<<
  *         PyMem_Free(o_closures)
  */
         PyMem_Free(__pyx_cur_scope->__pyx_v_stack_depth);
 
-        /* "chython/algorithms/_isomorphism.pyx":158
+        /* "chython/algorithms/_isomorphism.pyx":157
  *         PyMem_Free(stack_index)
  *         PyMem_Free(stack_depth)
  *         PyMem_Free(o_closures)             # <<<<<<<<<<<<<<
  */
         PyMem_Free(__pyx_cur_scope->__pyx_v_o_closures);
       }
       if (PY_MAJOR_VERSION >= 3) {
-        __Pyx_XGIVEREF(__pyx_t_21);
         __Pyx_XGIVEREF(__pyx_t_22);
         __Pyx_XGIVEREF(__pyx_t_23);
-        __Pyx_ExceptionReset(__pyx_t_21, __pyx_t_22, __pyx_t_23);
+        __Pyx_XGIVEREF(__pyx_t_24);
+        __Pyx_ExceptionReset(__pyx_t_22, __pyx_t_23, __pyx_t_24);
       }
-      __Pyx_XGIVEREF(__pyx_t_18);
       __Pyx_XGIVEREF(__pyx_t_19);
       __Pyx_XGIVEREF(__pyx_t_20);
-      __Pyx_ErrRestore(__pyx_t_18, __pyx_t_19, __pyx_t_20);
-      __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0;
-      __pyx_lineno = __pyx_t_15; __pyx_clineno = __pyx_t_16; __pyx_filename = __pyx_t_17;
+      __Pyx_XGIVEREF(__pyx_t_21);
+      __Pyx_ErrRestore(__pyx_t_19, __pyx_t_20, __pyx_t_21);
+      __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0;
+      __pyx_lineno = __pyx_t_16; __pyx_clineno = __pyx_t_17; __pyx_filename = __pyx_t_18;
       goto __pyx_L1_error;
     }
     __pyx_L20:;
   }
   CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
 
   /* "chython/algorithms/_isomorphism.pyx":30
@@ -4184,15 +4025,15 @@
   #endif
   __pyx_generator->resume_label = -1;
   __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":123
+/* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -4236,21 +4077,21 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_shape)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_itemsize)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 123, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_format)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 123, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
           if (value) { values[3] = value; kw_args--; }
         }
@@ -4258,15 +4099,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allocate_buffer);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 123, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 122, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -4274,46 +4115,46 @@
         values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_shape = ((PyObject*)values[0]);
-    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L3_error)
+    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 122, __pyx_L3_error)
     __pyx_v_format = values[2];
     __pyx_v_mode = values[3];
     if (values[4]) {
-      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 124, __pyx_L3_error)
+      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L3_error)
     } else {
 
-      /* "View.MemoryView":124
+      /* "View.MemoryView":123
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,
  *                   mode="c", bint allocate_buffer=True):             # <<<<<<<<<<<<<<
  * 
  *         cdef int idx
  */
       __pyx_v_allocate_buffer = ((int)1);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 123, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 122, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 123, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 122, __pyx_L1_error)
   if (unlikely(((PyObject *)__pyx_v_format) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 123, __pyx_L1_error)
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 122, __pyx_L1_error)
   }
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v_shape, __pyx_v_itemsize, __pyx_v_format, __pyx_v_mode, __pyx_v_allocate_buffer);
 
-  /* "View.MemoryView":123
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -4347,579 +4188,579 @@
   Py_ssize_t __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
   __Pyx_INCREF(__pyx_v_format);
 
-  /* "View.MemoryView":130
+  /* "View.MemoryView":129
  *         cdef PyObject **p
  * 
  *         self.ndim = <int> len(shape)             # <<<<<<<<<<<<<<
  *         self.itemsize = itemsize
  * 
  */
   if (unlikely(__pyx_v_shape == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(1, 130, __pyx_L1_error)
+    __PYX_ERR(1, 129, __pyx_L1_error)
   }
-  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 130, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 129, __pyx_L1_error)
   __pyx_v_self->ndim = ((int)__pyx_t_1);
 
-  /* "View.MemoryView":131
+  /* "View.MemoryView":130
  * 
  *         self.ndim = <int> len(shape)
  *         self.itemsize = itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not self.ndim:
  */
   __pyx_v_self->itemsize = __pyx_v_itemsize;
 
-  /* "View.MemoryView":133
+  /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_self->ndim != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":134
+    /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 134, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 133, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 134, __pyx_L1_error)
+    __PYX_ERR(1, 133, __pyx_L1_error)
 
-    /* "View.MemoryView":133
+    /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":136
+  /* "View.MemoryView":135
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   __pyx_t_2 = ((__pyx_v_itemsize <= 0) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":137
+    /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 137, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 136, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 137, __pyx_L1_error)
+    __PYX_ERR(1, 136, __pyx_L1_error)
 
-    /* "View.MemoryView":136
+    /* "View.MemoryView":135
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":139
+  /* "View.MemoryView":138
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   __pyx_t_2 = PyBytes_Check(__pyx_v_format); 
   __pyx_t_4 = ((!(__pyx_t_2 != 0)) != 0);
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":140
+    /* "View.MemoryView":139
  * 
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 140, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_n_s_ASCII) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_n_s_ASCII);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 140, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":139
+    /* "View.MemoryView":138
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   }
 
-  /* "View.MemoryView":141
+  /* "View.MemoryView":140
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string             # <<<<<<<<<<<<<<
  *         self.format = self._format
  * 
  */
-  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(1, 141, __pyx_L1_error)
+  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(1, 140, __pyx_L1_error)
   __pyx_t_3 = __pyx_v_format;
   __Pyx_INCREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->_format);
   __Pyx_DECREF(__pyx_v_self->_format);
   __pyx_v_self->_format = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":142
+  /* "View.MemoryView":141
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format             # <<<<<<<<<<<<<<
  * 
  * 
  */
   if (unlikely(__pyx_v_self->_format == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(1, 142, __pyx_L1_error)
+    __PYX_ERR(1, 141, __pyx_L1_error)
   }
-  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(1, 142, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(1, 141, __pyx_L1_error)
   __pyx_v_self->format = __pyx_t_7;
 
-  /* "View.MemoryView":145
+  /* "View.MemoryView":144
  * 
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)             # <<<<<<<<<<<<<<
  *         self._strides = self._shape + self.ndim
  * 
  */
   __pyx_v_self->_shape = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * __pyx_v_self->ndim) * 2)));
 
-  /* "View.MemoryView":146
+  /* "View.MemoryView":145
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)
  *         self._strides = self._shape + self.ndim             # <<<<<<<<<<<<<<
  * 
  *         if not self._shape:
  */
   __pyx_v_self->_strides = (__pyx_v_self->_shape + __pyx_v_self->ndim);
 
-  /* "View.MemoryView":148
+  /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   __pyx_t_4 = ((!(__pyx_v_self->_shape != 0)) != 0);
   if (unlikely(__pyx_t_4)) {
 
-    /* "View.MemoryView":149
+    /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 149, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 148, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 149, __pyx_L1_error)
+    __PYX_ERR(1, 148, __pyx_L1_error)
 
-    /* "View.MemoryView":148
+    /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   }
 
-  /* "View.MemoryView":152
+  /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   __pyx_t_8 = 0;
   __pyx_t_3 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
   for (;;) {
     if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(1, 152, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(1, 151, __pyx_L1_error)
     #else
-    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 152, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 152, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_9;
     __pyx_v_idx = __pyx_t_8;
     __pyx_t_8 = (__pyx_t_8 + 1);
 
-    /* "View.MemoryView":153
+    /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     __pyx_t_4 = ((__pyx_v_dim <= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":154
+      /* "View.MemoryView":153
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))             # <<<<<<<<<<<<<<
  *             self._shape[idx] = dim
  * 
  */
-      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_GIVEREF(__pyx_t_5);
       PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
       __Pyx_GIVEREF(__pyx_t_6);
       PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_6);
       __pyx_t_5 = 0;
       __pyx_t_6 = 0;
-      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __PYX_ERR(1, 154, __pyx_L1_error)
+      __PYX_ERR(1, 153, __pyx_L1_error)
 
-      /* "View.MemoryView":153
+      /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     }
 
-    /* "View.MemoryView":155
+    /* "View.MemoryView":154
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim             # <<<<<<<<<<<<<<
  * 
  *         cdef char order
  */
     (__pyx_v_self->_shape[__pyx_v_idx]) = __pyx_v_dim;
 
-    /* "View.MemoryView":152
+    /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":158
+  /* "View.MemoryView":157
  * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 158, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 157, __pyx_L1_error)
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":159
+    /* "View.MemoryView":158
  *         cdef char order
  *         if mode == 'fortran':
  *             order = b'F'             # <<<<<<<<<<<<<<
  *             self.mode = u'fortran'
  *         elif mode == 'c':
  */
     __pyx_v_order = 'F';
 
-    /* "View.MemoryView":160
+    /* "View.MemoryView":159
  *         if mode == 'fortran':
  *             order = b'F'
  *             self.mode = u'fortran'             # <<<<<<<<<<<<<<
  *         elif mode == 'c':
  *             order = b'C'
  */
     __Pyx_INCREF(__pyx_n_u_fortran);
     __Pyx_GIVEREF(__pyx_n_u_fortran);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
     __pyx_v_self->mode = __pyx_n_u_fortran;
 
-    /* "View.MemoryView":158
+    /* "View.MemoryView":157
  * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
     goto __pyx_L10;
   }
 
-  /* "View.MemoryView":161
+  /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
  *         elif mode == 'c':             # <<<<<<<<<<<<<<
  *             order = b'C'
  *             self.mode = u'c'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 161, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 160, __pyx_L1_error)
   if (likely(__pyx_t_4)) {
 
-    /* "View.MemoryView":162
+    /* "View.MemoryView":161
  *             self.mode = u'fortran'
  *         elif mode == 'c':
  *             order = b'C'             # <<<<<<<<<<<<<<
  *             self.mode = u'c'
  *         else:
  */
     __pyx_v_order = 'C';
 
-    /* "View.MemoryView":163
+    /* "View.MemoryView":162
  *         elif mode == 'c':
  *             order = b'C'
  *             self.mode = u'c'             # <<<<<<<<<<<<<<
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  */
     __Pyx_INCREF(__pyx_n_u_c);
     __Pyx_GIVEREF(__pyx_n_u_c);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
     __pyx_v_self->mode = __pyx_n_u_c;
 
-    /* "View.MemoryView":161
+    /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
  *         elif mode == 'c':             # <<<<<<<<<<<<<<
  *             order = b'C'
  *             self.mode = u'c'
  */
     goto __pyx_L10;
   }
 
-  /* "View.MemoryView":165
+  /* "View.MemoryView":164
  *             self.mode = u'c'
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)             # <<<<<<<<<<<<<<
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,
  */
   /*else*/ {
-    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 165, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 165, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_10, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __PYX_ERR(1, 165, __pyx_L1_error)
+    __PYX_ERR(1, 164, __pyx_L1_error)
   }
   __pyx_L10:;
 
-  /* "View.MemoryView":167
+  /* "View.MemoryView":166
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,             # <<<<<<<<<<<<<<
  *                                              itemsize, self.ndim, order)
  * 
  */
   __pyx_v_self->len = __pyx_fill_contig_strides_array(__pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_itemsize, __pyx_v_self->ndim, __pyx_v_order);
 
-  /* "View.MemoryView":170
+  /* "View.MemoryView":169
  *                                              itemsize, self.ndim, order)
  * 
  *         self.free_data = allocate_buffer             # <<<<<<<<<<<<<<
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:
  */
   __pyx_v_self->free_data = __pyx_v_allocate_buffer;
 
-  /* "View.MemoryView":171
+  /* "View.MemoryView":170
  * 
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'             # <<<<<<<<<<<<<<
  *         if allocate_buffer:
  * 
  */
-  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 171, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 171, __pyx_L1_error)
+  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 170, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 170, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
   __pyx_v_self->dtype_is_object = __pyx_t_4;
 
-  /* "View.MemoryView":172
+  /* "View.MemoryView":171
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_4 = (__pyx_v_allocate_buffer != 0);
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":175
+    /* "View.MemoryView":174
  * 
  * 
  *             self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")
  */
     __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
 
-    /* "View.MemoryView":176
+    /* "View.MemoryView":175
  * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
  * 
  */
     __pyx_t_4 = ((!(__pyx_v_self->data != 0)) != 0);
     if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":177
+      /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 177, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 176, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __PYX_ERR(1, 177, __pyx_L1_error)
+      __PYX_ERR(1, 176, __pyx_L1_error)
 
-      /* "View.MemoryView":176
+      /* "View.MemoryView":175
  * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
  * 
  */
     }
 
-    /* "View.MemoryView":179
+    /* "View.MemoryView":178
  *                 raise MemoryError("unable to allocate array data.")
  * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     __pyx_t_4 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_4) {
 
-      /* "View.MemoryView":180
+      /* "View.MemoryView":179
  * 
  *             if self.dtype_is_object:
  *                 p = <PyObject **> self.data             # <<<<<<<<<<<<<<
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  */
       __pyx_v_p = ((PyObject **)__pyx_v_self->data);
 
-      /* "View.MemoryView":181
+      /* "View.MemoryView":180
  *             if self.dtype_is_object:
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):             # <<<<<<<<<<<<<<
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)
  */
       if (unlikely(__pyx_v_itemsize == 0)) {
         PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-        __PYX_ERR(1, 181, __pyx_L1_error)
+        __PYX_ERR(1, 180, __pyx_L1_error)
       }
       else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
         PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-        __PYX_ERR(1, 181, __pyx_L1_error)
+        __PYX_ERR(1, 180, __pyx_L1_error)
       }
       __pyx_t_1 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_itemsize);
       __pyx_t_9 = __pyx_t_1;
       for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11+=1) {
         __pyx_v_i = __pyx_t_11;
 
-        /* "View.MemoryView":182
+        /* "View.MemoryView":181
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None             # <<<<<<<<<<<<<<
  *                     Py_INCREF(Py_None)
  * 
  */
         (__pyx_v_p[__pyx_v_i]) = Py_None;
 
-        /* "View.MemoryView":183
+        /* "View.MemoryView":182
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
         Py_INCREF(Py_None);
       }
 
-      /* "View.MemoryView":179
+      /* "View.MemoryView":178
  *                 raise MemoryError("unable to allocate array data.")
  * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     }
 
-    /* "View.MemoryView":172
+    /* "View.MemoryView":171
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":123
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -4935,15 +4776,15 @@
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_format);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":186
+/* "View.MemoryView":185
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
@@ -4978,249 +4819,249 @@
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":187
+  /* "View.MemoryView":186
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1             # <<<<<<<<<<<<<<
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
   __pyx_v_bufmode = -1;
 
-  /* "View.MemoryView":188
+  /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
  *         if self.mode == u"c":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  */
-  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 188, __pyx_L1_error)
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 187, __pyx_L1_error)
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":189
+    /* "View.MemoryView":188
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
     __pyx_v_bufmode = (PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-    /* "View.MemoryView":188
+    /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
  *         if self.mode == u"c":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":190
+  /* "View.MemoryView":189
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  */
-  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 190, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 189, __pyx_L1_error)
   __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":191
+    /* "View.MemoryView":190
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  */
     __pyx_v_bufmode = (PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-    /* "View.MemoryView":190
+    /* "View.MemoryView":189
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":192
+  /* "View.MemoryView":191
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
   __pyx_t_1 = ((!((__pyx_v_flags & __pyx_v_bufmode) != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":193
+    /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 193, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 193, __pyx_L1_error)
+    __PYX_ERR(1, 192, __pyx_L1_error)
 
-    /* "View.MemoryView":192
+    /* "View.MemoryView":191
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
   }
 
-  /* "View.MemoryView":194
+  /* "View.MemoryView":193
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data             # <<<<<<<<<<<<<<
  *         info.len = self.len
  *         info.ndim = self.ndim
  */
   __pyx_t_4 = __pyx_v_self->data;
   __pyx_v_info->buf = __pyx_t_4;
 
-  /* "View.MemoryView":195
+  /* "View.MemoryView":194
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  *         info.len = self.len             # <<<<<<<<<<<<<<
  *         info.ndim = self.ndim
  *         info.shape = self._shape
  */
   __pyx_t_5 = __pyx_v_self->len;
   __pyx_v_info->len = __pyx_t_5;
 
-  /* "View.MemoryView":196
+  /* "View.MemoryView":195
  *         info.buf = self.data
  *         info.len = self.len
  *         info.ndim = self.ndim             # <<<<<<<<<<<<<<
  *         info.shape = self._shape
  *         info.strides = self._strides
  */
   __pyx_t_6 = __pyx_v_self->ndim;
   __pyx_v_info->ndim = __pyx_t_6;
 
-  /* "View.MemoryView":197
+  /* "View.MemoryView":196
  *         info.len = self.len
  *         info.ndim = self.ndim
  *         info.shape = self._shape             # <<<<<<<<<<<<<<
  *         info.strides = self._strides
  *         info.suboffsets = NULL
  */
   __pyx_t_7 = __pyx_v_self->_shape;
   __pyx_v_info->shape = __pyx_t_7;
 
-  /* "View.MemoryView":198
+  /* "View.MemoryView":197
  *         info.ndim = self.ndim
  *         info.shape = self._shape
  *         info.strides = self._strides             # <<<<<<<<<<<<<<
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  */
   __pyx_t_7 = __pyx_v_self->_strides;
   __pyx_v_info->strides = __pyx_t_7;
 
-  /* "View.MemoryView":199
+  /* "View.MemoryView":198
  *         info.shape = self._shape
  *         info.strides = self._strides
  *         info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *         info.itemsize = self.itemsize
  *         info.readonly = 0
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* "View.MemoryView":200
+  /* "View.MemoryView":199
  *         info.strides = self._strides
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize             # <<<<<<<<<<<<<<
  *         info.readonly = 0
  * 
  */
   __pyx_t_5 = __pyx_v_self->itemsize;
   __pyx_v_info->itemsize = __pyx_t_5;
 
-  /* "View.MemoryView":201
+  /* "View.MemoryView":200
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  *         info.readonly = 0             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   __pyx_v_info->readonly = 0;
 
-  /* "View.MemoryView":203
+  /* "View.MemoryView":202
  *         info.readonly = 0
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":204
+    /* "View.MemoryView":203
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
     __pyx_t_4 = __pyx_v_self->format;
     __pyx_v_info->format = __pyx_t_4;
 
-    /* "View.MemoryView":203
+    /* "View.MemoryView":202
  *         info.readonly = 0
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
     goto __pyx_L5;
   }
 
-  /* "View.MemoryView":206
+  /* "View.MemoryView":205
  *             info.format = self.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.obj = self
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L5:;
 
-  /* "View.MemoryView":208
+  /* "View.MemoryView":207
  *             info.format = NULL
  * 
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":186
+  /* "View.MemoryView":185
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
@@ -5242,15 +5083,15 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":212
+/* "View.MemoryView":211
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
@@ -5266,122 +5107,122 @@
 }
 
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":213
+  /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
   __pyx_t_1 = ((__pyx_v_self->callback_free_data != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":214
+    /* "View.MemoryView":213
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)             # <<<<<<<<<<<<<<
  *         elif self.free_data:
  *             if self.dtype_is_object:
  */
     __pyx_v_self->callback_free_data(__pyx_v_self->data);
 
-    /* "View.MemoryView":213
+    /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":215
+  /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,
  */
   __pyx_t_1 = (__pyx_v_self->free_data != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":216
+    /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  */
     __pyx_t_1 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":217
+      /* "View.MemoryView":216
  *         elif self.free_data:
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,             # <<<<<<<<<<<<<<
  *                                           self._strides, self.ndim, False)
  *             free(self.data)
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_self->data, __pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_self->ndim, 0);
 
-      /* "View.MemoryView":216
+      /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  */
     }
 
-    /* "View.MemoryView":219
+    /* "View.MemoryView":218
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  *             free(self.data)             # <<<<<<<<<<<<<<
  *         PyObject_Free(self._shape)
  * 
  */
     free(__pyx_v_self->data);
 
-    /* "View.MemoryView":215
+    /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":220
+  /* "View.MemoryView":219
  *                                           self._strides, self.ndim, False)
  *             free(self.data)
  *         PyObject_Free(self._shape)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   PyObject_Free(__pyx_v_self->_shape);
 
-  /* "View.MemoryView":212
+  /* "View.MemoryView":211
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":223
+/* "View.MemoryView":222
  * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
  * 
  */
 
@@ -5403,29 +5244,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":224
+  /* "View.MemoryView":223
  *     @property
  *     def memview(self):
  *         return self.get_memview()             # <<<<<<<<<<<<<<
  * 
  *     @cname('get_memview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 224, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 223, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":223
+  /* "View.MemoryView":222
  * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
  * 
  */
 
@@ -5436,15 +5277,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":227
+/* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5456,54 +5297,54 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_memview", 0);
 
-  /* "View.MemoryView":228
+  /* "View.MemoryView":227
  *     @cname('get_memview')
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE             # <<<<<<<<<<<<<<
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  */
   __pyx_v_flags = ((PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) | PyBUF_WRITABLE);
 
-  /* "View.MemoryView":229
+  /* "View.MemoryView":228
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":227
+  /* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5516,15 +5357,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":231
+/* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
@@ -5542,39 +5383,39 @@
 }
 
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":232
+  /* "View.MemoryView":231
  * 
  *     def __len__(self):
  *         return self._shape[0]             # <<<<<<<<<<<<<<
  * 
  *     def __getattr__(self, attr):
  */
   __pyx_r = (__pyx_v_self->_shape[0]);
   goto __pyx_L0;
 
-  /* "View.MemoryView":231
+  /* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":234
+/* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -5597,32 +5438,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getattr__", 0);
 
-  /* "View.MemoryView":235
+  /* "View.MemoryView":234
  * 
  *     def __getattr__(self, attr):
  *         return getattr(self.memview, attr)             # <<<<<<<<<<<<<<
  * 
  *     def __getitem__(self, item):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":234
+  /* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -5634,15 +5475,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":237
+/* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -5665,32 +5506,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":238
+  /* "View.MemoryView":237
  * 
  *     def __getitem__(self, item):
  *         return self.memview[item]             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(self, item, value):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":237
+  /* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -5702,15 +5543,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":240
+/* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -5732,27 +5573,27 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
 
-  /* "View.MemoryView":241
+  /* "View.MemoryView":240
  * 
  *     def __setitem__(self, item, value):
  *         self.memview[item] = value             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 241, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(1, 241, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":240
+  /* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -5877,15 +5718,15 @@
   __Pyx_AddTraceback("View.MemoryView.array.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":245
+/* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
@@ -5899,145 +5740,145 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("array_cwrapper", 0);
 
-  /* "View.MemoryView":249
+  /* "View.MemoryView":248
  *     cdef array result
  * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_buf == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":250
+    /* "View.MemoryView":249
  * 
  *     if buf == NULL:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))             # <<<<<<<<<<<<<<
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
     __pyx_t_2 = 0;
     __pyx_t_3 = 0;
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "View.MemoryView":249
+    /* "View.MemoryView":248
  *     cdef array result
  * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":252
+  /* "View.MemoryView":251
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
   /*else*/ {
-    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_t_3);
     __pyx_t_4 = 0;
     __pyx_t_5 = 0;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":253
+    /* "View.MemoryView":252
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)             # <<<<<<<<<<<<<<
  *         result.data = buf
  * 
  */
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 253, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 253, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 252, __pyx_L1_error)
 
-    /* "View.MemoryView":252
+    /* "View.MemoryView":251
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
-    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "View.MemoryView":254
+    /* "View.MemoryView":253
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)
  *         result.data = buf             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
     __pyx_v_result->data = __pyx_v_buf;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":256
+  /* "View.MemoryView":255
  *         result.data = buf
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(((PyObject *)__pyx_r));
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":245
+  /* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
@@ -6052,15 +5893,15 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":282
+/* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
@@ -6089,26 +5930,26 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(1, 282, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(1, 281, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_name = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 282, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.Enum.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v_name);
 
@@ -6118,42 +5959,42 @@
 }
 
 static int __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v_name) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "View.MemoryView":283
+  /* "View.MemoryView":282
  *     cdef object name
  *     def __init__(self, name):
  *         self.name = name             # <<<<<<<<<<<<<<
  *     def __repr__(self):
  *         return self.name
  */
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   __Pyx_GOTREF(__pyx_v_self->name);
   __Pyx_DECREF(__pyx_v_self->name);
   __pyx_v_self->name = __pyx_v_name;
 
-  /* "View.MemoryView":282
+  /* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":284
+/* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -6171,27 +6012,27 @@
 }
 
 static PyObject *__pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum_2__repr__(struct __pyx_MemviewEnum_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":285
+  /* "View.MemoryView":284
  *         self.name = name
  *     def __repr__(self):
  *         return self.name             # <<<<<<<<<<<<<<
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->name);
   __pyx_r = __pyx_v_self->name;
   goto __pyx_L0;
 
-  /* "View.MemoryView":284
+  /* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -6466,15 +6307,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":17
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
-  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
+  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
@@ -6491,98 +6332,98 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":299
+/* "View.MemoryView":298
  * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
 static void *__pyx_align_pointer(void *__pyx_v_memory, size_t __pyx_v_alignment) {
   Py_intptr_t __pyx_v_aligned_p;
   size_t __pyx_v_offset;
   void *__pyx_r;
   int __pyx_t_1;
 
-  /* "View.MemoryView":301
+  /* "View.MemoryView":300
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory             # <<<<<<<<<<<<<<
  *     cdef size_t offset
  * 
  */
   __pyx_v_aligned_p = ((Py_intptr_t)__pyx_v_memory);
 
-  /* "View.MemoryView":305
+  /* "View.MemoryView":304
  * 
  *     with cython.cdivision(True):
  *         offset = aligned_p % alignment             # <<<<<<<<<<<<<<
  * 
  *     if offset > 0:
  */
   __pyx_v_offset = (__pyx_v_aligned_p % __pyx_v_alignment);
 
-  /* "View.MemoryView":307
+  /* "View.MemoryView":306
  *         offset = aligned_p % alignment
  * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
  * 
  */
   __pyx_t_1 = ((__pyx_v_offset > 0) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":308
+    /* "View.MemoryView":307
  * 
  *     if offset > 0:
  *         aligned_p += alignment - offset             # <<<<<<<<<<<<<<
  * 
  *     return <void *> aligned_p
  */
     __pyx_v_aligned_p = (__pyx_v_aligned_p + (__pyx_v_alignment - __pyx_v_offset));
 
-    /* "View.MemoryView":307
+    /* "View.MemoryView":306
  *         offset = aligned_p % alignment
  * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
  * 
  */
   }
 
-  /* "View.MemoryView":310
+  /* "View.MemoryView":309
  *         aligned_p += alignment - offset
  * 
  *     return <void *> aligned_p             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((void *)__pyx_v_aligned_p);
   goto __pyx_L0;
 
-  /* "View.MemoryView":299
+  /* "View.MemoryView":298
  * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":346
+/* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -6619,47 +6460,47 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_flags)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 346, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype_is_object);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 346, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 345, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_obj = values[0];
-    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 346, __pyx_L3_error)
+    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     if (values[2]) {
-      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 346, __pyx_L3_error)
+      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     } else {
       __pyx_v_dtype_is_object = ((int)0);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 346, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_obj, __pyx_v_flags, __pyx_v_dtype_is_object);
 
@@ -6676,37 +6517,37 @@
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "View.MemoryView":347
+  /* "View.MemoryView":346
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj             # <<<<<<<<<<<<<<
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  */
   __Pyx_INCREF(__pyx_v_obj);
   __Pyx_GIVEREF(__pyx_v_obj);
   __Pyx_GOTREF(__pyx_v_self->obj);
   __Pyx_DECREF(__pyx_v_self->obj);
   __pyx_v_self->obj = __pyx_v_obj;
 
-  /* "View.MemoryView":348
+  /* "View.MemoryView":347
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj
  *         self.flags = flags             # <<<<<<<<<<<<<<
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  */
   __pyx_v_self->flags = __pyx_v_flags;
 
-  /* "View.MemoryView":349
+  /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   __pyx_t_2 = (((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))) == ((PyObject *)__pyx_memoryview_type));
@@ -6718,250 +6559,231 @@
   }
   __pyx_t_3 = (__pyx_v_obj != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":350
+    /* "View.MemoryView":349
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)             # <<<<<<<<<<<<<<
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  */
-    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 350, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 349, __pyx_L1_error)
 
-    /* "View.MemoryView":351
+    /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     __pyx_t_1 = ((((PyObject *)__pyx_v_self->view.obj) == NULL) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":352
+      /* "View.MemoryView":351
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None             # <<<<<<<<<<<<<<
  *                 Py_INCREF(Py_None)
  * 
  */
       ((Py_buffer *)(&__pyx_v_self->view))->obj = Py_None;
 
-      /* "View.MemoryView":353
+      /* "View.MemoryView":352
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
+ *         global __pyx_memoryview_thread_locks_used
  */
       Py_INCREF(Py_None);
 
-      /* "View.MemoryView":351
+      /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     }
 
-    /* "View.MemoryView":349
+    /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   }
 
   /* "View.MemoryView":355
- *                 Py_INCREF(Py_None)
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-  __pyx_t_1 = ((!(__PYX_CYTHON_ATOMICS_ENABLED() != 0)) != 0);
+  __pyx_t_1 = ((__pyx_memoryview_thread_locks_used < 8) != 0);
   if (__pyx_t_1) {
 
+    /* "View.MemoryView":356
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ */
+    __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+
     /* "View.MemoryView":357
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  */
-    __pyx_t_1 = ((__pyx_memoryview_thread_locks_used < 8) != 0);
-    if (__pyx_t_1) {
+    __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
 
-      /* "View.MemoryView":358
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:
+    /* "View.MemoryView":355
+ * 
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-      __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+  }
 
-      /* "View.MemoryView":359
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":358
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
  */
-      __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
+  __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
+  if (__pyx_t_1) {
 
-      /* "View.MemoryView":357
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+    /* "View.MemoryView":359
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
+ *             if self.lock is NULL:
+ *                 raise MemoryError
  */
-    }
+    __pyx_v_self->lock = PyThread_allocate_lock();
 
     /* "View.MemoryView":360
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+ *                 raise MemoryError
+ * 
  */
     __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
-    if (__pyx_t_1) {
+    if (unlikely(__pyx_t_1)) {
 
       /* "View.MemoryView":361
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
- *                 if self.lock is NULL:
- *                     raise MemoryError
- */
-      __pyx_v_self->lock = PyThread_allocate_lock();
-
-      /* "View.MemoryView":362
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
- * 
- */
-      __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
-      if (unlikely(__pyx_t_1)) {
-
-        /* "View.MemoryView":363
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
- *                     raise MemoryError             # <<<<<<<<<<<<<<
+ *                 raise MemoryError             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
-        PyErr_NoMemory(); __PYX_ERR(1, 363, __pyx_L1_error)
-
-        /* "View.MemoryView":362
- *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
- * 
- */
-      }
+      PyErr_NoMemory(); __PYX_ERR(1, 361, __pyx_L1_error)
 
       /* "View.MemoryView":360
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+ *                 raise MemoryError
+ * 
  */
     }
 
-    /* "View.MemoryView":355
- *                 Py_INCREF(Py_None)
- * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+    /* "View.MemoryView":358
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
+ *             if self.lock is NULL:
  */
   }
 
-  /* "View.MemoryView":365
- *                     raise MemoryError
+  /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":366
+    /* "View.MemoryView":364
  * 
  *         if flags & PyBUF_FORMAT:
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')             # <<<<<<<<<<<<<<
  *         else:
  *             self.dtype_is_object = dtype_is_object
  */
     __pyx_t_2 = (((__pyx_v_self->view.format[0]) == 'O') != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
-      goto __pyx_L12_bool_binop_done;
+      goto __pyx_L11_bool_binop_done;
     }
     __pyx_t_2 = (((__pyx_v_self->view.format[1]) == '\x00') != 0);
     __pyx_t_1 = __pyx_t_2;
-    __pyx_L12_bool_binop_done:;
+    __pyx_L11_bool_binop_done:;
     __pyx_v_self->dtype_is_object = __pyx_t_1;
 
-    /* "View.MemoryView":365
- *                     raise MemoryError
+    /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":368
+  /* "View.MemoryView":366
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  *             self.dtype_is_object = dtype_is_object             # <<<<<<<<<<<<<<
  * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  */
   /*else*/ {
     __pyx_v_self->dtype_is_object = __pyx_v_dtype_is_object;
   }
-  __pyx_L11:;
+  __pyx_L10:;
 
-  /* "View.MemoryView":370
+  /* "View.MemoryView":368
  *             self.dtype_is_object = dtype_is_object
  * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(             # <<<<<<<<<<<<<<
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL
  */
   __pyx_v_self->acquisition_count_aligned_p = ((__pyx_atomic_int *)__pyx_align_pointer(((void *)(&(__pyx_v_self->acquisition_count[0]))), (sizeof(__pyx_atomic_int))));
 
-  /* "View.MemoryView":372
+  /* "View.MemoryView":370
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(memoryview self):
  */
   __pyx_v_self->typeinfo = NULL;
 
-  /* "View.MemoryView":346
+  /* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -6972,15 +6794,15 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":374
+/* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
@@ -7003,215 +6825,215 @@
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   PyThread_type_lock __pyx_t_6;
   PyThread_type_lock __pyx_t_7;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":375
+  /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
   __pyx_t_1 = (__pyx_v_self->obj != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":376
+    /* "View.MemoryView":374
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)             # <<<<<<<<<<<<<<
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  */
     __Pyx_ReleaseBuffer((&__pyx_v_self->view));
 
-    /* "View.MemoryView":375
+    /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":377
+  /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   __pyx_t_2 = ((((Py_buffer *)(&__pyx_v_self->view))->obj == Py_None) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":379
+    /* "View.MemoryView":377
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL             # <<<<<<<<<<<<<<
  *             Py_DECREF(Py_None)
  * 
  */
     ((Py_buffer *)(&__pyx_v_self->view))->obj = NULL;
 
-    /* "View.MemoryView":380
+    /* "View.MemoryView":378
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  *             Py_DECREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *         cdef int i
  */
     Py_DECREF(Py_None);
 
-    /* "View.MemoryView":377
+    /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":384
+  /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   __pyx_t_2 = ((__pyx_v_self->lock != NULL) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":385
+    /* "View.MemoryView":383
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):             # <<<<<<<<<<<<<<
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  */
     __pyx_t_3 = __pyx_memoryview_thread_locks_used;
     __pyx_t_4 = __pyx_t_3;
     for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
       __pyx_v_i = __pyx_t_5;
 
-      /* "View.MemoryView":386
+      /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       __pyx_t_2 = (((__pyx_memoryview_thread_locks[__pyx_v_i]) == __pyx_v_self->lock) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":387
+        /* "View.MemoryView":385
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1             # <<<<<<<<<<<<<<
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  */
         __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used - 1);
 
-        /* "View.MemoryView":388
+        /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         __pyx_t_2 = ((__pyx_v_i != __pyx_memoryview_thread_locks_used) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":390
+          /* "View.MemoryView":388
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])             # <<<<<<<<<<<<<<
  *                     break
  *             else:
  */
           __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
           __pyx_t_7 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
 
-          /* "View.MemoryView":389
+          /* "View.MemoryView":387
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (             # <<<<<<<<<<<<<<
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break
  */
           (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_6;
           (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_7;
 
-          /* "View.MemoryView":388
+          /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         }
 
-        /* "View.MemoryView":391
+        /* "View.MemoryView":389
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break             # <<<<<<<<<<<<<<
  *             else:
  *                 PyThread_free_lock(self.lock)
  */
         goto __pyx_L6_break;
 
-        /* "View.MemoryView":386
+        /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       }
     }
     /*else*/ {
 
-      /* "View.MemoryView":393
+      /* "View.MemoryView":391
  *                     break
  *             else:
  *                 PyThread_free_lock(self.lock)             # <<<<<<<<<<<<<<
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  */
       PyThread_free_lock(__pyx_v_self->lock);
     }
     __pyx_L6_break:;
 
-    /* "View.MemoryView":384
+    /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   }
 
-  /* "View.MemoryView":374
+  /* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":395
+/* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -7229,107 +7051,107 @@
   Py_ssize_t __pyx_t_6;
   char *__pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_item_pointer", 0);
 
-  /* "View.MemoryView":397
+  /* "View.MemoryView":395
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf             # <<<<<<<<<<<<<<
  * 
  *         for dim, idx in enumerate(index):
  */
   __pyx_v_itemp = ((char *)__pyx_v_self->view.buf);
 
-  /* "View.MemoryView":399
+  /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   __pyx_t_1 = 0;
   if (likely(PyList_CheckExact(__pyx_v_index)) || PyTuple_CheckExact(__pyx_v_index)) {
     __pyx_t_2 = __pyx_v_index; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 399, __pyx_L1_error)
+    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 397, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 399, __pyx_L1_error)
+    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 397, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_4)) {
       if (likely(PyList_CheckExact(__pyx_t_2))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       }
     } else {
       __pyx_t_5 = __pyx_t_4(__pyx_t_2);
       if (unlikely(!__pyx_t_5)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 399, __pyx_L1_error)
+          else __PYX_ERR(1, 397, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_5);
     }
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_1;
     __pyx_t_1 = (__pyx_t_1 + 1);
 
-    /* "View.MemoryView":400
+    /* "View.MemoryView":398
  * 
  *         for dim, idx in enumerate(index):
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)             # <<<<<<<<<<<<<<
  * 
  *         return itemp
  */
-    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 400, __pyx_L1_error)
-    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 400, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 398, __pyx_L1_error)
+    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 398, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_7;
 
-    /* "View.MemoryView":399
+    /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":402
+  /* "View.MemoryView":400
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  *         return itemp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_itemp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":395
+  /* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -7341,15 +7163,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":405
+/* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
@@ -7379,143 +7201,143 @@
   PyObject *__pyx_t_5 = NULL;
   char *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":406
+  /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   __pyx_t_1 = (__pyx_v_index == __pyx_builtin_Ellipsis);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":407
+    /* "View.MemoryView":405
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:
  *             return self             # <<<<<<<<<<<<<<
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __pyx_r = ((PyObject *)__pyx_v_self);
     goto __pyx_L0;
 
-    /* "View.MemoryView":406
+    /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   }
 
-  /* "View.MemoryView":409
+  /* "View.MemoryView":407
  *             return self
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         cdef char *itemp
  */
-  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 409, __pyx_L1_error)
+  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 407, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (likely(__pyx_t_3 != Py_None)) {
     PyObject* sequence = __pyx_t_3;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 409, __pyx_L1_error)
+      __PYX_ERR(1, 407, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 409, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 409, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 409, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 407, __pyx_L1_error)
   }
   __pyx_v_have_slices = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_v_indices = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "View.MemoryView":412
+  /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 412, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 410, __pyx_L1_error)
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":413
+    /* "View.MemoryView":411
  *         cdef char *itemp
  *         if have_slices:
  *             return memview_slice(self, indices)             # <<<<<<<<<<<<<<
  *         else:
  *             itemp = self.get_item_pointer(indices)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 413, __pyx_L1_error)
+    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 411, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":412
+    /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
   }
 
-  /* "View.MemoryView":415
+  /* "View.MemoryView":413
  *             return memview_slice(self, indices)
  *         else:
  *             itemp = self.get_item_pointer(indices)             # <<<<<<<<<<<<<<
  *             return self.convert_item_to_object(itemp)
  * 
  */
   /*else*/ {
-    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(1, 415, __pyx_L1_error)
+    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(1, 413, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_6;
 
-    /* "View.MemoryView":416
+    /* "View.MemoryView":414
  *         else:
  *             itemp = self.get_item_pointer(indices)
  *             return self.convert_item_to_object(itemp)             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(memoryview self, object index, object value):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 416, __pyx_L1_error)
+    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 414, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":405
+  /* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
@@ -7530,15 +7352,15 @@
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_indices);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":418
+/* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
@@ -7566,182 +7388,182 @@
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
   __Pyx_INCREF(__pyx_v_index);
 
-  /* "View.MemoryView":419
+  /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
   __pyx_t_1 = (__pyx_v_self->view.readonly != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":420
+    /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 418, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 420, __pyx_L1_error)
+    __PYX_ERR(1, 418, __pyx_L1_error)
 
-    /* "View.MemoryView":419
+    /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":422
+  /* "View.MemoryView":420
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         if have_slices:
  */
-  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 422, __pyx_L1_error)
+  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (likely(__pyx_t_2 != Py_None)) {
     PyObject* sequence = __pyx_t_2;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 422, __pyx_L1_error)
+      __PYX_ERR(1, 420, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 422, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 422, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     #endif
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 422, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 420, __pyx_L1_error)
   }
   __pyx_v_have_slices = __pyx_t_3;
   __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_4);
   __pyx_t_4 = 0;
 
-  /* "View.MemoryView":424
+  /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 424, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 422, __pyx_L1_error)
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":425
+    /* "View.MemoryView":423
  * 
  *         if have_slices:
  *             obj = self.is_slice(value)             # <<<<<<<<<<<<<<
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)
  */
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 425, __pyx_L1_error)
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 423, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_v_obj = __pyx_t_2;
     __pyx_t_2 = 0;
 
-    /* "View.MemoryView":426
+    /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 426, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 424, __pyx_L1_error)
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":427
+      /* "View.MemoryView":425
  *             obj = self.is_slice(value)
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)             # <<<<<<<<<<<<<<
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)
  */
-      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 425, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 425, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-      /* "View.MemoryView":426
+      /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":429
+    /* "View.MemoryView":427
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)             # <<<<<<<<<<<<<<
  *         else:
  *             self.setitem_indexed(index, value)
  */
     /*else*/ {
-      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 429, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 427, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(1, 429, __pyx_L1_error)
-      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 429, __pyx_L1_error)
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 427, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":424
+    /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
     goto __pyx_L4;
   }
 
-  /* "View.MemoryView":431
+  /* "View.MemoryView":429
  *                 self.setitem_slice_assign_scalar(self[index], value)
  *         else:
  *             self.setitem_indexed(index, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef is_slice(self, obj):
  */
   /*else*/ {
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 431, __pyx_L1_error)
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 429, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
   __pyx_L4:;
 
-  /* "View.MemoryView":418
+  /* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
@@ -7758,15 +7580,15 @@
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":433
+/* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7784,26 +7606,26 @@
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_slice", 0);
   __Pyx_INCREF(__pyx_v_obj);
 
-  /* "View.MemoryView":434
+  /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_obj, __pyx_memoryview_type); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":435
+    /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
     {
@@ -7811,59 +7633,59 @@
       __Pyx_PyThreadState_assign
       __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_3);
       __Pyx_XGOTREF(__pyx_t_4);
       __Pyx_XGOTREF(__pyx_t_5);
       /*try:*/ {
 
-        /* "View.MemoryView":436
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 436, __pyx_L4_error)
+        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":437
+        /* "View.MemoryView":435
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)             # <<<<<<<<<<<<<<
  *             except TypeError:
  *                 return None
  */
-        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 437, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 435, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
 
-        /* "View.MemoryView":436
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 436, __pyx_L4_error)
+        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_INCREF(__pyx_v_obj);
         __Pyx_GIVEREF(__pyx_v_obj);
         PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_obj);
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_6);
         __Pyx_GIVEREF(__pyx_t_7);
         PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_7);
         __pyx_t_6 = 0;
         __pyx_t_7 = 0;
-        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 436, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF_SET(__pyx_v_obj, __pyx_t_7);
         __pyx_t_7 = 0;
 
-        /* "View.MemoryView":435
+        /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       }
@@ -7872,30 +7694,30 @@
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       goto __pyx_L9_try_end;
       __pyx_L4_error:;
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-      /* "View.MemoryView":438
+      /* "View.MemoryView":436
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  *             except TypeError:             # <<<<<<<<<<<<<<
  *                 return None
  * 
  */
       __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
       if (__pyx_t_9) {
         __Pyx_AddTraceback("View.MemoryView.memoryview.is_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 438, __pyx_L6_except_error)
+        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 436, __pyx_L6_except_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":439
+        /* "View.MemoryView":437
  *                                  self.dtype_is_object)
  *             except TypeError:
  *                 return None             # <<<<<<<<<<<<<<
  * 
  *         return obj
  */
         __Pyx_XDECREF(__pyx_r);
@@ -7904,15 +7726,15 @@
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         goto __pyx_L7_except_return;
       }
       goto __pyx_L6_except_error;
       __pyx_L6_except_error:;
 
-      /* "View.MemoryView":435
+      /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       __Pyx_XGIVEREF(__pyx_t_3);
@@ -7925,36 +7747,36 @@
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L0;
       __pyx_L9_try_end:;
     }
 
-    /* "View.MemoryView":434
+    /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   }
 
-  /* "View.MemoryView":441
+  /* "View.MemoryView":439
  *                 return None
  * 
  *         return obj             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assignment(self, dst, src):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_obj);
   __pyx_r = __pyx_v_obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":433
+  /* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7968,15 +7790,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":443
+/* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
@@ -7992,60 +7814,60 @@
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assignment", 0);
 
-  /* "View.MemoryView":447
+  /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 447, __pyx_L1_error)
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 447, __pyx_L1_error)
+  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 445, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 445, __pyx_L1_error)
 
-  /* "View.MemoryView":448
+  /* "View.MemoryView":446
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],             # <<<<<<<<<<<<<<
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  */
-  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 448, __pyx_L1_error)
-  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 448, __pyx_L1_error)
+  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 446, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 446, __pyx_L1_error)
 
-  /* "View.MemoryView":449
+  /* "View.MemoryView":447
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":447
+  /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 447, __pyx_L1_error)
+  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 445, __pyx_L1_error)
 
-  /* "View.MemoryView":443
+  /* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
@@ -8058,15 +7880,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":451
+/* "View.MemoryView":449
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
@@ -8091,204 +7913,204 @@
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assign_scalar", 0);
 
-  /* "View.MemoryView":453
+  /* "View.MemoryView":451
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  *         cdef int array[128]
  *         cdef void *tmp = NULL             # <<<<<<<<<<<<<<
  *         cdef void *item
  * 
  */
   __pyx_v_tmp = NULL;
 
-  /* "View.MemoryView":458
+  /* "View.MemoryView":456
  *         cdef __Pyx_memviewslice *dst_slice
  *         cdef __Pyx_memviewslice tmp_slice
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)             # <<<<<<<<<<<<<<
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 458, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 456, __pyx_L1_error)
   __pyx_v_dst_slice = __pyx_t_1;
 
-  /* "View.MemoryView":460
+  /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
   __pyx_t_2 = ((((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array))) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":461
+    /* "View.MemoryView":459
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)             # <<<<<<<<<<<<<<
  *             if tmp == NULL:
  *                 raise MemoryError
  */
     __pyx_v_tmp = PyMem_Malloc(__pyx_v_self->view.itemsize);
 
-    /* "View.MemoryView":462
+    /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     __pyx_t_2 = ((__pyx_v_tmp == NULL) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":463
+      /* "View.MemoryView":461
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  *             item = tmp
  *         else:
  */
-      PyErr_NoMemory(); __PYX_ERR(1, 463, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(1, 461, __pyx_L1_error)
 
-      /* "View.MemoryView":462
+      /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     }
 
-    /* "View.MemoryView":464
+    /* "View.MemoryView":462
  *             if tmp == NULL:
  *                 raise MemoryError
  *             item = tmp             # <<<<<<<<<<<<<<
  *         else:
  *             item = <void *> array
  */
     __pyx_v_item = __pyx_v_tmp;
 
-    /* "View.MemoryView":460
+    /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":466
+  /* "View.MemoryView":464
  *             item = tmp
  *         else:
  *             item = <void *> array             # <<<<<<<<<<<<<<
  * 
  *         try:
  */
   /*else*/ {
     __pyx_v_item = ((void *)__pyx_v_array);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":468
+  /* "View.MemoryView":466
  *             item = <void *> array
  * 
  *         try:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value
  */
   /*try:*/ {
 
-    /* "View.MemoryView":469
+    /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
     __pyx_t_2 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":470
+      /* "View.MemoryView":468
  *         try:
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value             # <<<<<<<<<<<<<<
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)
  */
       (((PyObject **)__pyx_v_item)[0]) = ((PyObject *)__pyx_v_value);
 
-      /* "View.MemoryView":469
+      /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
       goto __pyx_L8;
     }
 
-    /* "View.MemoryView":472
+    /* "View.MemoryView":470
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     /*else*/ {
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 472, __pyx_L6_error)
+      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 470, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __pyx_L8:;
 
-    /* "View.MemoryView":476
+    /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     __pyx_t_2 = ((__pyx_v_self->view.suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":477
+      /* "View.MemoryView":475
  * 
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)             # <<<<<<<<<<<<<<
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  *                                 item, self.dtype_is_object)
  */
-      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 477, __pyx_L6_error)
+      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 475, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-      /* "View.MemoryView":476
+      /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     }
 
-    /* "View.MemoryView":478
+    /* "View.MemoryView":476
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,             # <<<<<<<<<<<<<<
  *                                 item, self.dtype_is_object)
  *         finally:
  */
     __pyx_memoryview_slice_assign_scalar(__pyx_v_dst_slice, __pyx_v_dst->view.ndim, __pyx_v_self->view.itemsize, __pyx_v_item, __pyx_v_self->dtype_is_object);
   }
 
-  /* "View.MemoryView":481
+  /* "View.MemoryView":479
  *                                 item, self.dtype_is_object)
  *         finally:
  *             PyMem_Free(tmp)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_indexed(self, index, value):
  */
   /*finally:*/ {
@@ -8327,15 +8149,15 @@
       __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
       __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "View.MemoryView":451
+  /* "View.MemoryView":449
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
@@ -8348,15 +8170,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":483
+/* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8367,36 +8189,36 @@
   char *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_indexed", 0);
 
-  /* "View.MemoryView":484
+  /* "View.MemoryView":482
  * 
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)             # <<<<<<<<<<<<<<
  *         self.assign_item_from_object(itemp, value)
  * 
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 484, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 482, __pyx_L1_error)
   __pyx_v_itemp = __pyx_t_1;
 
-  /* "View.MemoryView":485
+  /* "View.MemoryView":483
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 485, __pyx_L1_error)
+  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 483, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":483
+  /* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8409,15 +8231,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":487
+/* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8439,39 +8261,39 @@
   size_t __pyx_t_10;
   int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":490
+  /* "View.MemoryView":488
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef bytes bytesitem
  * 
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 490, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 488, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":493
+  /* "View.MemoryView":491
  *         cdef bytes bytesitem
  * 
  *         bytesitem = itemp[:self.view.itemsize]             # <<<<<<<<<<<<<<
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 491, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_bytesitem = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":494
+  /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
   {
@@ -8479,24 +8301,24 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_4);
     /*try:*/ {
 
-      /* "View.MemoryView":495
+      /* "View.MemoryView":493
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)             # <<<<<<<<<<<<<<
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 495, __pyx_L3_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 495, __pyx_L3_error)
+      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -8505,94 +8327,94 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       {
-        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_9);
         if (__pyx_t_7) {
           __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
         }
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_6);
         __Pyx_INCREF(__pyx_v_bytesitem);
         __Pyx_GIVEREF(__pyx_v_bytesitem);
         PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_bytesitem);
         __pyx_t_6 = 0;
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_result = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "View.MemoryView":494
+      /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     }
 
-    /* "View.MemoryView":499
+    /* "View.MemoryView":497
  *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
     /*else:*/ {
       __pyx_t_10 = strlen(__pyx_v_self->view.format); 
       __pyx_t_11 = ((__pyx_t_10 == 1) != 0);
       if (__pyx_t_11) {
 
-        /* "View.MemoryView":500
+        /* "View.MemoryView":498
  *         else:
  *             if len(self.view.format) == 1:
  *                 return result[0]             # <<<<<<<<<<<<<<
  *             return result
  * 
  */
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 500, __pyx_L5_except_error)
+        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 498, __pyx_L5_except_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_r = __pyx_t_1;
         __pyx_t_1 = 0;
         goto __pyx_L6_except_return;
 
-        /* "View.MemoryView":499
+        /* "View.MemoryView":497
  *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
       }
 
-      /* "View.MemoryView":501
+      /* "View.MemoryView":499
  *             if len(self.view.format) == 1:
  *                 return result[0]
  *             return result             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
       __Pyx_XDECREF(__pyx_r);
@@ -8603,52 +8425,52 @@
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-    /* "View.MemoryView":496
+    /* "View.MemoryView":494
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:             # <<<<<<<<<<<<<<
  *             raise ValueError("Unable to convert item to object")
  *         else:
  */
     __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_9);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 496, __pyx_L5_except_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 494, __pyx_L5_except_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_6);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_9);
     __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_9 = 0;
     if (__pyx_t_8) {
       __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 496, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 494, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_9);
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_1);
 
-      /* "View.MemoryView":497
+      /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 497, __pyx_L5_except_error)
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 495, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_Raise(__pyx_t_6, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(1, 497, __pyx_L5_except_error)
+      __PYX_ERR(1, 495, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "View.MemoryView":494
+    /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     __Pyx_XGIVEREF(__pyx_t_2);
@@ -8660,15 +8482,15 @@
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":487
+  /* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8686,15 +8508,15 @@
   __Pyx_XDECREF(__pyx_v_bytesitem);
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":503
+/* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8720,88 +8542,88 @@
   char *__pyx_t_13;
   char *__pyx_t_14;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":506
+  /* "View.MemoryView":504
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef char c
  *         cdef bytes bytesvalue
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 506, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 504, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":511
+  /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
   __pyx_t_2 = PyTuple_Check(__pyx_v_value); 
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "View.MemoryView":512
+    /* "View.MemoryView":510
  * 
  *         if isinstance(value, tuple):
  *             bytesvalue = struct.pack(self.view.format, *value)             # <<<<<<<<<<<<<<
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 512, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 510, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "View.MemoryView":511
+    /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":514
+  /* "View.MemoryView":512
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)             # <<<<<<<<<<<<<<
  * 
  *         for i, c in enumerate(bytesvalue):
  */
   /*else*/ {
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = NULL;
     __pyx_t_7 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -8810,102 +8632,102 @@
         __Pyx_DECREF_SET(__pyx_t_6, function);
         __pyx_t_7 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     {
-      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_8);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
       __Pyx_GIVEREF(__pyx_t_1);
       PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
       __Pyx_INCREF(__pyx_v_value);
       __Pyx_GIVEREF(__pyx_v_value);
       PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_value);
       __pyx_t_1 = 0;
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 514, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 512, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":516
+  /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
   __pyx_t_9 = 0;
   if (unlikely(__pyx_v_bytesvalue == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
-    __PYX_ERR(1, 516, __pyx_L1_error)
+    __PYX_ERR(1, 514, __pyx_L1_error)
   }
   __Pyx_INCREF(__pyx_v_bytesvalue);
   __pyx_t_10 = __pyx_v_bytesvalue;
   __pyx_t_12 = PyBytes_AS_STRING(__pyx_t_10);
   __pyx_t_13 = (__pyx_t_12 + PyBytes_GET_SIZE(__pyx_t_10));
   for (__pyx_t_14 = __pyx_t_12; __pyx_t_14 < __pyx_t_13; __pyx_t_14++) {
     __pyx_t_11 = __pyx_t_14;
     __pyx_v_c = (__pyx_t_11[0]);
 
-    /* "View.MemoryView":517
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     __pyx_v_i = __pyx_t_9;
 
-    /* "View.MemoryView":516
+    /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
     __pyx_t_9 = (__pyx_t_9 + 1);
 
-    /* "View.MemoryView":517
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     (__pyx_v_itemp[__pyx_v_i]) = __pyx_v_c;
   }
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "View.MemoryView":503
+  /* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8925,15 +8747,15 @@
   __Pyx_XDECREF(__pyx_v_struct);
   __Pyx_XDECREF(__pyx_v_bytesvalue);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":520
+/* "View.MemoryView":518
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
@@ -8968,15 +8790,15 @@
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":521
+  /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   __pyx_t_2 = ((__pyx_v_flags & PyBUF_WRITABLE) != 0);
@@ -8986,268 +8808,268 @@
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_2 = (__pyx_v_self->view.readonly != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":522
+    /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 522, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 520, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 522, __pyx_L1_error)
+    __PYX_ERR(1, 520, __pyx_L1_error)
 
-    /* "View.MemoryView":521
+    /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":524
+  /* "View.MemoryView":522
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_ND) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":525
+    /* "View.MemoryView":523
  * 
  *         if flags & PyBUF_ND:
  *             info.shape = self.view.shape             # <<<<<<<<<<<<<<
  *         else:
  *             info.shape = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.shape;
     __pyx_v_info->shape = __pyx_t_4;
 
-    /* "View.MemoryView":524
+    /* "View.MemoryView":522
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
     goto __pyx_L6;
   }
 
-  /* "View.MemoryView":527
+  /* "View.MemoryView":525
  *             info.shape = self.view.shape
  *         else:
  *             info.shape = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_STRIDES:
  */
   /*else*/ {
     __pyx_v_info->shape = NULL;
   }
   __pyx_L6:;
 
-  /* "View.MemoryView":529
+  /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":530
+    /* "View.MemoryView":528
  * 
  *         if flags & PyBUF_STRIDES:
  *             info.strides = self.view.strides             # <<<<<<<<<<<<<<
  *         else:
  *             info.strides = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.strides;
     __pyx_v_info->strides = __pyx_t_4;
 
-    /* "View.MemoryView":529
+    /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
     goto __pyx_L7;
   }
 
-  /* "View.MemoryView":532
+  /* "View.MemoryView":530
  *             info.strides = self.view.strides
  *         else:
  *             info.strides = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_INDIRECT:
  */
   /*else*/ {
     __pyx_v_info->strides = NULL;
   }
   __pyx_L7:;
 
-  /* "View.MemoryView":534
+  /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_INDIRECT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":535
+    /* "View.MemoryView":533
  * 
  *         if flags & PyBUF_INDIRECT:
  *             info.suboffsets = self.view.suboffsets             # <<<<<<<<<<<<<<
  *         else:
  *             info.suboffsets = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.suboffsets;
     __pyx_v_info->suboffsets = __pyx_t_4;
 
-    /* "View.MemoryView":534
+    /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
     goto __pyx_L8;
   }
 
-  /* "View.MemoryView":537
+  /* "View.MemoryView":535
  *             info.suboffsets = self.view.suboffsets
  *         else:
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   /*else*/ {
     __pyx_v_info->suboffsets = NULL;
   }
   __pyx_L8:;
 
-  /* "View.MemoryView":539
+  /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":540
+    /* "View.MemoryView":538
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.view.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
     __pyx_t_5 = __pyx_v_self->view.format;
     __pyx_v_info->format = __pyx_t_5;
 
-    /* "View.MemoryView":539
+    /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":542
+  /* "View.MemoryView":540
  *             info.format = self.view.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.buf = self.view.buf
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":544
+  /* "View.MemoryView":542
  *             info.format = NULL
  * 
  *         info.buf = self.view.buf             # <<<<<<<<<<<<<<
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  */
   __pyx_t_6 = __pyx_v_self->view.buf;
   __pyx_v_info->buf = __pyx_t_6;
 
-  /* "View.MemoryView":545
+  /* "View.MemoryView":543
  * 
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim             # <<<<<<<<<<<<<<
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  */
   __pyx_t_7 = __pyx_v_self->view.ndim;
   __pyx_v_info->ndim = __pyx_t_7;
 
-  /* "View.MemoryView":546
+  /* "View.MemoryView":544
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize             # <<<<<<<<<<<<<<
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  */
   __pyx_t_8 = __pyx_v_self->view.itemsize;
   __pyx_v_info->itemsize = __pyx_t_8;
 
-  /* "View.MemoryView":547
+  /* "View.MemoryView":545
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len             # <<<<<<<<<<<<<<
  *         info.readonly = self.view.readonly
  *         info.obj = self
  */
   __pyx_t_8 = __pyx_v_self->view.len;
   __pyx_v_info->len = __pyx_t_8;
 
-  /* "View.MemoryView":548
+  /* "View.MemoryView":546
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly             # <<<<<<<<<<<<<<
  *         info.obj = self
  * 
  */
   __pyx_t_1 = __pyx_v_self->view.readonly;
   __pyx_v_info->readonly = __pyx_t_1;
 
-  /* "View.MemoryView":549
+  /* "View.MemoryView":547
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":520
+  /* "View.MemoryView":518
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
@@ -9269,15 +9091,15 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":555
+/* "View.MemoryView":553
  * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
@@ -9301,49 +9123,49 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":556
+  /* "View.MemoryView":554
  *     @property
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&result.from_slice)
  *         return result
  */
-  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 556, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 554, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 556, __pyx_L1_error)
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 554, __pyx_L1_error)
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":557
+  /* "View.MemoryView":555
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)             # <<<<<<<<<<<<<<
  *         return result
  * 
  */
-  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 557, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 555, __pyx_L1_error)
 
-  /* "View.MemoryView":558
+  /* "View.MemoryView":556
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  *         return result             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":555
+  /* "View.MemoryView":553
  * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
@@ -9355,15 +9177,15 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":561
+/* "View.MemoryView":559
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
@@ -9381,42 +9203,42 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4base___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":562
+  /* "View.MemoryView":560
  *     @property
  *     def base(self):
  *         return self.obj             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->obj);
   __pyx_r = __pyx_v_self->obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":561
+  /* "View.MemoryView":559
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":565
+/* "View.MemoryView":563
  * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
  * 
  */
 
@@ -9443,41 +9265,41 @@
   Py_ssize_t *__pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":566
+  /* "View.MemoryView":564
  *     @property
  *     def shape(self):
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 566, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
   for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_length = (__pyx_t_2[0]);
-    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 566, __pyx_L1_error)
+    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 566, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 564, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 566, __pyx_L1_error)
+  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":565
+  /* "View.MemoryView":563
  * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
  * 
  */
 
@@ -9489,15 +9311,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":569
+/* "View.MemoryView":567
  * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
  * 
  */
 
@@ -9525,73 +9347,73 @@
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":570
+  /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   __pyx_t_1 = ((__pyx_v_self->view.strides == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":572
+    /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 570, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 572, __pyx_L1_error)
+    __PYX_ERR(1, 570, __pyx_L1_error)
 
-    /* "View.MemoryView":570
+    /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   }
 
-  /* "View.MemoryView":574
+  /* "View.MemoryView":572
  *             raise ValueError("Buffer view does not expose strides")
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 574, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
   for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
     __pyx_t_3 = __pyx_t_5;
     __pyx_v_stride = (__pyx_t_3[0]);
-    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 574, __pyx_L1_error)
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 574, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 572, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 574, __pyx_L1_error)
+  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":569
+  /* "View.MemoryView":567
  * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
  * 
  */
 
@@ -9603,15 +9425,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":577
+/* "View.MemoryView":575
  * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
@@ -9639,77 +9461,77 @@
   Py_ssize_t *__pyx_t_5;
   Py_ssize_t *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":578
+  /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.suboffsets == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":579
+    /* "View.MemoryView":577
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__13, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__13, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":578
+    /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   }
 
-  /* "View.MemoryView":581
+  /* "View.MemoryView":579
  *             return (-1,) * self.view.ndim
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 581, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_5 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
   for (__pyx_t_6 = __pyx_v_self->view.suboffsets; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
     __pyx_t_4 = __pyx_t_6;
     __pyx_v_suboffset = (__pyx_t_4[0]);
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 581, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(1, 581, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
-  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 581, __pyx_L1_error)
+  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":577
+  /* "View.MemoryView":575
  * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
@@ -9721,15 +9543,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":584
+/* "View.MemoryView":582
  * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
  * 
  */
 
@@ -9751,29 +9573,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":585
+  /* "View.MemoryView":583
  *     @property
  *     def ndim(self):
  *         return self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 585, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":584
+  /* "View.MemoryView":582
  * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
  * 
  */
 
@@ -9784,15 +9606,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":588
+/* "View.MemoryView":586
  * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
  * 
  */
 
@@ -9814,29 +9636,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":589
+  /* "View.MemoryView":587
  *     @property
  *     def itemsize(self):
  *         return self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 589, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":588
+  /* "View.MemoryView":586
  * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
  * 
  */
 
@@ -9847,15 +9669,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":592
+/* "View.MemoryView":590
  * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
  * 
  */
 
@@ -9879,35 +9701,35 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":593
+  /* "View.MemoryView":591
  *     @property
  *     def nbytes(self):
  *         return self.size * self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 593, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 593, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 593, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":592
+  /* "View.MemoryView":590
  * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
  * 
  */
 
@@ -9920,15 +9742,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":596
+/* "View.MemoryView":594
  * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
@@ -9957,98 +9779,98 @@
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":597
+  /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   __pyx_t_1 = (__pyx_v_self->_size == Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":598
+    /* "View.MemoryView":596
  *     def size(self):
  *         if self._size is None:
  *             result = 1             # <<<<<<<<<<<<<<
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  */
     __Pyx_INCREF(__pyx_int_1);
     __pyx_v_result = __pyx_int_1;
 
-    /* "View.MemoryView":600
+    /* "View.MemoryView":598
  *             result = 1
  * 
  *             for length in self.view.shape[:self.view.ndim]:             # <<<<<<<<<<<<<<
  *                 result *= length
  * 
  */
     __pyx_t_4 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
     for (__pyx_t_5 = __pyx_v_self->view.shape; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
       __pyx_t_3 = __pyx_t_5;
-      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 600, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 598, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_6);
       __pyx_t_6 = 0;
 
-      /* "View.MemoryView":601
+      /* "View.MemoryView":599
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  *                 result *= length             # <<<<<<<<<<<<<<
  * 
  *             self._size = result
  */
-      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 601, __pyx_L1_error)
+      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 599, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_6);
       __pyx_t_6 = 0;
     }
 
-    /* "View.MemoryView":603
+    /* "View.MemoryView":601
  *                 result *= length
  * 
  *             self._size = result             # <<<<<<<<<<<<<<
  * 
  *         return self._size
  */
     __Pyx_INCREF(__pyx_v_result);
     __Pyx_GIVEREF(__pyx_v_result);
     __Pyx_GOTREF(__pyx_v_self->_size);
     __Pyx_DECREF(__pyx_v_self->_size);
     __pyx_v_self->_size = __pyx_v_result;
 
-    /* "View.MemoryView":597
+    /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   }
 
-  /* "View.MemoryView":605
+  /* "View.MemoryView":603
  *             self._size = result
  * 
  *         return self._size             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_size);
   __pyx_r = __pyx_v_self->_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":596
+  /* "View.MemoryView":594
  * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
@@ -10061,15 +9883,15 @@
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":607
+/* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
@@ -10088,68 +9910,68 @@
 
 static Py_ssize_t __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(struct __pyx_memoryview_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":608
+  /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.ndim >= 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":609
+    /* "View.MemoryView":607
  *     def __len__(self):
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]             # <<<<<<<<<<<<<<
  * 
  *         return 0
  */
     __pyx_r = (__pyx_v_self->view.shape[0]);
     goto __pyx_L0;
 
-    /* "View.MemoryView":608
+    /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   }
 
-  /* "View.MemoryView":611
+  /* "View.MemoryView":609
  *             return self.view.shape[0]
  * 
  *         return 0             # <<<<<<<<<<<<<<
  * 
  *     def __repr__(self):
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":607
+  /* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":613
+/* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -10173,64 +9995,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":614
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":615
+  /* "View.MemoryView":613
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))             # <<<<<<<<<<<<<<
  * 
  *     def __str__(self):
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 615, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 613, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "View.MemoryView":614
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":613
+  /* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -10243,15 +10065,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":617
+/* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -10274,43 +10096,43 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__str__", 0);
 
-  /* "View.MemoryView":618
+  /* "View.MemoryView":616
  * 
  *     def __str__(self):
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":617
+  /* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -10322,15 +10144,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":621
+/* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10355,39 +10177,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_c_contig", 0);
 
-  /* "View.MemoryView":624
+  /* "View.MemoryView":622
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 624, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 622, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":625
+  /* "View.MemoryView":623
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def is_f_contig(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 625, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":621
+  /* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10398,15 +10220,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":627
+/* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10431,39 +10253,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_f_contig", 0);
 
-  /* "View.MemoryView":630
+  /* "View.MemoryView":628
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 630, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 628, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":631
+  /* "View.MemoryView":629
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def copy(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 631, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 629, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":627
+  /* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10474,15 +10296,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":633
+/* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -10507,57 +10329,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy", 0);
 
-  /* "View.MemoryView":635
+  /* "View.MemoryView":633
  *     def copy(self):
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &mslice)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_F_CONTIGUOUS));
 
-  /* "View.MemoryView":637
+  /* "View.MemoryView":635
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  * 
  *         slice_copy(self, &mslice)             # <<<<<<<<<<<<<<
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,
  *                                    self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_mslice));
 
-  /* "View.MemoryView":638
+  /* "View.MemoryView":636
  * 
  *         slice_copy(self, &mslice)
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                    self.view.itemsize,
  *                                    flags|PyBUF_C_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 638, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 636, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":643
+  /* "View.MemoryView":641
  *                                    self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &mslice)             # <<<<<<<<<<<<<<
  * 
  *     def copy_fortran(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 643, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":633
+  /* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -10568,15 +10390,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":645
+/* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -10602,57 +10424,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy_fortran", 0);
 
-  /* "View.MemoryView":647
+  /* "View.MemoryView":645
  *     def copy_fortran(self):
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &src)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_C_CONTIGUOUS));
 
-  /* "View.MemoryView":649
+  /* "View.MemoryView":647
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  * 
  *         slice_copy(self, &src)             # <<<<<<<<<<<<<<
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,
  *                                 self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_src));
 
-  /* "View.MemoryView":650
+  /* "View.MemoryView":648
  * 
  *         slice_copy(self, &src)
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                 self.view.itemsize,
  *                                 flags|PyBUF_F_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 650, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 648, __pyx_L1_error)
   __pyx_v_dst = __pyx_t_1;
 
-  /* "View.MemoryView":655
+  /* "View.MemoryView":653
  *                                 self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &dst)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 655, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":645
+  /* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -10776,15 +10598,15 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":659
+/* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10796,64 +10618,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_cwrapper", 0);
 
-  /* "View.MemoryView":660
+  /* "View.MemoryView":658
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)             # <<<<<<<<<<<<<<
  *     result.typeinfo = typeinfo
  *     return result
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_o);
   __Pyx_GIVEREF(__pyx_v_o);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_o);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryview_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":661
+  /* "View.MemoryView":659
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo             # <<<<<<<<<<<<<<
  *     return result
  * 
  */
   __pyx_v_result->typeinfo = __pyx_v_typeinfo;
 
-  /* "View.MemoryView":662
+  /* "View.MemoryView":660
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_check')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":659
+  /* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10867,54 +10689,54 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":665
+/* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *__pyx_v_o) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("memoryview_check", 0);
 
-  /* "View.MemoryView":666
+  /* "View.MemoryView":664
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):
  *     return isinstance(o, memoryview)             # <<<<<<<<<<<<<<
  * 
  * cdef tuple _unellipsify(object index, int ndim):
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_o, __pyx_memoryview_type); 
   __pyx_r = __pyx_t_1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":665
+  /* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":668
+/* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
@@ -10940,243 +10762,243 @@
   int __pyx_t_10;
   PyObject *__pyx_t_11 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_unellipsify", 0);
 
-  /* "View.MemoryView":673
+  /* "View.MemoryView":671
  *     full slices.
  *     """
  *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
  *         tup = (index,)
  *     else:
  */
   __pyx_t_1 = PyTuple_Check(__pyx_v_index); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":674
+    /* "View.MemoryView":672
  *     """
  *     if not isinstance(index, tuple):
  *         tup = (index,)             # <<<<<<<<<<<<<<
  *     else:
  *         tup = index
  */
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 674, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 672, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_index);
     __Pyx_GIVEREF(__pyx_v_index);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_index);
     __pyx_v_tup = __pyx_t_3;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":673
+    /* "View.MemoryView":671
  *     full slices.
  *     """
  *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
  *         tup = (index,)
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":676
+  /* "View.MemoryView":674
  *         tup = (index,)
  *     else:
  *         tup = index             # <<<<<<<<<<<<<<
  * 
  *     result = []
  */
   /*else*/ {
     __Pyx_INCREF(__pyx_v_index);
     __pyx_v_tup = __pyx_v_index;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":678
+  /* "View.MemoryView":676
  *         tup = index
  * 
  *     result = []             # <<<<<<<<<<<<<<
  *     have_slices = False
  *     seen_ellipsis = False
  */
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 678, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 676, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_v_result = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":679
+  /* "View.MemoryView":677
  * 
  *     result = []
  *     have_slices = False             # <<<<<<<<<<<<<<
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  */
   __pyx_v_have_slices = 0;
 
-  /* "View.MemoryView":680
+  /* "View.MemoryView":678
  *     result = []
  *     have_slices = False
  *     seen_ellipsis = False             # <<<<<<<<<<<<<<
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  */
   __pyx_v_seen_ellipsis = 0;
 
-  /* "View.MemoryView":681
+  /* "View.MemoryView":679
  *     have_slices = False
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   __Pyx_INCREF(__pyx_int_0);
   __pyx_t_3 = __pyx_int_0;
   if (likely(PyList_CheckExact(__pyx_v_tup)) || PyTuple_CheckExact(__pyx_v_tup)) {
     __pyx_t_4 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
     __pyx_t_6 = NULL;
   } else {
-    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 681, __pyx_L1_error)
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 679, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 681, __pyx_L1_error)
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 679, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_6)) {
       if (likely(PyList_CheckExact(__pyx_t_4))) {
         if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
     } else {
       __pyx_t_7 = __pyx_t_6(__pyx_t_4);
       if (unlikely(!__pyx_t_7)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 681, __pyx_L1_error)
+          else __PYX_ERR(1, 679, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_7);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
     __pyx_t_7 = 0;
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_3);
-    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 681, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_3);
     __pyx_t_3 = __pyx_t_7;
     __pyx_t_7 = 0;
 
-    /* "View.MemoryView":682
+    /* "View.MemoryView":680
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
     __pyx_t_2 = (__pyx_v_item == __pyx_builtin_Ellipsis);
     __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":683
+      /* "View.MemoryView":681
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
       __pyx_t_1 = ((!(__pyx_v_seen_ellipsis != 0)) != 0);
       if (__pyx_t_1) {
 
-        /* "View.MemoryView":684
+        /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 684, __pyx_L1_error)
-        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 684, __pyx_L1_error)
+        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
+        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 682, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         { Py_ssize_t __pyx_temp;
           for (__pyx_temp=0; __pyx_temp < ((__pyx_v_ndim - __pyx_t_8) + 1); __pyx_temp++) {
             __Pyx_INCREF(__pyx_slice__16);
             __Pyx_GIVEREF(__pyx_slice__16);
             PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__16);
           }
         }
-        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 684, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-        /* "View.MemoryView":685
+        /* "View.MemoryView":683
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True             # <<<<<<<<<<<<<<
  *             else:
  *                 result.append(slice(None))
  */
         __pyx_v_seen_ellipsis = 1;
 
-        /* "View.MemoryView":683
+        /* "View.MemoryView":681
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":687
+      /* "View.MemoryView":685
  *                 seen_ellipsis = True
  *             else:
  *                 result.append(slice(None))             # <<<<<<<<<<<<<<
  *             have_slices = True
  *         else:
  */
       /*else*/ {
-        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__16); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 687, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__16); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 685, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":688
+      /* "View.MemoryView":686
  *             else:
  *                 result.append(slice(None))
  *             have_slices = True             # <<<<<<<<<<<<<<
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  */
       __pyx_v_have_slices = 1;
 
-      /* "View.MemoryView":682
+      /* "View.MemoryView":680
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":690
+    /* "View.MemoryView":688
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  */
     /*else*/ {
@@ -11188,40 +11010,40 @@
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = ((!(PyIndex_Check(__pyx_v_item) != 0)) != 0);
       __pyx_t_1 = __pyx_t_10;
       __pyx_L9_bool_binop_done:;
       if (unlikely(__pyx_t_1)) {
 
-        /* "View.MemoryView":691
+        /* "View.MemoryView":689
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  *                 raise TypeError("Cannot index with type '%s'" % type(item))             # <<<<<<<<<<<<<<
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  */
-        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 691, __pyx_L1_error)
+        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 689, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 691, __pyx_L1_error)
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 689, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_Raise(__pyx_t_11, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        __PYX_ERR(1, 691, __pyx_L1_error)
+        __PYX_ERR(1, 689, __pyx_L1_error)
 
-        /* "View.MemoryView":690
+        /* "View.MemoryView":688
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  */
       }
 
-      /* "View.MemoryView":693
+      /* "View.MemoryView":691
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  *             have_slices = have_slices or isinstance(item, slice)             # <<<<<<<<<<<<<<
  *             result.append(item)
  * 
  */
       __pyx_t_10 = (__pyx_v_have_slices != 0);
@@ -11232,120 +11054,120 @@
       }
       __pyx_t_10 = PySlice_Check(__pyx_v_item); 
       __pyx_t_2 = (__pyx_t_10 != 0);
       __pyx_t_1 = __pyx_t_2;
       __pyx_L11_bool_binop_done:;
       __pyx_v_have_slices = __pyx_t_1;
 
-      /* "View.MemoryView":694
+      /* "View.MemoryView":692
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  *             result.append(item)             # <<<<<<<<<<<<<<
  * 
  *     nslices = ndim - len(result)
  */
-      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 694, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 692, __pyx_L1_error)
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":681
+    /* "View.MemoryView":679
  *     have_slices = False
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":696
+  /* "View.MemoryView":694
  *             result.append(item)
  * 
  *     nslices = ndim - len(result)             # <<<<<<<<<<<<<<
  *     if nslices:
  *         result.extend([slice(None)] * nslices)
  */
-  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 696, __pyx_L1_error)
+  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 694, __pyx_L1_error)
   __pyx_v_nslices = (__pyx_v_ndim - __pyx_t_5);
 
-  /* "View.MemoryView":697
+  /* "View.MemoryView":695
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
  * 
  */
   __pyx_t_1 = (__pyx_v_nslices != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":698
+    /* "View.MemoryView":696
  *     nslices = ndim - len(result)
  *     if nslices:
  *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
  * 
  *     return have_slices or nslices, tuple(result)
  */
-    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 698, __pyx_L1_error)
+    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     { Py_ssize_t __pyx_temp;
       for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
         __Pyx_INCREF(__pyx_slice__16);
         __Pyx_GIVEREF(__pyx_slice__16);
         PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__16);
       }
     }
-    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 698, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 696, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "View.MemoryView":697
+    /* "View.MemoryView":695
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
  * 
  */
   }
 
-  /* "View.MemoryView":700
+  /* "View.MemoryView":698
  *         result.extend([slice(None)] * nslices)
  * 
  *     return have_slices or nslices, tuple(result)             # <<<<<<<<<<<<<<
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  */
   __Pyx_XDECREF(__pyx_r);
   if (!__pyx_v_have_slices) {
   } else {
-    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 700, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_3 = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L14_bool_binop_done;
   }
-  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 700, __pyx_L1_error)
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_3 = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_L14_bool_binop_done:;
-  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 700, __pyx_L1_error)
+  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 700, __pyx_L1_error)
+  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_4);
   PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_4);
   __pyx_t_3 = 0;
   __pyx_t_4 = 0;
   __pyx_r = ((PyObject*)__pyx_t_11);
   __pyx_t_11 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":668
+  /* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
@@ -11363,15 +11185,15 @@
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":702
+/* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
@@ -11385,60 +11207,60 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assert_direct_dimensions", 0);
 
-  /* "View.MemoryView":703
+  /* "View.MemoryView":701
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")
  */
   __pyx_t_2 = (__pyx_v_suboffsets + __pyx_v_ndim);
   for (__pyx_t_3 = __pyx_v_suboffsets; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
     __pyx_t_1 = __pyx_t_3;
     __pyx_v_suboffset = (__pyx_t_1[0]);
 
-    /* "View.MemoryView":704
+    /* "View.MemoryView":702
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
  * 
  */
     __pyx_t_4 = ((__pyx_v_suboffset >= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":705
+      /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 705, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 703, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(1, 705, __pyx_L1_error)
+      __PYX_ERR(1, 703, __pyx_L1_error)
 
-      /* "View.MemoryView":704
+      /* "View.MemoryView":702
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":702
+  /* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
@@ -11451,15 +11273,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":712
+/* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -11495,529 +11317,529 @@
   int __pyx_t_11;
   Py_ssize_t __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memview_slice", 0);
 
-  /* "View.MemoryView":713
+  /* "View.MemoryView":711
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim             # <<<<<<<<<<<<<<
  *     cdef bint negative_step
  *     cdef __Pyx_memviewslice src, dst
  */
   __pyx_v_new_ndim = 0;
   __pyx_v_suboffset_dim = -1;
 
-  /* "View.MemoryView":720
+  /* "View.MemoryView":718
  * 
  * 
  *     memset(&dst, 0, sizeof(dst))             # <<<<<<<<<<<<<<
  * 
  *     cdef _memoryviewslice memviewsliceobj
  */
   (void)(memset((&__pyx_v_dst), 0, (sizeof(__pyx_v_dst))));
 
-  /* "View.MemoryView":724
+  /* "View.MemoryView":722
  *     cdef _memoryviewslice memviewsliceobj
  * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(1, 724, __pyx_L1_error)
+      __PYX_ERR(1, 722, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "View.MemoryView":726
+  /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":727
+    /* "View.MemoryView":725
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview             # <<<<<<<<<<<<<<
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 727, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 725, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":728
+    /* "View.MemoryView":726
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, &src)
  */
     __pyx_v_p_src = (&__pyx_v_memviewsliceobj->from_slice);
 
-    /* "View.MemoryView":726
+    /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":730
+  /* "View.MemoryView":728
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  *         slice_copy(memview, &src)             # <<<<<<<<<<<<<<
  *         p_src = &src
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_src));
 
-    /* "View.MemoryView":731
+    /* "View.MemoryView":729
  *     else:
  *         slice_copy(memview, &src)
  *         p_src = &src             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_p_src = (&__pyx_v_src);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":737
+  /* "View.MemoryView":735
  * 
  * 
  *     dst.memview = p_src.memview             # <<<<<<<<<<<<<<
  *     dst.data = p_src.data
  * 
  */
   __pyx_t_4 = __pyx_v_p_src->memview;
   __pyx_v_dst.memview = __pyx_t_4;
 
-  /* "View.MemoryView":738
+  /* "View.MemoryView":736
  * 
  *     dst.memview = p_src.memview
  *     dst.data = p_src.data             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_5 = __pyx_v_p_src->data;
   __pyx_v_dst.data = __pyx_t_5;
 
-  /* "View.MemoryView":743
+  /* "View.MemoryView":741
  * 
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst             # <<<<<<<<<<<<<<
  *     cdef int *p_suboffset_dim = &suboffset_dim
  *     cdef Py_ssize_t start, stop, step
  */
   __pyx_v_p_dst = (&__pyx_v_dst);
 
-  /* "View.MemoryView":744
+  /* "View.MemoryView":742
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst
  *     cdef int *p_suboffset_dim = &suboffset_dim             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t start, stop, step
  *     cdef bint have_start, have_stop, have_step
  */
   __pyx_v_p_suboffset_dim = (&__pyx_v_suboffset_dim);
 
-  /* "View.MemoryView":748
+  /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   __pyx_t_6 = 0;
   if (likely(PyList_CheckExact(__pyx_v_indices)) || PyTuple_CheckExact(__pyx_v_indices)) {
     __pyx_t_3 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
     __pyx_t_8 = NULL;
   } else {
-    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 748, __pyx_L1_error)
+    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 746, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 748, __pyx_L1_error)
+    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 746, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_8)) {
       if (likely(PyList_CheckExact(__pyx_t_3))) {
         if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       } else {
         if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       }
     } else {
       __pyx_t_9 = __pyx_t_8(__pyx_t_3);
       if (unlikely(!__pyx_t_9)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 748, __pyx_L1_error)
+          else __PYX_ERR(1, 746, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_9);
     }
     __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_9);
     __pyx_t_9 = 0;
     __pyx_v_dim = __pyx_t_6;
     __pyx_t_6 = (__pyx_t_6 + 1);
 
-    /* "View.MemoryView":749
+    /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
     __pyx_t_2 = (PyIndex_Check(__pyx_v_index) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":753
+      /* "View.MemoryView":751
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  *                 index, 0, 0, # start, stop, step             # <<<<<<<<<<<<<<
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  */
-      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 753, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 751, __pyx_L1_error)
 
-      /* "View.MemoryView":750
+      /* "View.MemoryView":748
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 750, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 748, __pyx_L1_error)
 
-      /* "View.MemoryView":749
+      /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":756
+    /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
     __pyx_t_2 = (__pyx_v_index == Py_None);
     __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":757
+      /* "View.MemoryView":755
  *                 False)
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1             # <<<<<<<<<<<<<<
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  */
       (__pyx_v_p_dst->shape[__pyx_v_new_ndim]) = 1;
 
-      /* "View.MemoryView":758
+      /* "View.MemoryView":756
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0             # <<<<<<<<<<<<<<
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1
  */
       (__pyx_v_p_dst->strides[__pyx_v_new_ndim]) = 0;
 
-      /* "View.MemoryView":759
+      /* "View.MemoryView":757
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1             # <<<<<<<<<<<<<<
  *             new_ndim += 1
  *         else:
  */
       (__pyx_v_p_dst->suboffsets[__pyx_v_new_ndim]) = -1L;
 
-      /* "View.MemoryView":760
+      /* "View.MemoryView":758
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  *         else:
  *             start = index.start or 0
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
 
-      /* "View.MemoryView":756
+      /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":762
+    /* "View.MemoryView":760
  *             new_ndim += 1
  *         else:
  *             start = index.start or 0             # <<<<<<<<<<<<<<
  *             stop = index.stop or 0
  *             step = index.step or 0
  */
     /*else*/ {
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 760, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 760, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 760, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L7_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L7_bool_binop_done:;
       __pyx_v_start = __pyx_t_10;
 
-      /* "View.MemoryView":763
+      /* "View.MemoryView":761
  *         else:
  *             start = index.start or 0
  *             stop = index.stop or 0             # <<<<<<<<<<<<<<
  *             step = index.step or 0
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 763, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 761, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 763, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 761, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 763, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 761, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L9_bool_binop_done:;
       __pyx_v_stop = __pyx_t_10;
 
-      /* "View.MemoryView":764
+      /* "View.MemoryView":762
  *             start = index.start or 0
  *             stop = index.stop or 0
  *             step = index.step or 0             # <<<<<<<<<<<<<<
  * 
  *             have_start = index.start is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 764, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 762, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 764, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 762, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 764, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L11_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L11_bool_binop_done:;
       __pyx_v_step = __pyx_t_10;
 
-      /* "View.MemoryView":766
+      /* "View.MemoryView":764
  *             step = index.step or 0
  * 
  *             have_start = index.start is not None             # <<<<<<<<<<<<<<
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 766, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 764, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_start = __pyx_t_1;
 
-      /* "View.MemoryView":767
+      /* "View.MemoryView":765
  * 
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None             # <<<<<<<<<<<<<<
  *             have_step = index.step is not None
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 767, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 765, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_stop = __pyx_t_1;
 
-      /* "View.MemoryView":768
+      /* "View.MemoryView":766
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None             # <<<<<<<<<<<<<<
  * 
  *             slice_memviewslice(
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 768, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 766, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_step = __pyx_t_1;
 
-      /* "View.MemoryView":770
+      /* "View.MemoryView":768
  *             have_step = index.step is not None
  * 
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 770, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 768, __pyx_L1_error)
 
-      /* "View.MemoryView":776
+      /* "View.MemoryView":774
  *                 have_start, have_stop, have_step,
  *                 True)
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":748
+    /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":778
+  /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":780
+    /* "View.MemoryView":778
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_dtype_func,
  *                                     memview.dtype_is_object)
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 780, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 778, __pyx_L1_error) }
 
-    /* "View.MemoryView":781
+    /* "View.MemoryView":779
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  *     else:
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 781, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 779, __pyx_L1_error) }
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 779, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 777, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 779, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 777, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":778
+    /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   }
 
-  /* "View.MemoryView":784
+  /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":785
+    /* "View.MemoryView":783
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,
  *                                     memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 784, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 782, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
 
-    /* "View.MemoryView":784
+    /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 784, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 782, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":712
+  /* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -12031,15 +11853,15 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_memviewsliceobj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":809
+/* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -12050,95 +11872,95 @@
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":829
+  /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
   __pyx_t_1 = ((!(__pyx_v_is_slice != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":831
+    /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     __pyx_t_1 = ((__pyx_v_start < 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":832
+      /* "View.MemoryView":830
  * 
  *         if start < 0:
  *             start += shape             # <<<<<<<<<<<<<<
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  */
       __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-      /* "View.MemoryView":831
+      /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     }
 
-    /* "View.MemoryView":833
+    /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     __pyx_t_1 = (0 <= __pyx_v_start);
     if (__pyx_t_1) {
       __pyx_t_1 = (__pyx_v_start < __pyx_v_shape);
     }
     __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":834
+      /* "View.MemoryView":832
  *             start += shape
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
  *     else:
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 834, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 832, __pyx_L1_error)
 
-      /* "View.MemoryView":833
+      /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     }
 
-    /* "View.MemoryView":829
+    /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":837
+  /* "View.MemoryView":835
  *     else:
  * 
  *         negative_step = have_step != 0 and step < 0             # <<<<<<<<<<<<<<
  * 
  *         if have_step and step == 0:
  */
   /*else*/ {
@@ -12149,15 +11971,15 @@
       goto __pyx_L6_bool_binop_done;
     }
     __pyx_t_1 = ((__pyx_v_step < 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L6_bool_binop_done:;
     __pyx_v_negative_step = __pyx_t_2;
 
-    /* "View.MemoryView":839
+    /* "View.MemoryView":837
  *         negative_step = have_step != 0 and step < 0
  * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
     __pyx_t_1 = (__pyx_v_have_step != 0);
@@ -12167,639 +11989,639 @@
       goto __pyx_L9_bool_binop_done;
     }
     __pyx_t_1 = ((__pyx_v_step == 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L9_bool_binop_done:;
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":840
+      /* "View.MemoryView":838
  * 
  *         if have_step and step == 0:
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 840, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 838, __pyx_L1_error)
 
-      /* "View.MemoryView":839
+      /* "View.MemoryView":837
  *         negative_step = have_step != 0 and step < 0
  * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
     }
 
-    /* "View.MemoryView":843
+    /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
     __pyx_t_2 = (__pyx_v_have_start != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":844
+      /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
       __pyx_t_2 = ((__pyx_v_start < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":845
+        /* "View.MemoryView":843
  *         if have_start:
  *             if start < 0:
  *                 start += shape             # <<<<<<<<<<<<<<
  *                 if start < 0:
  *                     start = 0
  */
         __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-        /* "View.MemoryView":846
+        /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         __pyx_t_2 = ((__pyx_v_start < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":847
+          /* "View.MemoryView":845
  *                 start += shape
  *                 if start < 0:
  *                     start = 0             # <<<<<<<<<<<<<<
  *             elif start >= shape:
  *                 if negative_step:
  */
           __pyx_v_start = 0;
 
-          /* "View.MemoryView":846
+          /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         }
 
-        /* "View.MemoryView":844
+        /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
         goto __pyx_L12;
       }
 
-      /* "View.MemoryView":848
+      /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       __pyx_t_2 = ((__pyx_v_start >= __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":849
+        /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
         __pyx_t_2 = (__pyx_v_negative_step != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":850
+          /* "View.MemoryView":848
  *             elif start >= shape:
  *                 if negative_step:
  *                     start = shape - 1             # <<<<<<<<<<<<<<
  *                 else:
  *                     start = shape
  */
           __pyx_v_start = (__pyx_v_shape - 1);
 
-          /* "View.MemoryView":849
+          /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
           goto __pyx_L14;
         }
 
-        /* "View.MemoryView":852
+        /* "View.MemoryView":850
  *                     start = shape - 1
  *                 else:
  *                     start = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         /*else*/ {
           __pyx_v_start = __pyx_v_shape;
         }
         __pyx_L14:;
 
-        /* "View.MemoryView":848
+        /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       }
       __pyx_L12:;
 
-      /* "View.MemoryView":843
+      /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
       goto __pyx_L11;
     }
 
-    /* "View.MemoryView":854
+    /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
     /*else*/ {
       __pyx_t_2 = (__pyx_v_negative_step != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":855
+        /* "View.MemoryView":853
  *         else:
  *             if negative_step:
  *                 start = shape - 1             # <<<<<<<<<<<<<<
  *             else:
  *                 start = 0
  */
         __pyx_v_start = (__pyx_v_shape - 1);
 
-        /* "View.MemoryView":854
+        /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
         goto __pyx_L15;
       }
 
-      /* "View.MemoryView":857
+      /* "View.MemoryView":855
  *                 start = shape - 1
  *             else:
  *                 start = 0             # <<<<<<<<<<<<<<
  * 
  *         if have_stop:
  */
       /*else*/ {
         __pyx_v_start = 0;
       }
       __pyx_L15:;
     }
     __pyx_L11:;
 
-    /* "View.MemoryView":859
+    /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
     __pyx_t_2 = (__pyx_v_have_stop != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":860
+      /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
       __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":861
+        /* "View.MemoryView":859
  *         if have_stop:
  *             if stop < 0:
  *                 stop += shape             # <<<<<<<<<<<<<<
  *                 if stop < 0:
  *                     stop = 0
  */
         __pyx_v_stop = (__pyx_v_stop + __pyx_v_shape);
 
-        /* "View.MemoryView":862
+        /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":863
+          /* "View.MemoryView":861
  *                 stop += shape
  *                 if stop < 0:
  *                     stop = 0             # <<<<<<<<<<<<<<
  *             elif stop > shape:
  *                 stop = shape
  */
           __pyx_v_stop = 0;
 
-          /* "View.MemoryView":862
+          /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         }
 
-        /* "View.MemoryView":860
+        /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
         goto __pyx_L17;
       }
 
-      /* "View.MemoryView":864
+      /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       __pyx_t_2 = ((__pyx_v_stop > __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":865
+        /* "View.MemoryView":863
  *                     stop = 0
  *             elif stop > shape:
  *                 stop = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         __pyx_v_stop = __pyx_v_shape;
 
-        /* "View.MemoryView":864
+        /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       }
       __pyx_L17:;
 
-      /* "View.MemoryView":859
+      /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
       goto __pyx_L16;
     }
 
-    /* "View.MemoryView":867
+    /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
     /*else*/ {
       __pyx_t_2 = (__pyx_v_negative_step != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":868
+        /* "View.MemoryView":866
  *         else:
  *             if negative_step:
  *                 stop = -1             # <<<<<<<<<<<<<<
  *             else:
  *                 stop = shape
  */
         __pyx_v_stop = -1L;
 
-        /* "View.MemoryView":867
+        /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
         goto __pyx_L19;
       }
 
-      /* "View.MemoryView":870
+      /* "View.MemoryView":868
  *                 stop = -1
  *             else:
  *                 stop = shape             # <<<<<<<<<<<<<<
  * 
  *         if not have_step:
  */
       /*else*/ {
         __pyx_v_stop = __pyx_v_shape;
       }
       __pyx_L19:;
     }
     __pyx_L16:;
 
-    /* "View.MemoryView":872
+    /* "View.MemoryView":870
  *                 stop = shape
  * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
  * 
  */
     __pyx_t_2 = ((!(__pyx_v_have_step != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":873
+      /* "View.MemoryView":871
  * 
  *         if not have_step:
  *             step = 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_step = 1;
 
-      /* "View.MemoryView":872
+      /* "View.MemoryView":870
  *                 stop = shape
  * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
  * 
  */
     }
 
-    /* "View.MemoryView":877
+    /* "View.MemoryView":875
  * 
  *         with cython.cdivision(True):
  *             new_shape = (stop - start) // step             # <<<<<<<<<<<<<<
  * 
  *             if (stop - start) - step * new_shape:
  */
     __pyx_v_new_shape = ((__pyx_v_stop - __pyx_v_start) / __pyx_v_step);
 
-    /* "View.MemoryView":879
+    /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     __pyx_t_2 = (((__pyx_v_stop - __pyx_v_start) - (__pyx_v_step * __pyx_v_new_shape)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":880
+      /* "View.MemoryView":878
  * 
  *             if (stop - start) - step * new_shape:
  *                 new_shape += 1             # <<<<<<<<<<<<<<
  * 
  *         if new_shape < 0:
  */
       __pyx_v_new_shape = (__pyx_v_new_shape + 1);
 
-      /* "View.MemoryView":879
+      /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     }
 
-    /* "View.MemoryView":882
+    /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     __pyx_t_2 = ((__pyx_v_new_shape < 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":883
+      /* "View.MemoryView":881
  * 
  *         if new_shape < 0:
  *             new_shape = 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_new_shape = 0;
 
-      /* "View.MemoryView":882
+      /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     }
 
-    /* "View.MemoryView":886
+    /* "View.MemoryView":884
  * 
  * 
  *         dst.strides[new_ndim] = stride * step             # <<<<<<<<<<<<<<
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset
  */
     (__pyx_v_dst->strides[__pyx_v_new_ndim]) = (__pyx_v_stride * __pyx_v_step);
 
-    /* "View.MemoryView":887
+    /* "View.MemoryView":885
  * 
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape             # <<<<<<<<<<<<<<
  *         dst.suboffsets[new_ndim] = suboffset
  * 
  */
     (__pyx_v_dst->shape[__pyx_v_new_ndim]) = __pyx_v_new_shape;
 
-    /* "View.MemoryView":888
+    /* "View.MemoryView":886
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_dst->suboffsets[__pyx_v_new_ndim]) = __pyx_v_suboffset;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":891
+  /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
   __pyx_t_2 = (((__pyx_v_suboffset_dim[0]) < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":892
+    /* "View.MemoryView":890
  * 
  *     if suboffset_dim[0] < 0:
  *         dst.data += start * stride             # <<<<<<<<<<<<<<
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  */
     __pyx_v_dst->data = (__pyx_v_dst->data + (__pyx_v_start * __pyx_v_stride));
 
-    /* "View.MemoryView":891
+    /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
     goto __pyx_L23;
   }
 
-  /* "View.MemoryView":894
+  /* "View.MemoryView":892
  *         dst.data += start * stride
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride             # <<<<<<<<<<<<<<
  * 
  *     if suboffset >= 0:
  */
   /*else*/ {
     __pyx_t_3 = (__pyx_v_suboffset_dim[0]);
     (__pyx_v_dst->suboffsets[__pyx_t_3]) = ((__pyx_v_dst->suboffsets[__pyx_t_3]) + (__pyx_v_start * __pyx_v_stride));
   }
   __pyx_L23:;
 
-  /* "View.MemoryView":896
+  /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":897
+    /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
     __pyx_t_2 = ((!(__pyx_v_is_slice != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":898
+      /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
       __pyx_t_2 = ((__pyx_v_new_ndim == 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":899
+        /* "View.MemoryView":897
  *         if not is_slice:
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  */
         __pyx_v_dst->data = ((((char **)__pyx_v_dst->data)[0]) + __pyx_v_suboffset);
 
-        /* "View.MemoryView":898
+        /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
         goto __pyx_L26;
       }
 
-      /* "View.MemoryView":901
+      /* "View.MemoryView":899
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "             # <<<<<<<<<<<<<<
  *                                      "must be indexed and not sliced", dim)
  *         else:
  */
       /*else*/ {
 
-        /* "View.MemoryView":902
+        /* "View.MemoryView":900
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  *                                      "must be indexed and not sliced", dim)             # <<<<<<<<<<<<<<
  *         else:
  *             suboffset_dim[0] = new_ndim
  */
-        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 901, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 899, __pyx_L1_error)
       }
       __pyx_L26:;
 
-      /* "View.MemoryView":897
+      /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
       goto __pyx_L25;
     }
 
-    /* "View.MemoryView":904
+    /* "View.MemoryView":902
  *                                      "must be indexed and not sliced", dim)
  *         else:
  *             suboffset_dim[0] = new_ndim             # <<<<<<<<<<<<<<
  * 
  *     return 0
  */
     /*else*/ {
       (__pyx_v_suboffset_dim[0]) = __pyx_v_new_ndim;
     }
     __pyx_L25:;
 
-    /* "View.MemoryView":896
+    /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   }
 
-  /* "View.MemoryView":906
+  /* "View.MemoryView":904
  *             suboffset_dim[0] = new_ndim
  * 
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":809
+  /* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -12815,15 +12637,15 @@
     #endif
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":912
+/* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -12840,280 +12662,280 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("pybuffer_index", 0);
 
-  /* "View.MemoryView":914
+  /* "View.MemoryView":912
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t itemsize = view.itemsize
  *     cdef char *resultp
  */
   __pyx_v_suboffset = -1L;
 
-  /* "View.MemoryView":915
+  /* "View.MemoryView":913
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  *     cdef Py_ssize_t itemsize = view.itemsize             # <<<<<<<<<<<<<<
  *     cdef char *resultp
  * 
  */
   __pyx_t_1 = __pyx_v_view->itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":918
+  /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
   __pyx_t_2 = ((__pyx_v_view->ndim == 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":919
+    /* "View.MemoryView":917
  * 
  *     if view.ndim == 0:
  *         shape = view.len / itemsize             # <<<<<<<<<<<<<<
  *         stride = itemsize
  *     else:
  */
     if (unlikely(__pyx_v_itemsize == 0)) {
       PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 919, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
     else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
       PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(1, 919, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
     __pyx_v_shape = __Pyx_div_Py_ssize_t(__pyx_v_view->len, __pyx_v_itemsize);
 
-    /* "View.MemoryView":920
+    /* "View.MemoryView":918
  *     if view.ndim == 0:
  *         shape = view.len / itemsize
  *         stride = itemsize             # <<<<<<<<<<<<<<
  *     else:
  *         shape = view.shape[dim]
  */
     __pyx_v_stride = __pyx_v_itemsize;
 
-    /* "View.MemoryView":918
+    /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":922
+  /* "View.MemoryView":920
  *         stride = itemsize
  *     else:
  *         shape = view.shape[dim]             # <<<<<<<<<<<<<<
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  */
   /*else*/ {
     __pyx_v_shape = (__pyx_v_view->shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":923
+    /* "View.MemoryView":921
  *     else:
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]             # <<<<<<<<<<<<<<
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]
  */
     __pyx_v_stride = (__pyx_v_view->strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":924
+    /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     __pyx_t_2 = ((__pyx_v_view->suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":925
+      /* "View.MemoryView":923
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]             # <<<<<<<<<<<<<<
  * 
  *     if index < 0:
  */
       __pyx_v_suboffset = (__pyx_v_view->suboffsets[__pyx_v_dim]);
 
-      /* "View.MemoryView":924
+      /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":927
+  /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   __pyx_t_2 = ((__pyx_v_index < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":928
+    /* "View.MemoryView":926
  * 
  *     if index < 0:
  *         index += view.shape[dim]             # <<<<<<<<<<<<<<
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  */
     __pyx_v_index = (__pyx_v_index + (__pyx_v_view->shape[__pyx_v_dim]));
 
-    /* "View.MemoryView":929
+    /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     __pyx_t_2 = ((__pyx_v_index < 0) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":930
+      /* "View.MemoryView":928
  *         index += view.shape[dim]
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     if index >= shape:
  */
-      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 930, __pyx_L1_error)
+      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 930, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 930, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(1, 930, __pyx_L1_error)
+      __PYX_ERR(1, 928, __pyx_L1_error)
 
-      /* "View.MemoryView":929
+      /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     }
 
-    /* "View.MemoryView":927
+    /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   }
 
-  /* "View.MemoryView":932
+  /* "View.MemoryView":930
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   __pyx_t_2 = ((__pyx_v_index >= __pyx_v_shape) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":933
+    /* "View.MemoryView":931
  * 
  *     if index >= shape:
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     resultp = bufp + index * stride
  */
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 933, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 933, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 933, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 933, __pyx_L1_error)
+    __PYX_ERR(1, 931, __pyx_L1_error)
 
-    /* "View.MemoryView":932
+    /* "View.MemoryView":930
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   }
 
-  /* "View.MemoryView":935
+  /* "View.MemoryView":933
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     resultp = bufp + index * stride             # <<<<<<<<<<<<<<
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset
  */
   __pyx_v_resultp = (__pyx_v_bufp + (__pyx_v_index * __pyx_v_stride));
 
-  /* "View.MemoryView":936
+  /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":937
+    /* "View.MemoryView":935
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset             # <<<<<<<<<<<<<<
  * 
  *     return resultp
  */
     __pyx_v_resultp = ((((char **)__pyx_v_resultp)[0]) + __pyx_v_suboffset);
 
-    /* "View.MemoryView":936
+    /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   }
 
-  /* "View.MemoryView":939
+  /* "View.MemoryView":937
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  *     return resultp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_resultp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":912
+  /* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -13124,15 +12946,15 @@
   __Pyx_AddTraceback("View.MemoryView.pybuffer_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":945
+/* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
@@ -13152,90 +12974,90 @@
   int __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":946
+  /* "View.MemoryView":944
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:
  *     cdef int ndim = memslice.memview.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  */
   __pyx_t_1 = __pyx_v_memslice->memview->view.ndim;
   __pyx_v_ndim = __pyx_t_1;
 
-  /* "View.MemoryView":948
+  /* "View.MemoryView":946
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  *     cdef Py_ssize_t *shape = memslice.shape             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t *strides = memslice.strides
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->shape;
   __pyx_v_shape = __pyx_t_2;
 
-  /* "View.MemoryView":949
+  /* "View.MemoryView":947
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  *     cdef Py_ssize_t *strides = memslice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->strides;
   __pyx_v_strides = __pyx_t_2;
 
-  /* "View.MemoryView":953
+  /* "View.MemoryView":951
  * 
  *     cdef int i, j
  *     for i in range(ndim / 2):             # <<<<<<<<<<<<<<
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  */
   __pyx_t_3 = __Pyx_div_long(__pyx_v_ndim, 2);
   __pyx_t_4 = __pyx_t_3;
   for (__pyx_t_1 = 0; __pyx_t_1 < __pyx_t_4; __pyx_t_1+=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":954
+    /* "View.MemoryView":952
  *     cdef int i, j
  *     for i in range(ndim / 2):
  *         j = ndim - 1 - i             # <<<<<<<<<<<<<<
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]
  */
     __pyx_v_j = ((__pyx_v_ndim - 1) - __pyx_v_i);
 
-    /* "View.MemoryView":955
+    /* "View.MemoryView":953
  *     for i in range(ndim / 2):
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]             # <<<<<<<<<<<<<<
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  */
     __pyx_t_5 = (__pyx_v_strides[__pyx_v_j]);
     __pyx_t_6 = (__pyx_v_strides[__pyx_v_i]);
     (__pyx_v_strides[__pyx_v_i]) = __pyx_t_5;
     (__pyx_v_strides[__pyx_v_j]) = __pyx_t_6;
 
-    /* "View.MemoryView":956
+    /* "View.MemoryView":954
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]             # <<<<<<<<<<<<<<
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  */
     __pyx_t_6 = (__pyx_v_shape[__pyx_v_j]);
     __pyx_t_5 = (__pyx_v_shape[__pyx_v_i]);
     (__pyx_v_shape[__pyx_v_i]) = __pyx_t_6;
     (__pyx_v_shape[__pyx_v_j]) = __pyx_t_5;
 
-    /* "View.MemoryView":958
+    /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
     __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0) != 0);
@@ -13245,44 +13067,44 @@
       goto __pyx_L6_bool_binop_done;
     }
     __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0) != 0);
     __pyx_t_7 = __pyx_t_8;
     __pyx_L6_bool_binop_done:;
     if (__pyx_t_7) {
 
-      /* "View.MemoryView":959
+      /* "View.MemoryView":957
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
  * 
  *     return 1
  */
-      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 959, __pyx_L1_error)
+      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 957, __pyx_L1_error)
 
-      /* "View.MemoryView":958
+      /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":961
+  /* "View.MemoryView":959
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  *     return 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":945
+  /* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
@@ -13298,15 +13120,15 @@
     #endif
   }
   __pyx_r = 0;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":978
+/* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
@@ -13321,36 +13143,36 @@
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":979
+  /* "View.MemoryView":977
  * 
  *     def __dealloc__(self):
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
   __PYX_XDEC_MEMVIEW((&__pyx_v_self->from_slice), 1);
 
-  /* "View.MemoryView":978
+  /* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":981
+/* "View.MemoryView":979
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
@@ -13360,64 +13182,64 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":982
+  /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_object_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":983
+    /* "View.MemoryView":981
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)             # <<<<<<<<<<<<<<
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 983, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 981, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":982
+    /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   }
 
-  /* "View.MemoryView":985
+  /* "View.MemoryView":983
  *             return self.to_object_func(itemp)
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 985, __pyx_L1_error)
+    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 983, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":981
+  /* "View.MemoryView":979
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
@@ -13428,15 +13250,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":987
+/* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13447,58 +13269,58 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":988
+  /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_dtype_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":989
+    /* "View.MemoryView":987
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)             # <<<<<<<<<<<<<<
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)
  */
-    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 989, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 987, __pyx_L1_error)
 
-    /* "View.MemoryView":988
+    /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":991
+  /* "View.MemoryView":989
  *             self.to_dtype_func(itemp, value)
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 991, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 989, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":987
+  /* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13511,15 +13333,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":994
+/* "View.MemoryView":992
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
@@ -13537,27 +13359,27 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":995
+  /* "View.MemoryView":993
  *     @property
  *     def base(self):
  *         return self.from_object             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->from_object);
   __pyx_r = __pyx_v_self->from_object;
   goto __pyx_L0;
 
-  /* "View.MemoryView":994
+  /* "View.MemoryView":992
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
@@ -13677,15 +13499,15 @@
   __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1001
+/* "View.MemoryView":999
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
@@ -13705,351 +13527,351 @@
   Py_ssize_t *__pyx_t_8;
   Py_ssize_t __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_fromslice", 0);
 
-  /* "View.MemoryView":1009
+  /* "View.MemoryView":1007
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
   __pyx_t_1 = ((((PyObject *)__pyx_v_memviewslice.memview) == Py_None) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1010
+    /* "View.MemoryView":1008
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:
  *         return None             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1009
+    /* "View.MemoryView":1007
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
   }
 
-  /* "View.MemoryView":1015
+  /* "View.MemoryView":1013
  * 
  * 
  *     result = _memoryviewslice(None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     result.from_slice = memviewslice
  */
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1015, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1015, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(Py_None);
   PyTuple_SET_ITEM(__pyx_t_3, 0, Py_None);
   __Pyx_INCREF(__pyx_int_0);
   __Pyx_GIVEREF(__pyx_int_0);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_0);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1015, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":1017
+  /* "View.MemoryView":1015
  *     result = _memoryviewslice(None, 0, dtype_is_object)
  * 
  *     result.from_slice = memviewslice             # <<<<<<<<<<<<<<
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  */
   __pyx_v_result->from_slice = __pyx_v_memviewslice;
 
-  /* "View.MemoryView":1018
+  /* "View.MemoryView":1016
  * 
  *     result.from_slice = memviewslice
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)             # <<<<<<<<<<<<<<
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  */
   __PYX_INC_MEMVIEW((&__pyx_v_memviewslice), 1);
 
-  /* "View.MemoryView":1020
+  /* "View.MemoryView":1018
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base             # <<<<<<<<<<<<<<
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1020, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1018, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_result->from_object);
   __Pyx_DECREF(__pyx_v_result->from_object);
   __pyx_v_result->from_object = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":1021
+  /* "View.MemoryView":1019
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  *     result.typeinfo = memviewslice.memview.typeinfo             # <<<<<<<<<<<<<<
  * 
  *     result.view = memviewslice.memview.view
  */
   __pyx_t_4 = __pyx_v_memviewslice.memview->typeinfo;
   __pyx_v_result->__pyx_base.typeinfo = __pyx_t_4;
 
-  /* "View.MemoryView":1023
+  /* "View.MemoryView":1021
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  *     result.view = memviewslice.memview.view             # <<<<<<<<<<<<<<
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  */
   __pyx_t_5 = __pyx_v_memviewslice.memview->view;
   __pyx_v_result->__pyx_base.view = __pyx_t_5;
 
-  /* "View.MemoryView":1024
+  /* "View.MemoryView":1022
  * 
  *     result.view = memviewslice.memview.view
  *     result.view.buf = <void *> memviewslice.data             # <<<<<<<<<<<<<<
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  */
   __pyx_v_result->__pyx_base.view.buf = ((void *)__pyx_v_memviewslice.data);
 
-  /* "View.MemoryView":1025
+  /* "View.MemoryView":1023
  *     result.view = memviewslice.memview.view
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim             # <<<<<<<<<<<<<<
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  *     Py_INCREF(Py_None)
  */
   __pyx_v_result->__pyx_base.view.ndim = __pyx_v_ndim;
 
-  /* "View.MemoryView":1026
+  /* "View.MemoryView":1024
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None             # <<<<<<<<<<<<<<
  *     Py_INCREF(Py_None)
  * 
  */
   ((Py_buffer *)(&__pyx_v_result->__pyx_base.view))->obj = Py_None;
 
-  /* "View.MemoryView":1027
+  /* "View.MemoryView":1025
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  *     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
  */
   Py_INCREF(Py_None);
 
-  /* "View.MemoryView":1029
+  /* "View.MemoryView":1027
  *     Py_INCREF(Py_None)
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
  *         result.flags = PyBUF_RECORDS
  *     else:
  */
   __pyx_t_1 = ((((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)->flags & PyBUF_WRITABLE) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1030
+    /* "View.MemoryView":1028
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
  *         result.flags = PyBUF_RECORDS             # <<<<<<<<<<<<<<
  *     else:
  *         result.flags = PyBUF_RECORDS_RO
  */
     __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS;
 
-    /* "View.MemoryView":1029
+    /* "View.MemoryView":1027
  *     Py_INCREF(Py_None)
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
  *         result.flags = PyBUF_RECORDS
  *     else:
  */
     goto __pyx_L4;
   }
 
-  /* "View.MemoryView":1032
+  /* "View.MemoryView":1030
  *         result.flags = PyBUF_RECORDS
  *     else:
  *         result.flags = PyBUF_RECORDS_RO             # <<<<<<<<<<<<<<
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  */
   /*else*/ {
     __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS_RO;
   }
   __pyx_L4:;
 
-  /* "View.MemoryView":1034
+  /* "View.MemoryView":1032
  *         result.flags = PyBUF_RECORDS_RO
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape             # <<<<<<<<<<<<<<
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides
  * 
  */
   __pyx_v_result->__pyx_base.view.shape = ((Py_ssize_t *)__pyx_v_result->from_slice.shape);
 
-  /* "View.MemoryView":1035
+  /* "View.MemoryView":1033
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_v_result->__pyx_base.view.strides = ((Py_ssize_t *)__pyx_v_result->from_slice.strides);
 
-  /* "View.MemoryView":1038
+  /* "View.MemoryView":1036
  * 
  * 
  *     result.view.suboffsets = NULL             # <<<<<<<<<<<<<<
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
   __pyx_v_result->__pyx_base.view.suboffsets = NULL;
 
-  /* "View.MemoryView":1039
+  /* "View.MemoryView":1037
  * 
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  */
   __pyx_t_7 = (__pyx_v_result->from_slice.suboffsets + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->from_slice.suboffsets; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
     __pyx_v_suboffset = (__pyx_t_6[0]);
 
-    /* "View.MemoryView":1040
+    /* "View.MemoryView":1038
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
     __pyx_t_1 = ((__pyx_v_suboffset >= 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1041
+      /* "View.MemoryView":1039
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_result->__pyx_base.view.suboffsets = ((Py_ssize_t *)__pyx_v_result->from_slice.suboffsets);
 
-      /* "View.MemoryView":1042
+      /* "View.MemoryView":1040
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break             # <<<<<<<<<<<<<<
  * 
  *     result.view.len = result.view.itemsize
  */
       goto __pyx_L6_break;
 
-      /* "View.MemoryView":1040
+      /* "View.MemoryView":1038
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
     }
   }
   __pyx_L6_break:;
 
-  /* "View.MemoryView":1044
+  /* "View.MemoryView":1042
  *             break
  * 
  *     result.view.len = result.view.itemsize             # <<<<<<<<<<<<<<
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length
  */
   __pyx_t_9 = __pyx_v_result->__pyx_base.view.itemsize;
   __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
 
-  /* "View.MemoryView":1045
+  /* "View.MemoryView":1043
  * 
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         result.view.len *= length
  * 
  */
   __pyx_t_7 = (__pyx_v_result->__pyx_base.view.shape + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->__pyx_base.view.shape; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
-    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1045, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1043, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "View.MemoryView":1046
+    /* "View.MemoryView":1044
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length             # <<<<<<<<<<<<<<
  * 
  *     result.to_object_func = to_object_func
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1046, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1044, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1046, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1044, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 1046, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 1044, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
   }
 
-  /* "View.MemoryView":1048
+  /* "View.MemoryView":1046
  *         result.view.len *= length
  * 
  *     result.to_object_func = to_object_func             # <<<<<<<<<<<<<<
  *     result.to_dtype_func = to_dtype_func
  * 
  */
   __pyx_v_result->to_object_func = __pyx_v_to_object_func;
 
-  /* "View.MemoryView":1049
+  /* "View.MemoryView":1047
  * 
  *     result.to_object_func = to_object_func
  *     result.to_dtype_func = to_dtype_func             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   __pyx_v_result->to_dtype_func = __pyx_v_to_dtype_func;
 
-  /* "View.MemoryView":1051
+  /* "View.MemoryView":1049
  *     result.to_dtype_func = to_dtype_func
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":1001
+  /* "View.MemoryView":999
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
@@ -14063,15 +13885,15 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1054
+/* "View.MemoryView":1052
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
@@ -14083,79 +13905,79 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_slice_from_memview", 0);
 
-  /* "View.MemoryView":1057
+  /* "View.MemoryView":1055
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1058
+    /* "View.MemoryView":1056
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview             # <<<<<<<<<<<<<<
  *         return &obj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 1058, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 1056, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":1059
+    /* "View.MemoryView":1057
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview
  *         return &obj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, mslice)
  */
     __pyx_r = (&__pyx_v_obj->from_slice);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1057
+    /* "View.MemoryView":1055
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   }
 
-  /* "View.MemoryView":1061
+  /* "View.MemoryView":1059
  *         return &obj.from_slice
  *     else:
  *         slice_copy(memview, mslice)             # <<<<<<<<<<<<<<
  *         return mslice
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, __pyx_v_mslice);
 
-    /* "View.MemoryView":1062
+    /* "View.MemoryView":1060
  *     else:
  *         slice_copy(memview, mslice)
  *         return mslice             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_slice_copy')
  */
     __pyx_r = __pyx_v_mslice;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1054
+  /* "View.MemoryView":1052
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
@@ -14166,15 +13988,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_obj);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1065
+/* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
@@ -14187,120 +14009,120 @@
   Py_ssize_t *__pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   __Pyx_RefNannySetupContext("slice_copy", 0);
 
-  /* "View.MemoryView":1069
+  /* "View.MemoryView":1067
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  * 
  *     shape = memview.view.shape             # <<<<<<<<<<<<<<
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets
  */
   __pyx_t_1 = __pyx_v_memview->view.shape;
   __pyx_v_shape = __pyx_t_1;
 
-  /* "View.MemoryView":1070
+  /* "View.MemoryView":1068
  * 
  *     shape = memview.view.shape
  *     strides = memview.view.strides             # <<<<<<<<<<<<<<
  *     suboffsets = memview.view.suboffsets
  * 
  */
   __pyx_t_1 = __pyx_v_memview->view.strides;
   __pyx_v_strides = __pyx_t_1;
 
-  /* "View.MemoryView":1071
+  /* "View.MemoryView":1069
  *     shape = memview.view.shape
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets             # <<<<<<<<<<<<<<
  * 
  *     dst.memview = <__pyx_memoryview *> memview
  */
   __pyx_t_1 = __pyx_v_memview->view.suboffsets;
   __pyx_v_suboffsets = __pyx_t_1;
 
-  /* "View.MemoryView":1073
+  /* "View.MemoryView":1071
  *     suboffsets = memview.view.suboffsets
  * 
  *     dst.memview = <__pyx_memoryview *> memview             # <<<<<<<<<<<<<<
  *     dst.data = <char *> memview.view.buf
  * 
  */
   __pyx_v_dst->memview = ((struct __pyx_memoryview_obj *)__pyx_v_memview);
 
-  /* "View.MemoryView":1074
+  /* "View.MemoryView":1072
  * 
  *     dst.memview = <__pyx_memoryview *> memview
  *     dst.data = <char *> memview.view.buf             # <<<<<<<<<<<<<<
  * 
  *     for dim in range(memview.view.ndim):
  */
   __pyx_v_dst->data = ((char *)__pyx_v_memview->view.buf);
 
-  /* "View.MemoryView":1076
+  /* "View.MemoryView":1074
  *     dst.data = <char *> memview.view.buf
  * 
  *     for dim in range(memview.view.ndim):             # <<<<<<<<<<<<<<
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  */
   __pyx_t_2 = __pyx_v_memview->view.ndim;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_dim = __pyx_t_4;
 
-    /* "View.MemoryView":1077
+    /* "View.MemoryView":1075
  * 
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]             # <<<<<<<<<<<<<<
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
  */
     (__pyx_v_dst->shape[__pyx_v_dim]) = (__pyx_v_shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":1078
+    /* "View.MemoryView":1076
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]             # <<<<<<<<<<<<<<
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
  * 
  */
     (__pyx_v_dst->strides[__pyx_v_dim]) = (__pyx_v_strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":1079
+    /* "View.MemoryView":1077
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_object')
  */
     if ((__pyx_v_suboffsets != 0)) {
       __pyx_t_5 = (__pyx_v_suboffsets[__pyx_v_dim]);
     } else {
       __pyx_t_5 = -1L;
     }
     (__pyx_v_dst->suboffsets[__pyx_v_dim]) = __pyx_t_5;
   }
 
-  /* "View.MemoryView":1065
+  /* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1082
+/* "View.MemoryView":1080
  * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
@@ -14310,38 +14132,38 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_copy", 0);
 
-  /* "View.MemoryView":1085
+  /* "View.MemoryView":1083
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)             # <<<<<<<<<<<<<<
  *     return memoryview_copy_from_slice(memview, &memviewslice)
  * 
  */
   __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_memviewslice));
 
-  /* "View.MemoryView":1086
+  /* "View.MemoryView":1084
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)
  *     return memoryview_copy_from_slice(memview, &memviewslice)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1086, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1084, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1082
+  /* "View.MemoryView":1080
  * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
@@ -14352,15 +14174,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1089
+/* "View.MemoryView":1087
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
@@ -14375,99 +14197,99 @@
   int (*__pyx_t_4)(char *, PyObject *);
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_copy_from_slice", 0);
 
-  /* "View.MemoryView":1096
+  /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1097
+    /* "View.MemoryView":1095
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func             # <<<<<<<<<<<<<<
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  */
     __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
     __pyx_v_to_object_func = __pyx_t_3;
 
-    /* "View.MemoryView":1098
+    /* "View.MemoryView":1096
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func             # <<<<<<<<<<<<<<
  *     else:
  *         to_object_func = NULL
  */
     __pyx_t_4 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
     __pyx_v_to_dtype_func = __pyx_t_4;
 
-    /* "View.MemoryView":1096
+    /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1100
+  /* "View.MemoryView":1098
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  *         to_object_func = NULL             # <<<<<<<<<<<<<<
  *         to_dtype_func = NULL
  * 
  */
   /*else*/ {
     __pyx_v_to_object_func = NULL;
 
-    /* "View.MemoryView":1101
+    /* "View.MemoryView":1099
  *     else:
  *         to_object_func = NULL
  *         to_dtype_func = NULL             # <<<<<<<<<<<<<<
  * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  */
     __pyx_v_to_dtype_func = NULL;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1103
+  /* "View.MemoryView":1101
  *         to_dtype_func = NULL
  * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,             # <<<<<<<<<<<<<<
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)
  */
   __Pyx_XDECREF(__pyx_r);
 
-  /* "View.MemoryView":1105
+  /* "View.MemoryView":1103
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 1103, __pyx_L1_error)
+  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 1101, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1089
+  /* "View.MemoryView":1087
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
@@ -14478,81 +14300,81 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1111
+/* "View.MemoryView":1109
  * 
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
 static Py_ssize_t abs_py_ssize_t(Py_ssize_t __pyx_v_arg) {
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
 
-  /* "View.MemoryView":1112
+  /* "View.MemoryView":1110
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_arg < 0) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1113
+    /* "View.MemoryView":1111
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:
  *         return -arg             # <<<<<<<<<<<<<<
  *     else:
  *         return arg
  */
     __pyx_r = (-__pyx_v_arg);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1112
+    /* "View.MemoryView":1110
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   }
 
-  /* "View.MemoryView":1115
+  /* "View.MemoryView":1113
  *         return -arg
  *     else:
  *         return arg             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_get_best_slice_order')
  */
   /*else*/ {
     __pyx_r = __pyx_v_arg;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1111
+  /* "View.MemoryView":1109
  * 
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1118
+/* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
@@ -14562,187 +14384,187 @@
   Py_ssize_t __pyx_v_f_stride;
   char __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1123
+  /* "View.MemoryView":1121
  *     """
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t f_stride = 0
  * 
  */
   __pyx_v_c_stride = 0;
 
-  /* "View.MemoryView":1124
+  /* "View.MemoryView":1122
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0
  *     cdef Py_ssize_t f_stride = 0             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_f_stride = 0;
 
-  /* "View.MemoryView":1126
+  /* "View.MemoryView":1124
  *     cdef Py_ssize_t f_stride = 0
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1127
+    /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1128
+      /* "View.MemoryView":1126
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_c_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1129
+      /* "View.MemoryView":1127
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
       goto __pyx_L4_break;
 
-      /* "View.MemoryView":1127
+      /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L4_break:;
 
-  /* "View.MemoryView":1131
+  /* "View.MemoryView":1129
  *             break
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  */
   __pyx_t_1 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_1;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1132
+    /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1133
+      /* "View.MemoryView":1131
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_f_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1134
+      /* "View.MemoryView":1132
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  */
       goto __pyx_L7_break;
 
-      /* "View.MemoryView":1132
+      /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L7_break:;
 
-  /* "View.MemoryView":1136
+  /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   __pyx_t_2 = ((abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1137
+    /* "View.MemoryView":1135
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  *         return 'C'             # <<<<<<<<<<<<<<
  *     else:
  *         return 'F'
  */
     __pyx_r = 'C';
     goto __pyx_L0;
 
-    /* "View.MemoryView":1136
+    /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   }
 
-  /* "View.MemoryView":1139
+  /* "View.MemoryView":1137
  *         return 'C'
  *     else:
  *         return 'F'             # <<<<<<<<<<<<<<
  * 
  * @cython.cdivision(True)
  */
   /*else*/ {
     __pyx_r = 'F';
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1118
+  /* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1142
+/* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
@@ -14755,61 +14577,61 @@
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   Py_ssize_t __pyx_t_6;
 
-  /* "View.MemoryView":1149
+  /* "View.MemoryView":1147
  * 
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  */
   __pyx_v_src_extent = (__pyx_v_src_shape[0]);
 
-  /* "View.MemoryView":1150
+  /* "View.MemoryView":1148
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  */
   __pyx_v_dst_extent = (__pyx_v_dst_shape[0]);
 
-  /* "View.MemoryView":1151
+  /* "View.MemoryView":1149
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  */
   __pyx_v_src_stride = (__pyx_v_src_strides[0]);
 
-  /* "View.MemoryView":1152
+  /* "View.MemoryView":1150
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_dst_stride = (__pyx_v_dst_strides[0]);
 
-  /* "View.MemoryView":1154
+  /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1155
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     __pyx_t_2 = ((__pyx_v_src_stride > 0) != 0);
@@ -14821,195 +14643,195 @@
     __pyx_t_2 = ((__pyx_v_dst_stride > 0) != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
       goto __pyx_L5_bool_binop_done;
     }
 
-    /* "View.MemoryView":1156
+    /* "View.MemoryView":1154
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):             # <<<<<<<<<<<<<<
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  *        else:
  */
     __pyx_t_2 = (((size_t)__pyx_v_src_stride) == __pyx_v_itemsize);
     if (__pyx_t_2) {
       __pyx_t_2 = (__pyx_v_itemsize == ((size_t)__pyx_v_dst_stride));
     }
     __pyx_t_3 = (__pyx_t_2 != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L5_bool_binop_done:;
 
-    /* "View.MemoryView":1155
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1157
+      /* "View.MemoryView":1155
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
  *        else:
  *            for i in range(dst_extent):
  */
       (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, (__pyx_v_itemsize * __pyx_v_dst_extent)));
 
-      /* "View.MemoryView":1155
+      /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
       goto __pyx_L4;
     }
 
-    /* "View.MemoryView":1159
+    /* "View.MemoryView":1157
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  *        else:
  *            for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride
  */
     /*else*/ {
       __pyx_t_4 = __pyx_v_dst_extent;
       __pyx_t_5 = __pyx_t_4;
       for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
         __pyx_v_i = __pyx_t_6;
 
-        /* "View.MemoryView":1160
+        /* "View.MemoryView":1158
  *        else:
  *            for i in range(dst_extent):
  *                memcpy(dst_data, src_data, itemsize)             # <<<<<<<<<<<<<<
  *                src_data += src_stride
  *                dst_data += dst_stride
  */
         (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, __pyx_v_itemsize));
 
-        /* "View.MemoryView":1161
+        /* "View.MemoryView":1159
  *            for i in range(dst_extent):
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride             # <<<<<<<<<<<<<<
  *                dst_data += dst_stride
  *     else:
  */
         __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-        /* "View.MemoryView":1162
+        /* "View.MemoryView":1160
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride
  *                dst_data += dst_stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(dst_extent):
  */
         __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
       }
     }
     __pyx_L4:;
 
-    /* "View.MemoryView":1154
+    /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1164
+  /* "View.MemoryView":1162
  *                dst_data += dst_stride
  *     else:
  *         for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *             _copy_strided_to_strided(src_data, src_strides + 1,
  *                                      dst_data, dst_strides + 1,
  */
   /*else*/ {
     __pyx_t_4 = __pyx_v_dst_extent;
     __pyx_t_5 = __pyx_t_4;
     for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
       __pyx_v_i = __pyx_t_6;
 
-      /* "View.MemoryView":1165
+      /* "View.MemoryView":1163
  *     else:
  *         for i in range(dst_extent):
  *             _copy_strided_to_strided(src_data, src_strides + 1,             # <<<<<<<<<<<<<<
  *                                      dst_data, dst_strides + 1,
  *                                      src_shape + 1, dst_shape + 1,
  */
       _copy_strided_to_strided(__pyx_v_src_data, (__pyx_v_src_strides + 1), __pyx_v_dst_data, (__pyx_v_dst_strides + 1), (__pyx_v_src_shape + 1), (__pyx_v_dst_shape + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize);
 
-      /* "View.MemoryView":1169
+      /* "View.MemoryView":1167
  *                                      src_shape + 1, dst_shape + 1,
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride             # <<<<<<<<<<<<<<
  *             dst_data += dst_stride
  * 
  */
       __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-      /* "View.MemoryView":1170
+      /* "View.MemoryView":1168
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride
  *             dst_data += dst_stride             # <<<<<<<<<<<<<<
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,
  */
       __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1142
+  /* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1172
+/* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
 static void copy_strided_to_strided(__Pyx_memviewslice *__pyx_v_src, __Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize) {
 
-  /* "View.MemoryView":1175
+  /* "View.MemoryView":1173
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  *     _copy_strided_to_strided(src.data, src.strides, dst.data, dst.strides,             # <<<<<<<<<<<<<<
  *                              src.shape, dst.shape, ndim, itemsize)
  * 
  */
   _copy_strided_to_strided(__pyx_v_src->data, __pyx_v_src->strides, __pyx_v_dst->data, __pyx_v_dst->strides, __pyx_v_src->shape, __pyx_v_dst->shape, __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1172
+  /* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1179
+/* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
@@ -15018,70 +14840,70 @@
   Py_ssize_t __pyx_v_size;
   Py_ssize_t __pyx_r;
   Py_ssize_t __pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
 
-  /* "View.MemoryView":1181
+  /* "View.MemoryView":1179
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     for shape in src.shape[:ndim]:
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_size = __pyx_t_1;
 
-  /* "View.MemoryView":1183
+  /* "View.MemoryView":1181
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  * 
  *     for shape in src.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         size *= shape
  * 
  */
   __pyx_t_3 = (__pyx_v_src->shape + __pyx_v_ndim);
   for (__pyx_t_4 = __pyx_v_src->shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_shape = (__pyx_t_2[0]);
 
-    /* "View.MemoryView":1184
+    /* "View.MemoryView":1182
  * 
  *     for shape in src.shape[:ndim]:
  *         size *= shape             # <<<<<<<<<<<<<<
  * 
  *     return size
  */
     __pyx_v_size = (__pyx_v_size * __pyx_v_shape);
   }
 
-  /* "View.MemoryView":1186
+  /* "View.MemoryView":1184
  *         size *= shape
  * 
  *     return size             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_fill_contig_strides_array')
  */
   __pyx_r = __pyx_v_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1179
+  /* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1189
+/* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
@@ -15089,121 +14911,121 @@
   int __pyx_v_idx;
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1198
+  /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
   __pyx_t_1 = ((__pyx_v_order == 'F') != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1199
+    /* "View.MemoryView":1197
  * 
  *     if order == 'F':
  *         for idx in range(ndim):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
     __pyx_t_2 = __pyx_v_ndim;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_idx = __pyx_t_4;
 
-      /* "View.MemoryView":1200
+      /* "View.MemoryView":1198
  *     if order == 'F':
  *         for idx in range(ndim):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  *     else:
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1201
+      /* "View.MemoryView":1199
  *         for idx in range(ndim):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
 
-    /* "View.MemoryView":1198
+    /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1203
+  /* "View.MemoryView":1201
  *             stride *= shape[idx]
  *     else:
  *         for idx in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
   /*else*/ {
     for (__pyx_t_2 = (__pyx_v_ndim - 1); __pyx_t_2 > -1; __pyx_t_2-=1) {
       __pyx_v_idx = __pyx_t_2;
 
-      /* "View.MemoryView":1204
+      /* "View.MemoryView":1202
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  * 
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1205
+      /* "View.MemoryView":1203
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  * 
  *     return stride
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1207
+  /* "View.MemoryView":1205
  *             stride *= shape[idx]
  * 
  *     return stride             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  */
   __pyx_r = __pyx_v_stride;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1189
+  /* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1210
+/* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -15219,222 +15041,222 @@
   struct __pyx_memoryview_obj *__pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":1221
+  /* "View.MemoryView":1219
  *     cdef void *result
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1222
+  /* "View.MemoryView":1220
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef size_t size = slice_get_size(src, ndim)             # <<<<<<<<<<<<<<
  * 
  *     result = malloc(size)
  */
   __pyx_v_size = __pyx_memoryview_slice_get_size(__pyx_v_src, __pyx_v_ndim);
 
-  /* "View.MemoryView":1224
+  /* "View.MemoryView":1222
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  *     result = malloc(size)             # <<<<<<<<<<<<<<
  *     if not result:
  *         _err(MemoryError, NULL)
  */
   __pyx_v_result = malloc(__pyx_v_size);
 
-  /* "View.MemoryView":1225
+  /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_result != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1226
+    /* "View.MemoryView":1224
  *     result = malloc(size)
  *     if not result:
  *         _err(MemoryError, NULL)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1226, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1224, __pyx_L1_error)
 
-    /* "View.MemoryView":1225
+    /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
  * 
  */
   }
 
-  /* "View.MemoryView":1229
+  /* "View.MemoryView":1227
  * 
  * 
  *     tmpslice.data = <char *> result             # <<<<<<<<<<<<<<
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  */
   __pyx_v_tmpslice->data = ((char *)__pyx_v_result);
 
-  /* "View.MemoryView":1230
+  /* "View.MemoryView":1228
  * 
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview             # <<<<<<<<<<<<<<
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  */
   __pyx_t_4 = __pyx_v_src->memview;
   __pyx_v_tmpslice->memview = __pyx_t_4;
 
-  /* "View.MemoryView":1231
+  /* "View.MemoryView":1229
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1232
+    /* "View.MemoryView":1230
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]             # <<<<<<<<<<<<<<
  *         tmpslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_tmpslice->shape[__pyx_v_i]) = (__pyx_v_src->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1233
+    /* "View.MemoryView":1231
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,
  */
     (__pyx_v_tmpslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1235
+  /* "View.MemoryView":1233
  *         tmpslice.suboffsets[i] = -1
  * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,             # <<<<<<<<<<<<<<
  *                               ndim, order)
  * 
  */
   (void)(__pyx_fill_contig_strides_array((&(__pyx_v_tmpslice->shape[0])), (&(__pyx_v_tmpslice->strides[0])), __pyx_v_itemsize, __pyx_v_ndim, __pyx_v_order));
 
-  /* "View.MemoryView":1239
+  /* "View.MemoryView":1237
  * 
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1240
+    /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     __pyx_t_2 = (((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1241
+      /* "View.MemoryView":1239
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0             # <<<<<<<<<<<<<<
  * 
  *     if slice_is_contig(src[0], order, ndim):
  */
       (__pyx_v_tmpslice->strides[__pyx_v_i]) = 0;
 
-      /* "View.MemoryView":1240
+      /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1243
+  /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
   __pyx_t_2 = (__pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1244
+    /* "View.MemoryView":1242
  * 
  *     if slice_is_contig(src[0], order, ndim):
  *         memcpy(result, src.data, size)             # <<<<<<<<<<<<<<
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  */
     (void)(memcpy(__pyx_v_result, __pyx_v_src->data, __pyx_v_size));
 
-    /* "View.MemoryView":1243
+    /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":1246
+  /* "View.MemoryView":1244
  *         memcpy(result, src.data, size)
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   /*else*/ {
     copy_strided_to_strided(__pyx_v_src, __pyx_v_tmpslice, __pyx_v_ndim, __pyx_v_itemsize);
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":1248
+  /* "View.MemoryView":1246
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1210
+  /* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -15450,15 +15272,15 @@
     #endif
   }
   __pyx_r = NULL;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1253
+/* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
@@ -15473,57 +15295,57 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_extents", 0);
 
-  /* "View.MemoryView":1256
+  /* "View.MemoryView":1254
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  *                                                         (i, extent1, extent2))             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err_dim')
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":1255
+  /* "View.MemoryView":1253
  * cdef int _err_extents(int i, Py_ssize_t extent1,
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %             # <<<<<<<<<<<<<<
  *                                                         (i, extent1, extent2))
  * 
  */
-  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1255, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1255, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_4, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __PYX_ERR(1, 1255, __pyx_L1_error)
+  __PYX_ERR(1, 1253, __pyx_L1_error)
 
-  /* "View.MemoryView":1253
+  /* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
@@ -15538,15 +15360,15 @@
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1259
+/* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
@@ -15562,26 +15384,26 @@
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_dim", 0);
   __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1260
+  /* "View.MemoryView":1258
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:
  *     raise error(msg.decode('ascii') % dim)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err')
  */
-  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_INCREF(__pyx_v_error);
   __pyx_t_3 = __pyx_v_error; __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
@@ -15591,22 +15413,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 1260, __pyx_L1_error)
+  __PYX_ERR(1, 1258, __pyx_L1_error)
 
-  /* "View.MemoryView":1259
+  /* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
@@ -15622,15 +15444,15 @@
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1263
+/* "View.MemoryView":1261
  * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
@@ -15647,32 +15469,32 @@
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err", 0);
   __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1264
+  /* "View.MemoryView":1262
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:             # <<<<<<<<<<<<<<
  *         raise error(msg.decode('ascii'))
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_msg != NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":1265
+    /* "View.MemoryView":1263
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))             # <<<<<<<<<<<<<<
  *     else:
  *         raise error
  */
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1265, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1263, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_error);
     __pyx_t_4 = __pyx_v_error; __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
@@ -15680,43 +15502,43 @@
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1265, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1263, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 1265, __pyx_L1_error)
+    __PYX_ERR(1, 1263, __pyx_L1_error)
 
-    /* "View.MemoryView":1264
+    /* "View.MemoryView":1262
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:             # <<<<<<<<<<<<<<
  *         raise error(msg.decode('ascii'))
  *     else:
  */
   }
 
-  /* "View.MemoryView":1267
+  /* "View.MemoryView":1265
  *         raise error(msg.decode('ascii'))
  *     else:
  *         raise error             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_contents')
  */
   /*else*/ {
     __Pyx_Raise(__pyx_v_error, 0, 0, 0);
-    __PYX_ERR(1, 1267, __pyx_L1_error)
+    __PYX_ERR(1, 1265, __pyx_L1_error)
   }
 
-  /* "View.MemoryView":1263
+  /* "View.MemoryView":1261
  * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
@@ -15732,15 +15554,15 @@
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1270
+/* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -15762,119 +15584,119 @@
   int __pyx_t_6;
   void *__pyx_t_7;
   int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":1278
+  /* "View.MemoryView":1276
  *     Check for overlapping memory and verify the shapes.
  *     """
  *     cdef void *tmpdata = NULL             # <<<<<<<<<<<<<<
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  */
   __pyx_v_tmpdata = NULL;
 
-  /* "View.MemoryView":1279
+  /* "View.MemoryView":1277
  *     """
  *     cdef void *tmpdata = NULL
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  */
   __pyx_t_1 = __pyx_v_src.memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1281
+  /* "View.MemoryView":1279
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)             # <<<<<<<<<<<<<<
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False
  */
   __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_src), __pyx_v_src_ndim);
 
-  /* "View.MemoryView":1282
+  /* "View.MemoryView":1280
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False             # <<<<<<<<<<<<<<
  *     cdef bint direct_copy = False
  *     cdef __Pyx_memviewslice tmp
  */
   __pyx_v_broadcasting = 0;
 
-  /* "View.MemoryView":1283
+  /* "View.MemoryView":1281
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False             # <<<<<<<<<<<<<<
  *     cdef __Pyx_memviewslice tmp
  * 
  */
   __pyx_v_direct_copy = 0;
 
-  /* "View.MemoryView":1286
+  /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
   __pyx_t_2 = ((__pyx_v_src_ndim < __pyx_v_dst_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1287
+    /* "View.MemoryView":1285
  * 
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_src), __pyx_v_src_ndim, __pyx_v_dst_ndim);
 
-    /* "View.MemoryView":1286
+    /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1288
+  /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   __pyx_t_2 = ((__pyx_v_dst_ndim < __pyx_v_src_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1289
+    /* "View.MemoryView":1287
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)             # <<<<<<<<<<<<<<
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_dst), __pyx_v_dst_ndim, __pyx_v_src_ndim);
 
-    /* "View.MemoryView":1288
+    /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1291
+  /* "View.MemoryView":1289
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
   __pyx_t_3 = __pyx_v_dst_ndim;
@@ -15882,420 +15704,420 @@
   if (((__pyx_t_3 > __pyx_t_4) != 0)) {
     __pyx_t_5 = __pyx_t_3;
   } else {
     __pyx_t_5 = __pyx_t_4;
   }
   __pyx_v_ndim = __pyx_t_5;
 
-  /* "View.MemoryView":1293
+  /* "View.MemoryView":1291
  *     cdef int ndim = max(src_ndim, dst_ndim)
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  */
   __pyx_t_5 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_5;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1294
+    /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i])) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1295
+      /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
       __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) == 1) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":1296
+        /* "View.MemoryView":1294
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  *                 broadcasting = True             # <<<<<<<<<<<<<<
  *                 src.strides[i] = 0
  *             else:
  */
         __pyx_v_broadcasting = 1;
 
-        /* "View.MemoryView":1297
+        /* "View.MemoryView":1295
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  *                 src.strides[i] = 0             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  */
         (__pyx_v_src.strides[__pyx_v_i]) = 0;
 
-        /* "View.MemoryView":1295
+        /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":1299
+      /* "View.MemoryView":1297
  *                 src.strides[i] = 0
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])             # <<<<<<<<<<<<<<
  * 
  *         if src.suboffsets[i] >= 0:
  */
       /*else*/ {
-        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1299, __pyx_L1_error)
+        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1297, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":1294
+      /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     }
 
-    /* "View.MemoryView":1301
+    /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     __pyx_t_2 = (((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1302
+      /* "View.MemoryView":1300
  * 
  *         if src.suboffsets[i] >= 0:
  *             _err_dim(ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  */
-      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1302, __pyx_L1_error)
+      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1300, __pyx_L1_error)
 
-      /* "View.MemoryView":1301
+      /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1304
+  /* "View.MemoryView":1302
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   __pyx_t_2 = (__pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1306
+    /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     __pyx_t_2 = ((!(__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim) != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1307
+      /* "View.MemoryView":1305
  * 
  *         if not slice_is_contig(src, order, ndim):
  *             order = get_best_order(&dst, ndim)             # <<<<<<<<<<<<<<
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  */
       __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim);
 
-      /* "View.MemoryView":1306
+      /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     }
 
-    /* "View.MemoryView":1309
+    /* "View.MemoryView":1307
  *             order = get_best_order(&dst, ndim)
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)             # <<<<<<<<<<<<<<
  *         src = tmp
  * 
  */
-    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1309, __pyx_L1_error)
+    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1307, __pyx_L1_error)
     __pyx_v_tmpdata = __pyx_t_7;
 
-    /* "View.MemoryView":1310
+    /* "View.MemoryView":1308
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  *         src = tmp             # <<<<<<<<<<<<<<
  * 
  *     if not broadcasting:
  */
     __pyx_v_src = __pyx_v_tmp;
 
-    /* "View.MemoryView":1304
+    /* "View.MemoryView":1302
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   }
 
-  /* "View.MemoryView":1312
+  /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_broadcasting != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1315
+    /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1316
+      /* "View.MemoryView":1314
  * 
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)             # <<<<<<<<<<<<<<
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'C', __pyx_v_ndim);
 
-      /* "View.MemoryView":1315
+      /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
       goto __pyx_L12;
     }
 
-    /* "View.MemoryView":1317
+    /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1318
+      /* "View.MemoryView":1316
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)             # <<<<<<<<<<<<<<
  * 
  *         if direct_copy:
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'F', __pyx_v_ndim);
 
-      /* "View.MemoryView":1317
+      /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     }
     __pyx_L12:;
 
-    /* "View.MemoryView":1320
+    /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     __pyx_t_2 = (__pyx_v_direct_copy != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1322
+      /* "View.MemoryView":1320
  *         if direct_copy:
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-      /* "View.MemoryView":1323
+      /* "View.MemoryView":1321
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))             # <<<<<<<<<<<<<<
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  */
       (void)(memcpy(__pyx_v_dst.data, __pyx_v_src.data, __pyx_memoryview_slice_get_size((&__pyx_v_src), __pyx_v_ndim)));
 
-      /* "View.MemoryView":1324
+      /* "View.MemoryView":1322
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  *             free(tmpdata)
  *             return 0
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-      /* "View.MemoryView":1325
+      /* "View.MemoryView":1323
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)             # <<<<<<<<<<<<<<
  *             return 0
  * 
  */
       free(__pyx_v_tmpdata);
 
-      /* "View.MemoryView":1326
+      /* "View.MemoryView":1324
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  *             return 0             # <<<<<<<<<<<<<<
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):
  */
       __pyx_r = 0;
       goto __pyx_L0;
 
-      /* "View.MemoryView":1320
+      /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     }
 
-    /* "View.MemoryView":1312
+    /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1328
+  /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = (__pyx_v_order == 'F');
   if (__pyx_t_2) {
     __pyx_t_2 = ('F' == __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim));
   }
   __pyx_t_8 = (__pyx_t_2 != 0);
   if (__pyx_t_8) {
 
-    /* "View.MemoryView":1331
+    /* "View.MemoryView":1329
  * 
  * 
  *         transpose_memslice(&src)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&dst)
  * 
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1331, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1329, __pyx_L1_error)
 
-    /* "View.MemoryView":1332
+    /* "View.MemoryView":1330
  * 
  *         transpose_memslice(&src)
  *         transpose_memslice(&dst)             # <<<<<<<<<<<<<<
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1332, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1330, __pyx_L1_error)
 
-    /* "View.MemoryView":1328
+    /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1334
+  /* "View.MemoryView":1332
  *         transpose_memslice(&dst)
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1335
+  /* "View.MemoryView":1333
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)             # <<<<<<<<<<<<<<
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  */
   copy_strided_to_strided((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1336
+  /* "View.MemoryView":1334
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  *     free(tmpdata)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1338
+  /* "View.MemoryView":1336
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  *     free(tmpdata)             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
   free(__pyx_v_tmpdata);
 
-  /* "View.MemoryView":1339
+  /* "View.MemoryView":1337
  * 
  *     free(tmpdata)
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1270
+  /* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -16311,217 +16133,217 @@
     #endif
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1342
+/* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim, int __pyx_v_ndim_other) {
   int __pyx_v_i;
   int __pyx_v_offset;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
 
-  /* "View.MemoryView":1346
+  /* "View.MemoryView":1344
  *                             int ndim_other) nogil:
  *     cdef int i
  *     cdef int offset = ndim_other - ndim             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_offset = (__pyx_v_ndim_other - __pyx_v_ndim);
 
-  /* "View.MemoryView":1348
+  /* "View.MemoryView":1346
  *     cdef int offset = ndim_other - ndim
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1349
+    /* "View.MemoryView":1347
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]             # <<<<<<<<<<<<<<
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  */
     (__pyx_v_mslice->shape[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1350
+    /* "View.MemoryView":1348
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  */
     (__pyx_v_mslice->strides[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-    /* "View.MemoryView":1351
+    /* "View.MemoryView":1349
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]             # <<<<<<<<<<<<<<
  * 
  *     for i in range(offset):
  */
     (__pyx_v_mslice->suboffsets[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->suboffsets[__pyx_v_i]);
   }
 
-  /* "View.MemoryView":1353
+  /* "View.MemoryView":1351
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  *     for i in range(offset):             # <<<<<<<<<<<<<<
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  */
   __pyx_t_1 = __pyx_v_offset;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1354
+    /* "View.MemoryView":1352
  * 
  *     for i in range(offset):
  *         mslice.shape[i] = 1             # <<<<<<<<<<<<<<
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1
  */
     (__pyx_v_mslice->shape[__pyx_v_i]) = 1;
 
-    /* "View.MemoryView":1355
+    /* "View.MemoryView":1353
  *     for i in range(offset):
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_mslice->strides[__pyx_v_i]) = (__pyx_v_mslice->strides[0]);
 
-    /* "View.MemoryView":1356
+    /* "View.MemoryView":1354
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_mslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1342
+  /* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1364
+/* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
  * 
  */
 
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_dtype_is_object, int __pyx_v_ndim, int __pyx_v_inc) {
   int __pyx_t_1;
 
-  /* "View.MemoryView":1368
+  /* "View.MemoryView":1366
  * 
  * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   __pyx_t_1 = (__pyx_v_dtype_is_object != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1369
+    /* "View.MemoryView":1367
  * 
  *     if dtype_is_object:
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,             # <<<<<<<<<<<<<<
  *                                            dst.strides, ndim, inc)
  * 
  */
     __pyx_memoryview_refcount_objects_in_slice_with_gil(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_inc);
 
-    /* "View.MemoryView":1368
+    /* "View.MemoryView":1366
  * 
  * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   }
 
-  /* "View.MemoryView":1364
+  /* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
  * 
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1373
+/* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   __Pyx_RefNannyDeclarations
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("refcount_objects_in_slice_with_gil", 0);
 
-  /* "View.MemoryView":1376
+  /* "View.MemoryView":1374
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  *     refcount_objects_in_slice(data, shape, strides, ndim, inc)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  */
   __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, __pyx_v_shape, __pyx_v_strides, __pyx_v_ndim, __pyx_v_inc);
 
-  /* "View.MemoryView":1373
+  /* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
 }
 
-/* "View.MemoryView":1379
+/* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
@@ -16530,178 +16352,178 @@
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   __Pyx_RefNannySetupContext("refcount_objects_in_slice", 0);
 
-  /* "View.MemoryView":1383
+  /* "View.MemoryView":1381
  *     cdef Py_ssize_t i
  * 
  *     for i in range(shape[0]):             # <<<<<<<<<<<<<<
  *         if ndim == 1:
  *             if inc:
  */
   __pyx_t_1 = (__pyx_v_shape[0]);
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1384
+    /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
     __pyx_t_4 = ((__pyx_v_ndim == 1) != 0);
     if (__pyx_t_4) {
 
-      /* "View.MemoryView":1385
+      /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
       __pyx_t_4 = (__pyx_v_inc != 0);
       if (__pyx_t_4) {
 
-        /* "View.MemoryView":1386
+        /* "View.MemoryView":1384
  *         if ndim == 1:
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])
  */
         Py_INCREF((((PyObject **)__pyx_v_data)[0]));
 
-        /* "View.MemoryView":1385
+        /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
         goto __pyx_L6;
       }
 
-      /* "View.MemoryView":1388
+      /* "View.MemoryView":1386
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  */
       /*else*/ {
         Py_DECREF((((PyObject **)__pyx_v_data)[0]));
       }
       __pyx_L6:;
 
-      /* "View.MemoryView":1384
+      /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":1390
+    /* "View.MemoryView":1388
  *                 Py_DECREF((<PyObject **> data)[0])
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
  *                                       ndim - 1, inc)
  * 
  */
     /*else*/ {
 
-      /* "View.MemoryView":1391
+      /* "View.MemoryView":1389
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  *                                       ndim - 1, inc)             # <<<<<<<<<<<<<<
  * 
  *         data += strides[0]
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_inc);
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":1393
+    /* "View.MemoryView":1391
  *                                       ndim - 1, inc)
  * 
  *         data += strides[0]             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_data = (__pyx_v_data + (__pyx_v_strides[0]));
   }
 
-  /* "View.MemoryView":1379
+  /* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1399
+/* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item, int __pyx_v_dtype_is_object) {
 
-  /* "View.MemoryView":1402
+  /* "View.MemoryView":1400
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  *     refcount_copying(dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
  *                          itemsize, item)
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1403
+  /* "View.MemoryView":1401
  *                               bint dtype_is_object) nogil:
  *     refcount_copying(dst, dtype_is_object, ndim, False)
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,             # <<<<<<<<<<<<<<
  *                          itemsize, item)
  *     refcount_copying(dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview__slice_assign_scalar(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_itemsize, __pyx_v_item);
 
-  /* "View.MemoryView":1405
+  /* "View.MemoryView":1403
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
  *                          itemsize, item)
  *     refcount_copying(dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1399
+  /* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1409
+/* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
@@ -16710,118 +16532,118 @@
   Py_ssize_t __pyx_v_stride;
   Py_ssize_t __pyx_v_extent;
   int __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   Py_ssize_t __pyx_t_4;
 
-  /* "View.MemoryView":1413
+  /* "View.MemoryView":1411
  *                               size_t itemsize, void *item) nogil:
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t extent = shape[0]
  * 
  */
   __pyx_v_stride = (__pyx_v_strides[0]);
 
-  /* "View.MemoryView":1414
+  /* "View.MemoryView":1412
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]
  *     cdef Py_ssize_t extent = shape[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_extent = (__pyx_v_shape[0]);
 
-  /* "View.MemoryView":1416
+  /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1417
+    /* "View.MemoryView":1415
  * 
  *     if ndim == 1:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             memcpy(data, item, itemsize)
  *             data += stride
  */
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1418
+      /* "View.MemoryView":1416
  *     if ndim == 1:
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)             # <<<<<<<<<<<<<<
  *             data += stride
  *     else:
  */
       (void)(memcpy(__pyx_v_data, __pyx_v_item, __pyx_v_itemsize));
 
-      /* "View.MemoryView":1419
+      /* "View.MemoryView":1417
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  *             data += stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(extent):
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
 
-    /* "View.MemoryView":1416
+    /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1421
+  /* "View.MemoryView":1419
  *             data += stride
  *     else:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             _slice_assign_scalar(data, shape + 1, strides + 1,
  *                                 ndim - 1, itemsize, item)
  */
   /*else*/ {
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1422
+      /* "View.MemoryView":1420
  *     else:
  *         for i in range(extent):
  *             _slice_assign_scalar(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
  *                                 ndim - 1, itemsize, item)
  *             data += stride
  */
       __pyx_memoryview__slice_assign_scalar(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize, __pyx_v_item);
 
-      /* "View.MemoryView":1424
+      /* "View.MemoryView":1422
  *             _slice_assign_scalar(data, shape + 1, strides + 1,
  *                                 ndim - 1, itemsize, item)
  *             data += stride             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1409
+  /* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
@@ -16911,155 +16733,151 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum", 0);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
-  __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__20, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (__pyx_t_2 != 0);
-  if (__pyx_t_3) {
+  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xb068931) != 0);
+  if (__pyx_t_1) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  */
-    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
-    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
-    __pyx_t_4 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_1, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_INCREF(__pyx_t_1);
-    __pyx_v___pyx_PickleError = __pyx_t_1;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);
+    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_INCREF(__pyx_t_2);
+    __pyx_v___pyx_PickleError = __pyx_t_2;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
-    __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_INCREF(__pyx_v___pyx_PickleError);
-    __pyx_t_1 = __pyx_v___pyx_PickleError; __pyx_t_6 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
-      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
-      if (likely(__pyx_t_6)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-        __Pyx_INCREF(__pyx_t_6);
+    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_1, function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
-    __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_1, function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
-  __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_5, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v___pyx_type);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result = __pyx_t_4;
-  __pyx_t_4 = 0;
+  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_v___pyx_result = __pyx_t_3;
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
-  __pyx_t_3 = (__pyx_v___pyx_state != Py_None);
-  __pyx_t_2 = (__pyx_t_3 != 0);
-  if (__pyx_t_2) {
+  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);
+  __pyx_t_6 = (__pyx_t_1 != 0);
+  if (__pyx_t_6) {
 
     /* "(tree fragment)":9
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  */
-    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
-    __pyx_t_4 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 9, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
+    __pyx_t_3 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
@@ -17079,18 +16897,18 @@
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
@@ -17388,23 +17206,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 static struct __pyx_vtabstruct_array __pyx_vtable_array;
 
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_array_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
@@ -17580,23 +17395,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
@@ -17702,23 +17514,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
@@ -17966,23 +17775,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
   PyObject *o = __pyx_tp_new_memoryview(t, a, k);
   if (unlikely(!o)) return 0;
@@ -18115,23 +17921,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
@@ -18180,15 +17983,15 @@
   {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
   {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
   {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
   {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
-  {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
+  {&__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_k_Incompatible_checksums_s_vs_0xb0, sizeof(__pyx_k_Incompatible_checksums_s_vs_0xb0), 0, 0, 1, 0},
   {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
   {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_k_Invalid_shape_in_axis_d_d, sizeof(__pyx_k_Invalid_shape_in_axis_d_d), 0, 0, 1, 0},
   {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
   {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
   {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
@@ -18201,15 +18004,14 @@
   {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
   {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
   {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
   {&__pyx_n_s_back, __pyx_k_back, sizeof(__pyx_k_back), 0, 0, 1, 1},
   {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
   {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
   {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
-  {&__pyx_n_s_c_bond, __pyx_k_c_bond, sizeof(__pyx_k_c_bond), 0, 0, 1, 1},
   {&__pyx_n_s_chython_algorithms__isomorphism, __pyx_k_chython_algorithms__isomorphism, sizeof(__pyx_k_chython_algorithms__isomorphism), 0, 0, 1, 1},
   {&__pyx_kp_s_chython_algorithms__isomorphism_2, __pyx_k_chython_algorithms__isomorphism_2, sizeof(__pyx_k_chython_algorithms__isomorphism_2), 0, 0, 1, 0},
   {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
   {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
   {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
   {&__pyx_n_s_closures_counter, __pyx_k_closures_counter, sizeof(__pyx_k_closures_counter), 0, 0, 1, 1},
   {&__pyx_n_s_closures_num, __pyx_k_closures_num, sizeof(__pyx_k_closures_num), 0, 0, 1, 1},
@@ -18318,81 +18120,81 @@
   {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
   __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 57, __pyx_L1_error)
   __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 67, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 134, __pyx_L1_error)
-  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 152, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 133, __pyx_L1_error)
+  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 151, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 406, __pyx_L1_error)
-  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 615, __pyx_L1_error)
-  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 834, __pyx_L1_error)
+  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 404, __pyx_L1_error)
+  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 613, __pyx_L1_error)
+  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 832, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "View.MemoryView":134
+  /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 134, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 133, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__2);
   __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* "View.MemoryView":137
+  /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 137, __pyx_L1_error)
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 136, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__3);
   __Pyx_GIVEREF(__pyx_tuple__3);
 
-  /* "View.MemoryView":149
+  /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 149, __pyx_L1_error)
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 148, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__4);
   __Pyx_GIVEREF(__pyx_tuple__4);
 
-  /* "View.MemoryView":177
+  /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 177, __pyx_L1_error)
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__5);
   __Pyx_GIVEREF(__pyx_tuple__5);
 
-  /* "View.MemoryView":193
+  /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 193, __pyx_L1_error)
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 192, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__6);
   __Pyx_GIVEREF(__pyx_tuple__6);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
@@ -18407,66 +18209,66 @@
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "View.MemoryView":420
+  /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 420, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 418, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "View.MemoryView":497
+  /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 497, __pyx_L1_error)
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 495, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
 
-  /* "View.MemoryView":522
+  /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 522, __pyx_L1_error)
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 520, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__11);
   __Pyx_GIVEREF(__pyx_tuple__11);
 
-  /* "View.MemoryView":572
+  /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 572, __pyx_L1_error)
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 570, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_GIVEREF(__pyx_tuple__12);
 
-  /* "View.MemoryView":579
+  /* "View.MemoryView":577
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
-  __pyx_tuple__13 = PyTuple_New(1); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __pyx_tuple__13 = PyTuple_New(1); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 577, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__13);
   __Pyx_INCREF(__pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_int_neg_1);
   PyTuple_SET_ITEM(__pyx_tuple__13, 0, __pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_tuple__13);
 
   /* "(tree fragment)":2
@@ -18484,33 +18286,33 @@
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__15);
   __Pyx_GIVEREF(__pyx_tuple__15);
 
-  /* "View.MemoryView":684
+  /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-  __pyx_slice__16 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__16)) __PYX_ERR(1, 684, __pyx_L1_error)
+  __pyx_slice__16 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__16)) __PYX_ERR(1, 682, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_slice__16);
   __Pyx_GIVEREF(__pyx_slice__16);
 
-  /* "View.MemoryView":705
+  /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 705, __pyx_L1_error)
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 703, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__17);
   __Pyx_GIVEREF(__pyx_tuple__17);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
@@ -18524,107 +18326,102 @@
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__19);
   __Pyx_GIVEREF(__pyx_tuple__19);
-  __pyx_tuple__20 = PyTuple_Pack(3, __pyx_int_184977713, __pyx_int_136983863, __pyx_int_112105877); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__20);
-  __Pyx_GIVEREF(__pyx_tuple__20);
 
   /* "chython/algorithms/_isomorphism.pyx":30
  * @cython.boundscheck(False)
  * @cython.wraparound(False)
  * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
  *                 unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
  *                 unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
  */
-  __pyx_tuple__21 = PyTuple_Pack(48, __pyx_n_s_q_numbers, __pyx_n_s_q_back, __pyx_n_s_q_masks1, __pyx_n_s_q_masks2, __pyx_n_s_q_masks3, __pyx_n_s_q_masks4, __pyx_n_s_q_closures, __pyx_n_s_q_from, __pyx_n_s_q_to, __pyx_n_s_q_indices, __pyx_n_s_q_bonds, __pyx_n_s_o_numbers, __pyx_n_s_o_bits1, __pyx_n_s_o_bits2, __pyx_n_s_o_bits3, __pyx_n_s_o_bits4, __pyx_n_s_o_bonds, __pyx_n_s_o_from, __pyx_n_s_o_to, __pyx_n_s_o_indices, __pyx_n_s_scope, __pyx_n_s_stack, __pyx_n_s_path_size, __pyx_n_s_q_size, __pyx_n_s_q_size_dec, __pyx_n_s_o_size, __pyx_n_s_depth, __pyx_n_s_front, __pyx_n_s_back, __pyx_n_s_closures_num, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_o, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_closures_counter, __pyx_n_s_q_mask1, __pyx_n_s_q_mask2, __pyx_n_s_q_mask3, __pyx_n_s_q_mask4, __pyx_n_s_o_bond, __pyx_n_s_c_bond, __pyx_n_s_mapping, __pyx_n_s_path, __pyx_n_s_stack_index, __pyx_n_s_stack_depth, __pyx_n_s_matched, __pyx_n_s_o_closures); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 30, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj_ = (PyObject*)__Pyx_PyCode_New(21, 0, 48, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_algorithms__isomorphism_2, __pyx_n_s_get_mapping, 30, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj_)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __pyx_tuple__20 = PyTuple_Pack(47, __pyx_n_s_q_numbers, __pyx_n_s_q_back, __pyx_n_s_q_masks1, __pyx_n_s_q_masks2, __pyx_n_s_q_masks3, __pyx_n_s_q_masks4, __pyx_n_s_q_closures, __pyx_n_s_q_from, __pyx_n_s_q_to, __pyx_n_s_q_indices, __pyx_n_s_q_bonds, __pyx_n_s_o_numbers, __pyx_n_s_o_bits1, __pyx_n_s_o_bits2, __pyx_n_s_o_bits3, __pyx_n_s_o_bits4, __pyx_n_s_o_bonds, __pyx_n_s_o_from, __pyx_n_s_o_to, __pyx_n_s_o_indices, __pyx_n_s_scope, __pyx_n_s_stack, __pyx_n_s_path_size, __pyx_n_s_q_size, __pyx_n_s_q_size_dec, __pyx_n_s_o_size, __pyx_n_s_depth, __pyx_n_s_front, __pyx_n_s_back, __pyx_n_s_closures_num, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_o, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_closures_counter, __pyx_n_s_q_mask1, __pyx_n_s_q_mask2, __pyx_n_s_q_mask3, __pyx_n_s_q_mask4, __pyx_n_s_o_bond, __pyx_n_s_mapping, __pyx_n_s_path, __pyx_n_s_stack_index, __pyx_n_s_stack_depth, __pyx_n_s_matched, __pyx_n_s_o_closures); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_codeobj_ = (PyObject*)__Pyx_PyCode_New(21, 0, 47, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_algorithms__isomorphism_2, __pyx_n_s_get_mapping, 30, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj_)) __PYX_ERR(0, 30, __pyx_L1_error)
 
-  /* "View.MemoryView":287
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 287, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__22);
-  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
-  /* "View.MemoryView":288
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 288, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__23);
-  __Pyx_GIVEREF(__pyx_tuple__23);
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
 
-  /* "View.MemoryView":289
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 289, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__24);
-  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
 
-  /* "View.MemoryView":292
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 292, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
 
-  /* "View.MemoryView":293
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 293, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__27 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
-  __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__27, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__26 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
@@ -18678,62 +18475,62 @@
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping.tp_dictoffset && __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = &__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping;
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
-  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_array.tp_print = 0;
   #endif
-  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
   __pyx_array_type = &__pyx_type___pyx_array;
-  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 280, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_MemviewEnum.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_MemviewEnum.tp_dictoffset && __pyx_type___pyx_MemviewEnum.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_MemviewEnum.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 280, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
   __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
   __pyx_vtabptr_memoryview = &__pyx_vtable_memoryview;
   __pyx_vtable_memoryview.get_item_pointer = (char *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_get_item_pointer;
   __pyx_vtable_memoryview.is_slice = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_is_slice;
   __pyx_vtable_memoryview.setitem_slice_assignment = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_slice_assignment;
   __pyx_vtable_memoryview.setitem_slice_assign_scalar = (PyObject *(*)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_setitem_slice_assign_scalar;
   __pyx_vtable_memoryview.setitem_indexed = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_indexed;
   __pyx_vtable_memoryview.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryview_convert_item_to_object;
   __pyx_vtable_memoryview.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryview_assign_item_from_object;
-  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 331, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_memoryview.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryview.tp_dictoffset && __pyx_type___pyx_memoryview.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_memoryview.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 331, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 331, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
   __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
   __pyx_vtabptr__memoryviewslice = &__pyx_vtable__memoryviewslice;
   __pyx_vtable__memoryviewslice.__pyx_base = *__pyx_vtabptr_memoryview;
   __pyx_vtable__memoryviewslice.__pyx_base.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryviewslice_convert_item_to_object;
   __pyx_vtable__memoryviewslice.__pyx_base.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryviewslice_assign_item_from_object;
   __pyx_type___pyx_memoryviewslice.tp_base = __pyx_memoryview_type;
-  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 967, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_memoryviewslice.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryviewslice.tp_dictoffset && __pyx_type___pyx_memoryviewslice.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_memoryviewslice.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 967, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 967, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
   __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
@@ -18925,15 +18722,15 @@
   #endif
   __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
   Py_INCREF(__pyx_d);
   __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
   Py_INCREF(__pyx_b);
   __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
   Py_INCREF(__pyx_cython_runtime);
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   if (__pyx_module_is_main_chython__algorithms___isomorphism) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -18974,114 +18771,114 @@
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_mapping, __pyx_t_1) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "chython/algorithms/_isomorphism.pyx":1
  * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
  * #
- * #  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
+ * #  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
  */
   __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":210
+  /* "View.MemoryView":209
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(array self):
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 210, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 209, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 210, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 209, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_array_type);
 
-  /* "View.MemoryView":287
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 286, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":288
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":289
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 289, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":292
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":293
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 293, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":317
+  /* "View.MemoryView":316
  * 
  * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0             # <<<<<<<<<<<<<<
  * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [
  *     PyThread_allocate_lock(),
  */
   __pyx_memoryview_thread_locks_used = 0;
 
-  /* "View.MemoryView":318
+  /* "View.MemoryView":317
  * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0
  * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [             # <<<<<<<<<<<<<<
  *     PyThread_allocate_lock(),
  *     PyThread_allocate_lock(),
  */
   __pyx_t_2[0] = PyThread_allocate_lock();
@@ -19090,37 +18887,37 @@
   __pyx_t_2[3] = PyThread_allocate_lock();
   __pyx_t_2[4] = PyThread_allocate_lock();
   __pyx_t_2[5] = PyThread_allocate_lock();
   __pyx_t_2[6] = PyThread_allocate_lock();
   __pyx_t_2[7] = PyThread_allocate_lock();
   memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_2, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
 
-  /* "View.MemoryView":551
+  /* "View.MemoryView":549
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 551, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 549, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 551, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 549, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryview_type);
 
-  /* "View.MemoryView":997
+  /* "View.MemoryView":995
  *         return self.from_object
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 997, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 995, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 997, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 995, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryviewslice_type);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
@@ -19402,15 +19199,15 @@
 }
 #ifndef Py_NO_RETURN
 #define Py_NO_RETURN
 #endif
 static void __pyx_fatalerror(const char *fmt, ...) Py_NO_RETURN {
     va_list vargs;
     char msg[200];
-#if PY_VERSION_HEX >= 0x030A0000 || defined(HAVE_STDARG_PROTOTYPES)
+#ifdef HAVE_STDARG_PROTOTYPES
     va_start(vargs, fmt);
 #else
     va_start(vargs);
 #endif
     vsnprintf(msg, 200, fmt, vargs);
     va_end(vargs);
     Py_FatalError(msg);
@@ -19845,28 +19642,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_FAST_THREAD_STATE
+#if CYTHON_COMPILING_IN_PYPY
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
+#else
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
-#else
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -20118,15 +19915,15 @@
         ps2 = PyBytes_AS_STRING(s2);
         if (ps1[0] != ps2[0]) {
             return (equals == Py_NE);
         } else if (length == 1) {
             return (equals == Py_EQ);
         } else {
             int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
+#if CYTHON_USE_UNICODE_INTERNALS
             Py_hash_t hash1, hash2;
             hash1 = ((PyBytesObject*)s1)->ob_shash;
             hash2 = ((PyBytesObject*)s2)->ob_shash;
             if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                 return (equals == Py_NE);
             }
 #endif
@@ -20247,15 +20044,15 @@
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(owned_ref);
     #endif
     return (equals == Py_NE);
 #endif
 }
 
-/* DivInt[Py_ssize_t] */
+/* None */
 static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
     Py_ssize_t q = a / b;
     Py_ssize_t r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
@@ -20358,15 +20155,15 @@
 #endif
     return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
 }
 
 /* ObjectGetItem */
 #if CYTHON_USE_TYPE_SLOTS
 static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
-    PyObject *runerr = NULL;
+    PyObject *runerr;
     Py_ssize_t key_value;
     PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
     if (unlikely(!(m && m->sq_item))) {
         PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
         return NULL;
     }
     key_value = __Pyx_PyIndex_AsSsize_t(index);
@@ -20843,15 +20640,15 @@
 #endif
 
 /* None */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
     PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
 }
 
-/* DivInt[long] */
+/* None */
 static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
     long q = a / b;
     long r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
@@ -20993,43 +20790,25 @@
   }
   Py_XDECREF(name_attr);
   return ret;
 }
 static int __Pyx_setup_reduce(PyObject* type_obj) {
     int ret = 0;
     PyObject *object_reduce = NULL;
-    PyObject *object_getstate = NULL;
     PyObject *object_reduce_ex = NULL;
     PyObject *reduce = NULL;
     PyObject *reduce_ex = NULL;
     PyObject *reduce_cython = NULL;
     PyObject *setstate = NULL;
     PyObject *setstate_cython = NULL;
-    PyObject *getstate = NULL;
 #if CYTHON_USE_PYTYPE_LOOKUP
-    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
+    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #else
-    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
-    if (!getstate && PyErr_Occurred()) {
-        goto __PYX_BAD;
-    }
+    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #endif
-    if (getstate) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
-#else
-        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
-        if (!object_getstate && PyErr_Occurred()) {
-            goto __PYX_BAD;
-        }
-#endif
-        if (object_getstate != getstate) {
-            goto __PYX_GOOD;
-        }
-    }
 #if CYTHON_USE_PYTYPE_LOOKUP
     object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #else
     object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #endif
     reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
     if (reduce_ex == object_reduce_ex) {
@@ -21066,28 +20845,26 @@
     if (!PyErr_Occurred())
         PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
     ret = -1;
 __PYX_GOOD:
 #if !CYTHON_USE_PYTYPE_LOOKUP
     Py_XDECREF(object_reduce);
     Py_XDECREF(object_reduce_ex);
-    Py_XDECREF(object_getstate);
-    Py_XDECREF(getstate);
 #endif
     Py_XDECREF(reduce);
     Py_XDECREF(reduce_ex);
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
 /* CLineInTraceback */
 #ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(CYTHON_UNUSED PyThreadState *tstate, int c_line) {
+static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
     if (unlikely(!__pyx_cython_runtime)) {
         return c_line;
@@ -21109,15 +20886,15 @@
       } else {
         PyErr_Clear();
         use_cline = NULL;
       }
     }
     if (!use_cline) {
         c_line = 0;
-        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
+        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
     }
     else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
         c_line = 0;
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
@@ -21203,48 +20980,41 @@
     Py_INCREF(code_object);
 }
 
 /* AddTraceback */
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
-    PyCodeObject *py_code = NULL;
-    PyObject *py_funcname = NULL;
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
     #if PY_MAJOR_VERSION < 3
-    PyObject *py_srcfile = NULL;
     py_srcfile = PyString_FromString(filename);
-    if (!py_srcfile) goto bad;
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
     #endif
+    if (!py_srcfile) goto bad;
     if (c_line) {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
         #else
         py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
-        funcname = PyUnicode_AsUTF8(py_funcname);
-        if (!funcname) goto bad;
         #endif
     }
     else {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromString(funcname);
-        if (!py_funcname) goto bad;
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
         #endif
     }
-    #if PY_MAJOR_VERSION < 3
+    if (!py_funcname) goto bad;
     py_code = __Pyx_PyCode_New(
         0,
         0,
         0,
         0,
         0,
         __pyx_empty_bytes, /*PyObject *code,*/
@@ -21255,49 +21025,34 @@
         __pyx_empty_tuple, /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
         py_funcname,  /*PyObject *name,*/
         py_line,
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
     Py_DECREF(py_srcfile);
-    #else
-    py_code = PyCode_NewEmpty(filename, funcname, py_line);
-    #endif
-    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
+    Py_DECREF(py_funcname);
     return py_code;
 bad:
-    Py_XDECREF(py_funcname);
-    #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_srcfile);
-    #endif
+    Py_XDECREF(py_funcname);
     return NULL;
 }
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename) {
     PyCodeObject *py_code = 0;
     PyFrameObject *py_frame = 0;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject *ptype, *pvalue, *ptraceback;
     if (c_line) {
         c_line = __Pyx_CLineForTraceback(tstate, c_line);
     }
     py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
     if (!py_code) {
-        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
         py_code = __Pyx_CreateCodeObjectForTraceback(
             funcname, c_line, py_line, filename);
-        if (!py_code) {
-            /* If the code object creation fails, then we should clear the
-               fetched exception references and propagate the new exception */
-            Py_XDECREF(ptype);
-            Py_XDECREF(pvalue);
-            Py_XDECREF(ptraceback);
-            goto bad;
-        }
-        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
+        if (!py_code) goto bad;
         __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
     }
     py_frame = PyFrame_New(
         tstate,            /*PyThreadState *tstate,*/
         py_code,           /*PyCodeObject *code,*/
         __pyx_d,    /*PyObject *globals,*/
         0                  /*PyObject *locals*/
@@ -23630,20 +23385,14 @@
     if (unlikely(!method)) return NULL;
     return __Pyx__PyObject_CallMethod1(method, arg);
 }
 
 /* CoroutineBase */
   #include <structmember.h>
 #include <frameobject.h>
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
 #define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
 static int __Pyx_PyGen__FetchStopIterationValue(CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject **pvalue) {
     PyObject *et, *ev, *tb;
     PyObject *value = NULL;
     __Pyx_ErrFetch(&et, &ev, &tb);
     if (!et) {
         Py_XDECREF(tb);
@@ -23807,21 +23556,17 @@
     exc_state = &self->gi_exc_state;
     if (exc_state->exc_type) {
         #if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
         #else
         if (exc_state->exc_traceback) {
             PyTracebackObject *tb = (PyTracebackObject *) exc_state->exc_traceback;
             PyFrameObject *f = tb->tb_frame;
-            assert(f->f_back == NULL);
-            #if PY_VERSION_HEX >= 0x030B00A1
-            f->f_back = PyThreadState_GetFrame(tstate);
-            #else
             Py_XINCREF(tstate->frame);
+            assert(f->f_back == NULL);
             f->f_back = tstate->frame;
-            #endif
         }
         #endif
     }
 #if CYTHON_USE_EXC_INFO_STACK
     exc_state->previous_item = tstate->exc_info;
     tstate->exc_info = exc_state;
 #else
@@ -24601,63 +24346,38 @@
 #endif
     0,
 #if CYTHON_USE_TP_FINALIZE
     __Pyx_Coroutine_del,
 #elif PY_VERSION_HEX >= 0x030400a1
     0,
 #endif
-#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+#if PY_VERSION_HEX >= 0x030800b1
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-    0,
-#endif
 };
 static int __pyx_Generator_init(void) {
     __pyx_GeneratorType_type.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
     __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
     __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
     if (unlikely(!__pyx_GeneratorType)) {
         return -1;
     }
     return 0;
 }
 
 /* CheckBinaryVersion */
   static int __Pyx_check_binary_version(void) {
-    char ctversion[5];
-    int same=1, i, found_dot;
-    const char* rt_from_call = Py_GetVersion();
-    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
-    found_dot = 0;
-    for (i = 0; i < 4; i++) {
-        if (!ctversion[i]) {
-            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
-            break;
-        }
-        if (rt_from_call[i] != ctversion[i]) {
-            same = 0;
-            break;
-        }
-    }
-    if (!same) {
-        char rtversion[5] = {'\0'};
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
         char message[200];
-        for (i=0; i<4; ++i) {
-            if (rt_from_call[i] == '.') {
-                if (found_dot) break;
-                found_dot = 1;
-            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
-                break;
-            }
-            rtversion[i] = rt_from_call[i];
-        }
         PyOS_snprintf(message, sizeof(message),
                       "compiletime version %s of module '%.100s' "
                       "does not match runtime version %s",
                       ctversion, __Pyx_MODULE_NAME, rtversion);
         return PyErr_WarnEx(NULL, message, 1);
     }
     return 0;
@@ -24907,31 +24627,14 @@
   }
   x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
-  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
-    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
-#if PY_MAJOR_VERSION < 3
-  } else if (likely(PyInt_CheckExact(o))) {
-    return PyInt_AS_LONG(o);
-#endif
-  } else {
-    Py_ssize_t ival;
-    PyObject *x;
-    x = PyNumber_Index(o);
-    if (!x) return -1;
-    ival = PyInt_AsLong(x);
-    Py_DECREF(x);
-    return ival;
-  }
-}
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
   return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
 }
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
```

### Comparing `chython-1.64/chython/algorithms/_isomorphism.pyx` & `chython-1.8/chython/algorithms/_isomorphism.pyx`

 * *Files 16% similar despite different names*

```diff
@@ -1,158 +1,157 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-cimport cython
-from cpython.mem cimport PyMem_Malloc, PyMem_Free
-from libc.string cimport memset
-
-cdef extern from "Python.h":
-    dict _PyDict_NewPresized(Py_ssize_t minused)
-
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
-                unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
-                unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
-                unsigned int[::1] q_closures not None, unsigned int[::1] q_from not None,
-                unsigned int[::1] q_to not None, unsigned int[::1] q_indices not None,
-                unsigned long long[::1] q_bonds not None, unsigned long[::1] o_numbers not None,
-                unsigned long long[::1] o_bits1 not None, unsigned long long[::1] o_bits2 not None,
-                unsigned long long[::1] o_bits3 not None, unsigned long long[::1] o_bits4 not None,
-                unsigned long long[::1] o_bonds not None, unsigned int[::1] o_from not None,
-                unsigned int[::1] o_to not None, unsigned int[::1] o_indices not None,
-                unsigned int[::1] scope not None):
-    # expected less than 2^16 atoms in structure.
-    cdef unsigned int stack = 0, path_size = 0, q_size, q_size_dec, o_size, depth, front, back, closures_num
-    cdef unsigned int n, m, o, i, j, closures_counter
-    cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond, c_bond
-    cdef dict mapping
-
-    q_size = len(q_numbers)
-    q_size_dec = q_size - 1
-    o_size = len(o_numbers)
-    cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
-    cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
-    cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
-    cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
-    cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
-
-    if not path or not stack_index or not stack_depth or not matched or not o_closures:
-        raise MemoryError()
-
-    memset(matched, 0, o_size * sizeof(bint))
-    memset(o_closures, 0, o_size * sizeof(unsigned long long))
-
-    # find entry-points.
-    q_mask1 = q_masks1[0]
-    q_mask2 = q_masks2[0]
-    q_mask3 = q_masks3[0]
-    q_mask4 = q_masks4[0]
-    for n in range(o_size):
-        if (scope[n] and
-            q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
-            q_mask2 & o_bits2[n] == o_bits2[n] and
-            q_mask3 & o_bits3[n] == o_bits3[n] and
-            q_mask4 & o_bits4[n]):
-
-            stack_index[stack] = n
-            stack_depth[stack] = 0
-            stack += 1
-
-    try:
-        while stack:
-            stack -= 1
-            depth = stack_depth[stack]
-            n = stack_index[stack]
-
-            if depth == q_size_dec:
-                mapping = _PyDict_NewPresized(q_size)
-                for i in range(depth):
-                    mapping[q_numbers[i]] = o_numbers[path[i]]
-                mapping[q_numbers[depth]] = o_numbers[n]
-                yield mapping
-            else:
-                if path_size != depth:  # dead end reached
-                    for i in range(depth, path_size):
-                        matched[path[i]] = False  # mark unmatched
-                    path_size = depth
-
-                matched[n] = True
-                path[path_size] = n
-                path_size += 1
-
-                front = depth + 1
-                back = q_back[front]
-                if back != depth:  # branch
-                    n = path[back]
-
-                # load next query atom
-                q_mask1 = q_masks1[front]
-                q_mask2 = q_masks2[front]
-                q_mask3 = q_masks3[front]
-                q_mask4 = q_masks4[front]
-                closures_num = q_closures[front]
-
-                for i in range(o_from[n], o_to[n]):
-                    o_bond = o_bonds[i]
-                    m = o_indices[i]
-                    if (scope[m] and not matched[m] and
-                        q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
-                        q_mask2 & o_bits2[m] == o_bits2[m] and
-                        q_mask3 & o_bits3[m] == o_bits3[m] and
-                        q_mask4 & o_bits4[m]):
-
-                        if closures_num:  # candidate atom should have same closures.
-                            closures_counter = 0
-                            # make a map of closures for o_n atom
-                            # an index is a neighbor atom and a value is a bond between o_n and the neighbor
-                            for j in range(o_from[m], o_to[m]):
-                                o = o_indices[j]
-                                if o != n and matched[o]:
-                                    o_closures[o] = o_bonds[j]
-                                    closures_counter += 1
-
-                            if closures_counter == closures_num:
-                                for j in range(q_from[front], q_to[front]):
-                                    c_bond = o_closures[path[q_indices[j]]]
-                                    if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
-                                        break
-                                else:
-                                    stack_index[stack] = m
-                                    stack_depth[stack] = front
-                                    stack += 1
-
-                            # fill an array with nulls
-                            for j in range(o_from[m], o_to[m]):
-                                o_closures[o_indices[j]] = 0
-                        else:  # candidate atom should not have closures.
-                            for j in range(o_from[m], o_to[m]):
-                               o = o_indices[j]
-                               if o != n and matched[o]:
-                                   break  # found closure
-                            else:
-                                stack_index[stack] = m
-                                stack_depth[stack] = front
-                                stack += 1
-    finally:
-        PyMem_Free(path)
-        PyMem_Free(matched)
-        PyMem_Free(stack_index)
-        PyMem_Free(stack_depth)
-        PyMem_Free(o_closures)
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+cimport cython
+from cpython.mem cimport PyMem_Malloc, PyMem_Free
+from libc.string cimport memset
+
+cdef extern from "Python.h":
+    dict _PyDict_NewPresized(Py_ssize_t minused)
+
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
+                unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
+                unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
+                unsigned int[::1] q_closures not None, unsigned int[::1] q_from not None,
+                unsigned int[::1] q_to not None, unsigned int[::1] q_indices not None,
+                unsigned long long[::1] q_bonds not None, unsigned long[::1] o_numbers not None,
+                unsigned long long[::1] o_bits1 not None, unsigned long long[::1] o_bits2 not None,
+                unsigned long long[::1] o_bits3 not None, unsigned long long[::1] o_bits4 not None,
+                unsigned long long[::1] o_bonds not None, unsigned int[::1] o_from not None,
+                unsigned int[::1] o_to not None, unsigned int[::1] o_indices not None,
+                unsigned int[::1] scope not None):
+    # expected less than 2^16 atoms in structure.
+    cdef unsigned int stack = 0, path_size = 0, q_size, q_size_dec, o_size, depth, front, back, closures_num
+    cdef unsigned int n, m, o, i, j, closures_counter
+    cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond
+    cdef dict mapping
+
+    q_size = len(q_numbers)
+    q_size_dec = q_size - 1
+    o_size = len(o_numbers)
+    cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+    cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+    cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+    cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
+    cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
+
+    if not path or not stack_index or not stack_depth or not matched or not o_closures:
+        raise MemoryError()
+
+    memset(matched, 0, o_size * sizeof(bint))
+    memset(o_closures, 0, o_size * sizeof(unsigned long long))
+
+    # find entry-points.
+    q_mask1 = q_masks1[0]
+    q_mask2 = q_masks2[0]
+    q_mask3 = q_masks3[0]
+    q_mask4 = q_masks4[0]
+    for n in range(o_size):
+        if (scope[n] and
+            q_mask1 & o_bits1[n] and
+            q_mask2 & o_bits2[n] == o_bits2[n] and
+            q_mask3 & o_bits3[n] == o_bits3[n] and
+            q_mask4 & o_bits4[n]):
+
+            stack_index[stack] = n
+            stack_depth[stack] = 0
+            stack += 1
+
+    try:
+        while stack:
+            stack -= 1
+            depth = stack_depth[stack]
+            n = stack_index[stack]
+
+            if depth == q_size_dec:
+                mapping = _PyDict_NewPresized(q_size)
+                for i in range(depth):
+                    mapping[q_numbers[i]] = o_numbers[path[i]]
+                mapping[q_numbers[depth]] = o_numbers[n]
+                yield mapping
+            else:
+                if path_size != depth:  # dead end reached
+                    for i in range(depth, path_size):
+                        matched[path[i]] = False  # mark unmatched
+                    path_size = depth
+
+                matched[n] = True
+                path[path_size] = n
+                path_size += 1
+
+                front = depth + 1
+                back = q_back[front]
+                if back != depth:  # branch
+                    n = path[back]
+
+                # load next query atom
+                q_mask1 = q_masks1[front]
+                q_mask2 = q_masks2[front]
+                q_mask3 = q_masks3[front]
+                q_mask4 = q_masks4[front]
+                closures_num = q_closures[front]
+
+                for i in range(o_from[n], o_to[n]):
+                    o_bond = o_bonds[i]
+                    m = o_indices[i]
+                    if (scope[m] and not matched[m] and
+                        q_mask1 & o_bond == o_bond and
+                        q_mask2 & o_bits2[m] == o_bits2[m] and
+                        q_mask3 & o_bits3[m] == o_bits3[m] and
+                        q_mask4 & o_bits4[m]):
+
+                        if closures_num:  # candidate atom should have same closures.
+                            closures_counter = 0
+                            # make a map of closures for o_n atom
+                            # an index is an neighbor atom and an value is an bond between o_n and the neighbor
+                            for j in range(o_from[m], o_to[m]):
+                                o = o_indices[j]
+                                if o != n and matched[o]:
+                                    o_closures[o] = o_bonds[j]
+                                    closures_counter += 1
+
+                            if closures_counter == closures_num:
+                                for j in range(q_from[front], q_to[front]):
+                                    if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
+                                        break
+                                else:
+                                    stack_index[stack] = m
+                                    stack_depth[stack] = front
+                                    stack += 1
+
+                            # fill an array with nulls
+                            for j in range(o_from[m], o_to[m]):
+                                o_closures[o_indices[j]] = 0
+                        else:  # candidate atom should not have closures.
+                            for j in range(o_from[m], o_to[m]):
+                               o = o_indices[j]
+                               if o != n and matched[o]:
+                                   break  # found closure
+                            else:
+                                stack_index[stack] = m
+                                stack_depth[stack] = front
+                                stack += 1
+    finally:
+        PyMem_Free(path)
+        PyMem_Free(matched)
+        PyMem_Free(stack_index)
+        PyMem_Free(stack_depth)
+        PyMem_Free(o_closures)
```

### Comparing `chython-1.64/chython/algorithms/aromatics/__init__.py` & `chython-1.8/chython/algorithms/fingerprints/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,27 +1,29 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .kekule import *
-from .thiele import *
-
-
-class Aromatize(Thiele, Kekule):
-    __slots__ = ()
-
-
-__all__ = ['Aromatize']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .linear import *
+from .morgan import *
+from .pharmacophore import *
+
+
+class Fingerprints(LinearFingerprint, MorganFingerprint, Pharmacophore):
+    __slots__ = ()
+
+
+__all__ = ['Fingerprints']
```

### Comparing `chython-1.64/chython/algorithms/aromatics/kekule.py` & `chython-1.8/chython/algorithms/aromatics/kekule.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,521 +1,476 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict, deque
-from typing import List, Optional, Tuple, TYPE_CHECKING, Union
-from ._rules import rules
-from ..._functions import lazy_product
-from ...exceptions import InvalidAromaticRing
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-
-class Kekule:
-    __slots__ = ()
-
-    def kekule(self: Union['Kekule', 'MoleculeContainer'], *, buffer_size=7) -> bool:
-        """
-        Convert structure to kekule form. Return True if found any aromatic ring. Set implicit hydrogen count and
-        hybridization marks on atoms.
-
-        Only one of possible double/single bonds positions will be set.
-        For enumerate bonds positions use `enumerate_kekule`.
-
-        :param buffer_size: number of attempts of pyridine form searching.
-        """
-        fixed = self.__fix_rings()  # fix bad aromatic rings
-        kekule = next(self.__kekule_full(buffer_size), None)
-        if kekule:
-            bonds = self._bonds
-            atoms = set()
-            for n, m, b in kekule:
-                bonds[n][m]._Bond__order = b  # noqa
-                atoms.add(n)
-                atoms.add(m)
-            for n in atoms:
-                self._calc_implicit(n)
-            self.flush_cache()
-            return True
-        return fixed
-
-    def enumerate_kekule(self: Union['Kekule', 'MoleculeContainer']):
-        """
-        Enumerate all possible kekule forms of molecule.
-        """
-        self.__fix_rings()  # fix bad aromatic rings
-        for form in self.__kekule_full(0):
-            copy = self.copy()
-            bonds = copy._bonds
-            atoms = set()
-            for n, m, b in form:
-                bonds[n][m]._Bond__order = b  # noqa
-                atoms.add(n)
-                atoms.add(m)
-            for n in atoms:
-                copy._calc_implicit(n)
-            yield copy
-
-    def __fix_rings(self: 'MoleculeContainer'):
-        bonds = self._bonds
-        charges = self._charges
-        seen = set()
-        for q, af, bf, mm in rules:
-            for mapping in q.get_mapping(self, automorphism_filter=False):
-                match = set(mapping.values())
-                if not mm and not match.isdisjoint(seen):  # prevent double patching of atoms
-                    continue
-                seen.update(match)
-
-                for n, c in af.items():
-                    n = mapping[n]
-                    charges[n] = c
-                for n, m, b in bf:
-                    n = mapping[n]
-                    m = mapping[m]
-                    bonds[n][m]._Bond__order = b  # noqa
-        if seen:
-            self.flush_cache()
-            return True
-        return False
-
-    def __prepare_rings(self: 'MoleculeContainer'):
-        atoms = self._atoms
-        charges = self._charges
-        radicals = self._radicals
-        bonds = self._bonds
-        hydrogens = self._hydrogens
-        neighbors = self.neighbors
-
-        rings = defaultdict(list)  # aromatic skeleton
-        pyrroles = set()
-
-        double_bonded = defaultdict(list)
-        triple_bonded = set()
-        for n, m_bond in bonds.items():
-            for m, bond in m_bond.items():
-                bo = bond.order
-                if bo == 4:
-                    rings[n].append(m)
-                elif bo == 2:
-                    double_bonded[n].append(m)
-                elif bo == 3:
-                    triple_bonded.add(n)
-
-        if not rings:
-            return rings, pyrroles, set()
-        elif not triple_bonded.isdisjoint(rings):
-            raise InvalidAromaticRing('triple bonds connected to rings')
-
-        copy_rings = {n: ms.copy() for n, ms in rings.items()}
-        for r in self.sssr:
-            if set(r).issubset(rings):
-                n, *_, m = r
-                if n not in rings[m]:  # fix invalid structures: c1ccc-cc1
-                    # remove inner ring double bonds: c1ccc=cc1
-                    if n in double_bonded and m in double_bonded and m in double_bonded[n]:
-                        double_bonded[n].remove(m)
-                        double_bonded[m].remove(n)
-                    rings[m].append(n)
-                    rings[n].append(m)
-                elif m in copy_rings[n]:
-                    copy_rings[n].remove(m)
-                    copy_rings[m].remove(n)
-                for n, m in zip(r, r[1:]):
-                    if n not in rings[m]:
-                        if n in double_bonded and m in double_bonded and m in double_bonded[n]:
-                            double_bonded[n].remove(m)
-                            double_bonded[m].remove(n)
-                        rings[m].append(n)
-                        rings[n].append(m)
-                    elif m in copy_rings[n]:
-                        copy_rings[n].remove(m)
-                        copy_rings[m].remove(n)
-
-        # fix invalid smiles: c1ccccc1c2ccccc2 instead of c1ccccc1-c2ccccc2
-        seen = set()
-        for n, ms in copy_rings.items():
-            if ms:
-                seen.add(n)
-                for m in ms:
-                    if m not in seen:
-                        rings[n].remove(m)
-                        rings[m].remove(n)
-                        bonds[n][m]._Bond__order = 1  # noqa
-
-        if any(len(ms) not in (2, 3) for ms in rings.values()):
-            raise InvalidAromaticRing('not in ring aromatic bond or hypercondensed rings: '
-                                      f'{{{", ".join(str(n) for n, ms in rings.items() if len(ms) not in (2, 3))}}}')
-
-        # get double bonded ring atoms
-        double_bonded = {n for n, ms in double_bonded.items() if ms and n in rings}
-        if any(len(rings[n]) != 2 for n in double_bonded):  # double bonded never condensed
-            raise InvalidAromaticRing('quinone valence error')
-        for n in double_bonded:
-            if atoms[n].atomic_number == 7:
-                if charges[n] != 1:
-                    raise InvalidAromaticRing('quinone should be charged N atom')
-            elif atoms[n].atomic_number not in (6, 15, 16, 33, 34, 52) or charges[n]:
-                raise InvalidAromaticRing('quinone should be neutral S, Se, Te, C, P, As atom')
-
-        for n in rings:
-            an = atoms[n].atomic_number
-            ac = charges[n]
-            ab = neighbors(n)
-            if an == 6:  # carbon
-                if ac == 0:
-                    if ab not in (2, 3):
-                        raise InvalidAromaticRing
-                elif ac in (-1, 1):
-                    if radicals[n]:
-                        if ab == 2:
-                            double_bonded.add(n)
-                        else:
-                            raise InvalidAromaticRing
-                    elif ab == 3:
-                        double_bonded.add(n)
-                    elif ab == 2:  # benzene (an|cat)ion or pyrrole
-                        pyrroles.add(n)
-                    else:
-                        raise InvalidAromaticRing
-                else:
-                    raise InvalidAromaticRing
-            elif an in (7, 15, 33):
-                if ac == 0:  # pyrrole or pyridine. include radical pyrrole
-                    if radicals[n]:
-                        if ab != 2:  # only pyrrole radical
-                            raise InvalidAromaticRing
-                        double_bonded.add(n)
-                    elif ab == 3:
-                        if an == 7:  # pyrrole only possible
-                            double_bonded.add(n)
-                        else:  # P(III) or P(V)H
-                            pyrroles.add(n)
-                    elif ab == 2:
-                        ah = hydrogens[n]
-                        if ah is None:  # pyrrole or pyridine
-                            pyrroles.add(n)
-                        elif ah == 1:  # only pyrrole
-                            double_bonded.add(n)
-                        elif ah:  # too many hydrogens for aromatic rings
-                            raise InvalidAromaticRing
-                    elif ab != 4 or an not in (15, 33):  # P(V) in ring [P;a](-R1)-R2
-                        raise InvalidAromaticRing
-                elif ac == -1:  # pyrrole only
-                    if ab != 2 or radicals[n]:
-                        raise InvalidAromaticRing
-                    double_bonded.add(n)
-                elif ac != 1:
-                    raise InvalidAromaticRing
-                elif radicals[n]:
-                    if ab != 2:  # not cation-radical pyridine
-                        raise InvalidAromaticRing
-                elif ab == 2:  # pyrrole cation or protonated pyridine
-                    pyrroles.add(n)
-                elif ab != 3:  # not pyridine oxyde
-                    raise InvalidAromaticRing
-            elif an == 8:  # furan
-                if ab == 2:
-                    if ac == 0:
-                        if radicals[n]:
-                            raise InvalidAromaticRing('radical oxygen')
-                        double_bonded.add(n)
-                    elif ac == 1:
-                        if radicals[n]:  # furan cation-radical
-                            double_bonded.add(n)
-                        # pyrylium
-                    else:
-                        raise InvalidAromaticRing('invalid oxygen charge')
-                else:
-                    raise InvalidAromaticRing('Triple-bonded oxygen')
-            elif an in (16, 34, 52):  # thiophene
-                if n not in double_bonded:  # not sulphoxyde nor sulphone
-                    if ab == 2:
-                        if radicals[n]:
-                            if ac == 1:
-                                double_bonded.add(n)
-                            else:
-                                raise InvalidAromaticRing('S, Se, Te cation-radical expected')
-                        if ac == 0:
-                            double_bonded.add(n)
-                        elif ac != 1:
-                            raise InvalidAromaticRing('S, Se, Te cation in benzene like ring expected')
-                    elif ab == 3:
-                        if radicals[n]:
-                            if ac:
-                                raise InvalidAromaticRing('S, Se, Te ion-radical ring')
-                            double_bonded.add(n)
-                        elif ac == 1:
-                            double_bonded.add(n)
-                        elif ac:
-                            raise InvalidAromaticRing('S, Se, Te invalid charge ring')
-                    else:
-                        raise InvalidAromaticRing('S, Se, Te hypervalent ring')
-            elif an == 5:  # boron
-                if ac == 0:
-                    if ab == 2:
-                        if radicals[n]:  # C=1O[B]OC=1
-                            double_bonded.add(n)
-                        else:
-                            ah = hydrogens[n]
-                            if ah is None:  # b1ccccc1, C=1OBOC=1 or B1C=CC=N1
-                                pyrroles.add(n)
-                            elif ah == 1:  # C=1O[BH]OC=1 or [BH]1C=CC=N1
-                                double_bonded.add(n)
-                            elif ah:
-                                raise InvalidAromaticRing
-                    elif not radicals[n]:
-                        double_bonded.add(n)
-                    else:
-                        raise InvalidAromaticRing
-                elif ac == 1:
-                    if ab == 2 and not radicals[n]:
-                        double_bonded.add(n)
-                    else:
-                        raise InvalidAromaticRing
-                elif ac == -1:
-                    if ab == 2:
-                        if not radicals[n]:  # C=1O[B-]OC=1 or [bH-]1ccccc1
-                            pyrroles.add(n)
-                        # anion-radical is benzene like
-                    elif radicals[n]:  # C=1O[B-*](R)OC=1
-                        double_bonded.add(n)
-                    else:
-                        pyrroles.add(n)
-                else:
-                    raise InvalidAromaticRing
-            else:
-                raise InvalidAromaticRing(f'only B, C, N, P, O, S, Se, Te possible, not: {atoms[n].atomic_symbol}')
-        return rings, pyrroles, double_bonded
-
-    def __kekule_full(self, buffer_size):
-        rings, pyrroles, double_bonded = self.__prepare_rings()
-        atoms = set(rings)
-        components = []
-        while atoms:
-            start = atoms.pop()
-            component = {start: rings[start]}
-            queue = deque([start])
-            while queue:
-                current = queue.popleft()
-                for n in rings[current]:
-                    if n not in component:
-                        queue.append(n)
-                        component[n] = rings[n]
-
-            components.append(component)
-            atoms.difference_update(component)
-
-        for keks in lazy_product(*(_kekule_component(c, double_bonded & c.keys(), pyrroles & c.keys(), buffer_size)
-                                   for c in components)):
-            yield [x for x in keks for x in x]
-
-
-def _kekule_component(rings, double_bonded, pyrroles, buffer_size):
-    # (current atom, previous atom, bond between cp atoms, path deep for cutting [None if cut impossible])
-    stack: List[List[Tuple[int, int, int, Optional[int]]]]
-    if double_bonded:  # start from double bonded if exists
-        start = next(iter(double_bonded))
-        stack = [[(next(iter(rings[start])), start, 1, 0)]]
-    else:  # select not pyrrole not condensed atom
-        try:
-            start = next(n for n, ms in rings.items() if len(ms) == 2 and n not in pyrroles)
-        except StopIteration:  # all pyrroles. select not condensed atom.
-            try:
-                start = next(n for n, ms in rings.items() if len(ms) == 2)
-            except StopIteration:  # fullerene?
-                start = next(iter(rings))
-                double_bonded.add(start)
-                stack = [[(next_atom, start, 2, 0)] for next_atom in rings[start]]
-            else:
-                stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
-        else:
-            stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
-
-    size = sum(len(x) for x in rings.values()) // 2
-    path = []
-    hashed_path = set()
-    nether_yielded = True
-    buffer = []
-
-    while stack:
-        atom, prev_atom, bond, _ = stack[-1].pop()
-        path.append((atom, prev_atom, bond))
-        hashed_path.add(atom)
-
-        if len(path) == size:
-            if nether_yielded:
-                nether_yielded = False
-            if pyrroles and buffer_size:  # prioritize pyridine over pyrrole
-                g = defaultdict(int)
-                for n, m, b in path:
-                    g[n] += b
-                    g[m] += b
-                # should be pairs of pyrrole atoms
-                if sum(b == 2 and n in pyrroles for n, b in g.items()) >= 2:
-                    if len(buffer) == buffer_size:  # optimization. try only few times to prevent freezes.
-                        buffer_size = 0  # disable bufferization
-                        yield from buffer
-                        yield path
-                        buffer = []
-                    else:
-                        buffer.append(path)
-                else:
-                    yield path
-                    buffer_size = 0  # disable bufferization
-                    if buffer:  # empty buffer
-                        yield from buffer
-                        buffer = []
-            else:
-                yield path
-
-            del stack[-1]
-            if stack:
-                path = path[:stack[-1][-1][-1]]
-                hashed_path = {x for x, *_ in path}
-        elif atom != start:
-            for_stack = []
-            closures = []
-            loop = 0
-            for next_atom in rings[atom]:
-                if next_atom == prev_atom:  # only forward. behind us is the homeland
-                    continue
-                elif next_atom == start:
-                    loop = next_atom
-                elif next_atom in hashed_path:  # closure found
-                    closures.append(next_atom)
-                else:
-                    for_stack.append(next_atom)
-
-            if loop:  # we found starting point.
-                if bond == 2:  # finish should be single bonded
-                    if double_bonded:  # ok
-                        stack[-1].insert(0, (loop, atom, 1, None))
-                    else:
-                        del stack[-1]
-                        if stack:
-                            path = path[:stack[-1][-1][-1]]
-                            hashed_path = {x for x, *_ in path}
-                        continue
-                elif double_bonded:  # we in quinone ring. finish should be single bonded
-                    # side-path for storing double bond or atom is quinone or pyrrole
-                    if for_stack or atom in double_bonded or atom in pyrroles:
-                        stack[-1].insert(0, (loop, atom, 1, None))
-                    else:
-                        del stack[-1]
-                        if stack:
-                            path = path[:stack[-1][-1][-1]]
-                            hashed_path = {x for x, *_ in path}
-                        continue
-                else:  # finish should be double bonded
-                    stack[-1].insert(0, (loop, atom, 2, None))
-                    bond = 2  # grow should be single bonded
-
-            if bond == 2 or atom in double_bonded:  # double in - single out. quinone has two single bonds
-                for next_atom in closures:
-                    path.append((next_atom, atom, 1))  # closures always single-bonded
-                    stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
-                for next_atom in for_stack:
-                    stack[-1].append((next_atom, atom, 1, None))
-            elif len(for_stack) == 1:  # easy path grow. next bond double or include single for pyrroles
-                next_atom = for_stack[0]
-                if next_atom in double_bonded:  # need double bond, but next atom quinone
-                    if atom in pyrroles:
-                        stack[-1].append((next_atom, atom, 1, None))
-                    else:
-                        del stack[-1]
-                        if stack:
-                            path = path[:stack[-1][-1][-1]]
-                            hashed_path = {x for x, *_ in path}
-                elif atom in pyrroles:  # try pyrrole and pyridine
-                    opposite = stack[-1].copy()
-                    opposite.append((next_atom, atom, 2, None))
-                    stack[-1].append((next_atom, atom, 1, len(path)))
-                    stack.append(opposite)
-                else:
-                    stack[-1].append((next_atom, atom, 2, None))
-                    if closures:
-                        next_atom = closures[0]
-                        path.append((next_atom, atom, 1))  # closures always single-bonded
-                        stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
-            elif for_stack:  # fork
-                next_atom1, next_atom2 = for_stack
-                if next_atom1 in double_bonded:  # quinone next from fork
-                    if next_atom2 in double_bonded:
-                        if atom in pyrroles:  # shit like O=C1C=CC2=CC=CC3=C2P1C(=O)C=C3
-                            stack[-1].append((next_atom1, atom, 1, None))
-                            stack[-1].append((next_atom2, atom, 1, None))
-                        else:  # bad path
-                            del stack[-1]
-                            if stack:
-                                path = path[:stack[-1][-1][-1]]
-                                hashed_path = {x for x, *_ in path}
-                    elif atom in pyrroles:  # O=C1C=CC2=CC=CC3=C2P1C=C3 or O=C1C=CC2=CC=CC3=C2P1=CC=C3
-                        opposite = stack[-1].copy()
-                        opposite.append((next_atom1, atom, 1, None))
-                        opposite.append((next_atom2, atom, 2, None))
-                        stack[-1].append((next_atom1, atom, 1, None))
-                        stack[-1].append((next_atom2, atom, 1, len(path)))
-                        stack.append(opposite)  # pyridine first
-                    else:  # normal condensed ring
-                        stack[-1].append((next_atom1, atom, 1, None))
-                        stack[-1].append((next_atom2, atom, 2, None))
-                elif next_atom2 in double_bonded:  # quinone next from fork
-                    if atom in pyrroles:
-                        opposite = stack[-1].copy()
-                        opposite.append((next_atom2, atom, 1, None))
-                        opposite.append((next_atom1, atom, 2, None))
-                        stack[-1].append((next_atom1, atom, 1, None))
-                        stack[-1].append((next_atom2, atom, 1, len(path)))
-                        stack.append(opposite)
-                    else:
-                        stack[-1].append((next_atom2, atom, 1, None))
-                        stack[-1].append((next_atom1, atom, 2, None))
-                elif atom in pyrroles:  # C1=CC2=CC=CC3=C2P1C=C3 or C1=CP2=CC=CC3=C2C1=CC=C3
-                    opposite1 = stack[-1].copy()
-                    opposite1.append((next_atom2, atom, 1, None))
-                    opposite1.append((next_atom1, atom, 2, len(path)))
-                    opposite2 = stack[-1].copy()
-                    opposite2.append((next_atom1, atom, 1, None))
-                    opposite2.append((next_atom2, atom, 2, None))
-
-                    stack[-1].append((next_atom1, atom, 1, None))
-                    stack[-1].append((next_atom2, atom, 1, len(path)))
-                    stack.append(opposite1)
-                    stack.append(opposite2)
-                else:  # new path
-                    opposite = stack[-1].copy()
-                    stack[-1].append((next_atom1, atom, 1, None))
-                    stack[-1].append((next_atom2, atom, 2, len(path)))  # double bond on top of stack
-                    opposite.append((next_atom2, atom, 1, None))
-                    opposite.append((next_atom1, atom, 2, None))
-                    stack.append(opposite)
-            elif closures and atom not in pyrroles:  # need double bond, but closure should be single bonded
-                del stack[-1]
-                if stack:
-                    path = path[:stack[-1][-1][-1]]
-                    hashed_path = {x for x, *_ in path}
-
-    if nether_yielded:
-        raise InvalidAromaticRing(f'kekule form not found for: {list(rings)}')
-    elif buffer:  # optimal solution not found. return available.
-        yield from buffer
-
-
-__all__ = ['Kekule']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict, deque
+from typing import List, Optional, Tuple, TYPE_CHECKING, Union
+from ._rules import rules
+from ..._functions import lazy_product
+from ...exceptions import InvalidAromaticRing
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+
+class Kekule:
+    __slots__ = ()
+
+    def kekule(self: Union['Kekule', 'MoleculeContainer']) -> bool:
+        """
+        Convert structure to kekule form. Return True if found any aromatic ring. Set implicit hydrogen count and
+        hybridization marks on atoms.
+
+        Only one of possible double/single bonds positions will be set.
+        For enumerate bonds positions use `enumerate_kekule`.
+        """
+        kekule = next(self.__kekule_full(), None)
+        if kekule:
+            bonds = self._bonds
+            atoms = set()
+            for n, m, b in kekule:
+                bonds[n][m]._Bond__order = b
+                atoms.add(n)
+                atoms.add(m)
+            for n in atoms:
+                self._calc_implicit(n)
+            self.flush_cache()
+            return True
+        return False
+
+    def enumerate_kekule(self: Union['Kekule', 'MoleculeContainer']):
+        """
+        Enumerate all possible kekule forms of molecule.
+        """
+        for form in self.__kekule_full():
+            copy = self.copy()
+            bonds = copy._bonds
+            atoms = set()
+            for n, m, b in form:
+                bonds[n][m]._Bond__order = b
+                atoms.add(n)
+                atoms.add(m)
+            for n in atoms:
+                copy._calc_implicit(n)
+            yield copy
+
+    def check_thiele(self, fast=True) -> bool:
+        """
+        Check basic aromaticity errors of molecule.
+
+        :param fast: don't try to solve kekule form
+        """
+        try:
+            if fast:
+                self.__prepare_rings()
+            else:
+                next(self.__kekule_full(), None)
+        except InvalidAromaticRing:
+            return False
+        return True
+
+    def __fix_rings(self: 'MoleculeContainer'):
+        bonds = self._bonds
+        seen = set()
+        for q, af, bf in rules:
+            for mapping in q.get_mapping(self, automorphism_filter=False):
+                match = set(mapping.values())
+                if not match.isdisjoint(seen):  # prevent double patching of atoms
+                    continue
+                seen.update(match)
+
+                for n, fix in af.items():
+                    n = mapping[n]
+                    for key, value in fix.items():
+                        getattr(self, key)[n] = value
+                for n, m, b in bf:
+                    n = mapping[n]
+                    m = mapping[m]
+                    bonds[n][m]._Bond__order = b
+        if seen:
+            self.flush_cache()
+
+    def __prepare_rings(self: 'MoleculeContainer'):
+        atoms = self._atoms
+        charges = self._charges
+        radicals = self._radicals
+        bonds = self._bonds
+        hydrogens = self._hydrogens
+        neighbors = self.neighbors
+
+        rings = defaultdict(list)  # aromatic skeleton
+        pyroles = set()
+
+        double_bonded = defaultdict(list)
+        triple_bonded = set()
+        for n, m_bond in bonds.items():
+            for m, bond in m_bond.items():
+                bo = bond.order
+                if bo == 4:
+                    rings[n].append(m)
+                elif bo == 2:
+                    double_bonded[n].append(m)
+                elif bo == 3:
+                    triple_bonded.add(n)
+
+        if not rings:
+            return rings, pyroles, set()
+        elif not triple_bonded.isdisjoint(rings):
+            raise InvalidAromaticRing('triple bonds connected to rings')
+
+        copy_rings = {n: ms.copy() for n, ms in rings.items()}
+        for r in self.sssr:
+            if set(r).issubset(rings):
+                n, *_, m = r
+                if n not in rings[m]:  # fix invalid structures: c1ccc-cc1
+                    # remove inner ring double bonds: c1ccc=cc1
+                    if n in double_bonded and m in double_bonded and m in double_bonded[n]:
+                        double_bonded[n].remove(m)
+                        double_bonded[m].remove(n)
+                    rings[m].append(n)
+                    rings[n].append(m)
+                elif m in copy_rings[n]:
+                    copy_rings[n].remove(m)
+                    copy_rings[m].remove(n)
+                for n, m in zip(r, r[1:]):
+                    if n not in rings[m]:
+                        if n in double_bonded and m in double_bonded and m in double_bonded[n]:
+                            double_bonded[n].remove(m)
+                            double_bonded[m].remove(n)
+                        rings[m].append(n)
+                        rings[n].append(m)
+                    elif m in copy_rings[n]:
+                        copy_rings[n].remove(m)
+                        copy_rings[m].remove(n)
+
+        # fix invalid smiles: c1ccccc1c2ccccc2 instead of c1ccccc1-c2ccccc2
+        seen = set()
+        for n, ms in copy_rings.items():
+            if ms:
+                seen.add(n)
+                for m in ms:
+                    if m not in seen:
+                        rings[n].remove(m)
+                        rings[m].remove(n)
+                        bonds[n][m]._Bond__order = 1
+
+        if any(len(ms) not in (2, 3) for ms in rings.values()):
+            raise InvalidAromaticRing('not in ring aromatic bond or hypercondensed rings: '
+                                      f'{{{", ".join(str(n) for n, ms in rings.items() if len(ms) not in (2, 3))}}}')
+
+        # get double bonded ring atoms
+        double_bonded = {n for n, ms in double_bonded.items() if ms and n in rings}
+        if any(len(rings[n]) != 2 for n in double_bonded):  # double bonded never condensed
+            raise InvalidAromaticRing('quinone valence error')
+        for n in double_bonded:
+            if atoms[n].atomic_number == 7:
+                if charges[n] != 1:
+                    raise InvalidAromaticRing('quinone should be charged N atom')
+            elif atoms[n].atomic_number not in (6, 15, 16, 33, 34, 52) or charges[n]:
+                raise InvalidAromaticRing('quinone should be neutral S, Se, Te, C, P, As atom')
+
+        for n in rings:
+            an = atoms[n].atomic_number
+            ac = charges[n]
+            ab = neighbors(n)
+            if an == 6:  # carbon
+                if ac == 0:
+                    if ab not in (2, 3):
+                        raise InvalidAromaticRing
+                elif ac in (-1, 1):
+                    if radicals[n]:
+                        if ab == 2:
+                            double_bonded.add(n)
+                        else:
+                            raise InvalidAromaticRing
+                    elif ab == 3:
+                        double_bonded.add(n)
+                    elif ab == 2:  # benzene an[cat]ion or pyrole
+                        pyroles.add(n)
+                    else:
+                        raise InvalidAromaticRing
+                else:
+                    raise InvalidAromaticRing
+            elif an in (7, 15, 33):
+                if ac == 0:  # pyrole or pyridine. include radical pyrole
+                    if radicals[n]:
+                        if ab != 2:
+                            raise InvalidAromaticRing
+                        double_bonded.add(n)
+                    elif ab == 3:
+                        if an == 7:  # pyrole only possible
+                            double_bonded.add(n)
+                        else:  # P(III) or P(V)H
+                            pyroles.add(n)
+                    elif ab == 2:
+                        ah = hydrogens[n]
+                        if ah is None:
+                            pyroles.add(n)
+                        elif ah == 1:  # only pyrole
+                            double_bonded.add(n)
+                        elif ah:
+                            raise InvalidAromaticRing
+                    elif ab != 4 or an not in (15, 33):  # P(V) in ring
+                        raise InvalidAromaticRing
+                elif ac == -1:  # pyrole only
+                    if ab != 2 or radicals[n]:
+                        raise InvalidAromaticRing
+                    double_bonded.add(n)
+                elif ac != 1:
+                    raise InvalidAromaticRing
+                elif radicals[n]:
+                    if ab != 2:  # not cation-radical pyridine
+                        raise InvalidAromaticRing
+                elif ab == 2:  # pyrole cation or protonated pyridine
+                    pyroles.add(n)
+                elif ab != 3:  # not pyridine oxyde
+                    raise InvalidAromaticRing
+            elif an == 8:  # furan
+                if ab == 2:
+                    if ac == 0:
+                        if radicals[n]:
+                            raise InvalidAromaticRing('radical oxygen')
+                        double_bonded.add(n)
+                    elif ac == 1:
+                        if radicals[n]:  # furan cation-radical
+                            double_bonded.add(n)
+                        # pyrylium
+                    else:
+                        raise InvalidAromaticRing('invalid oxygen charge')
+                else:
+                    raise InvalidAromaticRing('Triple-bonded oxygen')
+            elif an in (16, 34, 52):  # thiophene
+                if n not in double_bonded:  # not sulphoxyde or sulphone
+                    if ab == 2:
+                        if radicals[n]:
+                            if ac == 1:
+                                double_bonded.add(n)
+                            else:
+                                raise InvalidAromaticRing('S, Se, Te cation-radical expected')
+                        if ac == 0:
+                            double_bonded.add(n)
+                        elif ac != 1:
+                            raise InvalidAromaticRing('S, Se, Te cation in benzene like ring expected')
+                    elif ab == 3:
+                        if radicals[n]:
+                            if ac:
+                                raise InvalidAromaticRing('S, Se, Te ion-radical ring')
+                            double_bonded.add(n)
+                        elif ac == 1:
+                            double_bonded.add(n)
+                        elif ac:
+                            raise InvalidAromaticRing('S, Se, Te invalid charge ring')
+                    else:
+                        raise InvalidAromaticRing('S, Se, Te hypervalent ring')
+            elif an == 5:  # boron
+                if ac == 0:
+                    if ab == 2:
+                        if radicals[n]:  # C=1O[B]OC=1
+                            double_bonded.add(n)
+                        else:
+                            ah = hydrogens[n]
+                            if ah is None:  # b1ccccc1, C=1OBOC=1 or B1C=CC=N1
+                                pyroles.add(n)
+                            elif ah == 1:  # C=1O[BH]OC=1 or [BH]1C=CC=N1
+                                double_bonded.add(n)
+                            elif ah:
+                                raise InvalidAromaticRing
+                    elif not radicals[n]:
+                        double_bonded.add(n)
+                    else:
+                        raise InvalidAromaticRing
+                elif ac == 1:
+                    if ab == 2 and not radicals[n]:
+                        double_bonded.add(n)
+                    else:
+                        raise InvalidAromaticRing
+                elif ac == -1:
+                    if ab == 2:
+                        if not radicals[n]:  # C=1O[B-]OC=1 or [bH-]1ccccc1
+                            pyroles.add(n)
+                        # anion-radical is benzene like
+                    elif radicals[n]:  # C=1O[B-*](R)OC=1
+                        double_bonded.add(n)
+                    else:
+                        pyroles.add(n)
+                else:
+                    raise InvalidAromaticRing
+            else:
+                raise InvalidAromaticRing(f'only B, C, N, P, O, S, Se, Te possible, not: {atoms[n].atomic_symbol}')
+        return rings, pyroles, double_bonded
+
+    def __kekule_full(self):
+        self.__fix_rings()  # fix bad aromatic rings
+        rings, pyroles, double_bonded = self.__prepare_rings()
+        atoms = set(rings)
+        components = []
+        while atoms:
+            start = atoms.pop()
+            component = {start: rings[start]}
+            queue = deque([start])
+            while queue:
+                current = queue.popleft()
+                for n in rings[current]:
+                    if n not in component:
+                        queue.append(n)
+                        component[n] = rings[n]
+
+            components.append(component)
+            atoms.difference_update(component)
+
+        for keks in lazy_product(*(_kekule_component(c, double_bonded & c.keys(), pyroles & c.keys())
+                                   for c in components)):
+            yield [x for x in keks for x in x]
+
+
+def _kekule_component(rings, double_bonded, pyroles):
+    # (current atom, previous atom, bond between cp atoms, path deep for cutting [None if cut impossible])
+    stack: List[List[Tuple[int, int, int, Optional[int]]]]
+    if double_bonded:  # start from double bonded if exists
+        start = next(iter(double_bonded))
+        stack = [[(next(iter(rings[start])), start, 1, 0)]]
+    else:  # select not pyrole not condensed atom
+        try:
+            start = next(n for n, ms in rings.items() if len(ms) == 2 and n not in pyroles)
+        except StopIteration:  # all pyroles. select not condensed atom.
+            try:
+                start = next(n for n, ms in rings.items() if len(ms) == 2)
+            except StopIteration:  # fullerene?
+                start = next(iter(rings))
+                double_bonded.add(start)
+                stack = [[(next_atom, start, 2, 0)] for next_atom in rings[start]]
+            else:
+                stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
+        else:
+            stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
+
+    size = sum(len(x) for x in rings.values()) // 2
+    path = []
+    hashed_path = set()
+    nether_yielded = True
+
+    while stack:
+        atom, prev_atom, bond, _ = stack[-1].pop()
+        path.append((atom, prev_atom, bond))
+        hashed_path.add(atom)
+
+        if len(path) == size:
+            yield path
+            if nether_yielded:
+                nether_yielded = False
+            del stack[-1]
+            if stack:
+                path = path[:stack[-1][-1][-1]]
+                hashed_path = {x for x, *_ in path}
+        elif atom != start:
+            for_stack = []
+            closures = []
+            loop = 0
+            for next_atom in rings[atom]:
+                if next_atom == prev_atom:  # only forward. behind us is the homeland
+                    continue
+                elif next_atom == start:
+                    loop = next_atom
+                elif next_atom in hashed_path:  # closure found
+                    closures.append(next_atom)
+                else:
+                    for_stack.append(next_atom)
+
+            if loop:  # we found starting point.
+                if bond == 2:  # finish should be single bonded
+                    if double_bonded:  # ok
+                        stack[-1].insert(0, (loop, atom, 1, None))
+                    else:
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                        continue
+                elif double_bonded:  # we in quinone ring. finish should be single bonded
+                    # side-path for storing double bond or atom is quinone or pyrole
+                    if for_stack or atom in double_bonded or atom in pyroles:
+                        stack[-1].insert(0, (loop, atom, 1, None))
+                    else:
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                        continue
+                else:  # finish should be double bonded
+                    stack[-1].insert(0, (loop, atom, 2, None))
+                    bond = 2  # grow should be single bonded
+
+            if bond == 2 or atom in double_bonded:  # double in - single out. quinone has two single bonds
+                for next_atom in closures:
+                    path.append((next_atom, atom, 1))  # closures always single-bonded
+                    stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
+                for next_atom in for_stack:
+                    stack[-1].append((next_atom, atom, 1, None))
+            elif len(for_stack) == 1:  # easy path grow. next bond double or include single for pyroles
+                next_atom = for_stack[0]
+                if next_atom in double_bonded:  # need double bond, but next atom quinone
+                    if atom in pyroles:
+                        stack[-1].append((next_atom, atom, 1, None))
+                    else:
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                else:
+                    if atom in pyroles:  # try pyrole and pyridine
+                        opposite = stack[-1].copy()
+                        opposite.append((next_atom, atom, 2, None))
+                        stack[-1].append((next_atom, atom, 1, len(path)))
+                        stack.append(opposite)
+                    else:
+                        stack[-1].append((next_atom, atom, 2, None))
+                        if closures:
+                            next_atom = closures[0]
+                            path.append((next_atom, atom, 1))  # closures always single-bonded
+                            stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
+            elif for_stack:  # fork
+                next_atom1, next_atom2 = for_stack
+                if next_atom1 in double_bonded:  # quinone next from fork
+                    if next_atom2 in double_bonded:  # bad path
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                    else:
+                        stack[-1].append((next_atom1, atom, 1, None))
+                        stack[-1].append((next_atom2, atom, 2, None))
+                elif next_atom2 in double_bonded:  # quinone next from fork
+                    stack[-1].append((next_atom2, atom, 1, None))
+                    stack[-1].append((next_atom1, atom, 2, None))
+                else:  # new path
+                    opposite = stack[-1].copy()
+                    stack[-1].append((next_atom1, atom, 1, None))
+                    stack[-1].append((next_atom2, atom, 2, len(path)))
+                    opposite.append((next_atom2, atom, 1, None))
+                    opposite.append((next_atom1, atom, 2, None))
+                    stack.append(opposite)
+            elif closures and atom not in pyroles:  # need double bond, but closure should be single bonded
+                del stack[-1]
+                if stack:
+                    path = path[:stack[-1][-1][-1]]
+                    hashed_path = {x for x, *_ in path}
+
+    if nether_yielded:
+        raise InvalidAromaticRing(f'kekule form not found for: {list(rings)}')
+
+
+__all__ = ['Kekule']
```

### Comparing `chython-1.64/chython/algorithms/calculate2d/clean2d.js` & `chython-1.8/chython/algorithms/calculate2d/clean2d.js`

 * *Files 10% similar despite different names*

#### js-beautify {}

```diff
@@ -1,12 +1,47 @@
 ! function(t, e) {
     "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.$ = e() : t.$ = e()
 }(self, (function() {
     return (() => {
         var t = {
+                261: (t, e, i) => {
+                    const r = i(881),
+                        n = i(19),
+                        s = i(479);
+                    var o = !("undefined" == typeof window || !window.document || !window.document.createElement),
+                        a = {
+                            Version: "1.0.0"
+                        };
+                    a.Drawer = r, a.Parser = n, a.SvgDrawer = s, a.clean = function(t) {
+                        return t.replace(/[^A-Za-z0-9@\.\+\-\?!\(\)\[\]\{\}/\\=#\$:\*]/g, "")
+                    }, a.apply = function(t, e = "canvas[data-smiles]", i = "light", n = null) {
+                        let s = new r(t),
+                            o = document.querySelectorAll(e);
+                        for (var h = 0; h < o.length; h++) {
+                            let t = o[h];
+                            a.parse(t.getAttribute("data-smiles"), (function(e) {
+                                s.draw(e, t, i, !1)
+                            }), (function(t) {
+                                n && n(t)
+                            }))
+                        }
+                    }, a.parse = function(t, e, i) {
+                        try {
+                            e && e(n.parse(t))
+                        } catch (t) {
+                            i && i(t)
+                        }
+                    }, o && (window.SmilesDrawer = a), Array.prototype.fill || Object.defineProperty(Array.prototype, "fill", {
+                        value: function(t) {
+                            if (null == this) throw new TypeError("this is null or not defined");
+                            for (var e = Object(this), i = e.length >>> 0, r = arguments[1], n = r >> 0, s = n < 0 ? Math.max(i + n, 0) : Math.min(n, i), o = arguments[2], a = void 0 === o ? i : o >> 0, h = a < 0 ? Math.max(i + a, 0) : Math.min(a, i); s < h;) e[s] = t, s++;
+                            return e
+                        }
+                    }), t.exports = a
+                },
                 348: t => {
                     class e {
                         static clone(t) {
                             let i = Array.isArray(t) ? Array() : {};
                             for (let r in t) {
                                 let n = t[r];
                                 "function" == typeof n.clone ? i[r] = n.clone() : i[r] = "object" == typeof n ? e.clone(n) : n
@@ -124,15 +159,15 @@
                     t.exports = e
                 },
                 427: (t, e, i) => {
                     const r = i(348);
                     i(843), i(421);
                     class n {
                         constructor(t, e = "-") {
-                            this.element = 1 === t.length ? t.toUpperCase() : t, this.drawExplicit = !1, this.ringbonds = Array(), this.rings = Array(), this.bondType = e, this.branchBond = null, this.isBridge = !1, this.isBridgeNode = !1, this.originalRings = Array(), this.bridgedRing = null, this.anchoredRings = Array(), this.bracket = null, this.plane = 0, this.attachedPseudoElements = {}, this.hasAttachedPseudoElements = !1, this.isDrawn = !0, this.isConnectedToRing = !1, this.neighbouringElements = Array(), this.isPartOfAromaticRing = t !== this.element, this.bondCount = 0, this.chirality = "", this.isStereoCenter = !1, this.priority = 0, this.mainChain = !1, this.hydrogenDirection = "down", this.subtreeDepth = 1, this.hasHydrogen = !1, this.class = void 0
+                            this.element = 1 === t.length ? t.toUpperCase() : t, this.drawExplicit = !1, this.ringbonds = Array(), this.rings = Array(), this.bondType = e, this.branchBond = null, this.isBridge = !1, this.isBridgeNode = !1, this.originalRings = Array(), this.bridgedRing = null, this.anchoredRings = Array(), this.bracket = null, this.plane = 0, this.attachedPseudoElements = {}, this.hasAttachedPseudoElements = !1, this.isDrawn = !0, this.isConnectedToRing = !1, this.neighbouringElements = Array(), this.isPartOfAromaticRing = t !== this.element, this.bondCount = 0, this.chirality = "", this.isStereoCenter = !1, this.priority = 0, this.mainChain = !1, this.hydrogenDirection = "down", this.subtreeDepth = 1, this.hasHydrogen = !1
                         }
                         addNeighbouringElement(t) {
                             this.neighbouringElements.push(t)
                         }
                         attachPseudoElement(t, e, i = 0, r = 0) {
                             null === i && (i = 0), null === r && (r = 0);
                             let n = i + t + r;
@@ -490,87 +525,87 @@
                             for (var s = 0; s < t.length; s++) {
                                 if (!t[s].value.isDrawn) continue;
                                 let o = t[s].position;
                                 e < o.x && (e = o.x), i < o.y && (i = o.y), r > o.x && (r = o.x), n > o.y && (n = o.y)
                             }
                             var o = this.opts.padding;
                             e += o, i += o, r -= o, n -= o, this.drawingWidth = e - r, this.drawingHeight = i - n;
-                            var h = this.canvas.offsetWidth / this.drawingWidth,
-                                a = this.canvas.offsetHeight / this.drawingHeight,
-                                l = h < a ? h : a;
-                            this.ctx.scale(l, l), this.offsetX = -r, this.offsetY = -n, h < a ? this.offsetY += this.canvas.offsetHeight / (2 * l) - this.drawingHeight / 2 : this.offsetX += this.canvas.offsetWidth / (2 * l) - this.drawingWidth / 2
+                            var a = this.canvas.offsetWidth / this.drawingWidth,
+                                h = this.canvas.offsetHeight / this.drawingHeight,
+                                l = a < h ? a : h;
+                            this.ctx.scale(l, l), this.offsetX = -r, this.offsetY = -n, a < h ? this.offsetY += this.canvas.offsetHeight / (2 * l) - this.drawingHeight / 2 : this.offsetX += this.canvas.offsetWidth / (2 * l) - this.drawingWidth / 2
                         }
                         reset() {
                             this.ctx.setTransform(1, 0, 0, 1, 0, 0)
                         }
                         getColor(t) {
                             return (t = t.toUpperCase()) in this.colors ? this.colors[t] : this.colors.C
                         }
-                        drawCircle(t, e, i, n, s = !0, o = !1, h = "") {
-                            let a = this.ctx,
+                        drawCircle(t, e, i, n, s = !0, o = !1, a = "") {
+                            let h = this.ctx,
                                 l = this.offsetX,
                                 g = this.offsetY;
-                            a.save(), a.lineWidth = 1.5, a.beginPath(), a.arc(t + l, e + g, i, 0, r.twoPI, !0), a.closePath(), o ? (s ? (a.fillStyle = "#f00", a.fill()) : (a.strokeStyle = "#f00", a.stroke()), this.drawDebugText(t, e, h)) : s ? (a.fillStyle = n, a.fill()) : (a.strokeStyle = n, a.stroke()), a.restore()
+                            h.save(), h.lineWidth = 1.5, h.beginPath(), h.arc(t + l, e + g, i, 0, r.twoPI, !0), h.closePath(), o ? (s ? (h.fillStyle = "#f00", h.fill()) : (h.strokeStyle = "#f00", h.stroke()), this.drawDebugText(t, e, a)) : s ? (h.fillStyle = n, h.fill()) : (h.strokeStyle = n, h.stroke()), h.restore()
                         }
                         drawLine(t, e = !1, i = 1) {
                             let r = this.ctx,
                                 n = this.offsetX,
                                 s = this.offsetY,
                                 o = t.clone().shorten(4),
-                                h = o.getLeftVector().clone(),
-                                a = o.getRightVector().clone();
-                            h.x += n, h.y += s, a.x += n, a.y += s, e || (r.save(), r.globalCompositeOperation = "destination-out", r.beginPath(), r.moveTo(h.x, h.y), r.lineTo(a.x, a.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness + 1.2, r.strokeStyle = this.themeManager.getColor("BACKGROUND"), r.stroke(), r.globalCompositeOperation = "source-over", r.restore()), h = t.getLeftVector().clone(), a = t.getRightVector().clone(), h.x += n, h.y += s, a.x += n, a.y += s, r.save(), r.beginPath(), r.moveTo(h.x, h.y), r.lineTo(a.x, a.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness;
-                            let l = this.ctx.createLinearGradient(h.x, h.y, a.x, a.y);
+                                a = o.getLeftVector().clone(),
+                                h = o.getRightVector().clone();
+                            a.x += n, a.y += s, h.x += n, h.y += s, e || (r.save(), r.globalCompositeOperation = "destination-out", r.beginPath(), r.moveTo(a.x, a.y), r.lineTo(h.x, h.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness + 1.2, r.strokeStyle = this.themeManager.getColor("BACKGROUND"), r.stroke(), r.globalCompositeOperation = "source-over", r.restore()), a = t.getLeftVector().clone(), h = t.getRightVector().clone(), a.x += n, a.y += s, h.x += n, h.y += s, r.save(), r.beginPath(), r.moveTo(a.x, a.y), r.lineTo(h.x, h.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness;
+                            let l = this.ctx.createLinearGradient(a.x, a.y, h.x, h.y);
                             l.addColorStop(.4, this.themeManager.getColor(t.getLeftElement()) || this.themeManager.getColor("C")), l.addColorStop(.6, this.themeManager.getColor(t.getRightElement()) || this.themeManager.getColor("C")), e && (r.setLineDash([1, 1.5]), r.lineWidth = this.opts.bondThickness / 1.5), i < 1 && (r.globalAlpha = i), r.strokeStyle = l, r.stroke(), r.restore()
                         }
                         drawWedge(t, e = 1) {
                             if (isNaN(t.from.x) || isNaN(t.from.y) || isNaN(t.to.x) || isNaN(t.to.y)) return;
                             let i = this.ctx,
                                 r = this.offsetX,
                                 s = this.offsetY,
                                 o = t.clone().shorten(5),
-                                h = o.getLeftVector().clone(),
-                                a = o.getRightVector().clone();
-                            h.x += r, h.y += s, a.x += r, a.y += s, h = t.getLeftVector().clone(), a = t.getRightVector().clone(), h.x += r, h.y += s, a.x += r, a.y += s, i.save();
-                            let l = n.normals(h, a);
+                                a = o.getLeftVector().clone(),
+                                h = o.getRightVector().clone();
+                            a.x += r, a.y += s, h.x += r, h.y += s, a = t.getLeftVector().clone(), h = t.getRightVector().clone(), a.x += r, a.y += s, h.x += r, h.y += s, i.save();
+                            let l = n.normals(a, h);
                             l[0].normalize(), l[1].normalize();
-                            let g = h,
-                                d = a;
-                            t.getRightChiral() && (g = a, d = h);
+                            let g = a,
+                                d = h;
+                            t.getRightChiral() && (g = h, d = a);
                             let u = n.add(g, n.multiplyScalar(l[0], this.halfBondThickness)),
                                 c = n.add(d, n.multiplyScalar(l[0], 1.5 + this.halfBondThickness)),
                                 p = n.add(d, n.multiplyScalar(l[1], 1.5 + this.halfBondThickness)),
                                 f = n.add(g, n.multiplyScalar(l[1], this.halfBondThickness));
                             i.beginPath(), i.moveTo(u.x, u.y), i.lineTo(c.x, c.y), i.lineTo(p.x, p.y), i.lineTo(f.x, f.y);
-                            let v = this.ctx.createRadialGradient(a.x, a.y, this.opts.bondLength, a.x, a.y, 0);
+                            let v = this.ctx.createRadialGradient(h.x, h.y, this.opts.bondLength, h.x, h.y, 0);
                             v.addColorStop(.4, this.themeManager.getColor(t.getLeftElement()) || this.themeManager.getColor("C")), v.addColorStop(.6, this.themeManager.getColor(t.getRightElement()) || this.themeManager.getColor("C")), i.fillStyle = v, i.fill(), i.restore()
                         }
                         drawDashedWedge(t) {
                             if (isNaN(t.from.x) || isNaN(t.from.y) || isNaN(t.to.x) || isNaN(t.to.y)) return;
                             let e = this.ctx,
                                 i = this.offsetX,
                                 r = this.offsetY,
                                 s = t.getLeftVector().clone(),
                                 o = t.getRightVector().clone();
                             s.x += i, s.y += r, o.x += i, o.y += r, e.save();
-                            let h = n.normals(s, o);
-                            h[0].normalize(), h[1].normalize();
-                            let a, l, g, d, u = t.getRightChiral(),
+                            let a = n.normals(s, o);
+                            a[0].normalize(), a[1].normalize();
+                            let h, l, g, d, u = t.getRightChiral(),
                                 c = t.clone();
-                            u ? (a = o, l = s, c.shortenRight(1), g = c.getRightVector().clone(), d = c.getLeftVector().clone()) : (a = s, l = o, c.shortenLeft(1), g = c.getLeftVector().clone(), d = c.getRightVector().clone()), g.x += i, g.y += r, d.x += i, d.y += r;
-                            let p = n.subtract(l, a).normalize();
+                            u ? (h = o, l = s, c.shortenRight(1), g = c.getRightVector().clone(), d = c.getLeftVector().clone()) : (h = s, l = o, c.shortenLeft(1), g = c.getLeftVector().clone(), d = c.getRightVector().clone()), g.x += i, g.y += r, d.x += i, d.y += r;
+                            let p = n.subtract(l, h).normalize();
                             e.strokeStyle = this.themeManager.getColor("C"), e.lineCap = "round", e.lineWidth = this.opts.bondThickness, e.beginPath();
                             let f = t.getLength(),
                                 v = 1.25 / (f / (3 * this.opts.bondThickness)),
                                 m = !1;
                             for (var b = 0; b < 1; b += v) {
                                 let i = n.multiplyScalar(p, b * f),
-                                    r = n.add(a, i),
+                                    r = n.add(h, i),
                                     s = 1.5 * b,
-                                    o = n.multiplyScalar(h[0], s);
+                                    o = n.multiplyScalar(a[0], s);
                                 !m && b > .5 && (e.stroke(), e.beginPath(), e.strokeStyle = this.themeManager.getColor(t.getRightElement()) || this.themeManager.getColor("C"), m = !0), r.subtract(o), e.moveTo(r.x, r.y), r.add(n.multiplyScalar(o, 2)), e.lineTo(r.x, r.y)
                             }
                             e.stroke(), e.restore()
                         }
                         drawDebugText(t, e, i) {
                             let r = this.ctx;
                             r.save(), r.font = "5px Droid Sans, sans-serif", r.textAlign = "start", r.textBaseline = "top", r.fillStyle = "#ff0000", r.fillText(i, t + this.offsetX, e + this.offsetY), r.restore()
@@ -581,70 +616,70 @@
                         }
                         drawPoint(t, e, i) {
                             let n = this.ctx,
                                 s = this.offsetX,
                                 o = this.offsetY;
                             n.save(), n.globalCompositeOperation = "destination-out", n.beginPath(), n.arc(t + s, e + o, 1.5, 0, r.twoPI, !0), n.closePath(), n.fill(), n.globalCompositeOperation = "source-over", n.beginPath(), n.arc(t + this.offsetX, e + this.offsetY, .75, 0, r.twoPI, !1), n.fillStyle = this.themeManager.getColor(i), n.fill(), n.restore()
                         }
-                        drawText(t, e, i, n, o, h, a, l, g, d = {}) {
-                            let u = this.ctx,
-                                c = this.offsetX,
-                                p = this.offsetY;
-                            u.save(), u.textAlign = "start", u.textBaseline = "alphabetic";
-                            let f = "",
-                                v = 0;
-                            a && (f = s(a), u.font = this.fontSmall, v = u.measureText(f).width);
-                            let m = "0",
-                                b = 0;
-                            l > 0 && (m = l.toString(), u.font = this.fontSmall, b = u.measureText(m).width), 1 === a && "N" === i && d.hasOwnProperty("0O") && d.hasOwnProperty("0O-1") && (d = {
+                        drawText(t, e, i, n, o, a, h, l, g = {}) {
+                            let d = this.ctx,
+                                u = this.offsetX,
+                                c = this.offsetY;
+                            d.save(), d.textAlign = "start", d.textBaseline = "alphabetic";
+                            let p = "",
+                                f = 0;
+                            h && (p = s(h), d.font = this.fontSmall, f = d.measureText(p).width);
+                            let v = "0",
+                                m = 0;
+                            l > 0 && (v = l.toString(), d.font = this.fontSmall, m = d.measureText(v).width), 1 === h && "N" === i && g.hasOwnProperty("0O") && g.hasOwnProperty("0O-1") && (g = {
                                 "0O": {
                                     element: "O",
                                     count: 2,
                                     hydrogenCount: 0,
                                     previousElement: "C",
                                     charge: ""
                                 }
-                            }, a = 0), u.font = this.fontLarge, u.fillStyle = this.themeManager.getColor("BACKGROUND");
-                            let y = u.measureText(i);
-                            y.totalWidth = y.width + v, y.height = parseInt(this.fontLarge, 10);
-                            let x = y.width > this.opts.fontSizeLarge ? y.width : this.opts.fontSizeLarge;
-                            x /= 1.5, u.globalCompositeOperation = "destination-out", u.beginPath(), u.arc(t + c, e + p, x, 0, r.twoPI, !0), u.closePath(), u.fill(), u.globalCompositeOperation = "source-over";
-                            let S = -y.width / 2,
-                                A = -y.width / 2;
-                            u.fillStyle = this.themeManager.getColor(i), u.fillText(i, t + c + S, e + this.opts.halfFontSizeLarge + p), S += y.width, a && (u.font = this.fontSmall, u.fillText(f, t + c + S, e - this.opts.fifthFontSizeSmall + p), S += v), l > 0 && (u.font = this.fontSmall, u.fillText(m, t + c + A - b, e - this.opts.fifthFontSizeSmall + p), A -= b), u.font = this.fontLarge;
-                            let C = 0,
-                                R = 0;
+                            }, h = 0), d.font = this.fontLarge, d.fillStyle = this.themeManager.getColor("BACKGROUND");
+                            let b = d.measureText(i);
+                            b.totalWidth = b.width + f, b.height = parseInt(this.fontLarge, 10);
+                            let y = b.width > this.opts.fontSizeLarge ? b.width : this.opts.fontSizeLarge;
+                            y /= 1.5, d.globalCompositeOperation = "destination-out", d.beginPath(), d.arc(t + u, e + c, y, 0, r.twoPI, !0), d.closePath(), d.fill(), d.globalCompositeOperation = "source-over";
+                            let S = -b.width / 2,
+                                w = -b.width / 2;
+                            d.fillStyle = this.themeManager.getColor(i), d.fillText(i, t + u + S, e + this.opts.halfFontSizeLarge + c), S += b.width, h && (d.font = this.fontSmall, d.fillText(p, t + u + S, e - this.opts.fifthFontSizeSmall + c), S += f), l > 0 && (d.font = this.fontSmall, d.fillText(v, t + u + w - m, e - this.opts.fifthFontSizeSmall + c), w -= m), d.font = this.fontLarge;
+                            let x = 0,
+                                A = 0;
                             if (1 === n) {
-                                let i = t + c,
-                                    r = e + p + this.opts.halfFontSizeLarge;
-                                C = this.hydrogenWidth, A -= C, "left" === o ? i += A : "right" === o || "up" === o && h || "down" === o && h ? i += S : "up" !== o || h ? "down" !== o || h || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), u.fillText("H", i, r), S += C
+                                let i = t + u,
+                                    r = e + c + this.opts.halfFontSizeLarge;
+                                x = this.hydrogenWidth, w -= x, "left" === o ? i += w : "right" === o || "up" === o && a || "down" === o && a ? i += S : "up" !== o || a ? "down" !== o || a || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), d.fillText("H", i, r), S += x
                             } else if (n > 1) {
-                                let i = t + c,
-                                    r = e + p + this.opts.halfFontSizeLarge;
-                                C = this.hydrogenWidth, u.font = this.fontSmall, R = u.measureText(n).width, A -= C + R, "left" === o ? i += A : "right" === o || "up" === o && h || "down" === o && h ? i += S : "up" !== o || h ? "down" !== o || h || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), u.font = this.fontLarge, u.fillText("H", i, r), u.font = this.fontSmall, u.fillText(n, i + this.halfHydrogenWidth + R, r + this.opts.fifthFontSizeSmall), S += C + this.halfHydrogenWidth + R
+                                let i = t + u,
+                                    r = e + c + this.opts.halfFontSizeLarge;
+                                x = this.hydrogenWidth, d.font = this.fontSmall, A = d.measureText(n).width, w -= x + A, "left" === o ? i += w : "right" === o || "up" === o && a || "down" === o && a ? i += S : "up" !== o || a ? "down" !== o || a || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), d.font = this.fontLarge, d.fillText("H", i, r), d.font = this.fontSmall, d.fillText(n, i + this.halfHydrogenWidth + A, r + this.opts.fifthFontSizeSmall), S += x + this.halfHydrogenWidth + A
                             }
-                            for (let i in d) {
-                                if (!d.hasOwnProperty(i)) continue;
+                            for (let i in g) {
+                                if (!g.hasOwnProperty(i)) continue;
                                 let r = 0,
                                     n = 0,
-                                    h = d[i].element,
-                                    a = d[i].count,
-                                    l = d[i].hydrogenCount,
-                                    g = d[i].charge;
-                                u.font = this.fontLarge, a > 1 && l > 0 && (r = u.measureText("(").width, n = u.measureText(")").width);
-                                let f = u.measureText(h).width,
+                                    a = g[i].element,
+                                    h = g[i].count,
+                                    l = g[i].hydrogenCount,
+                                    p = g[i].charge;
+                                d.font = this.fontLarge, h > 1 && l > 0 && (r = d.measureText("(").width, n = d.measureText(")").width);
+                                let f = d.measureText(a).width,
                                     v = 0,
                                     m = "",
                                     b = 0;
-                                C = 0, l > 0 && (C = this.hydrogenWidth), u.font = this.fontSmall, a > 1 && (v = u.measureText(a).width), 0 !== g && (m = s(g), b = u.measureText(m).width), R = 0, l > 1 && (R = u.measureText(l).width), u.font = this.fontLarge;
-                                let y = t + c,
-                                    x = e + p + this.opts.halfFontSizeLarge;
-                                u.fillStyle = this.themeManager.getColor(h), a > 0 && (A -= v), a > 1 && l > 0 && ("left" === o ? (A -= n, u.fillText(")", y + A, x)) : (u.fillText("(", y + S, x), S += r)), "left" === o ? (A -= f, u.fillText(h, y + A, x)) : (u.fillText(h, y + S, x), S += f), l > 0 && ("left" === o ? (A -= C + R, u.fillText("H", y + A, x), l > 1 && (u.font = this.fontSmall, u.fillText(l, y + A + C, x + this.opts.fifthFontSizeSmall))) : (u.fillText("H", y + S, x), S += C, l > 1 && (u.font = this.fontSmall, u.fillText(l, y + S, x + this.opts.fifthFontSizeSmall), S += R))), u.font = this.fontLarge, a > 1 && l > 0 && ("left" === o ? (A -= r, u.fillText("(", y + A, x)) : (u.fillText(")", y + S, x), S += n)), u.font = this.fontSmall, a > 1 && ("left" === o ? u.fillText(a, y + A + r + n + C + R + f, x + this.opts.fifthFontSizeSmall) : (u.fillText(a, y + S, x + this.opts.fifthFontSizeSmall), S += v)), 0 !== g && ("left" === o ? u.fillText(m, y + A + r + n + C + R + f, e - this.opts.fifthFontSizeSmall + p) : (u.fillText(m, y + S, e - this.opts.fifthFontSizeSmall + p), S += b))
+                                x = 0, l > 0 && (x = this.hydrogenWidth), d.font = this.fontSmall, h > 1 && (v = d.measureText(h).width), 0 !== p && (m = s(p), b = d.measureText(m).width), A = 0, l > 1 && (A = d.measureText(l).width), d.font = this.fontLarge;
+                                let y = t + u,
+                                    C = e + c + this.opts.halfFontSizeLarge;
+                                d.fillStyle = this.themeManager.getColor(a), h > 0 && (w -= v), h > 1 && l > 0 && ("left" === o ? (w -= n, d.fillText(")", y + w, C)) : (d.fillText("(", y + S, C), S += r)), "left" === o ? (w -= f, d.fillText(a, y + w, C)) : (d.fillText(a, y + S, C), S += f), l > 0 && ("left" === o ? (w -= x + A, d.fillText("H", y + w, C), l > 1 && (d.font = this.fontSmall, d.fillText(l, y + w + x, C + this.opts.fifthFontSizeSmall))) : (d.fillText("H", y + S, C), S += x, l > 1 && (d.font = this.fontSmall, d.fillText(l, y + S, C + this.opts.fifthFontSizeSmall), S += A))), d.font = this.fontLarge, h > 1 && l > 0 && ("left" === o ? (w -= r, d.fillText("(", y + w, C)) : (d.fillText(")", y + S, C), S += n)), d.font = this.fontSmall, h > 1 && ("left" === o ? d.fillText(h, y + w + r + n + x + A + f, C + this.opts.fifthFontSizeSmall) : (d.fillText(h, y + S, C + this.opts.fifthFontSizeSmall), S += v)), 0 !== p && ("left" === o ? d.fillText(m, y + w + r + n + x + A + f, e - this.opts.fifthFontSizeSmall + c) : (d.fillText(m, y + S, e - this.opts.fifthFontSizeSmall + c), S += b))
                             }
-                            u.restore()
+                            d.restore()
                         }
                         getChargeText(t) {
                             return 1 === t ? "+" : 2 === t ? "2+" : -1 === t ? "-" : -2 === t ? "2-" : ""
                         }
                         drawDebugPoint(t, e, i = "", r = "#f00") {
                             this.drawCircle(t, e, 2, r, !0, !0, i)
                         }
@@ -654,50 +689,47 @@
                             e.save(), e.strokeStyle = this.themeManager.getColor("C"), e.lineWidth = this.opts.bondThickness, e.beginPath(), e.arc(t.center.x + this.offsetX, t.center.y + this.offsetY, i - this.opts.bondSpacing, 0, 2 * Math.PI, !0), e.closePath(), e.stroke(), e.restore()
                         }
                         clear() {
                             this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight)
                         }
                     }
                 },
-                237: (t, e, i) => {
+                881: (t, e, i) => {
                     const r = i(474),
                         n = i(348),
                         s = i(614),
                         o = i(929),
-                        h = (i(843), i(826)),
-                        a = i(427),
+                        a = (i(843), i(826)),
+                        h = i(427),
                         l = i(421),
                         g = i(333),
                         d = i(841),
                         u = i(707),
                         c = i(473),
-                        p = i(654),
-                        f = i(207);
+                        p = i(654);
                     t.exports = class {
                         constructor(t) {
                             this.graph = null, this.doubleBondConfigCount = 0, this.doubleBondConfig = null, this.ringIdCounter = 0, this.ringConnectionIdCounter = 0, this.canvasWrapper = null, this.totalOverlapScore = 0, this.defaultOptions = {
                                 width: 500,
                                 height: 500,
-                                scale: 0,
-                                bondThickness: 1,
-                                bondLength: 30,
-                                shortBondLength: .8,
-                                bondSpacing: .17 * 30,
+                                bondThickness: .6,
+                                bondLength: 15,
+                                shortBondLength: .85,
+                                bondSpacing: .18 * 15,
                                 atomVisualization: "default",
                                 isomeric: !0,
                                 debug: !1,
                                 terminalCarbons: !1,
                                 explicitHydrogens: !0,
                                 overlapSensitivity: .42,
                                 overlapResolutionIterations: 1,
                                 compactDrawing: !0,
-                                fontFamily: "Arial, Helvetica, sans-serif",
-                                fontSizeLarge: 11,
+                                fontSizeLarge: 5,
                                 fontSizeSmall: 3,
-                                padding: 10,
+                                padding: 20,
                                 experimentalSSSR: !1,
                                 kkThreshold: .1,
                                 kkInnerThreshold: .1,
                                 kkMaxIteration: 2e4,
                                 kkMaxInnerIteration: 50,
                                 kkMaxEnergy: 1e9,
                                 themes: {
@@ -709,184 +741,47 @@
                                         CL: "#16a085",
                                         BR: "#d35400",
                                         I: "#8e44ad",
                                         P: "#d35400",
                                         S: "#f1c40f",
                                         B: "#e67e22",
                                         SI: "#e67e22",
-                                        H: "#aaa",
+                                        H: "#fff",
                                         BACKGROUND: "#141414"
                                     },
                                     light: {
                                         C: "#222",
                                         O: "#e74c3c",
                                         N: "#3498db",
                                         F: "#27ae60",
                                         CL: "#16a085",
                                         BR: "#d35400",
                                         I: "#8e44ad",
                                         P: "#d35400",
                                         S: "#f1c40f",
                                         B: "#e67e22",
                                         SI: "#e67e22",
-                                        H: "#666",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    oldschool: {
-                                        C: "#000",
-                                        O: "#000",
-                                        N: "#000",
-                                        F: "#000",
-                                        CL: "#000",
-                                        BR: "#000",
-                                        I: "#000",
-                                        P: "#000",
-                                        S: "#000",
-                                        B: "#000",
-                                        SI: "#000",
-                                        H: "#000",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    solarized: {
-                                        C: "#586e75",
-                                        O: "#dc322f",
-                                        N: "#268bd2",
-                                        F: "#859900",
-                                        CL: "#16a085",
-                                        BR: "#cb4b16",
-                                        I: "#6c71c4",
-                                        P: "#d33682",
-                                        S: "#b58900",
-                                        B: "#2aa198",
-                                        SI: "#2aa198",
-                                        H: "#657b83",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    "solarized-dark": {
-                                        C: "#93a1a1",
-                                        O: "#dc322f",
-                                        N: "#268bd2",
-                                        F: "#859900",
-                                        CL: "#16a085",
-                                        BR: "#cb4b16",
-                                        I: "#6c71c4",
-                                        P: "#d33682",
-                                        S: "#b58900",
-                                        B: "#2aa198",
-                                        SI: "#2aa198",
-                                        H: "#839496",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    matrix: {
-                                        C: "#678c61",
-                                        O: "#2fc079",
-                                        N: "#4f7e7e",
-                                        F: "#90d762",
-                                        CL: "#82d967",
-                                        BR: "#23755a",
-                                        I: "#409931",
-                                        P: "#c1ff8a",
-                                        S: "#faff00",
-                                        B: "#50b45a",
-                                        SI: "#409931",
-                                        H: "#426644",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    github: {
-                                        C: "#24292f",
-                                        O: "#cf222e",
-                                        N: "#0969da",
-                                        F: "#2da44e",
-                                        CL: "#6fdd8b",
-                                        BR: "#bc4c00",
-                                        I: "#8250df",
-                                        P: "#bf3989",
-                                        S: "#d4a72c",
-                                        B: "#fb8f44",
-                                        SI: "#bc4c00",
-                                        H: "#57606a",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    carbon: {
-                                        C: "#161616",
-                                        O: "#da1e28",
-                                        N: "#0f62fe",
-                                        F: "#198038",
-                                        CL: "#007d79",
-                                        BR: "#fa4d56",
-                                        I: "#8a3ffc",
-                                        P: "#ff832b",
-                                        S: "#f1c21b",
-                                        B: "#8a3800",
-                                        SI: "#e67e22",
-                                        H: "#525252",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    cyberpunk: {
-                                        C: "#ea00d9",
-                                        O: "#ff3131",
-                                        N: "#0abdc6",
-                                        F: "#00ff9f",
-                                        CL: "#00fe00",
-                                        BR: "#fe9f20",
-                                        I: "#ff00ff",
-                                        P: "#fe7f00",
-                                        S: "#fcee0c",
-                                        B: "#ff00ff",
-                                        SI: "#ffffff",
-                                        H: "#913cb1",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    gruvbox: {
-                                        C: "#665c54",
-                                        O: "#cc241d",
-                                        N: "#458588",
-                                        F: "#98971a",
-                                        CL: "#79740e",
-                                        BR: "#d65d0e",
-                                        I: "#b16286",
-                                        P: "#af3a03",
-                                        S: "#d79921",
-                                        B: "#689d6a",
-                                        SI: "#427b58",
-                                        H: "#7c6f64",
-                                        BACKGROUND: "#fbf1c7"
-                                    },
-                                    "gruvbox-dark": {
-                                        C: "#ebdbb2",
-                                        O: "#cc241d",
-                                        N: "#458588",
-                                        F: "#98971a",
-                                        CL: "#b8bb26",
-                                        BR: "#d65d0e",
-                                        I: "#b16286",
-                                        P: "#fe8019",
-                                        S: "#d79921",
-                                        B: "#8ec07c",
-                                        SI: "#83a598",
-                                        H: "#bdae93",
-                                        BACKGROUND: "#282828"
-                                    },
-                                    custom: {
-                                        C: "#222",
-                                        O: "#e74c3c",
-                                        N: "#3498db",
-                                        F: "#27ae60",
-                                        CL: "#16a085",
-                                        BR: "#d35400",
-                                        I: "#8e44ad",
-                                        P: "#d35400",
-                                        S: "#f1c40f",
-                                        B: "#e67e22",
-                                        SI: "#e67e22",
-                                        H: "#666",
+                                        H: "#222",
                                         BACKGROUND: "#fff"
                                     }
                                 }
-                            }, this.opts = f.extend(!0, this.defaultOptions, t), this.opts.halfBondSpacing = this.opts.bondSpacing / 2, this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength, this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2, this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4, this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5, this.theme = this.opts.themes.dark
+                            }, this.opts = this.extend(!0, this.defaultOptions, t), this.opts.halfBondSpacing = this.opts.bondSpacing / 2, this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength, this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2, this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4, this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5, this.theme = this.opts.themes.dark
+                        }
+                        extend() {
+                            let t = this,
+                                e = {},
+                                i = !1,
+                                r = 0,
+                                n = arguments.length;
+                            "[object Boolean]" === Object.prototype.toString.call(arguments[0]) && (i = arguments[0], r++);
+                            let s = function(r) {
+                                for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (i && "[object Object]" === Object.prototype.toString.call(r[n]) ? e[n] = t.extend(!0, e[n], r[n]) : e[n] = r[n])
+                            };
+                            for (; r < n; r++) s(arguments[r]);
+                            return e
                         }
                         draw(t, e, i = "light", r = !1) {
                             this.initDraw(t, i, r), this.infoOnly || (this.themeManager = new p(this.opts.themes, i), this.canvasWrapper = new d(e, this.themeManager, this.opts)), r || (this.processGraph(), this.canvasWrapper.scale(this.graph.vertices), this.drawEdges(this.opts.debug), this.drawVertices(this.opts.debug), this.canvasWrapper.reset(), this.opts.debug && (console.log(this.graph), console.log(this.rings), console.log(this.ringConnections)))
                         }
                         edgeRingCount(t) {
                             let e = this.graph.edges[t],
                                 i = this.graph.vertices[e.sourceId],
@@ -922,16 +817,16 @@
                                 i = 0;
                             for (var r = 0; r < this.graph.vertices.length; r++) {
                                 let s = this.graph.vertices[r];
                                 if (s.value.isDrawn)
                                     for (var n = r + 1; n < this.graph.vertices.length; n++) {
                                         let o = this.graph.vertices[n];
                                         if (!o.value.isDrawn) continue;
-                                        let h = s.position.distanceSq(o.position);
-                                        h > i && (i = h, t = r, e = n)
+                                        let a = s.position.distanceSq(o.position);
+                                        a > i && (i = a, t = r, e = n)
                                     }
                             }
                             let o = -s.subtract(this.graph.vertices[t].position, this.graph.vertices[e].position).angle();
                             if (!isNaN(o)) {
                                 let t = o % .523599;
                                 for (t < .2617995 ? o -= t : o += .523599 - t, r = 0; r < this.graph.vertices.length; r++) r !== e && this.graph.vertices[r].position.rotateAround(o, this.graph.vertices[e].position);
                                 for (r = 0; r < this.rings.length; r++) this.rings[r].center.rotateAround(o, this.graph.vertices[e].position)
@@ -947,49 +842,48 @@
                             return this.bridgedRing
                         }
                         getHeavyAtomCount() {
                             let t = 0;
                             for (var e = 0; e < this.graph.vertices.length; e++) "H" !== this.graph.vertices[e].value.element && t++;
                             return t
                         }
-                        getMolecularFormula(t = null) {
-                            let e = "",
-                                i = new Map,
-                                r = null === t ? this.graph : new u(t, this.opts.isomeric);
-                            for (var n = 0; n < r.vertices.length; n++) {
-                                let t = r.vertices[n].value;
-                                if (i.has(t.element) ? i.set(t.element, i.get(t.element) + 1) : i.set(t.element, 1), t.bracket && !t.bracket.chirality && (i.has("H") ? i.set("H", i.get("H") + t.bracket.hcount) : i.set("H", t.bracket.hcount)), !t.bracket) {
-                                    let e = a.maxBonds[t.element] - t.bondCount;
-                                    t.isPartOfAromaticRing && e--, i.has("H") ? i.set("H", i.get("H") + e) : i.set("H", e)
-                                }
-                            }
-                            if (i.has("C")) {
-                                let t = i.get("C");
-                                e += "C" + (t > 1 ? t : ""), i.delete("C")
-                            }
-                            if (i.has("H")) {
-                                let t = i.get("H");
-                                e += "H" + (t > 1 ? t : ""), i.delete("H")
-                            }
-                            return Object.keys(a.atomicNumbers).sort().map((t => {
-                                if (i.has(t)) {
-                                    let r = i.get(t);
-                                    e += t + (r > 1 ? r : "")
+                        getMolecularFormula() {
+                            let t = "",
+                                e = new Map;
+                            for (var i = 0; i < this.graph.vertices.length; i++) {
+                                let t = this.graph.vertices[i].value;
+                                if (e.has(t.element) ? e.set(t.element, e.get(t.element) + 1) : e.set(t.element, 1), t.bracket && !t.bracket.chirality && (e.has("H") ? e.set("H", e.get("H") + t.bracket.hcount) : e.set("H", t.bracket.hcount)), !t.bracket) {
+                                    let i = h.maxBonds[t.element] - t.bondCount;
+                                    t.isPartOfAromaticRing && i--, e.has("H") ? e.set("H", e.get("H") + i) : e.set("H", i)
+                                }
+                            }
+                            if (e.has("C")) {
+                                let i = e.get("C");
+                                t += "C" + (i > 1 ? i : ""), e.delete("C")
+                            }
+                            if (e.has("H")) {
+                                let i = e.get("H");
+                                t += "H" + (i > 1 ? i : ""), e.delete("H")
+                            }
+                            return Object.keys(h.atomicNumbers).sort().map((i => {
+                                if (e.has(i)) {
+                                    let r = e.get(i);
+                                    t += i + (r > 1 ? r : "")
                                 }
-                            })), e
+                            })), t
                         }
                         getRingbondType(t, e) {
                             if (t.value.getRingbondCount() < 1 || e.value.getRingbondCount() < 1) return null;
                             for (var i = 0; i < t.value.ringbonds.length; i++)
                                 for (var r = 0; r < e.value.ringbonds.length; r++)
                                     if (t.value.ringbonds[i].id === e.value.ringbonds[r].id) return "-" === t.value.ringbonds[i].bondType ? e.value.ringbonds[r].bond : t.value.ringbonds[i].bond;
                             return null
                         }
-                        initDraw(t, e, i, r) {
-                            this.data = t, this.infoOnly = i, this.ringIdCounter = 0, this.ringConnectionIdCounter = 0, this.graph = new u(t, this.opts.isomeric), this.rings = Array(), this.ringConnections = Array(), this.originalRings = Array(), this.originalRingConnections = Array(), this.bridgedRing = !1, this.doubleBondConfigCount = null, this.doubleBondConfig = null, this.highlight_atoms = r, this.initRings(), this.initHydrogens()
+                        initDraw(t, e, i) {
+                            this.data = t, this.infoOnly = i, this.ringIdCounter = 0, this.ringConnectionIdCounter = 0, this.graph = new u(t, this.opts.isomeric), this.rings = Array(), this.ringConnections = Array(), this.originalRings = Array(), this.originalRingConnections = Array(), this.bridgedRing = !1, this.doubleBondConfigCount = null, this.doubleBondConfig = null, this.initRings(), this.initHydrogens()
                         }
                         processGraph() {
                             this.position(), this.restoreRingInformation(), this.resolvePrimaryOverlaps();
                             let t = this.getOverlapScore();
                             this.totalOverlapScore = this.getOverlapScore().total;
                             for (var e = 0; e < this.opts.overlapResolutionIterations; e++)
                                 for (var i = 0; i < this.graph.edges.length; i++) {
@@ -1016,16 +910,16 @@
                                                 if (1 === t.value.rings.length && 1 === s.value.rings.length) {
                                                     if (t.value.rings[0] !== s.value.rings[0]) continue
                                                 } else {
                                                     if (0 !== t.value.rings.length || 0 !== s.value.rings.length) continue; {
                                                         let n = t.position.getRotateAwayFromAngle(e.position, i.position, r.toRad(120)),
                                                             o = s.position.getRotateAwayFromAngle(e.position, i.position, r.toRad(120));
                                                         this.rotateSubtree(t.id, i.id, n, i.position), this.rotateSubtree(s.id, i.id, o, i.position);
-                                                        let h = this.getOverlapScore().total;
-                                                        h > this.totalOverlapScore ? (this.rotateSubtree(t.id, i.id, -n, i.position), this.rotateSubtree(s.id, i.id, -o, i.position)) : this.totalOverlapScore = h
+                                                        let a = this.getOverlapScore().total;
+                                                        a > this.totalOverlapScore ? (this.rotateSubtree(t.id, i.id, -n, i.position), this.rotateSubtree(s.id, i.id, -o, i.position)) : this.totalOverlapScore = a
                                                     }
                                                 }
                                             }
                                             t = this.getOverlapScore()
                                         }
                                     }
                                 }
@@ -1038,17 +932,17 @@
                                 if (0 !== r.value.ringbonds.length)
                                     for (var i = 0; i < r.value.ringbonds.length; i++) {
                                         let e = r.value.ringbonds[i].id,
                                             n = r.value.ringbonds[i].bond;
                                         if (t.has(e)) {
                                             let s = r.id,
                                                 o = t.get(e)[0],
-                                                a = t.get(e)[1],
-                                                l = new h(s, o, 1);
-                                            l.setBondType(a || n || "-");
+                                                h = t.get(e)[1],
+                                                l = new a(s, o, 1);
+                                            l.setBondType(h || n || "-");
                                             let g = this.graph.addEdge(l),
                                                 d = this.graph.vertices[o];
                                             r.addRingbondChild(o, i), r.value.addNeighbouringElement(d.value.element), d.addRingbondChild(s, i), d.value.addNeighbouringElement(r.value.element), r.edges.push(g), d.edges.push(g), t.delete(e)
                                         } else t.set(e, [r.id, n])
                                     }
                             }
                             let r = c.getRings(this.graph, this.opts.experimentalSSSR);
@@ -1115,46 +1009,46 @@
                         createBridgedRing(t, e) {
                             let i = new Set,
                                 r = new Set,
                                 s = new Set;
                             for (var o = 0; o < t.length; o++) {
                                 let e = this.getRing(t[o]);
                                 e.isPartOfBridged = !0;
-                                for (var h = 0; h < e.members.length; h++) r.add(e.members[h]);
-                                for (h = 0; h < e.neighbours.length; h++) {
-                                    let i = e.neighbours[h]; - 1 === t.indexOf(i) && s.add(e.neighbours[h])
+                                for (var a = 0; a < e.members.length; a++) r.add(e.members[a]);
+                                for (a = 0; a < e.neighbours.length; a++) {
+                                    let i = e.neighbours[a]; - 1 === t.indexOf(i) && s.add(e.neighbours[a])
                                 }
                             }
-                            let a = new Set;
+                            let h = new Set;
                             for (let e of r) {
                                 let r = this.graph.vertices[e],
                                     s = n.intersection(t, r.value.rings);
-                                1 === r.value.rings.length || 1 === s.length ? i.add(r.id) : a.add(r.id)
+                                1 === r.value.rings.length || 1 === s.length ? i.add(r.id) : h.add(r.id)
                             }
                             Array();
                             let g = Array();
-                            for (let t of a) {
+                            for (let t of h) {
                                 let e = this.graph.vertices[t],
                                     r = !1;
                                 for (let t = 0; t < e.edges.length; t++) 1 === this.edgeRingCount(e.edges[t]) && (r = !0);
                                 r ? (e.value.isBridgeNode = !0, i.add(e.id)) : (e.value.isBridge = !0, i.add(e.id))
                             }
                             let d = new l([...i]);
                             for (this.addRing(d), d.isBridged = !0, d.neighbours = [...s], o = 0; o < t.length; o++) d.rings.push(this.getRing(t[o]).clone());
                             for (o = 0; o < d.members.length; o++) this.graph.vertices[d.members[o]].value.bridgedRing = d.id;
                             for (o = 0; o < g.length; o++) this.graph.vertices[g[o]].value.rings = Array();
                             for (let e of i) {
                                 let i = this.graph.vertices[e];
                                 i.value.rings = n.removeAll(i.value.rings, t), i.value.rings.push(d.id)
                             }
                             for (o = 0; o < t.length; o++)
-                                for (h = o + 1; h < t.length; h++) this.removeRingConnectionsBetween(t[o], t[h]);
+                                for (a = o + 1; a < t.length; a++) this.removeRingConnectionsBetween(t[o], t[a]);
                             for (let e of s) {
                                 let i = this.getRingConnections(e, t);
-                                for (h = 0; h < i.length; h++) this.getRingConnection(i[h]).updateOther(d.id, e);
+                                for (a = 0; a < i.length; a++) this.getRingConnection(i[a]).updateOther(d.id, e);
                                 this.getRing(e).neighbours.push(d.id)
                             }
                             return d
                         }
                         areVerticesInSameRing(t, e) {
                             for (var i = 0; i < t.value.rings.length; i++)
                                 for (var r = 0; r < e.value.rings.length; r++)
@@ -1254,17 +1148,17 @@
                                 e = new Float32Array(this.graph.vertices.length);
                             for (var i = 0; i < this.graph.vertices.length; i++) e[i] = 0;
                             for (i = 0; i < this.graph.vertices.length; i++)
                                 for (var r = this.graph.vertices.length; --r > i;) {
                                     let n = this.graph.vertices[i],
                                         o = this.graph.vertices[r];
                                     if (!n.value.isDrawn || !o.value.isDrawn) continue;
-                                    let h = s.subtract(n.position, o.position).lengthSq();
-                                    if (h < this.opts.bondLengthSq) {
-                                        let n = (this.opts.bondLength - Math.sqrt(h)) / this.opts.bondLength;
+                                    let a = s.subtract(n.position, o.position).lengthSq();
+                                    if (a < this.opts.bondLengthSq) {
+                                        let n = (this.opts.bondLength - Math.sqrt(a)) / this.opts.bondLength;
                                         t += n, e[i] += n, e[r] += n
                                     }
                                 }
                             let n = Array();
                             for (i = 0; i < this.graph.vertices.length; i++) n.push({
                                 id: i,
                                 score: e[i]
@@ -1277,27 +1171,27 @@
                                 vertexScores: e
                             }
                         }
                         chooseSide(t, e, i) {
                             let r = t.getNeighbours(e.id),
                                 s = e.getNeighbours(t.id),
                                 o = r.length,
-                                h = s.length,
-                                a = n.merge(r, s),
+                                a = s.length,
+                                h = n.merge(r, s),
                                 l = [0, 0];
-                            for (var g = 0; g < a.length; g++) this.graph.vertices[a[g]].position.sameSideAs(t.position, e.position, i[0]) ? l[0]++ : l[1]++;
+                            for (var g = 0; g < h.length; g++) this.graph.vertices[h[g]].position.sameSideAs(t.position, e.position, i[0]) ? l[0]++ : l[1]++;
                             let d = [0, 0];
                             for (g = 0; g < this.graph.vertices.length; g++) this.graph.vertices[g].position.sameSideAs(t.position, e.position, i[0]) ? d[0]++ : d[1]++;
                             return {
                                 totalSideCount: d,
                                 totalPosition: d[0] > d[1] ? 0 : 1,
                                 sideCount: l,
                                 position: l[0] > l[1] ? 0 : 1,
                                 anCount: o,
-                                bnCount: h
+                                bnCount: a
                             }
                         }
                         setRingCenter(t) {
                             let e = t.getSize(),
                                 i = new s(0, 0);
                             for (var r = 0; r < e; r++) i.add(this.graph.vertices[t.members[r]].position);
                             t.center = i.divide(e)
@@ -1324,32 +1218,32 @@
                                     let t = this.rings[r];
                                     this.isRingAromatic(t) && this.canvasWrapper.drawAromaticityRing(t)
                                 }
                         }
                         drawEdge(t, e) {
                             let i = this,
                                 r = this.graph.edges[t],
-                                h = this.graph.vertices[r.sourceId],
-                                a = this.graph.vertices[r.targetId],
-                                l = h.value.element,
-                                g = a.value.element;
-                            if (!(h.value.isDrawn && a.value.isDrawn || "default" !== this.opts.atomVisualization)) return;
-                            let d = h.position,
-                                u = a.position,
+                                a = this.graph.vertices[r.sourceId],
+                                h = this.graph.vertices[r.targetId],
+                                l = a.value.element,
+                                g = h.value.element;
+                            if (!(a.value.isDrawn && h.value.isDrawn || "default" !== this.opts.atomVisualization)) return;
+                            let d = a.position,
+                                u = h.position,
                                 c = this.getEdgeNormals(r),
                                 p = n.clone(c);
-                            if (p[0].multiplyScalar(10).add(d), p[1].multiplyScalar(10).add(d), "=" === r.bondType || "=" === this.getRingbondType(h, a) || r.isPartOfAromaticRing && this.bridgedRing) {
-                                let t = this.areVerticesInSameRing(h, a),
-                                    e = this.chooseSide(h, a, p);
+                            if (p[0].multiplyScalar(10).add(d), p[1].multiplyScalar(10).add(d), "=" === r.bondType || "=" === this.getRingbondType(a, h) || r.isPartOfAromaticRing && this.bridgedRing) {
+                                let t = this.areVerticesInSameRing(a, h),
+                                    e = this.chooseSide(a, h, p);
                                 if (t) {
-                                    let t = this.getLargestOrAromaticCommonRing(h, a).center;
+                                    let t = this.getLargestOrAromaticCommonRing(a, h).center;
                                     c[0].multiplyScalar(i.opts.bondSpacing), c[1].multiplyScalar(i.opts.bondSpacing);
                                     let e = null;
-                                    e = t.sameSideAs(h.position, a.position, s.add(d, c[0])) ? new o(s.add(d, c[0]), s.add(u, c[0]), l, g) : new o(s.add(d, c[1]), s.add(u, c[1]), l, g), e.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength), r.isPartOfAromaticRing ? this.canvasWrapper.drawLine(e, !0) : this.canvasWrapper.drawLine(e), this.canvasWrapper.drawLine(new o(d, u, l, g))
-                                } else if (r.center || h.isTerminal() && a.isTerminal()) {
+                                    e = t.sameSideAs(a.position, h.position, s.add(d, c[0])) ? new o(s.add(d, c[0]), s.add(u, c[0]), l, g) : new o(s.add(d, c[1]), s.add(u, c[1]), l, g), e.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength), r.isPartOfAromaticRing ? this.canvasWrapper.drawLine(e, !0) : this.canvasWrapper.drawLine(e), this.canvasWrapper.drawLine(new o(d, u, l, g))
+                                } else if (r.center || a.isTerminal() && h.isTerminal()) {
                                     c[0].multiplyScalar(i.opts.halfBondSpacing), c[1].multiplyScalar(i.opts.halfBondSpacing);
                                     let t = new o(s.add(d, c[0]), s.add(u, c[0]), l, g),
                                         e = new o(s.add(d, c[1]), s.add(u, c[1]), l, g);
                                     this.canvasWrapper.drawLine(t), this.canvasWrapper.drawLine(e)
                                 } else if (0 == e.anCount && e.bnCount > 1 || 0 == e.bnCount && e.anCount > 1) {
                                     c[0].multiplyScalar(i.opts.halfBondSpacing), c[1].multiplyScalar(i.opts.halfBondSpacing);
                                     let t = new o(s.add(d, c[0]), s.add(u, c[0]), l, g),
@@ -1375,38 +1269,38 @@
                             } else if ("#" === r.bondType) {
                                 c[0].multiplyScalar(i.opts.bondSpacing / 1.5), c[1].multiplyScalar(i.opts.bondSpacing / 1.5);
                                 let t = new o(s.add(d, c[0]), s.add(u, c[0]), l, g),
                                     e = new o(s.add(d, c[1]), s.add(u, c[1]), l, g);
                                 this.canvasWrapper.drawLine(t), this.canvasWrapper.drawLine(e), this.canvasWrapper.drawLine(new o(d, u, l, g))
                             } else if ("." === r.bondType);
                             else {
-                                let t = h.value.isStereoCenter,
-                                    e = a.value.isStereoCenter;
+                                let t = a.value.isStereoCenter,
+                                    e = h.value.isStereoCenter;
                                 "up" === r.wedge ? this.canvasWrapper.drawWedge(new o(d, u, l, g, t, e)) : "down" === r.wedge ? this.canvasWrapper.drawDashedWedge(new o(d, u, l, g, t, e)) : this.canvasWrapper.drawLine(new o(d, u, l, g, t, e))
                             }
                             if (e) {
                                 let e = s.midpoint(d, u);
                                 this.canvasWrapper.drawDebugText(e.x, e.y, "e: " + t)
                             }
                         }
                         drawVertices(t) {
                             var e = this.graph.vertices.length;
                             for (e = 0; e < this.graph.vertices.length; e++) {
                                 let i = this.graph.vertices[e],
                                     r = i.value,
                                     o = 0,
-                                    h = 0,
+                                    a = 0,
                                     l = i.value.bondCount,
                                     g = r.element,
-                                    d = a.maxBonds[g] - l,
+                                    d = h.maxBonds[g] - l,
                                     u = i.getTextDirection(this.graph.vertices),
                                     c = !(!this.opts.terminalCarbons && "C" === g && !r.hasAttachedPseudoElements) && i.isTerminal(),
                                     p = "C" === r.element;
-                                if ("N" === r.element && r.isPartOfAromaticRing && (d = 0), r.bracket && (d = r.bracket.hcount, o = r.bracket.charge, h = r.bracket.isotope), "allballs" === this.opts.atomVisualization) this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
-                                else if (r.isDrawn && (!p || r.drawExplicit || c || r.hasAttachedPseudoElements) || 1 === this.graph.vertices.length) "default" === this.opts.atomVisualization ? this.canvasWrapper.drawText(i.position.x, i.position.y, g, d, u, c, o, h, this.graph.vertices.length, r.getAttachedPseudoElements()) : "balls" === this.opts.atomVisualization && this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
+                                if ("N" === r.element && r.isPartOfAromaticRing && (d = 0), r.bracket && (d = r.bracket.hcount, o = r.bracket.charge, a = r.bracket.isotope), "allballs" === this.opts.atomVisualization) this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
+                                else if (r.isDrawn && (!p || r.drawExplicit || c || r.hasAttachedPseudoElements) || 1 === this.graph.vertices.length) "default" === this.opts.atomVisualization ? this.canvasWrapper.drawText(i.position.x, i.position.y, g, d, u, c, o, a, r.getAttachedPseudoElements()) : "balls" === this.opts.atomVisualization && this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
                                 else if (2 === i.getNeighbourCount() && 1 == i.forcePositioned) {
                                     let t = this.graph.vertices[i.neighbours[0]].position,
                                         e = this.graph.vertices[i.neighbours[1]].position,
                                         r = s.threePointangle(i.position, t, e);
                                     Math.abs(Math.PI - r) < .1 && this.canvasWrapper.drawPoint(i.position.x, i.position.y, g)
                                 }
                                 if (t) {
@@ -1422,20 +1316,16 @@
                         }
                         position() {
                             let t = null;
                             for (var e = 0; e < this.graph.vertices.length; e++)
                                 if (null !== this.graph.vertices[e].value.bridgedRing) {
                                     t = this.graph.vertices[e];
                                     break
-                                } if (null === t)
-                                for (e = 0; e < this.rings.length; e++)
-                                    if (this.rings[e].isBridged) {
-                                        t = this.graph.vertices[this.rings[e].members[0]];
-                                        break
-                                    } null === t && this.rings.length > 0 && (t = this.graph.vertices[this.rings[0].members[0]]), null === t && (t = this.graph.vertices[0]), this.createNextBond(t, null, 0)
+                                } for (e = 0; e < this.rings.length; e++) this.rings[e].isBridged && (t = this.graph.vertices[this.rings[e].members[0]]);
+                            this.rings.length > 0 && null === t && (t = this.graph.vertices[this.rings[0].members[0]]), null === t && (t = this.graph.vertices[0]), this.createNextBond(t, null, 0)
                         }
                         backupRingInformation() {
                             this.originalRings = Array(), this.originalRingConnections = Array();
                             for (var t = 0; t < this.rings.length; t++) this.originalRings.push(this.rings[t]);
                             for (t = 0; t < this.ringConnections.length; t++) this.originalRingConnections.push(this.ringConnections[t]);
                             for (t = 0; t < this.graph.vertices.length; t++) this.graph.vertices[t].value.backupRings()
                         }
@@ -1453,53 +1343,53 @@
                             for (e = 0; e < this.originalRingConnections.length; e++) this.ringConnections.push(this.originalRingConnections[e]);
                             for (e = 0; e < this.graph.vertices.length; e++) this.graph.vertices[e].value.restoreRings()
                         }
                         createRing(t, e = null, i = null, n = null) {
                             if (t.positioned) return;
                             e = e || new s(0, 0);
                             let o = t.getOrderedNeighbours(this.ringConnections),
-                                h = i ? s.subtract(i.position, e).angle() : 0,
-                                a = r.polyCircumradius(this.opts.bondLength, t.getSize()),
+                                a = i ? s.subtract(i.position, e).angle() : 0,
+                                h = r.polyCircumradius(this.opts.bondLength, t.getSize()),
                                 l = r.centralAngle(t.getSize());
                             t.centralAngle = l;
-                            let d = h,
+                            let d = a,
                                 u = this,
                                 c = i ? i.id : null;
                             if (-1 === t.members.indexOf(c) && (i && (i.positioned = !1), c = t.members[0]), t.isBridged) {
                                 this.graph.kkLayout(t.members.slice(), e, i.id, t, this.opts.bondLength, this.opts.kkThreshold, this.opts.kkInnerThreshold, this.opts.kkMaxIteration, this.opts.kkMaxInnerIteration, this.opts.kkMaxEnergy), t.positioned = !0, this.setRingCenter(t), e = t.center;
                                 for (var p = 0; p < t.rings.length; p++) this.setRingCenter(t.rings[p])
                             } else t.eachMember(this.graph.vertices, (function(i) {
                                 let r = u.graph.vertices[i];
-                                r.positioned || r.setPosition(e.x + Math.cos(d) * a, e.y + Math.sin(d) * a), d += l, (!t.isBridged || t.rings.length < 3) && (r.angle = d, r.positioned = !0)
+                                r.positioned || r.setPosition(e.x + Math.cos(d) * h, e.y + Math.sin(d) * h), d += l, (!t.isBridged || t.rings.length < 3) && (r.angle = d, r.positioned = !0)
                             }), c, n ? n.id : null);
                             for (t.positioned = !0, t.center = e, p = 0; p < o.length; p++) {
                                 let i = this.getRing(o[p].neighbour);
                                 if (i.positioned) continue;
                                 let n = g.getVertices(this.ringConnections, t.id, i.id);
                                 if (2 === n.length) {
                                     t.isFused = !0, i.isFused = !0;
                                     let o = this.graph.vertices[n[0]],
-                                        h = this.graph.vertices[n[1]],
-                                        a = s.midpoint(o.position, h.position),
-                                        l = s.normals(o.position, h.position);
+                                        a = this.graph.vertices[n[1]],
+                                        h = s.midpoint(o.position, a.position),
+                                        l = s.normals(o.position, a.position);
                                     l[0].normalize(), l[1].normalize();
                                     let g = r.polyCircumradius(this.opts.bondLength, i.getSize()),
                                         d = r.apothem(g, i.getSize());
-                                    l[0].multiplyScalar(d).add(a), l[1].multiplyScalar(d).add(a);
+                                    l[0].multiplyScalar(d).add(h), l[1].multiplyScalar(d).add(h);
                                     let u = l[0];
                                     s.subtract(e, l[1]).lengthSq() > s.subtract(e, l[0]).lengthSq() && (u = l[1]);
                                     let c = s.subtract(o.position, u),
-                                        p = s.subtract(h.position, u); - 1 === c.clockwise(p) ? i.positioned || this.createRing(i, u, o, h) : i.positioned || this.createRing(i, u, h, o)
+                                        p = s.subtract(a.position, u); - 1 === c.clockwise(p) ? i.positioned || this.createRing(i, u, o, a) : i.positioned || this.createRing(i, u, a, o)
                                 } else if (1 === n.length) {
                                     t.isSpiro = !0, i.isSpiro = !0;
                                     let o = this.graph.vertices[n[0]],
-                                        h = s.subtract(e, o.position);
-                                    h.invert(), h.normalize();
-                                    let a = r.polyCircumradius(this.opts.bondLength, i.getSize());
-                                    h.multiplyScalar(a), h.add(o.position), i.positioned || this.createRing(i, h, o)
+                                        a = s.subtract(e, o.position);
+                                    a.invert(), a.normalize();
+                                    let h = r.polyCircumradius(this.opts.bondLength, i.getSize());
+                                    a.multiplyScalar(h), a.add(o.position), i.positioned || this.createRing(i, a, o)
                                 }
                             }
                             for (p = 0; p < t.members.length; p++) {
                                 let e = this.graph.vertices[t.members[p]],
                                     i = e.neighbours;
                                 for (var f = 0; f < i.length; f++) {
                                     let t = this.graph.vertices[i[f]];
@@ -1517,23 +1407,23 @@
                                 }
                             }))
                         }
                         getSubtreeOverlapScore(t, e, i) {
                             let r = this,
                                 n = 0,
                                 o = new s(0, 0),
-                                h = 0;
+                                a = 0;
                             return this.graph.traverseTree(t, e, (function(t) {
                                 if (!t.value.isDrawn) return;
                                 let e = i[t.id];
-                                e > r.opts.overlapSensitivity && (n += e, h++);
+                                e > r.opts.overlapSensitivity && (n += e, a++);
                                 let s = r.graph.vertices[t.id].position.clone();
                                 s.multiplyScalar(e), o.add(s)
                             })), o.divide(n), {
-                                value: n / h,
+                                value: n / a,
                                 center: o
                             }
                         }
                         getCurrentCenterOfMass() {
                             let t = new s(0, 0),
                                 e = 0;
                             for (var i = 0; i < this.graph.vertices.length; i++) {
@@ -1588,16 +1478,16 @@
                                         i = e.vertices[1];
                                     if (!t.value.isDrawn || !i.value.isDrawn) continue;
                                     let r = (2 * Math.PI - this.getRing(e.rings[0]).getAngle()) / 6;
                                     this.rotateSubtree(t.id, e.common.id, r, e.common.position), this.rotateSubtree(i.id, e.common.id, -r, e.common.position);
                                     let n = this.getOverlapScore(),
                                         s = this.getSubtreeOverlapScore(t.id, e.common.id, n.vertexScores),
                                         o = this.getSubtreeOverlapScore(i.id, e.common.id, n.vertexScores),
-                                        h = s.value + o.value;
-                                    this.rotateSubtree(t.id, e.common.id, -2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, 2 * r, e.common.position), n = this.getOverlapScore(), s = this.getSubtreeOverlapScore(t.id, e.common.id, n.vertexScores), o = this.getSubtreeOverlapScore(i.id, e.common.id, n.vertexScores), s.value + o.value > h && (this.rotateSubtree(t.id, e.common.id, 2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, -2 * r, e.common.position))
+                                        a = s.value + o.value;
+                                    this.rotateSubtree(t.id, e.common.id, -2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, 2 * r, e.common.position), n = this.getOverlapScore(), s = this.getSubtreeOverlapScore(t.id, e.common.id, n.vertexScores), o = this.getSubtreeOverlapScore(i.id, e.common.id, n.vertexScores), s.value + o.value > a && (this.rotateSubtree(t.id, e.common.id, 2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, -2 * r, e.common.position))
                                 } else 1 === e.vertices.length && e.rings.length
                             }
                         }
                         resolveSecondaryOverlaps(t) {
                             for (var e = 0; e < t.length; e++)
                                 if (t[e].score > this.opts.overlapSensitivity) {
                                     let i = this.graph.vertices[t[e].id];
@@ -1614,22 +1504,22 @@
                         }
                         getLastVertexWithAngle(t) {
                             let e = 0,
                                 i = null;
                             for (; !e && t;) i = this.graph.vertices[t], e = i.angle, t = i.parentVertexId;
                             return i
                         }
-                        createNextBond(t, e = null, i = 0, o = !1, h = !1) {
-                            if (t.positioned && !h) return;
-                            let a = !1;
+                        createNextBond(t, e = null, i = 0, o = !1, a = !1) {
+                            if (t.positioned && !a) return;
+                            let h = !1;
                             if (e) {
                                 let i = this.graph.getEdge(t.id, e.id);
-                                "/" !== i.bondType && "\\" !== i.bondType || ++this.doubleBondConfigCount % 2 != 1 || null === this.doubleBondConfig && (this.doubleBondConfig = i.bondType, a = !0, null === e.parentVertexId && t.value.branchBond && ("/" === this.doubleBondConfig ? this.doubleBondConfig = "\\" : "\\" === this.doubleBondConfig && (this.doubleBondConfig = "/")))
+                                "/" !== i.bondType && "\\" !== i.bondType || ++this.doubleBondConfigCount % 2 != 1 || null === this.doubleBondConfig && (this.doubleBondConfig = i.bondType, h = !0, null === e.parentVertexId && t.value.branchBond && ("/" === this.doubleBondConfig ? this.doubleBondConfig = "\\" : "\\" === this.doubleBondConfig && (this.doubleBondConfig = "/")))
                             }
-                            if (!h)
+                            if (!a)
                                 if (e)
                                     if (e.value.rings.length > 0) {
                                         let i = e.neighbours,
                                             r = null,
                                             o = new s(0, 0);
                                         if (null === e.value.bridgedRing && e.value.rings.length > 1)
                                             for (var l = 0; l < i.length; l++) {
@@ -1670,74 +1560,74 @@
                                     i.invert(), i.normalize();
                                     let n = r.polyCircumradius(this.opts.bondLength, e.getSize());
                                     i.multiplyScalar(n), i.add(t.position), this.createRing(e, i, t)
                                 }
                             } else {
                                 t.value.isStereoCenter;
                                 let i = t.getNeighbours(),
-                                    h = Array();
-                                for (l = 0; l < i.length; l++) this.graph.vertices[i[l]].value.isDrawn && h.push(i[l]);
-                                e && (h = n.remove(h, e.id));
+                                    a = Array();
+                                for (l = 0; l < i.length; l++) this.graph.vertices[i[l]].value.isDrawn && a.push(i[l]);
+                                e && (a = n.remove(a, e.id));
                                 let g = t.getAngle();
-                                if (1 === h.length) {
-                                    let i = this.graph.vertices[h[0]];
+                                if (1 === a.length) {
+                                    let i = this.graph.vertices[a[0]];
                                     if ("#" === t.value.bondType || e && "#" === e.value.bondType || "=" === t.value.bondType && e && 0 === e.value.rings.length && "=" === e.value.bondType && "-" !== t.value.branchBond) t.value.drawExplicit = !1, e && (this.graph.getEdge(t.id, e.id).center = !0), this.graph.getEdge(t.id, i.id).center = !0, ("#" === t.value.bondType || e && "#" === e.value.bondType) && (i.angle = 0), i.drawExplicit = !0, this.createNextBond(i, t, g + i.angle);
                                     else if (e && e.value.rings.length > 0) {
                                         let e = r.toRad(60),
                                             n = -e,
                                             o = new s(this.opts.bondLength, 0),
-                                            h = new s(this.opts.bondLength, 0);
-                                        o.rotate(e).add(t.position), h.rotate(n).add(t.position);
-                                        let a = this.getCurrentCenterOfMass(),
-                                            l = o.distanceSq(a),
-                                            d = h.distanceSq(a);
+                                            a = new s(this.opts.bondLength, 0);
+                                        o.rotate(e).add(t.position), a.rotate(n).add(t.position);
+                                        let h = this.getCurrentCenterOfMass(),
+                                            l = o.distanceSq(h),
+                                            d = a.distanceSq(h);
                                         i.angle = l < d ? n : e, this.createNextBond(i, t, g + i.angle)
                                     } else {
                                         let r = t.angle;
-                                        if (e && e.neighbours.length > 3 ? r = r > 0 ? Math.min(1.0472, r) : r < 0 ? Math.max(-1.0472, r) : 1.0472 : r || (r = this.getLastVertexWithAngle(t.id).angle, r || (r = 1.0472)), e && !a) {
+                                        if (e && e.neighbours.length > 3 ? r = r > 0 ? Math.min(1.0472, r) : r < 0 ? Math.max(-1.0472, r) : 1.0472 : r || (r = this.getLastVertexWithAngle(t.id).angle, r || (r = 1.0472)), e && !h) {
                                             let e = this.graph.getEdge(t.id, i.id).bondType;
                                             "/" === e ? ("/" === this.doubleBondConfig || "\\" === this.doubleBondConfig && (r = -r), this.doubleBondConfig = null) : "\\" === e && ("/" === this.doubleBondConfig ? r = -r : this.doubleBondConfig, this.doubleBondConfig = null)
                                         }
                                         i.angle = o ? r : -r, this.createNextBond(i, t, g + i.angle)
                                     }
-                                } else if (2 === h.length) {
+                                } else if (2 === a.length) {
                                     let i = t.angle;
                                     i || (i = 1.0472);
-                                    let r = this.graph.getTreeDepth(h[0], t.id),
-                                        n = this.graph.getTreeDepth(h[1], t.id),
-                                        s = this.graph.vertices[h[0]],
-                                        o = this.graph.vertices[h[1]];
+                                    let r = this.graph.getTreeDepth(a[0], t.id),
+                                        n = this.graph.getTreeDepth(a[1], t.id),
+                                        s = this.graph.vertices[a[0]],
+                                        o = this.graph.vertices[a[1]];
                                     s.value.subtreeDepth = r, o.value.subtreeDepth = n;
-                                    let a = this.graph.getTreeDepth(e ? e.id : null, t.id);
-                                    e && (e.value.subtreeDepth = a);
+                                    let h = this.graph.getTreeDepth(e ? e.id : null, t.id);
+                                    e && (e.value.subtreeDepth = h);
                                     let l = 0,
                                         d = 1;
                                     "C" === o.value.element && "C" !== s.value.element && n > 1 && r < 5 ? (l = 1, d = 0) : "C" !== o.value.element && "C" === s.value.element && r > 1 && n < 5 ? (l = 0, d = 1) : n > r && (l = 1, d = 0);
-                                    let u = this.graph.vertices[h[l]],
-                                        c = this.graph.vertices[h[d]],
+                                    let u = this.graph.vertices[a[l]],
+                                        c = this.graph.vertices[a[d]],
                                         p = (this.graph.getEdge(t.id, u.id), this.graph.getEdge(t.id, c.id), !1);
-                                    a < r && a < n && (p = !0), c.angle = i, u.angle = -i, "\\" === this.doubleBondConfig ? "\\" === c.value.branchBond && (c.angle = -i, u.angle = i) : "/" === this.doubleBondConfig && "/" === c.value.branchBond && (c.angle = -i, u.angle = i), this.createNextBond(c, t, g + c.angle, p), this.createNextBond(u, t, g + u.angle, p)
-                                } else if (3 === h.length) {
-                                    let i = this.graph.getTreeDepth(h[0], t.id),
-                                        n = this.graph.getTreeDepth(h[1], t.id),
-                                        s = this.graph.getTreeDepth(h[2], t.id),
-                                        o = this.graph.vertices[h[0]],
-                                        a = this.graph.vertices[h[1]],
-                                        l = this.graph.vertices[h[2]];
-                                    o.value.subtreeDepth = i, a.value.subtreeDepth = n, l.value.subtreeDepth = s, n > i && n > s ? (o = this.graph.vertices[h[1]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[2]]) : s > i && s > n && (o = this.graph.vertices[h[2]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[1]]), e && e.value.rings.length < 1 && o.value.rings.length < 1 && a.value.rings.length < 1 && l.value.rings.length < 1 && 1 === this.graph.getTreeDepth(a.id, t.id) && 1 === this.graph.getTreeDepth(l.id, t.id) && this.graph.getTreeDepth(o.id, t.id) > 1 ? (o.angle = -t.angle, t.angle >= 0 ? (a.angle = r.toRad(30), l.angle = r.toRad(90)) : (a.angle = -r.toRad(30), l.angle = -r.toRad(90)), this.createNextBond(o, t, g + o.angle), this.createNextBond(a, t, g + a.angle), this.createNextBond(l, t, g + l.angle)) : (o.angle = 0, a.angle = r.toRad(90), l.angle = -r.toRad(90), this.createNextBond(o, t, g + o.angle), this.createNextBond(a, t, g + a.angle), this.createNextBond(l, t, g + l.angle))
-                                } else if (4 === h.length) {
-                                    let e = this.graph.getTreeDepth(h[0], t.id),
-                                        i = this.graph.getTreeDepth(h[1], t.id),
-                                        n = this.graph.getTreeDepth(h[2], t.id),
-                                        s = this.graph.getTreeDepth(h[3], t.id),
-                                        o = this.graph.vertices[h[0]],
-                                        a = this.graph.vertices[h[1]],
-                                        l = this.graph.vertices[h[2]],
-                                        d = this.graph.vertices[h[3]];
-                                    o.value.subtreeDepth = e, a.value.subtreeDepth = i, l.value.subtreeDepth = n, d.value.subtreeDepth = s, i > e && i > n && i > s ? (o = this.graph.vertices[h[1]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[2]], d = this.graph.vertices[h[3]]) : n > e && n > i && n > s ? (o = this.graph.vertices[h[2]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[1]], d = this.graph.vertices[h[3]]) : s > e && s > i && s > n && (o = this.graph.vertices[h[3]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[1]], d = this.graph.vertices[h[2]]), o.angle = -r.toRad(36), a.angle = r.toRad(36), l.angle = -r.toRad(108), d.angle = r.toRad(108), this.createNextBond(o, t, g + o.angle), this.createNextBond(a, t, g + a.angle), this.createNextBond(l, t, g + l.angle), this.createNextBond(d, t, g + d.angle)
+                                    h < r && h < n && (p = !0), c.angle = i, u.angle = -i, "\\" === this.doubleBondConfig ? "\\" === c.value.branchBond && (c.angle = -i, u.angle = i) : "/" === this.doubleBondConfig && "/" === c.value.branchBond && (c.angle = -i, u.angle = i), this.createNextBond(c, t, g + c.angle, p), this.createNextBond(u, t, g + u.angle, p)
+                                } else if (3 === a.length) {
+                                    let i = this.graph.getTreeDepth(a[0], t.id),
+                                        n = this.graph.getTreeDepth(a[1], t.id),
+                                        s = this.graph.getTreeDepth(a[2], t.id),
+                                        o = this.graph.vertices[a[0]],
+                                        h = this.graph.vertices[a[1]],
+                                        l = this.graph.vertices[a[2]];
+                                    o.value.subtreeDepth = i, h.value.subtreeDepth = n, l.value.subtreeDepth = s, n > i && n > s ? (o = this.graph.vertices[a[1]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[2]]) : s > i && s > n && (o = this.graph.vertices[a[2]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[1]]), e && e.value.rings.length < 1 && o.value.rings.length < 1 && h.value.rings.length < 1 && l.value.rings.length < 1 && 1 === this.graph.getTreeDepth(h.id, t.id) && 1 === this.graph.getTreeDepth(l.id, t.id) && this.graph.getTreeDepth(o.id, t.id) > 1 ? (o.angle = -t.angle, t.angle >= 0 ? (h.angle = r.toRad(30), l.angle = r.toRad(90)) : (h.angle = -r.toRad(30), l.angle = -r.toRad(90)), this.createNextBond(o, t, g + o.angle), this.createNextBond(h, t, g + h.angle), this.createNextBond(l, t, g + l.angle)) : (o.angle = 0, h.angle = r.toRad(90), l.angle = -r.toRad(90), this.createNextBond(o, t, g + o.angle), this.createNextBond(h, t, g + h.angle), this.createNextBond(l, t, g + l.angle))
+                                } else if (4 === a.length) {
+                                    let e = this.graph.getTreeDepth(a[0], t.id),
+                                        i = this.graph.getTreeDepth(a[1], t.id),
+                                        n = this.graph.getTreeDepth(a[2], t.id),
+                                        s = this.graph.getTreeDepth(a[3], t.id),
+                                        o = this.graph.vertices[a[0]],
+                                        h = this.graph.vertices[a[1]],
+                                        l = this.graph.vertices[a[2]],
+                                        d = this.graph.vertices[a[3]];
+                                    o.value.subtreeDepth = e, h.value.subtreeDepth = i, l.value.subtreeDepth = n, d.value.subtreeDepth = s, i > e && i > n && i > s ? (o = this.graph.vertices[a[1]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[2]], d = this.graph.vertices[a[3]]) : n > e && n > i && n > s ? (o = this.graph.vertices[a[2]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[1]], d = this.graph.vertices[a[3]]) : s > e && s > i && s > n && (o = this.graph.vertices[a[3]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[1]], d = this.graph.vertices[a[2]]), o.angle = -r.toRad(36), h.angle = r.toRad(36), l.angle = -r.toRad(108), d.angle = r.toRad(108), this.createNextBond(o, t, g + o.angle), this.createNextBond(h, t, g + h.angle), this.createNextBond(l, t, g + l.angle), this.createNextBond(d, t, g + d.angle)
                                 }
                             }
                         }
                         getCommonRingbondNeighbour(t) {
                             let e = t.neighbours;
                             for (var i = 0; i < e.length; i++) {
                                 let r = this.graph.vertices[e[i]];
@@ -1786,91 +1676,91 @@
                             return e
                         }
                         annotateStereochemistry() {
                             for (var t = 0; t < this.graph.vertices.length; t++) {
                                 let s = this.graph.vertices[t];
                                 if (!s.value.isStereoCenter) continue;
                                 let o = s.getNeighbours(),
-                                    h = o.length,
-                                    a = Array(h);
-                                for (var e = 0; e < h; e++) {
+                                    a = o.length,
+                                    h = Array(a);
+                                for (var e = 0; e < a; e++) {
                                     let t = new Uint8Array(this.graph.vertices.length),
                                         r = Array(Array());
                                     t[s.id] = 1, this.visitStereochemistry(o[e], s.id, t, r, 10, 0);
                                     for (var i = 0; i < r.length; i++) r[i].sort((function(t, e) {
                                         return e - t
                                     }));
-                                    a[e] = [e, r]
+                                    h[e] = [e, r]
                                 }
                                 let l = 0,
                                     g = 0;
-                                for (e = 0; e < a.length; e++)
-                                    for (a[e][1].length > l && (l = a[e][1].length), i = 0; i < a[e][1].length; i++) a[e][1][i].length > g && (g = a[e][1][i].length);
-                                for (e = 0; e < a.length; e++) {
-                                    let t = l - a[e][1].length;
-                                    for (i = 0; i < t; i++) a[e][1].push([]);
-                                    for (a[e][1].push([o[e]]), i = 0; i < a[e][1].length; i++) {
-                                        let t = g - a[e][1][i].length;
-                                        for (var n = 0; n < t; n++) a[e][1][i].push(0)
+                                for (e = 0; e < h.length; e++)
+                                    for (h[e][1].length > l && (l = h[e][1].length), i = 0; i < h[e][1].length; i++) h[e][1][i].length > g && (g = h[e][1][i].length);
+                                for (e = 0; e < h.length; e++) {
+                                    let t = l - h[e][1].length;
+                                    for (i = 0; i < t; i++) h[e][1].push([]);
+                                    for (h[e][1].push([o[e]]), i = 0; i < h[e][1].length; i++) {
+                                        let t = g - h[e][1][i].length;
+                                        for (var n = 0; n < t; n++) h[e][1][i].push(0)
                                     }
                                 }
-                                a.sort((function(t, e) {
+                                h.sort((function(t, e) {
                                     for (var i = 0; i < t[1].length; i++)
                                         for (var r = 0; r < t[1][i].length; r++) {
                                             if (t[1][i][r] > e[1][i][r]) return -1;
                                             if (t[1][i][r] < e[1][i][r]) return 1
                                         }
                                     return 0
                                 }));
-                                let d = new Uint8Array(h);
-                                for (e = 0; e < h; e++) d[e] = a[e][0], s.value.priority = e;
+                                let d = new Uint8Array(a);
+                                for (e = 0; e < a; e++) d[e] = h[e][0], s.value.priority = e;
                                 let u = this.graph.vertices[o[d[0]]].position,
                                     c = this.graph.vertices[o[d[1]]].position,
                                     p = this.graph.vertices[o[d[2]]].position,
                                     f = u.relativeClockwise(c, s.position),
                                     v = (u.relativeClockwise(p, s.position), -1 === f),
                                     m = "@" === s.value.bracket.chirality ? -1 : 1,
                                     b = r.parityOfPermutation(d) * m == 1 ? "R" : "S",
                                     y = "down",
-                                    x = "up";
-                                (v && "R" !== b || !v && "S" !== b) && (s.value.hydrogenDirection = "up", y = "up", x = "down"), s.value.hasHydrogen && (this.graph.getEdge(s.id, o[d[d.length - 1]]).wedge = y);
-                                let S = new Array(o.length - 1),
-                                    A = s.value.rings.length > 1 && s.value.hasHydrogen,
-                                    C = s.value.hasHydrogen ? 1 : 0;
-                                for (e = 0; e < d.length - C; e++) {
-                                    S[e] = new Uint32Array(2);
+                                    S = "up";
+                                (v && "R" !== b || !v && "S" !== b) && (s.value.hydrogenDirection = "up", y = "up", S = "down"), s.value.hasHydrogen && (this.graph.getEdge(s.id, o[d[d.length - 1]]).wedge = y);
+                                let w = new Array(o.length - 1),
+                                    x = s.value.rings.length > 1 && s.value.hasHydrogen,
+                                    A = s.value.hasHydrogen ? 1 : 0;
+                                for (e = 0; e < d.length - A; e++) {
+                                    w[e] = new Uint32Array(2);
                                     let t = this.graph.vertices[o[d[e]]];
-                                    S[e][0] += t.value.isStereoCenter ? 0 : 1e5, S[e][0] += this.areVerticesInSameRing(t, s) ? 0 : 1e4, S[e][0] += t.value.isHeteroAtom() ? 1e3 : 0, S[e][0] -= 0 === t.value.subtreeDepth ? 1e3 : 0, S[e][0] += 1e3 - t.value.subtreeDepth, S[e][1] = o[d[e]]
+                                    w[e][0] += t.value.isStereoCenter ? 0 : 1e5, w[e][0] += this.areVerticesInSameRing(t, s) ? 0 : 1e4, w[e][0] += t.value.isHeteroAtom() ? 1e3 : 0, w[e][0] -= 0 === t.value.subtreeDepth ? 1e3 : 0, w[e][0] += 1e3 - t.value.subtreeDepth, w[e][1] = o[d[e]]
                                 }
-                                if (S.sort((function(t, e) {
+                                if (w.sort((function(t, e) {
                                         return t[0] > e[0] ? -1 : t[0] < e[0] ? 1 : 0
-                                    })), !A) {
-                                    let t = S[0][1];
-                                    if (s.value.hasHydrogen) this.graph.getEdge(s.id, t).wedge = x;
+                                    })), !x) {
+                                    let t = w[0][1];
+                                    if (s.value.hasHydrogen) this.graph.getEdge(s.id, t).wedge = S;
                                     else {
-                                        let i = x;
-                                        for (e = d.length - 1; e >= 0 && (i = i === y ? x : y, o[d[e]] !== t); e--);
+                                        let i = S;
+                                        for (e = d.length - 1; e >= 0 && (i = i === y ? S : y, o[d[e]] !== t); e--);
                                         this.graph.getEdge(s.id, t).wedge = i
                                     }
                                 }
                                 s.value.chirality = b
                             }
                         }
                         visitStereochemistry(t, e, i, r, n, s, o = 0) {
                             i[t] = 1;
-                            let h = this.graph.vertices[t],
-                                a = h.value.getAtomicNumber();
+                            let a = this.graph.vertices[t],
+                                h = a.value.getAtomicNumber();
                             r.length <= s && r.push(Array());
-                            for (var l = 0; l < this.graph.getEdge(t, e).weight; l++) r[s].push(1e3 * o + a);
+                            for (var l = 0; l < this.graph.getEdge(t, e).weight; l++) r[s].push(1e3 * o + h);
                             let g = this.graph.vertices[t].neighbours;
-                            for (l = 0; l < g.length; l++) 1 !== i[g[l]] && s < n - 1 && this.visitStereochemistry(g[l], t, i.slice(), r, n, s + 1, a);
+                            for (l = 0; l < g.length; l++) 1 !== i[g[l]] && s < n - 1 && this.visitStereochemistry(g[l], t, i.slice(), r, n, s + 1, h);
                             if (s < n - 1) {
                                 let e = 0;
                                 for (l = 0; l < g.length; l++) e += this.graph.getEdge(t, g[l]).weight;
-                                for (l = 0; l < h.value.getMaxBonds() - e; l++) r.length <= s + 1 && r.push(Array()), r[s + 1].push(1e3 * a + 1)
+                                for (l = 0; l < a.value.getMaxBonds() - e; l++) r.length <= s + 1 && r.push(Array()), r[s + 1].push(1e3 * h + 1)
                             }
                         }
                         initPseudoElements() {
                             for (var t = 0; t < this.graph.vertices.length; t++) {
                                 const i = this.graph.vertices[t],
                                     r = i.neighbours;
                                 let n = Array(r.length);
@@ -1883,26 +1773,26 @@
                                 for (e = 0; e < n.length; e++) {
                                     let t = n[e],
                                         i = t.value.element,
                                         r = t.getNeighbourCount();
                                     "C" !== i && "H" !== i && 1 === r && s++, r > 1 && o++
                                 }
                                 if (o > 1 || s < 2) continue;
-                                let h = null;
+                                let a = null;
                                 for (e = 0; e < n.length; e++) {
                                     let t = n[e];
-                                    t.getNeighbourCount() > 1 && (h = t)
+                                    t.getNeighbourCount() > 1 && (a = t)
                                 }
                                 for (e = 0; e < n.length; e++) {
                                     let t = n[e];
                                     if (t.getNeighbourCount() > 1) continue;
                                     t.value.isDrawn = !1;
-                                    let r = a.maxBonds[t.value.element] - t.value.bondCount,
+                                    let r = h.maxBonds[t.value.element] - t.value.bondCount,
                                         s = "";
-                                    t.value.bracket && (r = t.value.bracket.hcount, s = t.value.bracket.charge || 0), i.value.attachPseudoElement(t.value.element, h ? h.value.element : null, r, s)
+                                    t.value.bracket && (r = t.value.bracket.hcount, s = t.value.bracket.charge || 0), i.value.attachPseudoElement(t.value.element, a ? a.value.element : null, r, s)
                                 }
                             }
                             for (t = 0; t < this.graph.vertices.length; t++) {
                                 const i = this.graph.vertices[t],
                                     r = i.value,
                                     n = r.element;
                                 if ("C" === n || "H" === n || !r.isDrawn) continue;
@@ -1941,48 +1831,48 @@
                     t.exports = e
                 },
                 707: (t, e, i) => {
                     const r = i(474),
                         n = (i(614), i(843)),
                         s = i(826),
                         o = (i(421), i(427));
-                    class h {
+                    class a {
                         constructor(t, e = !1) {
                             this.vertices = Array(), this.edges = Array(), this.vertexIdsToEdgeId = {}, this.isomeric = e, this._time = 0, this._init(t)
                         }
                         _init(t, e = 0, i = null, r = !1) {
-                            let h = new o(t.atom.element ? t.atom.element : t.atom, t.bond);
-                            h.branchBond = t.branchBond, h.ringbonds = t.ringbonds, h.bracket = t.atom.element ? t.atom : null, h.class = t.atom.class;
-                            let a = new n(h),
+                            let a = new o(t.atom.element ? t.atom.element : t.atom, t.bond);
+                            a.branchBond = t.branchBond, a.ringbonds = t.ringbonds, a.bracket = t.atom.element ? t.atom : null;
+                            let h = new n(a),
                                 l = this.vertices[i];
-                            if (this.addVertex(a), null !== i) {
-                                a.setParentVertexId(i), a.value.addNeighbouringElement(l.value.element), l.addChild(a.id), l.value.addNeighbouringElement(h.element), l.spanningTreeChildren.push(a.id);
-                                let t = new s(i, a.id, 1),
+                            if (this.addVertex(h), null !== i) {
+                                h.setParentVertexId(i), h.value.addNeighbouringElement(l.value.element), l.addChild(h.id), l.value.addNeighbouringElement(a.element), l.spanningTreeChildren.push(h.id);
+                                let t = new s(i, h.id, 1),
                                     e = null;
-                                r ? (t.setBondType(a.value.branchBond || "-"), e = a.id, t.setBondType(a.value.branchBond || "-"), e = a.id) : (t.setBondType(l.value.bondType || "-"), e = l.id), this.addEdge(t)
+                                r ? (t.setBondType(h.value.branchBond || "-"), e = h.id, t.setBondType(h.value.branchBond || "-"), e = h.id) : (t.setBondType(l.value.bondType || "-"), e = l.id), this.addEdge(t)
                             }
                             let g = t.ringbondCount + 1;
-                            h.bracket && (g += h.bracket.hcount);
+                            a.bracket && (g += a.bracket.hcount);
                             let d = 0;
-                            if (h.bracket && h.bracket.chirality) {
-                                h.isStereoCenter = !0, d = h.bracket.hcount;
+                            if (a.bracket && a.bracket.chirality) {
+                                a.isStereoCenter = !0, d = a.bracket.hcount;
                                 for (var u = 0; u < d; u++) this._init({
                                     atom: "H",
                                     isBracket: "false",
                                     branches: Array(),
                                     branchCount: 0,
                                     ringbonds: Array(),
                                     ringbondCount: !1,
                                     next: null,
                                     hasNext: !1,
                                     bond: "-"
-                                }, u, a.id, !0)
+                                }, u, h.id, !0)
                             }
-                            for (u = 0; u < t.branchCount; u++) this._init(t.branches[u], u + g, a.id, !0);
-                            t.hasNext && this._init(t.next, t.branchCount + g, a.id)
+                            for (u = 0; u < t.branchCount; u++) this._init(t.branches[u], u + g, h.id, !0);
+                            t.hasNext && this._init(t.next, t.branchCount + g, h.id)
                         }
                         clear() {
                             this.vertices = Array(), this.edges = Array(), this.vertexIdsToEdgeId = {}
                         }
                         addVertex(t) {
                             return t.id = this.vertices.length, this.vertices.push(t), t.id
                         }
@@ -2092,15 +1982,15 @@
                                 e = new Array(t),
                                 i = new Array(t),
                                 r = new Array(t),
                                 n = new Array(t),
                                 s = this.getAdjacencyList(),
                                 o = Array();
                             e.fill(!1), n.fill(null), this._time = 0;
-                            for (var h = 0; h < t; h++) e[h] || this._bridgeDfs(h, e, i, r, n, s, o);
+                            for (var a = 0; a < t; a++) e[a] || this._bridgeDfs(a, e, i, r, n, s, o);
                             return o
                         }
                         traverseBF(t, e) {
                             let i = this.vertices.length,
                                 r = new Array(i);
                             r.fill(!1);
                             for (var n = [t]; n.length > 0;) {
@@ -2123,139 +2013,139 @@
                                 s > r && (r = s)
                             }
                             return r + 1
                         }
                         traverseTree(t, e, i, r = 999999, n = !1, s = 1, o = null) {
                             if (null === o && (o = new Uint8Array(this.vertices.length)), s > r + 1 || 1 === o[t]) return;
                             o[t] = 1;
-                            let h = this.vertices[t],
-                                a = h.getNeighbours(e);
-                            (!n || s > 1) && i(h);
-                            for (var l = 0; l < a.length; l++) this.traverseTree(a[l], t, i, r, n, s + 1, o)
+                            let a = this.vertices[t],
+                                h = a.getNeighbours(e);
+                            (!n || s > 1) && i(a);
+                            for (var l = 0; l < h.length; l++) this.traverseTree(h[l], t, i, r, n, s + 1, o)
                         }
-                        kkLayout(t, e, i, n, s, o = .1, h = .1, a = 2e3, l = 50, g = 1e9) {
+                        kkLayout(t, e, i, n, s, o = .1, a = .1, h = 2e3, l = 50, g = 1e9) {
                             let d = s;
                             for (var u = t.length; u--;) var c = this.vertices[t[u]].neighbours.length;
                             let p = this.getSubgraphDistanceMatrix(t),
                                 f = t.length,
                                 v = r.polyCircumradius(500, f),
                                 m = r.centralAngle(f),
                                 b = 0,
                                 y = new Float32Array(f),
-                                x = new Float32Array(f),
-                                S = Array(f);
+                                S = new Float32Array(f),
+                                w = Array(f);
                             for (u = f; u--;) {
                                 let i = this.vertices[t[u]];
-                                i.positioned ? (y[u] = i.position.x, x[u] = i.position.y) : (y[u] = e.x + Math.cos(b) * v, x[u] = e.y + Math.sin(b) * v), S[u] = i.positioned, b += m
+                                i.positioned ? (y[u] = i.position.x, S[u] = i.position.y) : (y[u] = e.x + Math.cos(b) * v, S[u] = e.y + Math.sin(b) * v), w[u] = i.positioned, b += m
                             }
-                            let A = Array(f);
+                            let x = Array(f);
                             for (u = f; u--;)
-                                for (A[u] = new Array(f), c = f; c--;) A[u][c] = s * p[u][c];
-                            let C = Array(f);
+                                for (x[u] = new Array(f), c = f; c--;) x[u][c] = s * p[u][c];
+                            let A = Array(f);
                             for (u = f; u--;)
-                                for (C[u] = Array(f), c = f; c--;) C[u][c] = d * Math.pow(p[u][c], -2);
-                            let R, w, T, B, I, P, L, N = Array(f),
-                                O = new Float32Array(f),
+                                for (A[u] = Array(f), c = f; c--;) A[u][c] = d * Math.pow(p[u][c], -2);
+                            let C, R, N, T, L, P, B, I = Array(f),
+                                E = new Float32Array(f),
                                 M = new Float32Array(f);
-                            for (u = f; u--;) N[u] = Array(f);
+                            for (u = f; u--;) I[u] = Array(f);
                             for (u = f; u--;) {
-                                R = y[u], w = x[u], T = 0, B = 0;
+                                C = y[u], R = S[u], N = 0, T = 0;
                                 let t = f;
-                                for (; t--;) u !== t && (I = y[t], P = x[t], L = 1 / Math.sqrt((R - I) * (R - I) + (w - P) * (w - P)), N[u][t] = [C[u][t] * (R - I - A[u][t] * (R - I) * L), C[u][t] * (w - P - A[u][t] * (w - P) * L)], N[t][u] = N[u][t], T += N[u][t][0], B += N[u][t][1]);
-                                O[u] = T, M[u] = B
+                                for (; t--;) u !== t && (L = y[t], P = S[t], B = 1 / Math.sqrt((C - L) * (C - L) + (R - P) * (R - P)), I[u][t] = [A[u][t] * (C - L - x[u][t] * (C - L) * B), A[u][t] * (R - P - x[u][t] * (R - P) * B)], I[t][u] = I[u][t], N += I[u][t][0], T += I[u][t][1]);
+                                E[u] = N, M[u] = T
                             }
                             let k = function(t) {
-                                    return [O[t] * O[t] + M[t] * M[t], O[t], M[t]]
+                                    return [E[t] * E[t] + M[t] * M[t], E[t], M[t]]
                                 },
-                                E = function() {
+                                O = function() {
                                     let t = 0,
                                         e = 0,
                                         i = 0,
                                         r = 0;
                                     for (u = f; u--;) {
                                         let [n, s, o] = k(u);
-                                        n > t && !1 === S[u] && (t = n, e = u, i = s, r = o)
+                                        n > t && !1 === w[u] && (t = n, e = u, i = s, r = o)
                                     }
                                     return [e, t, i, r]
                                 },
                                 D = function(t, e, i) {
                                     let r = 0,
                                         n = 0,
                                         s = 0,
                                         o = y[t],
+                                        a = S[t],
                                         h = x[t],
-                                        a = A[t],
-                                        l = C[t];
+                                        l = A[t];
                                     for (u = f; u--;) {
                                         if (u === t) continue;
                                         let e = y[u],
-                                            i = x[u],
-                                            g = a[u],
+                                            i = S[u],
+                                            g = h[u],
                                             d = l[u],
                                             c = (o - e) * (o - e),
-                                            p = 1 / Math.pow(c + (h - i) * (h - i), 1.5);
-                                        r += d * (1 - g * (h - i) * (h - i) * p), n += d * (1 - g * c * p), s += d * (g * (o - e) * (h - i) * p)
+                                            p = 1 / Math.pow(c + (a - i) * (a - i), 1.5);
+                                        r += d * (1 - g * (a - i) * (a - i) * p), n += d * (1 - g * c * p), s += d * (g * (o - e) * (a - i) * p)
                                     }
                                     0 === r && (r = .1), 0 === n && (n = .1), 0 === s && (s = .1);
                                     let g = e / r + i / s;
                                     g /= s / r - n / s;
                                     let d = -(s * g + e) / r;
-                                    y[t] += d, x[t] += g;
-                                    let c, p, v, m, b, S = N[t];
-                                    for (e = 0, i = 0, o = y[t], h = x[t], u = f; u--;) t !== u && (c = y[u], p = x[u], v = S[u][0], m = S[u][1], b = 1 / Math.sqrt((o - c) * (o - c) + (h - p) * (h - p)), d = l[u] * (o - c - a[u] * (o - c) * b), g = l[u] * (h - p - a[u] * (h - p) * b), S[u] = [d, g], e += d, i += g, O[u] += d - v, M[u] += g - m);
-                                    O[t] = e, M[t] = i
+                                    y[t] += d, S[t] += g;
+                                    let c, p, v, m, b, w = I[t];
+                                    for (e = 0, i = 0, o = y[t], a = S[t], u = f; u--;) t !== u && (c = y[u], p = S[u], v = w[u][0], m = w[u][1], b = 1 / Math.sqrt((o - c) * (o - c) + (a - p) * (a - p)), d = l[u] * (o - c - h[u] * (o - c) * b), g = l[u] * (a - p - h[u] * (a - p) * b), w[u] = [d, g], e += d, i += g, E[u] += d - v, M[u] += g - m);
+                                    E[t] = e, M[t] = i
                                 },
-                                F = 0,
                                 z = 0,
-                                H = 0,
                                 V = 0,
+                                F = 0,
+                                H = 0,
                                 W = 0,
-                                U = 0;
-                            for (; g > o && a > W;)
-                                for (W++, [F, g, z, H] = E(), V = g, U = 0; V > h && l > U;) U++, D(F, z, H), [V, z, H] = k(F);
+                                q = 0;
+                            for (; g > o && h > W;)
+                                for (W++, [z, g, V, F] = O(), H = g, q = 0; H > a && l > q;) q++, D(z, V, F), [H, V, F] = k(z);
                             for (u = f; u--;) {
                                 let e = t[u],
                                     i = this.vertices[e];
-                                i.position.x = y[u], i.position.y = x[u], i.positioned = !0, i.forcePositioned = !0
+                                i.position.x = y[u], i.position.y = S[u], i.positioned = !0, i.forcePositioned = !0
                             }
                         }
                         _bridgeDfs(t, e, i, r, n, s, o) {
                             e[t] = !0, i[t] = r[t] = ++this._time;
-                            for (var h = 0; h < s[t].length; h++) {
-                                let a = s[t][h];
-                                e[a] ? a !== n[t] && (r[t] = Math.min(r[t], i[a])) : (n[a] = t, this._bridgeDfs(a, e, i, r, n, s, o), r[t] = Math.min(r[t], r[a]), r[a] > i[t] && o.push([t, a]))
+                            for (var a = 0; a < s[t].length; a++) {
+                                let h = s[t][a];
+                                e[h] ? h !== n[t] && (r[t] = Math.min(r[t], i[h])) : (n[h] = t, this._bridgeDfs(h, e, i, r, n, s, o), r[t] = Math.min(r[t], r[h]), r[h] > i[t] && o.push([t, h]))
                             }
                         }
                         static getConnectedComponents(t) {
                             let e = t.length,
                                 i = new Array(e),
                                 r = new Array;
                             i.fill(!1);
                             for (var n = 0; n < e; n++)
                                 if (!i[n]) {
                                     let e = Array();
-                                    i[n] = !0, e.push(n), h._ccGetDfs(n, i, t, e), e.length > 1 && r.push(e)
+                                    i[n] = !0, e.push(n), a._ccGetDfs(n, i, t, e), e.length > 1 && r.push(e)
                                 } return r
                         }
                         static getConnectedComponentCount(t) {
                             let e = t.length,
                                 i = new Array(e),
                                 r = 0;
                             i.fill(!1);
-                            for (var n = 0; n < e; n++) i[n] || (i[n] = !0, r++, h._ccCountDfs(n, i, t));
+                            for (var n = 0; n < e; n++) i[n] || (i[n] = !0, r++, a._ccCountDfs(n, i, t));
                             return r
                         }
                         static _ccCountDfs(t, e, i) {
-                            for (var r = 0; r < i[t].length; r++) i[t][r] && !e[r] && t !== r && (e[r] = !0, h._ccCountDfs(r, e, i))
+                            for (var r = 0; r < i[t].length; r++) i[t][r] && !e[r] && t !== r && (e[r] = !0, a._ccCountDfs(r, e, i))
                         }
                         static _ccGetDfs(t, e, i, r) {
-                            for (var n = 0; n < i[t].length; n++) i[t][n] && !e[n] && t !== n && (e[n] = !0, r.push(n), h._ccGetDfs(n, e, i, r))
+                            for (var n = 0; n < i[t].length; n++) i[t][n] && !e[n] && t !== n && (e[n] = !0, r.push(n), a._ccGetDfs(n, e, i, r))
                         }
                     }
-                    t.exports = h
+                    t.exports = a
                 },
                 929: (t, e, i) => {
                     const r = i(614);
                     class n {
                         constructor(t = new r(0, 0), e = new r(0, 0), i = null, n = null, s = !1, o = !1) {
                             this.from = t, this.to = e, this.elementFrom = i, this.elementTo = n, this.chiralFrom = s, this.chiralTo = o
                         }
@@ -2376,31 +2266,14 @@
                         }
                         static get twoPI() {
                             return 2 * Math.PI
                         }
                     }
                     t.exports = e
                 },
-                207: t => {
-                    t.exports = class {
-                        static extend() {
-                            let t = this,
-                                e = {},
-                                i = !1,
-                                r = 0,
-                                n = arguments.length;
-                            "[object Boolean]" === Object.prototype.toString.call(arguments[0]) && (i = arguments[0], r++);
-                            let s = function(r) {
-                                for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (i && "[object Object]" === Object.prototype.toString.call(r[n]) ? e[n] = t.extend(!0, e[n], r[n]) : e[n] = r[n])
-                            };
-                            for (; r < n; r++) s(arguments[r]);
-                            return e
-                        }
-                    }
-                },
                 19: t => {
                     t.exports = function() {
                         "use strict";
 
                         function t(e, i, r, n) {
                             this.message = e, this.expected = i, this.found = r, this.location = n, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, t)
                         }
@@ -2466,82 +2339,82 @@
                                 }
                             }(t) + " but " + function(t) {
                                 return t ? '"' + n(t) + '"' : "end of input"
                             }(e) + " found."
                         }, {
                             SyntaxError: t,
                             parse: function(e, i) {
-                                if (i = void 0 !== i ? i : {}, e.split("(").length - 1 != e.split(")").length - 1) throw ht("The number of opening parentheses does not match the number of closing parentheses.", 0);
-                                var r, n, s, o, h = {},
-                                    a = {
-                                        chain: at
+                                if (i = void 0 !== i ? i : {}, e.split("(").length - 1 != e.split(")").length - 1) throw at("The number of opening parentheses does not match the number of closing parentheses.", 0);
+                                var r, n, s, o, a = {},
+                                    h = {
+                                        chain: ht
                                     },
-                                    l = at,
+                                    l = ht,
                                     g = it("(", !1),
                                     d = it(")", !1),
                                     u = /^[\-=#$:\/\\.]/,
                                     c = rt(["-", "=", "#", "$", ":", "/", "\\", "."], !1, !1),
                                     p = it("[", !1),
                                     f = it("se", !1),
                                     v = it("as", !1),
                                     m = it("]", !1),
                                     b = it("B", !1),
                                     y = it("r", !1),
-                                    x = it("C", !1),
-                                    S = it("l", !1),
-                                    A = /^[NOPSFI]/,
-                                    C = rt(["N", "O", "P", "S", "F", "I"], !1, !1),
-                                    R = /^[bcnops]/,
-                                    w = rt(["b", "c", "n", "o", "p", "s"], !1, !1),
-                                    T = it("*", !1),
-                                    B = /^[A-Z]/,
-                                    I = rt([
+                                    S = it("C", !1),
+                                    w = it("l", !1),
+                                    x = /^[NOPSFI]/,
+                                    A = rt(["N", "O", "P", "S", "F", "I"], !1, !1),
+                                    C = /^[bcnops]/,
+                                    R = rt(["b", "c", "n", "o", "p", "s"], !1, !1),
+                                    N = it("*", !1),
+                                    T = /^[A-Z]/,
+                                    L = rt([
                                         ["A", "Z"]
                                     ], !1, !1),
                                     P = /^[a-z]/,
-                                    L = rt([
+                                    B = rt([
                                         ["a", "z"]
                                     ], !1, !1),
-                                    N = it("%", !1),
-                                    O = /^[1-9]/,
+                                    I = it("%", !1),
+                                    E = /^[1-9]/,
                                     M = rt([
                                         ["1", "9"]
                                     ], !1, !1),
                                     k = /^[0-9]/,
-                                    E = rt([
+                                    O = rt([
                                         ["0", "9"]
                                     ], !1, !1),
                                     D = it("@", !1),
-                                    F = it("TH", !1),
-                                    z = /^[12]/,
-                                    H = rt(["1", "2"], !1, !1),
-                                    V = it("AL", !1),
+                                    z = it("TH", !1),
+                                    V = /^[12]/,
+                                    F = rt(["1", "2"], !1, !1),
+                                    H = it("AL", !1),
                                     W = it("SP", !1),
-                                    U = /^[1-3]/,
-                                    q = rt([
+                                    q = /^[1-3]/,
+                                    j = rt([
                                         ["1", "3"]
                                     ], !1, !1),
-                                    j = it("TB", !1),
-                                    _ = it("OH", !1),
-                                    G = it("+", !1),
-                                    X = it("-", !1),
-                                    K = it("H", !1),
-                                    Y = it(":", !1),
-                                    Z = /^[0]/,
-                                    $ = rt(["0"], !1, !1),
+                                    U = it("TB", !1),
+                                    X = it("OH", !1),
+                                    _ = it("+", !1),
+                                    Y = it("-", !1),
+                                    $ = it("H", !1),
+                                    G = it(":", !1),
+                                    K = /^[0]/,
+                                    Z = rt(["0"], !1, !1),
                                     J = 0,
                                     Q = [{
                                         line: 1,
                                         column: 1
                                     }],
                                     tt = 0,
                                     et = [];
                                 if ("startRule" in i) {
-                                    if (!(i.startRule in a)) throw new Error("Can't start parsing from rule \"" + i.startRule + '".');
-                                    l = a[i.startRule]
+                                    if (!(i.startRule in h)) throw new Error("Can't start parsing from rule \"" + i.startRule + '".');
+                                    l = h[i.startRule]
                                 }
 
                                 function it(t, e) {
                                     return {
                                         type: "literal",
                                         text: t,
                                         ignoreCase: e
@@ -2585,85 +2458,85 @@
                                     }
                                 }
 
                                 function ot(t) {
                                     J < tt || (J > tt && (tt = J, et = []), et.push(t))
                                 }
 
-                                function ht(e, i) {
+                                function at(e, i) {
                                     return new t(e, null, null, i)
                                 }
 
-                                function at() {
-                                    var t, i, r, n, s, o, a, l, g;
-                                    if (J, t = J, i = function() {
+                                function ht() {
+                                    var t, i, r, n, s, o, h, l, g;
+                                    if (J, t = J, (i = function() {
                                             var t;
-                                            return J, t = function() {
+                                            return J, (t = function() {
                                                 var t, i, r, n;
-                                                return J, t = J, 66 === e.charCodeAt(J) ? (i = "B", J++) : (i = h, ot(b)), i !== h ? (114 === e.charCodeAt(J) ? (r = "r", J++) : (r = h, ot(y)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t === h && (t = J, 67 === e.charCodeAt(J) ? (i = "C", J++) : (i = h, ot(x)), i !== h ? (108 === e.charCodeAt(J) ? (r = "l", J++) : (r = h, ot(S)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t === h && (A.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = h, ot(C)))), t !== h && (t = (n = t).length > 1 ? n.join("") : n), t
-                                            }(), t === h && (t = dt()) === h && (t = function() {
-                                                var t, i, r, n, s, o, a, l, g, d;
-                                                return J, t = J, 91 === e.charCodeAt(J) ? (i = "[", J++) : (i = h, ot(p)), i !== h ? (r = function() {
+                                                return J, t = J, 66 === e.charCodeAt(J) ? (i = "B", J++) : (i = a, ot(b)), i !== a ? (114 === e.charCodeAt(J) ? (r = "r", J++) : (r = a, ot(y)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t === a && (t = J, 67 === e.charCodeAt(J) ? (i = "C", J++) : (i = a, ot(S)), i !== a ? (108 === e.charCodeAt(J) ? (r = "l", J++) : (r = a, ot(w)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t === a && (x.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = a, ot(A)))), t !== a && (t = (n = t).length > 1 ? n.join("") : n), t
+                                            }()) === a && (t = dt()) === a && (t = function() {
+                                                var t, i, r, n, s, o, h, l, g, d;
+                                                return J, t = J, 91 === e.charCodeAt(J) ? (i = "[", J++) : (i = a, ot(p)), i !== a ? ((r = function() {
                                                     var t, i, r, n;
-                                                    return J, t = J, O.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = h, ot(M)), i !== h ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(E)), r === h && (r = null), r !== h ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(E)), n === h && (n = null), n !== h ? t = i = [i, r, n] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t !== h && (t = Number(t.join(""))), t
-                                                }(), r === h && (r = null), r !== h ? ("se" === e.substr(J, 2) ? (n = "se", J += 2) : (n = h, ot(f)), n === h && ("as" === e.substr(J, 2) ? (n = "as", J += 2) : (n = h, ot(v)), n === h && (n = dt()) === h && (n = function() {
+                                                    return J, t = J, E.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = a, ot(M)), i !== a ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(O)), r === a && (r = null), r !== a ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(O)), n === a && (n = null), n !== a ? t = i = [i, r, n] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t !== a && (t = Number(t.join(""))), t
+                                                }()) === a && (r = null), r !== a ? ("se" === e.substr(J, 2) ? (n = "se", J += 2) : (n = a, ot(f)), n === a && ("as" === e.substr(J, 2) ? (n = "as", J += 2) : (n = a, ot(v)), n === a && (n = dt()) === a && (n = function() {
                                                     var t, i, r;
-                                                    return J, t = J, B.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = h, ot(I)), i !== h ? (P.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(L)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = t.join("")), t
-                                                }(), n === h && (n = ut()))), n !== h ? (s = function() {
-                                                    var t, i, r, n, s, o, a;
-                                                    return J, t = J, 64 === e.charCodeAt(J) ? (i = "@", J++) : (i = h, ot(D)), i !== h ? (64 === e.charCodeAt(J) ? (r = "@", J++) : (r = h, ot(D)), r === h && (r = J, "TH" === e.substr(J, 2) ? (n = "TH", J += 2) : (n = h, ot(F)), n !== h ? (z.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(H)), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "AL" === e.substr(J, 2) ? (n = "AL", J += 2) : (n = h, ot(V)), n !== h ? (z.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(H)), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "SP" === e.substr(J, 2) ? (n = "SP", J += 2) : (n = h, ot(W)), n !== h ? (U.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(q)), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "TB" === e.substr(J, 2) ? (n = "TB", J += 2) : (n = h, ot(j)), n !== h ? (O.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(M)), s !== h ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E)), o === h && (o = null), o !== h ? r = n = [n, s, o] : (J = r, r = h)) : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "OH" === e.substr(J, 2) ? (n = "OH", J += 2) : (n = h, ot(_)), n !== h ? (O.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(M)), s !== h ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E)), o === h && (o = null), o !== h ? r = n = [n, s, o] : (J = r, r = h)) : (J = r, r = h)) : (J = r, r = h)))))), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (a = t)[1] ? "@" == a[1] ? "@@" : a[1].join("").replace(",", "") : "@"), t
-                                                }(), s === h && (s = null), s !== h ? (o = function() {
+                                                    return J, t = J, T.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = a, ot(L)), i !== a ? (P.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(B)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = t.join("")), t
+                                                }()) === a && (n = ut())), n !== a ? ((s = function() {
+                                                    var t, i, r, n, s, o, h;
+                                                    return J, t = J, 64 === e.charCodeAt(J) ? (i = "@", J++) : (i = a, ot(D)), i !== a ? (64 === e.charCodeAt(J) ? (r = "@", J++) : (r = a, ot(D)), r === a && (r = J, "TH" === e.substr(J, 2) ? (n = "TH", J += 2) : (n = a, ot(z)), n !== a ? (V.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(F)), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "AL" === e.substr(J, 2) ? (n = "AL", J += 2) : (n = a, ot(H)), n !== a ? (V.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(F)), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "SP" === e.substr(J, 2) ? (n = "SP", J += 2) : (n = a, ot(W)), n !== a ? (q.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(j)), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "TB" === e.substr(J, 2) ? (n = "TB", J += 2) : (n = a, ot(U)), n !== a ? (E.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(M)), s !== a ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O)), o === a && (o = null), o !== a ? r = n = [n, s, o] : (J = r, r = a)) : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "OH" === e.substr(J, 2) ? (n = "OH", J += 2) : (n = a, ot(X)), n !== a ? (E.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(M)), s !== a ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O)), o === a && (o = null), o !== a ? r = n = [n, s, o] : (J = r, r = a)) : (J = r, r = a)) : (J = r, r = a)))))), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (h = t)[1] ? "@" == h[1] ? "@@" : h[1].join("").replace(",", "") : "@"), t
+                                                }()) === a && (s = null), s !== a ? ((o = function() {
                                                     var t, i, r, n;
-                                                    return J, t = J, 72 === e.charCodeAt(J) ? (i = "H", J++) : (i = h, ot(K)), i !== h ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(E)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (n = t)[1] ? Number(n[1]) : 1), t
-                                                }(), o === h && (o = null), o !== h ? (a = function() {
+                                                    return J, t = J, 72 === e.charCodeAt(J) ? (i = "H", J++) : (i = a, ot($)), i !== a ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(O)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (n = t)[1] ? Number(n[1]) : 1), t
+                                                }()) === a && (o = null), o !== a ? ((h = function() {
                                                     var t;
-                                                    return J, t = function() {
+                                                    return J, (t = function() {
                                                         var t, i, r, n, s, o;
-                                                        return J, t = J, 43 === e.charCodeAt(J) ? (i = "+", J++) : (i = h, ot(G)), i !== h ? (43 === e.charCodeAt(J) ? (r = "+", J++) : (r = h, ot(G)), r === h && (r = J, O.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(M)), n !== h ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(E)), s === h && (s = null), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (o = t)[1] ? "+" != o[1] ? Number(o[1].join("")) : 2 : 1), t
-                                                    }(), t === h && (t = function() {
+                                                        return J, t = J, 43 === e.charCodeAt(J) ? (i = "+", J++) : (i = a, ot(_)), i !== a ? (43 === e.charCodeAt(J) ? (r = "+", J++) : (r = a, ot(_)), r === a && (r = J, E.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(M)), n !== a ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(O)), s === a && (s = null), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (o = t)[1] ? "+" != o[1] ? Number(o[1].join("")) : 2 : 1), t
+                                                    }()) === a && (t = function() {
                                                         var t, i, r, n, s, o;
-                                                        return J, t = J, 45 === e.charCodeAt(J) ? (i = "-", J++) : (i = h, ot(X)), i !== h ? (45 === e.charCodeAt(J) ? (r = "-", J++) : (r = h, ot(X)), r === h && (r = J, O.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(M)), n !== h ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(E)), s === h && (s = null), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (o = t)[1] ? "-" != o[1] ? -Number(o[1].join("")) : -2 : -1), t
-                                                    }()), t
-                                                }(), a === h && (a = null), a !== h ? (l = function() {
-                                                    var t, i, r, n, s, o, a;
-                                                    if (J, t = J, 58 === e.charCodeAt(J) ? (i = ":", J++) : (i = h, ot(Y)), i !== h) {
-                                                        if (r = J, O.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(M)), n !== h) {
-                                                            for (s = [], k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E)); o !== h;) s.push(o), k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E));
-                                                            s !== h ? r = n = [n, s] : (J = r, r = h)
-                                                        } else J = r, r = h;
-                                                        r === h && (Z.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot($))), r !== h ? t = i = [i, r] : (J = t, t = h)
-                                                    } else J = t, t = h;
-                                                    return t !== h && (a = t, t = Number(a[1][0] + a[1][1].join(""))), t
-                                                }(), l === h && (l = null), l !== h ? (93 === e.charCodeAt(J) ? (g = "]", J++) : (g = h, ot(m)), g !== h ? t = i = [i, r, n, s, o, a, l, g] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t !== h && (t = {
+                                                        return J, t = J, 45 === e.charCodeAt(J) ? (i = "-", J++) : (i = a, ot(Y)), i !== a ? (45 === e.charCodeAt(J) ? (r = "-", J++) : (r = a, ot(Y)), r === a && (r = J, E.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(M)), n !== a ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(O)), s === a && (s = null), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (o = t)[1] ? "-" != o[1] ? -Number(o[1].join("")) : -2 : -1), t
+                                                    }()), t !== a && (t = t), t
+                                                }()) === a && (h = null), h !== a ? ((l = function() {
+                                                    var t, i, r, n, s, o, h;
+                                                    if (J, t = J, 58 === e.charCodeAt(J) ? (i = ":", J++) : (i = a, ot(G)), i !== a) {
+                                                        if (r = J, E.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(M)), n !== a) {
+                                                            for (s = [], k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O)); o !== a;) s.push(o), k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O));
+                                                            s !== a ? r = n = [n, s] : (J = r, r = a)
+                                                        } else J = r, r = a;
+                                                        r === a && (K.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(Z))), r !== a ? t = i = [i, r] : (J = t, t = a)
+                                                    } else J = t, t = a;
+                                                    return t !== a && (h = t, t = Number(h[1][0] + h[1][1].join(""))), t
+                                                }()) === a && (l = null), l !== a ? (93 === e.charCodeAt(J) ? (g = "]", J++) : (g = a, ot(m)), g !== a ? t = i = [i, r, n, s, o, h, l, g] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t !== a && (t = {
                                                     isotope: (d = t)[1],
                                                     element: d[2],
                                                     chirality: d[3],
                                                     hcount: d[4],
                                                     charge: d[5],
                                                     class: d[6]
                                                 }), t
-                                            }(), t === h && (t = ut())), t
-                                        }(), i !== h) {
-                                        for (r = [], n = lt(); n !== h;) r.push(n), n = lt();
-                                        if (r !== h) {
-                                            for (n = [], s = J, (o = gt()) === h && (o = null), o !== h && (a = ct()) !== h ? s = o = [o, a] : (J = s, s = h); s !== h;) n.push(s), s = J, (o = gt()) === h && (o = null), o !== h && (a = ct()) !== h ? s = o = [o, a] : (J = s, s = h);
-                                            if (n !== h) {
-                                                for (s = [], o = lt(); o !== h;) s.push(o), o = lt();
-                                                if (s !== h)
-                                                    if ((o = gt()) === h && (o = null), o !== h)
-                                                        if ((a = at()) === h && (a = null), a !== h) {
-                                                            for (l = [], g = lt(); g !== h;) l.push(g), g = lt();
-                                                            l !== h ? t = i = [i, r, n, s, o, a, l] : (J = t, t = h)
-                                                        } else J = t, t = h;
-                                                else J = t, t = h;
-                                                else J = t, t = h
-                                            } else J = t, t = h
-                                        } else J = t, t = h
-                                    } else J = t, t = h;
-                                    return t !== h && (t = function(t) {
+                                            }()) === a && (t = ut()), t !== a && (t = t), t
+                                        }()) !== a) {
+                                        for (r = [], n = lt(); n !== a;) r.push(n), n = lt();
+                                        if (r !== a) {
+                                            for (n = [], s = J, (o = gt()) === a && (o = null), o !== a && (h = ct()) !== a ? s = o = [o, h] : (J = s, s = a); s !== a;) n.push(s), s = J, (o = gt()) === a && (o = null), o !== a && (h = ct()) !== a ? s = o = [o, h] : (J = s, s = a);
+                                            if (n !== a) {
+                                                for (s = [], o = lt(); o !== a;) s.push(o), o = lt();
+                                                if (s !== a)
+                                                    if ((o = gt()) === a && (o = null), o !== a)
+                                                        if ((h = ht()) === a && (h = null), h !== a) {
+                                                            for (l = [], g = lt(); g !== a;) l.push(g), g = lt();
+                                                            l !== a ? t = i = [i, r, n, s, o, h, l] : (J = t, t = a)
+                                                        } else J = t, t = a;
+                                                else J = t, t = a;
+                                                else J = t, t = a
+                                            } else J = t, t = a
+                                        } else J = t, t = a
+                                    } else J = t, t = a;
+                                    return t !== a && (t = function(t) {
                                         for (var e = [], i = [], r = 0; r < t[1].length; r++) e.push(t[1][r]);
                                         for (r = 0; r < t[2].length; r++) {
                                             var n = t[2][r][0] ? t[2][r][0] : "-";
                                             i.push({
                                                 bond: n,
                                                 id: t[2][r][1]
                                             })
@@ -2681,43 +2554,43 @@
                                             next: t[5],
                                             hasNext: !!t[5]
                                         }
                                     }(t)), t
                                 }
 
                                 function lt() {
-                                    var t, i, r, n, s, o, a;
-                                    return J, t = J, 40 === e.charCodeAt(J) ? (i = "(", J++) : (i = h, ot(g)), i !== h ? ((r = gt()) === h && (r = null), r !== h && (n = at()) !== h ? (41 === e.charCodeAt(J) ? (s = ")", J++) : (s = h, ot(d)), s !== h ? t = i = [i, r, n, s] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t !== h && (a = (o = t)[1] ? o[1] : "-", o[2].branchBond = a, t = o[2]), t
+                                    var t, i, r, n, s, o, h;
+                                    return J, t = J, 40 === e.charCodeAt(J) ? (i = "(", J++) : (i = a, ot(g)), i !== a ? ((r = gt()) === a && (r = null), r !== a && (n = ht()) !== a ? (41 === e.charCodeAt(J) ? (s = ")", J++) : (s = a, ot(d)), s !== a ? t = i = [i, r, n, s] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t !== a && (h = (o = t)[1] ? o[1] : "-", o[2].branchBond = h, t = o[2]), t
                                 }
 
                                 function gt() {
                                     var t;
                                     if (J, u.test(e.charAt(J))) {
-                                        if ((t = e.charAt(J)) === e.charAt(J + 1)) throw t = h, ht("The parser encountered a bond repetition.", J + 1);
+                                        if ((t = e.charAt(J)) === e.charAt(J + 1)) throw t = a, at("The parser encountered a bond repetition.", J + 1);
                                         J++
-                                    } else t = h, ot(c);
-                                    return t
+                                    } else t = a, ot(c);
+                                    return t !== a && (t = t), t
                                 }
 
                                 function dt() {
                                     var t;
-                                    return J, R.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = h, ot(w)), t
+                                    return J, C.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = a, ot(R)), t !== a && (t = t), t
                                 }
 
                                 function ut() {
                                     var t;
-                                    return J, 42 === e.charCodeAt(J) ? (t = "*", J++) : (t = h, ot(T)), t
+                                    return J, 42 === e.charCodeAt(J) ? (t = "*", J++) : (t = a, ot(N)), t !== a && (t = t), t
                                 }
 
                                 function ct() {
                                     var t, i, r, n, s;
-                                    return J, t = J, 37 === e.charCodeAt(J) ? (i = "%", J++) : (i = h, ot(N)), i !== h ? (O.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(M)), r !== h ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(E)), n !== h ? t = i = [i, r, n] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t === h && (k.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = h, ot(E))), t !== h && (t = 1 == (s = t).length ? Number(s) : Number(s.join("").replace("%", ""))), t
+                                    return J, t = J, 37 === e.charCodeAt(J) ? (i = "%", J++) : (i = a, ot(I)), i !== a ? (E.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(M)), r !== a ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(O)), n !== a ? t = i = [i, r, n] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t === a && (k.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = a, ot(O))), t !== a && (t = 1 == (s = t).length ? Number(s) : Number(s.join("").replace("%", ""))), t
                                 }
-                                if ((r = l()) !== h && J === e.length) return r;
-                                throw r !== h && J < e.length && ot({
+                                if ((r = l()) !== a && J === e.length) return r;
+                                throw r !== a && J < e.length && ot({
                                     type: "end"
                                 }), n = et, s = tt < e.length ? e.charAt(tt) : null, o = tt < e.length ? st(tt, tt + 1) : st(tt, tt), new t(t.buildMessage(n, s), n, s, o)
                             }
                         }
                     }()
                 },
                 421: (t, e, i) => {
@@ -2835,43 +2708,43 @@
                     const r = i(707);
                     class n {
                         static getRings(t, e = !1) {
                             let i = t.getComponentsAdjacencyMatrix();
                             if (0 === i.length) return null;
                             let s = r.getConnectedComponents(i),
                                 o = Array();
-                            for (var h = 0; h < s.length; h++) {
-                                let i = s[h],
+                            for (var a = 0; a < s.length; a++) {
+                                let i = s[a],
                                     r = t.getSubgraphAdjacencyMatrix([...i]),
                                     g = new Uint16Array(r.length),
                                     d = new Uint16Array(r.length);
-                                for (var a = 0; a < r.length; a++) {
-                                    d[a] = 0, g[a] = 0;
-                                    for (var l = 0; l < r[a].length; l++) g[a] += r[a][l]
+                                for (var h = 0; h < r.length; h++) {
+                                    d[h] = 0, g[h] = 0;
+                                    for (var l = 0; l < r[h].length; l++) g[h] += r[h][l]
                                 }
                                 let u = 0;
-                                for (a = 0; a < r.length; a++)
-                                    for (l = a + 1; l < r.length; l++) u += r[a][l];
+                                for (h = 0; h < r.length; h++)
+                                    for (l = h + 1; l < r.length; l++) u += r[h][l];
                                 let c = u - r.length + 1,
                                     p = !0;
-                                for (a = 0; a < g.length; a++) 3 !== g[a] && (p = !1);
+                                for (h = 0; h < g.length; h++) 3 !== g[h] && (p = !1);
                                 if (p && (c = 2 + u - r.length), 1 === c) {
                                     o.push([...i]);
                                     continue
                                 }
                                 e && (c = 999);
                                 let {
                                     d: f,
                                     pe: v,
                                     pe_prime: m
                                 } = n.getPathIncludedDistanceMatrices(r), b = n.getRingCandidates(f, v, m), y = n.getSSSR(b, f, r, v, m, g, d, c);
-                                for (a = 0; a < y.length; a++) {
-                                    let t = Array(y[a].size),
+                                for (h = 0; h < y.length; h++) {
+                                    let t = Array(y[h].size),
                                         e = 0;
-                                    for (let r of y[a]) t[e++] = i[r];
+                                    for (let r of y[h]) t[e++] = i[r];
                                     o.push(t)
                                 }
                             }
                             return o
                         }
                         static matrixToString(t) {
                             let e = "";
@@ -2882,95 +2755,95 @@
                             return e
                         }
                         static getPathIncludedDistanceMatrices(t) {
                             let e = t.length,
                                 i = Array(e),
                                 r = Array(e),
                                 n = Array(e);
-                            for (var s = 0, o = 0, h = 0, a = e; a--;) {
-                                i[a] = Array(e), r[a] = Array(e), n[a] = Array(e);
-                                for (var l = e; l--;) i[a][l] = a === l || 1 === t[a][l] ? t[a][l] : Number.POSITIVE_INFINITY, 1 === i[a][l] ? r[a][l] = [
+                            for (var s = 0, o = 0, a = 0, h = e; h--;) {
+                                i[h] = Array(e), r[h] = Array(e), n[h] = Array(e);
+                                for (var l = e; l--;) i[h][l] = h === l || 1 === t[h][l] ? t[h][l] : Number.POSITIVE_INFINITY, 1 === i[h][l] ? r[h][l] = [
                                     [
-                                        [a, l]
+                                        [h, l]
                                     ]
-                                ] : r[a][l] = Array(), n[a][l] = Array()
+                                ] : r[h][l] = Array(), n[h][l] = Array()
                             }
                             for (var g = e; g--;)
-                                for (a = e; a--;)
+                                for (h = e; h--;)
                                     for (l = e; l--;) {
-                                        const t = i[a][l],
-                                            e = i[a][g] + i[g][l];
+                                        const t = i[h][l],
+                                            e = i[h][g] + i[g][l];
                                         if (t > e) {
                                             if (t === e + 1)
-                                                for (n[a][l] = [r[a][l].length], s = r[a][l].length; s--;)
-                                                    for (n[a][l][s] = [r[a][l][s].length], o = r[a][l][s].length; o--;)
-                                                        for (n[a][l][s][o] = [r[a][l][s][o].length], h = r[a][l][s][o].length; h--;) n[a][l][s][o][h] = [r[a][l][s][o][0], r[a][l][s][o][1]];
-                                            else n[a][l] = Array();
-                                            for (i[a][l] = e, r[a][l] = [
+                                                for (n[h][l] = [r[h][l].length], s = r[h][l].length; s--;)
+                                                    for (n[h][l][s] = [r[h][l][s].length], o = r[h][l][s].length; o--;)
+                                                        for (n[h][l][s][o] = [r[h][l][s][o].length], a = r[h][l][s][o].length; a--;) n[h][l][s][o][a] = [r[h][l][s][o][0], r[h][l][s][o][1]];
+                                            else n[h][l] = Array();
+                                            for (i[h][l] = e, r[h][l] = [
                                                     []
-                                                ], s = r[a][g][0].length; s--;) r[a][l][0].push(r[a][g][0][s]);
-                                            for (s = r[g][l][0].length; s--;) r[a][l][0].push(r[g][l][0][s])
+                                                ], s = r[h][g][0].length; s--;) r[h][l][0].push(r[h][g][0][s]);
+                                            for (s = r[g][l][0].length; s--;) r[h][l][0].push(r[g][l][0][s])
                                         } else if (t === e) {
-                                            if (r[a][g].length && r[g][l].length)
-                                                if (r[a][l].length) {
+                                            if (r[h][g].length && r[g][l].length)
+                                                if (r[h][l].length) {
                                                     let t = Array();
-                                                    for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                    for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                     for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                    r[a][l].push(t)
+                                                    r[h][l].push(t)
                                                 } else {
                                                     let t = Array();
-                                                    for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                    for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                     for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                    r[a][l][0] = t
+                                                    r[h][l][0] = t
                                                 }
                                         } else if (t === e - 1)
-                                            if (n[a][l].length) {
+                                            if (n[h][l].length) {
                                                 let t = Array();
-                                                for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                 for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                n[a][l].push(t)
+                                                n[h][l].push(t)
                                             } else {
                                                 let t = Array();
-                                                for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                 for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                n[a][l][0] = t
+                                                n[h][l][0] = t
                                             }
                                     }
                             return {
                                 d: i,
                                 pe: r,
                                 pe_prime: n
                             }
                         }
                         static getRingCandidates(t, e, i) {
                             let r = t.length,
                                 n = Array(),
                                 s = 0;
                             for (let o = 0; o < r; o++)
-                                for (let h = 0; h < r; h++) 0 === t[o][h] || 1 === e[o][h].length && 0 === i[o][h] || (s = 0 !== i[o][h].length ? 2 * (t[o][h] + .5) : 2 * t[o][h], s !== 1 / 0 && n.push([s, e[o][h], i[o][h]]));
+                                for (let a = 0; a < r; a++) 0 === t[o][a] || 1 === e[o][a].length && 0 === i[o][a] || (s = 0 !== i[o][a].length ? 2 * (t[o][a] + .5) : 2 * t[o][a], s !== 1 / 0 && n.push([s, e[o][a], i[o][a]]));
                             return n.sort((function(t, e) {
                                 return t[0] - e[0]
                             })), n
                         }
-                        static getSSSR(t, e, i, r, s, o, h, a) {
+                        static getSSSR(t, e, i, r, s, o, a, h) {
                             let l = Array(),
                                 g = Array();
                             for (let e = 0; e < t.length; e++)
                                 if (t[e][0] % 2 != 0)
                                     for (let r = 0; r < t[e][2].length; r++) {
                                         let s = t[e][1][0].concat(t[e][2][r]);
                                         for (var d = 0; d < s.length; d++) s[d][0].constructor === Array && (s[d] = s[d][0]);
                                         let u = n.bondsToAtoms(s);
-                                        if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, h) || (l.push(u), g = g.concat(s)), l.length > a) return l
+                                        if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, a) || (l.push(u), g = g.concat(s)), l.length > h) return l
                                     } else
                                         for (let r = 0; r < t[e][1].length - 1; r++) {
                                             let s = t[e][1][r].concat(t[e][1][r + 1]);
                                             for (d = 0; d < s.length; d++) s[d][0].constructor === Array && (s[d] = s[d][0]);
                                             let u = n.bondsToAtoms(s);
-                                            if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, h) || (l.push(u), g = g.concat(s)), l.length > a) return l
+                                            if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, a) || (l.push(u), g = g.concat(s)), l.length > h) return l
                                         }
                             return l
                         }
                         static getEdgeCount(t) {
                             let e = 0,
                                 i = t.length;
                             for (var r = i - 1; r--;)
@@ -2992,22 +2865,22 @@
                         static getBondCount(t, e) {
                             let i = 0;
                             for (let r of t)
                                 for (let n of t) r !== n && (i += e[r][n]);
                             return i / 2
                         }
                         static pathSetsContain(t, e, i, r, s, o) {
-                            for (var h = t.length; h--;) {
-                                if (n.isSupersetOf(e, t[h])) return !0;
-                                if (t[h].size === e.size && n.areSetsEqual(t[h], e)) return !0
+                            for (var a = t.length; a--;) {
+                                if (n.isSupersetOf(e, t[a])) return !0;
+                                if (t[a].size === e.size && n.areSetsEqual(t[a], e)) return !0
                             }
-                            let a = 0,
+                            let h = 0,
                                 l = !1;
-                            for (h = i.length; h--;)
-                                for (var g = r.length; g--;)(i[h][0] === r[g][0] && i[h][1] === r[g][1] || i[h][1] === r[g][0] && i[h][0] === r[g][1]) && a++, a === i.length && (l = !0);
+                            for (a = i.length; a--;)
+                                for (var g = r.length; g--;)(i[a][0] === r[g][0] && i[a][1] === r[g][1] || i[a][1] === r[g][0] && i[a][0] === r[g][1]) && h++, h === i.length && (l = !0);
                             let d = !1;
                             if (l)
                                 for (let t of e)
                                     if (o[t] < s[t]) {
                                         d = !0;
                                         break
                                     } if (l && !d) return !0;
@@ -3024,14 +2897,363 @@
                             for (var i of e)
                                 if (!t.has(i)) return !1;
                             return !0
                         }
                     }
                     t.exports = n
                 },
+                479: (t, e, i) => {
+                    const r = i(348),
+                        n = i(427),
+                        s = i(881),
+                        o = (i(707), i(929)),
+                        a = i(36),
+                        h = i(654),
+                        l = i(614);
+                    t.exports = class {
+                        constructor(t) {
+                            this.preprocessor = new s(t)
+                        }
+                        draw(t, e, i = "light", r = !1) {
+                            let n = this.preprocessor;
+                            return n.initDraw(t, i, r), r || (this.themeManager = new h(this.preprocessor.opts.themes, i), this.svgWrapper = new a(this.themeManager, e, this.preprocessor.opts)), n.processGraph(), this.svgWrapper.determineDimensions(n.graph.vertices), this.drawEdges(n.opts.debug), this.drawVertices(n.opts.debug), n.opts.debug && (console.log(n.graph), console.log(n.rings), console.log(n.ringConnections)), this.svgWrapper.constructSvg()
+                        }
+                        drawAromaticityRing(t) {
+                            let e = this.ctx,
+                                i = MathHelper.apothemFromSideLength(this.opts.bondLength, t.getSize());
+                            e.save(), e.strokeStyle = this.getColor("C"), e.lineWidth = this.opts.bondThickness, e.beginPath(), e.arc(t.center.x + this.offsetX, t.center.y + this.offsetY, i - this.opts.bondSpacing, 0, 2 * Math.PI, !0), e.closePath(), e.stroke(), e.restore()
+                        }
+                        drawEdges(t) {
+                            let e = this.preprocessor,
+                                i = e.graph,
+                                r = e.rings,
+                                n = Array(this.preprocessor.graph.edges.length);
+                            if (n.fill(!1), i.traverseBF(0, (e => {
+                                    let r = i.getEdges(e.id);
+                                    for (var s = 0; s < r.length; s++) {
+                                        let e = r[s];
+                                        n[e] || (n[e] = !0, this.drawEdge(e, t))
+                                    }
+                                })), !this.bridgedRing)
+                                for (var s = 0; s < r.length; s++) {
+                                    let t = r[s];
+                                    e.isRingAromatic(t) && this.drawAromaticityRing(t)
+                                }
+                        }
+                        drawEdge(t, e) {
+                            let i = this.preprocessor,
+                                n = i.opts,
+                                s = this.svgWrapper,
+                                a = i.graph.edges[t],
+                                h = i.graph.vertices[a.sourceId],
+                                g = i.graph.vertices[a.targetId],
+                                d = h.value.element,
+                                u = g.value.element;
+                            if (!(h.value.isDrawn && g.value.isDrawn || "default" !== i.opts.atomVisualization)) return;
+                            let c = h.position,
+                                p = g.position,
+                                f = i.getEdgeNormals(a),
+                                v = r.clone(f);
+                            if (v[0].multiplyScalar(10).add(c), v[1].multiplyScalar(10).add(c), "=" === a.bondType || "=" === i.getRingbondType(h, g) || a.isPartOfAromaticRing && i.bridgedRing) {
+                                let t = i.areVerticesInSameRing(h, g),
+                                    e = i.chooseSide(h, g, v);
+                                if (t) {
+                                    let t = i.getLargestOrAromaticCommonRing(h, g).center;
+                                    f[0].multiplyScalar(n.bondSpacing), f[1].multiplyScalar(n.bondSpacing);
+                                    let e = null;
+                                    e = t.sameSideAs(h.position, g.position, l.add(c, f[0])) ? new o(l.add(c, f[0]), l.add(p, f[0]), d, u) : new o(l.add(c, f[1]), l.add(p, f[1]), d, u), e.shorten(n.bondLength - n.shortBondLength * n.bondLength), a.isPartOfAromaticRing ? s.drawLine(e, !0) : s.drawLine(e), s.drawLine(new o(c, p, d, u))
+                                } else if (a.center || h.isTerminal() && g.isTerminal() || 0 == e.anCount && e.bnCount > 1 || 0 == e.bnCount && e.anCount > 1) {
+                                    this.multiplyNormals(f, n.halfBondSpacing);
+                                    let t = new o(l.add(c, f[0]), l.add(p, f[0]), d, u),
+                                        e = new o(l.add(c, f[1]), l.add(p, f[1]), d, u);
+                                    s.drawLine(t), s.drawLine(e)
+                                } else if (e.sideCount[0] > e.sideCount[1] || e.totalSideCount[0] > e.totalSideCount[1]) {
+                                    this.multiplyNormals(f, n.bondSpacing);
+                                    let t = new o(l.add(c, f[0]), l.add(p, f[0]), d, u);
+                                    t.shorten(n.bondLength - n.shortBondLength * n.bondLength), s.drawLine(t), s.drawLine(new o(c, p, d, u))
+                                } else if (e.sideCount[0] < e.sideCount[1] || e.totalSideCount[0] <= e.totalSideCount[1]) {
+                                    this.multiplyNormals(f, n.bondSpacing);
+                                    let t = new o(l.add(c, f[1]), l.add(p, f[1]), d, u);
+                                    t.shorten(n.bondLength - n.shortBondLength * n.bondLength), s.drawLine(t), s.drawLine(new o(c, p, d, u))
+                                }
+                            } else if ("#" === a.bondType) {
+                                f[0].multiplyScalar(n.bondSpacing / 1.5), f[1].multiplyScalar(n.bondSpacing / 1.5);
+                                let t = new o(l.add(c, f[0]), l.add(p, f[0]), d, u),
+                                    e = new o(l.add(c, f[1]), l.add(p, f[1]), d, u);
+                                s.drawLine(t), s.drawLine(e), s.drawLine(new o(c, p, d, u))
+                            } else if ("." === a.bondType);
+                            else {
+                                let t = h.value.isStereoCenter,
+                                    e = g.value.isStereoCenter;
+                                "up" === a.wedge ? s.drawWedge(new o(c, p, d, u, t, e)) : "down" === a.wedge ? s.drawDashedWedge(new o(c, p, d, u, t, e)) : s.drawLine(new o(c, p, d, u, t, e))
+                            }
+                            if (e) {
+                                let e = l.midpoint(c, p);
+                                s.drawDebugText(e.x, e.y, "e: " + t)
+                            }
+                        }
+                        drawVertices(t) {
+                            let e = this.preprocessor,
+                                i = e.opts,
+                                s = e.graph,
+                                o = e.rings,
+                                a = this.svgWrapper;
+                            var h = s.vertices.length;
+                            for (h = 0; h < s.vertices.length; h++) {
+                                let e = s.vertices[h],
+                                    o = e.value,
+                                    g = 0,
+                                    d = 0,
+                                    u = e.value.bondCount,
+                                    c = o.element,
+                                    p = n.maxBonds[c] - u,
+                                    f = e.getTextDirection(s.vertices),
+                                    v = !(!i.terminalCarbons && "C" === c && !o.hasAttachedPseudoElements) && e.isTerminal(),
+                                    m = "C" === o.element;
+                                if ("N" === o.element && o.isPartOfAromaticRing && (p = 0), o.bracket && (p = o.bracket.hcount, g = o.bracket.charge, d = o.bracket.isotope), "allballs" === i.atomVisualization) a.drawBall(e.position.x, e.position.y, c);
+                                else if (o.isDrawn && (!m || o.drawExplicit || v || o.hasAttachedPseudoElements) || 1 === s.vertices.length) "default" === i.atomVisualization ? a.drawText(e.position.x, e.position.y, c, p, f, v, g, d, o.getAttachedPseudoElements()) : "balls" === i.atomVisualization && a.drawBall(e.position.x, e.position.y, c);
+                                else if (2 === e.getNeighbourCount() && 1 == e.forcePositioned) {
+                                    let t = s.vertices[e.neighbours[0]].position,
+                                        i = s.vertices[e.neighbours[1]].position,
+                                        r = l.threePointangle(e.position, t, i);
+                                    Math.abs(Math.PI - r) < .1 && a.drawPoint(e.position.x, e.position.y, c)
+                                }
+                                if (t) {
+                                    let t = "v: " + e.id + " " + r.print(o.ringbonds);
+                                    a.drawDebugText(e.position.x, e.position.y, t)
+                                } else a.drawDebugText(e.position.x, e.position.y, e.value.chirality)
+                            }
+                            if (i.debug)
+                                for (h = 0; h < o.length; h++) {
+                                    let t = o[h].center;
+                                    a.drawDebugPoint(t.x, t.y, "r: " + o[h].id)
+                                }
+                        }
+                        getTotalOverlapScore() {
+                            return this.preprocessor.getTotalOverlapScore()
+                        }
+                        getMolecularFormula() {
+                            return this.preprocessor.getMolecularFormula()
+                        }
+                        multiplyNormals(t, e) {
+                            t[0].multiplyScalar(e), t[1].multiplyScalar(e)
+                        }
+                    }
+                },
+                36: (t, e, i) => {
+                    const {
+                        getChargeText: r
+                    } = i(537), n = i(929), s = i(614);
+                    t.exports = class {
+                        constructor(t, e, i) {
+                            this.svg = document.getElementById(e), this.opts = i, this.gradientId = 0, this.paths = [], this.vertices = [], this.gradients = [], this.offsetX = 0, this.offsetY = 0, this.drawingWidth = 0, this.drawingHeight = 0, this.halfBondThickness = this.opts.bondThickness / 2, this.themeManager = t, this.maskElements = [];
+                            let r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
+                            for (r.setAttributeNS(null, "x", 0), r.setAttributeNS(null, "y", 0), r.setAttributeNS(null, "width", "100%"), r.setAttributeNS(null, "height", "100%"), r.setAttributeNS(null, "fill", "white"), this.maskElements.push(r); this.svg.firstChild;) this.svg.removeChild(this.svg.firstChild)
+                        }
+                        constructSvg() {
+                            let t = document.createElementNS("http://www.w3.org/2000/svg", "defs"),
+                                e = document.createElementNS("http://www.w3.org/2000/svg", "mask"),
+                                i = document.createElementNS("http://www.w3.org/2000/svg", "style"),
+                                r = document.createElementNS("http://www.w3.org/2000/svg", "g"),
+                                n = document.createElementNS("http://www.w3.org/2000/svg", "g"),
+                                s = this.paths;
+                            e.setAttributeNS(null, "id", "text-mask"), i.appendChild(document.createTextNode(`\n                .element {\n                    font: ${this.opts.fontSizeLarge}pt Helvetica, Arial, sans-serif;\n                    alignment-baseline: 'middle';\n                }\n                .sub {\n                    font: ${this.opts.fontSizeSmall}pt Helvetica, Arial, sans-serif;\n                }\n            `));
+                            for (let t of s) r.appendChild(t);
+                            for (let t of this.vertices) n.appendChild(t);
+                            for (let t of this.maskElements) e.appendChild(t);
+                            for (let e of this.gradients) t.appendChild(e);
+                            if (r.setAttributeNS(null, "mask", "url(#text-mask)"), this.svg) return this.svg.appendChild(t), this.svg.appendChild(e), this.svg.appendChild(i), this.svg.appendChild(r), this.svg.appendChild(n), this.svg; {
+                                let s = document.createElementNS("http://www.w3.org/2000/svg", "g");
+                                return s.appendChild(t), s.appendChild(e), s.appendChild(i), s.appendChild(r), s.appendChild(n), s
+                            }
+                        }
+                        createGradient(t) {
+                            let e = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"),
+                                i = "line-" + this.gradientId++,
+                                r = t.getLeftVector(),
+                                n = t.getRightVector(),
+                                s = r.x + this.offsetX,
+                                o = r.y + this.offsetY,
+                                a = n.x + this.offsetX,
+                                h = n.y + this.offsetY;
+                            e.setAttributeNS(null, "id", i), e.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), e.setAttributeNS(null, "x1", s), e.setAttributeNS(null, "y1", o), e.setAttributeNS(null, "x2", a), e.setAttributeNS(null, "y2", h);
+                            let l = document.createElementNS("http://www.w3.org/2000/svg", "stop");
+                            l.setAttributeNS(null, "stop-color", this.themeManager.getColor(t.getLeftElement()) || this.themeManager.getColor("C")), l.setAttributeNS(null, "offset", "20%");
+                            let g = document.createElementNS("http://www.w3.org/2000/svg", "stop");
+                            return g.setAttributeNS(null, "stop-color", this.themeManager.getColor(t.getRightElement() || this.themeManager.getColor("C"))), g.setAttributeNS(null, "offset", "100%"), e.appendChild(l), e.appendChild(g), this.gradients.push(e), i
+                        }
+                        createSubSuperScripts(t, e) {
+                            let i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                            return i.setAttributeNS(null, "baseline-shift", e), i.appendChild(document.createTextNode(t)), i.setAttributeNS(null, "class", "sub"), i
+                        }
+                        determineDimensions(t) {
+                            let e = -Number.MAX_VALUE,
+                                i = -Number.MAX_VALUE,
+                                r = Number.MAX_VALUE,
+                                n = Number.MAX_VALUE;
+                            for (var s = 0; s < t.length; s++) {
+                                if (!t[s].value.isDrawn) continue;
+                                let o = t[s].position;
+                                e < o.x && (e = o.x), i < o.y && (i = o.y), r > o.x && (r = o.x), n > o.y && (n = o.y)
+                            }
+                            let o = this.opts.padding;
+                            e += o, i += o, r -= o, n -= o, this.drawingWidth = e - r, this.drawingHeight = i - n;
+                            let a = this.svg.clientWidth / this.drawingWidth,
+                                h = this.svg.clientHeight / this.drawingHeight,
+                                l = a < h ? a : h,
+                                g = Math.round(this.drawingWidth > this.drawingHeight ? this.drawingWidth : this.drawingHeight);
+                            this.svg.setAttributeNS(null, "viewBox", `0 0 ${g} ${g}`), this.offsetX = -r, this.offsetY = -n, a < h ? this.offsetY += this.svg.clientHeight / (2 * l) - this.drawingHeight / 2 : this.offsetX += this.svg.clientWidth / (2 * l) - this.drawingWidth / 2
+                        }
+                        drawBall(t, e, i) {
+                            let r = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            r.setAttributeNS(null, "cx", t + this.offsetX), r.setAttributeNS(null, "cy", e + this.offsetY), r.setAttributeNS(null, "r", this.opts.bondLength / 4.5), r.setAttributeNS(null, "fill", this.themeManager.getColor(i)), this.vertices.push(r)
+                        }
+                        drawDashedWedge(t) {
+                            if (isNaN(t.from.x) || isNaN(t.from.y) || isNaN(t.to.x) || isNaN(t.to.y)) return;
+                            this.offsetX, this.offsetY;
+                            let e, i, r = t.getLeftVector().clone(),
+                                o = t.getRightVector().clone(),
+                                a = s.normals(r, o);
+                            a[0].normalize(), a[1].normalize(), t.getRightChiral() ? (e = o, i = r) : (e = r, i = o);
+                            let h = s.subtract(i, e).normalize(),
+                                l = t.getLength(),
+                                g = 1.25 / (l / (3 * this.opts.bondThickness)),
+                                d = this.createGradient(t);
+                            for (let t = 0; t < 1; t += g) {
+                                let i = s.multiplyScalar(h, t * l),
+                                    r = s.add(e, i),
+                                    o = 1.5 * t,
+                                    g = s.multiplyScalar(a[0], o);
+                                r.subtract(g);
+                                let u = r.clone();
+                                u.add(s.multiplyScalar(g, 2)), this.drawLine(new n(r, u), null, d)
+                            }
+                        }
+                        drawDebugPoint(t, e, i = "", r = "#f00") {
+                            let n = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            n.setAttributeNS(null, "cx", t + this.offsetX), n.setAttributeNS(null, "cy", e + this.offsetY), n.setAttributeNS(null, "r", "2"), n.setAttributeNS(null, "fill", "#f00"), this.vertices.push(n), this.drawDebugText(t, e, i)
+                        }
+                        drawDebugText(t, e, i) {
+                            let r = document.createElementNS("http://www.w3.org/2000/svg", "text");
+                            r.setAttributeNS(null, "x", t + this.offsetX), r.setAttributeNS(null, "y", e + this.offsetY), r.setAttributeNS(null, "class", "debug"), r.setAttributeNS(null, "fill", "#ff0000"), r.setAttributeNS(null, "style", "\n                font: 5px Droid Sans, sans-serif;\n            "), r.appendChild(document.createTextNode(i)), this.vertices.push(r)
+                        }
+                        drawLine(t, e = !1, i = null) {
+                            this.opts;
+                            let r = [
+                                    ["stroke-linecap", "round"],
+                                    ["stroke-dasharray", e ? "5, 5" : "none"]
+                                ],
+                                n = t.getLeftVector(),
+                                s = t.getRightVector(),
+                                o = n.x + this.offsetX,
+                                a = n.y + this.offsetY,
+                                h = s.x + this.offsetX,
+                                l = s.y + this.offsetY,
+                                g = r.map((t => t.join(":"))).join(";"),
+                                d = document.createElementNS("http://www.w3.org/2000/svg", "line");
+                            d.setAttributeNS(null, "x1", o), d.setAttributeNS(null, "y1", a), d.setAttributeNS(null, "x2", h), d.setAttributeNS(null, "y2", l), d.setAttributeNS(null, "style", g), this.paths.push(d), null == i && (i = this.createGradient(t, o, a, h, l)), d.setAttributeNS(null, "stroke", `url('#${i}')`)
+                        }
+                        drawPoint(t, e, i) {
+                            this.ctx;
+                            let r = this.offsetX,
+                                n = this.offsetY,
+                                s = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            s.setAttributeNS(null, "cx", t + r), s.setAttributeNS(null, "cy", e + n), s.setAttributeNS(null, "r", "1.5"), s.setAttributeNS(null, "fill", "black"), this.maskElements.push(s);
+                            let o = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            o.setAttributeNS(null, "cx", t + r), o.setAttributeNS(null, "cy", e + n), o.setAttributeNS(null, "r", "0.75"), o.setAttributeNS(null, "fill", this.themeManager.getColor(i)), this.vertices.push(o)
+                        }
+                        drawText(t, e, i, n, s, o, a, h, l = {}) {
+                            let g = {
+                                    x: t + this.offsetX,
+                                    y: e + this.offsetY
+                                },
+                                d = document.createElementNS("http://www.w3.org/2000/svg", "text"),
+                                u = "horizontal-tb",
+                                c = "normal",
+                                p = "mixed",
+                                f = "direction: ltr;",
+                                v = -2,
+                                m = 2.5,
+                                b = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            b.setAttributeNS(null, "cx", g.x), b.setAttributeNS(null, "cy", g.y), b.setAttributeNS(null, "r", "3.5"), b.setAttributeNS(null, "fill", "black"), this.maskElements.push(b), /up|down/.test(s) && !o && (u = "vertical-rl", p = "upright", c = "-1px"), "down" !== s || o ? "up" !== s || o ? "left" === s && (v = 2) : v = .5 : (v = 0, m = -2), ("left" === s || "up" === s && !o) && (f = "direction: rtl; unicode-bidi: bidi-override;"), d.setAttributeNS(null, "x", g.x + v), d.setAttributeNS(null, "y", g.y + m), d.setAttributeNS(null, "class", "element"), d.setAttributeNS(null, "fill", this.themeManager.getColor(i)), d.setAttributeNS(null, "style", `\n                text-anchor: start;\n                writing-mode: ${u};\n                text-orientation: ${p};\n                letter-spacing: ${c};\n                ${f}\n            `);
+                            let y = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                            if (i.length > 1) {
+                                let t = /up|down/.test(s) ? "middle" : "start";
+                                y.setAttributeNS(null, "style", `\n                unicode-bidi: plaintext;\n                writing-mode: lr-tb;\n                letter-spacing: normal;\n                text-anchor: ${t};\n            `)
+                            }
+                            if (y.appendChild(document.createTextNode(i)), d.appendChild(y), a) {
+                                let t = this.createSubSuperScripts(r(a), "super");
+                                y.appendChild(t)
+                            }
+                            if (h > 0) {
+                                let t = this.createSubSuperScripts(h.toString(), "super");
+                                y.appendChild(t)
+                            }
+                            if (1 === a && "N" === i && l.hasOwnProperty("0O") && l.hasOwnProperty("0O-1") && (l = {
+                                    "0O": {
+                                        element: "O",
+                                        count: 2,
+                                        hydrogenCount: 0,
+                                        previousElement: "C",
+                                        charge: ""
+                                    }
+                                }, a = 0), n > 0) {
+                                let t = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                                if (t.setAttributeNS(null, "style", "unicode-bidi: plaintext;"), t.appendChild(document.createTextNode("H")), d.appendChild(t), n > 1) {
+                                    let e = this.createSubSuperScripts(n, "sub");
+                                    t.appendChild(e)
+                                }
+                            }
+                            for (let t in l) {
+                                if (!l.hasOwnProperty(t)) continue;
+                                let e = l[t].element,
+                                    i = l[t].count,
+                                    n = l[t].hydrogenCount,
+                                    s = l[t].charge,
+                                    o = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                                if (o.setAttributeNS(null, "style", "unicode-bidi: plaintext;"), o.appendChild(document.createTextNode(e)), o.setAttributeNS(null, "fill", this.themeManager.getColor(e)), 0 !== s) {
+                                    let t = this.createSubSuperScripts(r(s), "super");
+                                    o.appendChild(t)
+                                }
+                                if (n > 0) {
+                                    let t = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                                    if (t.setAttributeNS(null, "style", "unicode-bidi: plaintext;"), t.appendChild(document.createTextNode("H")), o.appendChild(t), n > 1) {
+                                        let e = this.createSubSuperScripts(n, "sub");
+                                        t.appendChild(e)
+                                    }
+                                }
+                                if (i > 1) {
+                                    let t = this.createSubSuperScripts(i, "sub");
+                                    o.appendChild(t)
+                                }
+                                d.appendChild(o)
+                            }
+                            this.vertices.push(d)
+                        }
+                        drawWedge(t) {
+                            let e = this.offsetX,
+                                i = this.offsetY,
+                                r = t.getLeftVector().clone(),
+                                n = t.getRightVector().clone();
+                            r.x += e, r.y += i, n.x += e, n.y += i;
+                            let o = s.normals(r, n);
+                            o[0].normalize(), o[1].normalize();
+                            let a = r,
+                                h = n;
+                            t.getRightChiral() && (a = n, h = r);
+                            let l = s.add(a, s.multiplyScalar(o[0], this.halfBondThickness)),
+                                g = s.add(h, s.multiplyScalar(o[0], 1.5 + this.halfBondThickness)),
+                                d = s.add(h, s.multiplyScalar(o[1], 1.5 + this.halfBondThickness)),
+                                u = s.add(a, s.multiplyScalar(o[1], this.halfBondThickness)),
+                                c = document.createElementNS("http://www.w3.org/2000/svg", "polygon"),
+                                p = this.createGradient(t, r.x, r.y, n.x, n.y);
+                            c.setAttributeNS(null, "points", `${l.x},${l.y} ${g.x},${g.y} ${d.x},${d.y} ${u.x},${u.y}`), c.setAttributeNS(null, "fill", `url('#${p}')`), this.paths.push(c)
+                        }
+                    }
+                },
                 654: t => {
                     t.exports = class {
                         constructor(t, e) {
                             this.colors = t, this.theme = this.colors[e]
                         }
                         getColor(t) {
                             return t && (t = t.toUpperCase()) in this.theme ? this.theme[t] : this.theme.C
@@ -3040,15 +3262,15 @@
                             this.colors.hasOwnProperty(t) && (this.theme = this.colors[t])
                         }
                     }
                 },
                 537: t => {
                     t.exports = {
                         getChargeText: function(t) {
-                            return 1 === t ? "+" : 2 === t ? "2+" : -1 === t ? "-" : -2 === t ? "2-" : ""
+                            return console.log("in the utility version of getChargeText"), 1 === t ? "+" : 2 === t ? "2+" : -1 === t ? "-" : -2 === t ? "2-" : ""
                         }
                     }
                 },
                 614: t => {
                     class e {
                         constructor(t, e) {
                             0 == arguments.length ? (this.x = 0, this.y = 0) : 1 == arguments.length ? (this.x = t.x, this.y = t.y) : (this.x = t, this.y = e)
@@ -3201,16 +3423,16 @@
                             let r = e.dot(t, i);
                             return Math.acos(r / (t.length() * i.length()))
                         }
                         static threePointangle(t, i, r) {
                             let n = e.subtract(i, t),
                                 s = e.subtract(r, i),
                                 o = t.distance(i),
-                                h = i.distance(r);
-                            return Math.acos(e.dot(n, s) / (o * h))
+                                a = i.distance(r);
+                            return Math.acos(e.dot(n, s) / (o * a))
                         }
                         static scalarProjection(t, i) {
                             let r = i.normalized();
                             return e.dot(t, r)
                         }
                         static averageDirection(t) {
                             let i = new e(0, 0);
@@ -3264,15 +3486,14 @@
                         getAngle(t = null, e = !1) {
                             let i = null;
                             return i = t ? s.subtract(this.position, t) : s.subtract(this.position, this.previousPosition), e ? r.toDeg(i.angle()) : i.angle()
                         }
                         getTextDirection(t) {
                             let e = this.getDrawnNeighbours(t),
                                 i = Array();
-                            if (1 === t.length) return "right";
                             for (let r = 0; r < e.length; r++) i.push(this.getAngle(t[e[r]].position));
                             let n = r.meanAngle(i),
                                 s = Math.PI / 2;
                             return n = Math.round(Math.round(n / s) * s), 2 === n ? "down" : -2 === n ? "up" : 0 === n || -0 === n ? "right" : 3 === n || -3 === n ? "left" : "down"
                         }
                         getNeighbours(t = null) {
                             if (null === t) return this.neighbours.slice();
@@ -3310,20 +3531,15 @@
         function i(r) {
             if (e[r]) return e[r].exports;
             var n = e[r] = {
                 exports: {}
             };
             return t[r](n, n.exports, i), n.exports
         }
-        i.n = t => {
-            var e = t && t.__esModule ? () => t.default : () => t;
-            return i.d(e, {
-                a: e
-            }), e
-        }, i.d = (t, e) => {
+        i.d = (t, e) => {
             for (var r in e) i.o(e, r) && !i.o(t, r) && Object.defineProperty(t, r, {
                 enumerable: !0,
                 get: e[r]
             })
         }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => {
             "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                 value: "Module"
@@ -3331,29 +3547,31 @@
                 value: !0
             })
         };
         var r = {};
         return (() => {
             "use strict";
             i.r(r), i.d(r, {
-                clean2d: () => o
+                clean2d: () => s
+            });
+            const {
+                Parser: t,
+                Drawer: e
+            } = i(261), n = new e({
+                debug: !1,
+                atomVisualization: "default"
             });
-            var t = i(237),
-                e = i.n(t),
-                n = i(19),
-                s = i.n(n);
 
-            function o(t) {
-                const i = new(e())({}),
-                    r = s().parse(t);
-                i.initDraw(r, "light", !1), i.processGraph();
-                let n = i.graph.vertices,
-                    o = Array();
-                for (let t = 0; t < n.length; t++) {
-                    let e = n[t].position;
-                    o.push([e.x, e.y])
+            function s(e) {
+                let i = t.parse(e);
+                n.initDraw(i, "light", !1), n.processGraph();
+                let r = n.graph.vertices,
+                    s = Array();
+                for (let t = 0; t < r.length; t++) {
+                    let e = r[t].position;
+                    s.push([e.x, e.y])
                 }
-                return o
+                return s
             }
         })(), r
     })()
 }));
```

### Comparing `chython-1.64/chython/algorithms/fingerprints/__init__.py` & `chython-1.8/chython/algorithms/fingerprints/pharmacophore/test/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,28 +1,19 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .linear import *
-from .morgan import *
-
-
-class Fingerprints(LinearFingerprint, MorganFingerprint):
-    __slots__ = ()
-
-
-__all__ = ['Fingerprints']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.64/chython/algorithms/mapping/__init__.py` & `chython-1.8/chython/algorithms/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,28 +1,18 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .attention import Attention
-from .fixmapper import FixMapper
-from .groups import GroupsFix
-
-
-class Mapping(GroupsFix, Attention, FixMapper):
-    __slots__ = ()
-
-
-__all__ = ['Mapping']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.64/chython/algorithms/mcs.py` & `chython-1.8/chython/algorithms/mcs.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,202 +1,202 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from itertools import product, combinations, islice
-from typing import Dict, Set, Iterator, Tuple
-from ..containers import molecule
-
-
-class MCS:
-    __slots__ = ()
-
-    def get_mcs_mapping(self, other: 'molecule.MoleculeContainer', /, *, limit=10000) -> Iterator[Dict[int, int]]:
-        """
-        Find maximum common substructure. Based on clique searching in product graph.
-
-        :param limit: limit tested cliques
-        """
-        if not isinstance(other, molecule.MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-
-        core_product, full_product = self.__get_product(other)
-        if not core_product:
-            return
-
-        # search maximum bonded substructures
-        hits = []
-        max_atoms = 0
-        max_bonds = 0
-        for mapping in islice(_clique(full_product), limit):
-            if len(mapping) < max_atoms:
-                continue
-            # search bonds count
-            bonds = 0
-            seen = set()
-            for n in mapping:
-                seen.add(n)
-                for m in core_product[n]:
-                    if m not in seen and m in mapping:
-                        bonds += 1
-            if bonds > max_bonds:
-                max_bonds = bonds
-                max_atoms = len(mapping) - 1  # -1 is ad-hoc
-                hits = [mapping]
-            elif bonds == max_bonds:
-                hits.append(mapping)
-
-        # search maximal components in substructures
-        hits2 = []
-        max_component = 0
-        for mapping in hits:
-            # search components
-            components = []
-            atoms = mapping.copy()
-            while atoms:
-                n = atoms.pop()
-                seen = {n}
-                queue = [n]
-                component = []
-                while queue:
-                    n = queue.pop(0)
-                    component.append(n)
-                    for m in core_product[n]:
-                        if m not in seen and m in mapping:
-                            queue.append(m)
-                            seen.add(m)
-
-                components.append(component)
-                atoms.difference_update(component)
-
-            # get max component
-            component = max(len(x) for x in components)
-            if component > max_component:
-                max_component = component
-                hits2 = [mapping]
-            elif component == max_component:
-                hits2.append(mapping)
-        yield from (dict(x) for x in hits2)
-
-    def __get_product(self: 'molecule.MoleculeContainer', other: 'molecule.MoleculeContainer'):
-        bonds = self._bonds
-        o_bonds = other._bonds
-
-        s_equal = defaultdict(list)  # equal self atoms
-        for n, atom in self._atoms.items():
-            s_equal[atom].append(n)
-        p_equal = defaultdict(list)  # equal other atoms
-        for n, atom in other._atoms.items():
-            p_equal[atom].append(n)
-
-        full_product = {}
-        core_product = {}
-        equal_atoms = {}
-        for atom, ns in s_equal.items():
-            ms = p_equal[atom]
-            if ms:
-                for nm in product(ns, ms):
-                    full_product[nm] = set()
-                    core_product[nm] = set()
-                for n in ns:
-                    equal_atoms[n] = ms  # memory save
-
-        seen = set()
-        for n, o_ns in equal_atoms.items():
-            seen.add(n)
-            for m, b in bonds[n].items():
-                if m in equal_atoms and m not in seen:
-                    o_ms = equal_atoms[m]
-                    for o_n in o_ns:
-                        node1 = (n, o_n)
-                        fms = full_product[node1]
-                        cms = core_product[node1]
-                        for o_m, o_b in o_bonds[o_n].items():
-                            if o_m in o_ms and b == o_b:
-                                node2 = (m, o_m)
-                                full_product[node2].add(node1)
-                                core_product[node2].add(node1)
-                                fms.add(node2)
-                                cms.add(node2)
-
-        atoms = core_product
-        while atoms:
-            new_atoms = set()
-            for n in atoms:
-                core = core_product[n]
-                for nm1, nm2 in combinations(full_product[n], 2):
-                    n1, m1 = nm1
-                    n2, m2 = nm2
-                    if n1 == n2 or m1 == m2:
-                        continue
-                    if nm1 in full_product[nm2]:
-                        continue
-                    if nm1 not in core and nm2 not in core:
-                        continue
-
-                    full_product[nm1].add(nm2)
-                    full_product[nm2].add(nm1)
-                    new_atoms.add(nm1)
-                    new_atoms.add(nm2)
-            atoms = new_atoms
-
-        return core_product, full_product
-
-
-def _clique(graph) -> Iterator[Set[Tuple[int, int]]]:
-    """
-    clique search
-
-    adopted from networkx algorithms.clique.find_cliques
-    """
-    subgraph = {x for x, y in graph.items() if y}  # skip isolated nodes
-    if not subgraph:
-        return  # empty or fully disconnected
-    elif len(subgraph) == 2:  # dimer
-        yield set(subgraph)
-        return
-
-    stack = []
-    clique_atoms = [None]
-    candidates = subgraph.copy()
-    roots = candidates - graph[max(subgraph, key=lambda x: len(graph[x]))]
-
-    while True:
-        if roots:
-            root = roots.pop()
-            candidates.remove(root)
-            clique_atoms[-1] = root
-            neighbors = graph[root]
-            neighbors_subgraph = subgraph & neighbors
-            if not neighbors_subgraph:
-                yield set(clique_atoms)
-            else:
-                neighbors_candidates = candidates & neighbors
-                if neighbors_candidates:
-                    stack.append((subgraph, candidates, roots))
-                    clique_atoms.append(None)
-                    subgraph = neighbors_subgraph
-                    candidates = neighbors_candidates
-                    roots = candidates - graph[max(subgraph, key=lambda x: len(candidates & graph[x]))]
-        elif not stack:
-            return
-        else:
-            clique_atoms.pop()
-            subgraph, candidates, roots = stack.pop()
-
-
-__all__ = ['MCS']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from itertools import product, combinations, islice
+from typing import Dict, Set, Iterator, Tuple
+from ..containers import molecule
+
+
+class MCS:
+    __slots__ = ()
+
+    def get_mcs_mapping(self, other: 'molecule.MoleculeContainer', /, *, limit=10000) -> Iterator[Dict[int, int]]:
+        """
+        Find maximum common substructure. Based on clique searching in product graph.
+
+        :param limit: limit tested cliques
+        """
+        if not isinstance(other, molecule.MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+
+        core_product, full_product = self.__get_product(other)
+        if not core_product:
+            return
+
+        # search maximum bonded substructures
+        hits = []
+        max_atoms = 0
+        max_bonds = 0
+        for mapping in islice(_clique(full_product), limit):
+            if len(mapping) < max_atoms:
+                continue
+            # search bonds count
+            bonds = 0
+            seen = set()
+            for n in mapping:
+                seen.add(n)
+                for m in core_product[n]:
+                    if m not in seen and m in mapping:
+                        bonds += 1
+            if bonds > max_bonds:
+                max_bonds = bonds
+                max_atoms = len(mapping) - 1  # -1 is ad-hoc
+                hits = [mapping]
+            elif bonds == max_bonds:
+                hits.append(mapping)
+
+        # search maximal components in substructures
+        hits2 = []
+        max_component = 0
+        for mapping in hits:
+            # search components
+            components = []
+            atoms = mapping.copy()
+            while atoms:
+                n = atoms.pop()
+                seen = {n}
+                queue = [n]
+                component = []
+                while queue:
+                    n = queue.pop(0)
+                    component.append(n)
+                    for m in core_product[n]:
+                        if m not in seen and m in mapping:
+                            queue.append(m)
+                            seen.add(m)
+
+                components.append(component)
+                atoms.difference_update(component)
+
+            # get max component
+            component = max(len(x) for x in components)
+            if component > max_component:
+                max_component = component
+                hits2 = [mapping]
+            elif component == max_component:
+                hits2.append(mapping)
+        yield from (dict(x) for x in hits2)
+
+    def __get_product(self: 'molecule.MoleculeContainer', other: 'molecule.MoleculeContainer'):
+        bonds = self._bonds
+        o_bonds = other._bonds
+
+        s_equal = defaultdict(list)  # equal self atoms
+        for n, atom in self._atoms.items():
+            s_equal[atom].append(n)
+        p_equal = defaultdict(list)  # equal other atoms
+        for n, atom in other._atoms.items():
+            p_equal[atom].append(n)
+
+        full_product = {}
+        core_product = {}
+        equal_atoms = {}
+        for atom, ns in s_equal.items():
+            ms = p_equal[atom]
+            if ms:
+                for nm in product(ns, ms):
+                    full_product[nm] = set()
+                    core_product[nm] = set()
+                for n in ns:
+                    equal_atoms[n] = ms  # memory save
+
+        seen = set()
+        for n, o_ns in equal_atoms.items():
+            seen.add(n)
+            for m, b in bonds[n].items():
+                if m in equal_atoms and m not in seen:
+                    o_ms = equal_atoms[m]
+                    for o_n in o_ns:
+                        node1 = (n, o_n)
+                        fms = full_product[node1]
+                        cms = core_product[node1]
+                        for o_m, o_b in o_bonds[o_n].items():
+                            if o_m in o_ms and b == o_b:
+                                node2 = (m, o_m)
+                                full_product[node2].add(node1)
+                                core_product[node2].add(node1)
+                                fms.add(node2)
+                                cms.add(node2)
+
+        atoms = core_product
+        while atoms:
+            new_atoms = set()
+            for n in atoms:
+                core = core_product[n]
+                for nm1, nm2 in combinations(full_product[n], 2):
+                    n1, m1 = nm1
+                    n2, m2 = nm2
+                    if n1 == n2 or m1 == m2:
+                        continue
+                    if nm1 in full_product[nm2]:
+                        continue
+                    if nm1 not in core and nm2 not in core:
+                        continue
+
+                    full_product[nm1].add(nm2)
+                    full_product[nm2].add(nm1)
+                    new_atoms.add(nm1)
+                    new_atoms.add(nm2)
+            atoms = new_atoms
+
+        return core_product, full_product
+
+
+def _clique(graph) -> Iterator[Set[Tuple[int, int]]]:
+    """
+    clique search
+
+    adopted from networkx algorithms.clique.find_cliques
+    """
+    subgraph = {x for x, y in graph.items() if y}  # skip isolated nodes
+    if not subgraph:
+        return  # empty or fully disconnected
+    elif len(subgraph) == 2:  # dimer
+        yield set(subgraph)
+        return
+
+    stack = []
+    clique_atoms = [None]
+    candidates = subgraph.copy()
+    roots = candidates - graph[max(subgraph, key=lambda x: len(graph[x]))]
+
+    while True:
+        if roots:
+            root = roots.pop()
+            candidates.remove(root)
+            clique_atoms[-1] = root
+            neighbors = graph[root]
+            neighbors_subgraph = subgraph & neighbors
+            if not neighbors_subgraph:
+                yield set(clique_atoms)
+            else:
+                neighbors_candidates = candidates & neighbors
+                if neighbors_candidates:
+                    stack.append((subgraph, candidates, roots))
+                    clique_atoms.append(None)
+                    subgraph = neighbors_subgraph
+                    candidates = neighbors_candidates
+                    roots = candidates - graph[max(subgraph, key=lambda x: len(candidates & graph[x]))]
+        elif not stack:
+            return
+        else:
+            clique_atoms.pop()
+            subgraph, candidates, roots = stack.pop()
+
+
+__all__ = ['MCS']
```

### Comparing `chython-1.64/chython/algorithms/morgan.py` & `chython-1.8/chython/algorithms/morgan.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,84 +1,81 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from functools import cached_property
-from itertools import groupby
-from logging import getLogger
-from operator import itemgetter
-from typing import Dict, TYPE_CHECKING
-
-
-logger = getLogger('chython.morgan')
-
-
-if TYPE_CHECKING:
-    from chython.containers.graph import Graph
-
-
-class Morgan:
-    __slots__ = ()
-
-    @cached_property
-    def atoms_order(self: 'Graph') -> Dict[int, int]:
-        """
-        Morgan like algorithm for graph nodes ordering
-
-        :return: dict of atom-order pairs
-        """
-        atoms = self._atoms
-        if not atoms:  # for empty containers
-            return {}
-        elif len(atoms) == 1:  # optimize single atom containers
-            return dict.fromkeys(atoms, 1)
-        ring = self.ring_atoms
-        return _morgan({n: hash((hash(a), n in ring)) for n, a in atoms.items()}, self.int_adjacency)
-
-    @cached_property
-    def int_adjacency(self: 'Graph') -> Dict[int, Dict[int, int]]:
-        """
-        Adjacency with integer-coded bonds.
-        """
-        return {n: {m: hash(b) for m, b in mb.items()} for n, mb in self._bonds.items()}
-
-
-def _morgan(atoms: Dict[int, int], bonds: Dict[int, Dict[int, int]]) -> Dict[int, int]:
-    tries = len(atoms) - 1
-    numb = len(set(atoms.values()))
-    stab = old_numb = 0
-
-    for _ in range(tries):
-        atoms = {n: hash((atoms[n], *(x for x in sorted((atoms[m], b) for m, b in ms.items()) for x in x)))
-                 for n, ms in bonds.items()}
-        old_numb, numb = numb, len(set(atoms.values()))
-        if numb == len(atoms):  # each atom now unique
-            break
-        elif numb == old_numb:  # not changed. molecules like benzene
-            if stab == 3:
-                break
-            stab += 1
-        elif stab:  # changed unique atoms number. reset stability check.
-            stab = 0
-    else:
-        if numb < old_numb:
-            logger.warning('number of attempts exceeded. uniqueness has decreased.')
-
-    return {n: i for i, (_, g) in enumerate(groupby(sorted(atoms.items(), key=itemgetter(1)), key=itemgetter(1)),
-                                            start=1) for n, _ in g}
-
-
-__all__ = ['Morgan']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from functools import cached_property
+from itertools import groupby
+from logging import warning
+from operator import itemgetter
+from typing import Dict, TYPE_CHECKING
+
+
+if TYPE_CHECKING:
+    from chython.containers.graph import Graph
+
+
+class Morgan:
+    __slots__ = ()
+
+    @cached_property
+    def atoms_order(self: 'Graph') -> Dict[int, int]:
+        """
+        Morgan like algorithm for graph nodes ordering
+
+        :return: dict of atom-order pairs
+        """
+        atoms = self._atoms
+        if not atoms:  # for empty containers
+            return {}
+        elif len(atoms) == 1:  # optimize single atom containers
+            return dict.fromkeys(atoms, 1)
+        ring = self.ring_atoms
+        return _morgan({n: hash((hash(a), n in ring)) for n, a in atoms.items()}, self.int_adjacency)
+
+    @cached_property
+    def int_adjacency(self: 'Graph') -> Dict[int, Dict[int, int]]:
+        """
+        Adjacency with integer-coded bonds.
+        """
+        return {n: {m: int(b) for m, b in mb.items()} for n, mb in self._bonds.items()}
+
+
+def _morgan(atoms: Dict[int, int], bonds: Dict[int, Dict[int, int]]) -> Dict[int, int]:
+    tries = len(atoms) - 1
+    numb = len(set(atoms.values()))
+    stab = old_numb = 0
+
+    for _ in range(tries):
+        atoms = {n: hash((atoms[n], *(x for x in sorted((atoms[m], b) for m, b in ms.items()) for x in x)))
+                 for n, ms in bonds.items()}
+        old_numb, numb = numb, len(set(atoms.values()))
+        if numb == len(atoms):  # each atom now unique
+            break
+        elif numb == old_numb:  # not changed. molecules like benzene
+            if stab == 3:
+                break
+            stab += 1
+        elif stab:  # changed unique atoms number. reset stability check.
+            stab = 0
+    else:
+        if numb < old_numb:
+            warning('morgan. number of attempts exceeded. uniqueness has decreased.')
+
+    return {n: i for i, (_, g) in enumerate(groupby(sorted(atoms.items(), key=itemgetter(1)), key=itemgetter(1)),
+                                            start=1) for n, _ in g}
+
+
+__all__ = ['Morgan']
```

### Comparing `chython-1.64/chython/algorithms/rings.py` & `chython-1.8/chython/algorithms/rings.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,566 +1,559 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from CachedMethods import cached_args_method
-from collections import defaultdict, deque
-from functools import cached_property
-from itertools import combinations
-from operator import itemgetter
-from typing import Any, Dict, List, Optional, Set, Tuple, TYPE_CHECKING, Union
-from ..exceptions import ImplementationError
-
-
-if TYPE_CHECKING:
-    from chython.containers.graph import Graph
-
-
-class Rings:
-    __slots__ = ()
-
-    @cached_property
-    def sssr(self) -> Tuple[Tuple[int, ...], ...]:
-        """
-        Smallest Set of Smallest Rings. Special bonds ignored.
-
-        Based on idea of PID matrices from:
-        Lee, C. J., Kang, Y.-M., Cho, K.-H., & No, K. T. (2009).
-        A robust method for searching the smallest set of smallest rings with a path-included distance matrix.
-        Proceedings of the National Academy of Sciences of the United States of America, 106(41), 17355–17358.
-        https://doi.org/10.1073/pnas.0813040106
-
-        :return rings atoms numbers
-        """
-        if self.rings_count:
-            return _sssr(self.not_special_connectivity, self.rings_count)
-        return ()
-
-    @cached_property
-    def atoms_rings(self) -> Dict[int, Tuple[Tuple[int, ...]]]:
-        """
-        Dict of atoms rings which contains it.
-        """
-        rings = defaultdict(list)
-        for r in self.sssr:
-            for n in r:
-                rings[n].append(r)
-        return {n: tuple(rs) for n, rs in rings.items()}
-
-    @cached_property
-    def atoms_rings_sizes(self) -> Dict[int, Tuple[int, ...]]:
-        """
-        Sizes of rings containing atom.
-        """
-        return {n: tuple(len(r) for r in rs) for n, rs in self.atoms_rings.items()}
-
-    @cached_args_method
-    def is_ring_bond(self: 'Graph', n: int, m: int, /) -> bool:
-        """
-        Check is bond in any ring.
-        """
-        self.bond(n, m)  # check if bond exists
-        try:
-            return not set(self.atoms_rings[n]).isdisjoint(self.atoms_rings[m])
-        except KeyError:
-            return False
-
-    @cached_property
-    def ring_atoms(self):
-        """
-        Atoms in rings. Not SSSR based fast algorithm.
-        """
-        bonds = _skin_graph(self.not_special_connectivity)
-        if not bonds:
-            return set()
-
-        in_rings = set()
-        atoms = set(bonds)
-        while atoms:
-            stack = deque([(atoms.pop(), 0, 0)])
-            path = []
-            seen = set()
-            while stack:
-                c, p, d = stack.pop()
-                if len(path) > d:
-                    path = path[:d]
-                if c in in_rings:
-                    continue
-                path.append(c)
-                seen.add(c)
-
-                d += 1
-                for n in bonds[c]:
-                    if n == p:
-                        continue
-                    elif n in seen:
-                        in_rings.update(path[path.index(n):])
-                    else:
-                        stack.append((n, c, d))
-
-            atoms.difference_update(seen)
-        return in_rings
-
-    @cached_property
-    def rings_count(self) -> int:
-        """
-        SSSR rings count. Ignored rings with special bonds.
-        """
-        bonds = self.not_special_connectivity
-        return sum(len(x) for x in bonds.values()) // 2 - len(bonds) + len(_connected_components(bonds))
-
-    @cached_property
-    def not_special_connectivity(self: 'Graph') -> Dict[int, Set[int]]:
-        """
-        Graph connectivity without special bonds.
-        """
-        bonds = {}
-        for n, ms in self._bonds.items():
-            bonds[n] = ngb = set()
-            for m, b in ms.items():
-                if b != 8:
-                    ngb.add(m)
-        return bonds
-
-    @cached_property
-    def connected_components(self: 'Graph') -> Tuple[Tuple[int, ...], ...]:
-        """
-        Isolated components of single graph. E.g. salts as ion pair.
-        """
-        if not self._atoms:
-            return ()
-        return tuple(tuple(x) for x in self._connected_components)
-
-    @property
-    def connected_components_count(self) -> int:
-        """
-        Number of components in graph
-        """
-        return len(self.connected_components)
-
-    @cached_property
-    def skin_graph(self: 'Graph') -> Dict[int, Set[int]]:
-        """
-        Graph without terminal atoms. Only rings and linkers
-        """
-        return _skin_graph(self._bonds)
-
-    @cached_property
-    def _connected_components(self: 'Graph') -> List[Set[int]]:
-        return _connected_components(self._bonds)
-
-
-def _sssr(bonds: Dict[int, Union[Set[int], Dict[int, Any]]], n_sssr: int) -> Tuple[Tuple[int, ...], ...]:
-    """
-    Smallest Set of Smallest Rings of any adjacency matrix.
-    Number of rings required.
-    """
-    bonds = _skin_graph(bonds)
-    paths = _bfs(bonds)
-    pid1, pid2, dist = _make_pid(paths)
-    return _rings_filter(_c_set(pid1, pid2, dist), n_sssr)
-
-
-def _connected_components(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> List[Set[int]]:
-    atoms = set(bonds)
-    components = []
-    while atoms:
-        start = atoms.pop()
-        seen = {start}
-        queue = deque([start])
-        while queue:
-            current = queue.popleft()
-            for i in bonds[current]:
-                if i not in seen:
-                    queue.append(i)
-                    seen.add(i)
-        components.append(seen)
-        atoms.difference_update(seen)
-    return components
-
-
-def _skin_graph(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> Dict[int, Set[int]]:
-    """
-    Graph without terminal nodes. Only rings and linkers
-    """
-    bonds = {n: set(ms) for n, ms in bonds.items() if ms}
-    while True:  # skip not-cycle chains
-        try:
-            n = next(n for n, ms in bonds.items() if len(ms) <= 1)
-        except StopIteration:
-            break
-        for m in bonds.pop(n):
-            bonds[m].discard(n)
-    return bonds
-
-
-def _bfs(bonds):
-    atoms = set(bonds)
-    terminated = []
-    tail = atoms.pop()
-    next_stack = {x: [tail, x] for x in bonds[tail]}
-
-    while True:
-        next_front = set()
-        found_odd = set()
-        stack, next_stack = next_stack, {}
-        for tail, path in stack.items():
-            neighbors = bonds[tail] & atoms
-            next_front.add(tail)
-
-            if len(neighbors) == 1:
-                n = neighbors.pop()
-                if n in found_odd:
-                    if len(path) != 1:
-                        terminated.append(tuple(path))  # save second ring closure
-                    next_stack[n] = [n]  # maybe we have another path?
-                else:
-                    path.append(n)
-                    if n in stack:  # odd rings
-                        found_odd.add(tail)
-                        terminated.append(tuple(path))  # found ring closure. save path.
-                    elif n in next_stack:  # even rings
-                        terminated.append(tuple(path))
-                        if len(next_stack[n]) != 1:  # prevent bicycle case
-                            terminated.append(tuple(next_stack[n]))
-                            next_stack[n] = [n]
-                    else:
-                        next_stack[n] = path  # grow must go on
-            elif neighbors:
-                if len(path) != 1:
-                    terminated.append(tuple(path))  # save path.
-                for n in neighbors:
-                    if n in found_odd:
-                        if n in stack:
-                            if n in next_stack:
-                                del next_stack[n]
-                        else:
-                            next_stack[n] = [n]
-                    else:
-                        path = [tail, n]
-                        if n in stack:  # odd rings
-                            found_odd.add(tail)
-                            terminated.append(tuple(path))
-                        elif n in next_stack:  # even rings
-                            terminated.append(tuple(path))
-                            if len(next_stack[n]) != 1:  # prevent bicycle case
-                                terminated.append(tuple(next_stack[n]))
-                                next_stack[n] = [n]
-                        else:
-                            next_stack[n] = path
-
-        atoms.difference_update(next_front)
-        if not atoms:
-            break
-        elif not next_stack:
-            tail = atoms.pop()
-            next_stack = {x: [tail, x] for x in bonds[tail] & atoms}
-    return terminated
-
-
-def _make_pid(paths: List[List[int]]):
-    pid1 = defaultdict(lambda: defaultdict(dict))
-    pid2 = defaultdict(lambda: defaultdict(dict))
-    distances = defaultdict(lambda: defaultdict(lambda: 1e9))
-    chains = sorted(paths, key=len)
-    for c in chains:
-        di = len(c) - 1
-        n, m = c[0], c[-1]
-        nn, mm = c[1], c[-2]
-        if n in distances and m in distances[n] and distances[n][m] != di:
-            pid2[n][m][(nn, mm)] = c
-            pid2[m][n][(mm, nn)] = c[::-1]
-        else:
-            pid1[n][m][(nn, mm)] = c
-            pid1[m][n][(mm, nn)] = c[::-1]
-            distances[n][m] = distances[m][n] = di
-
-    for k in pid1:
-        new_distances = defaultdict(dict)
-        dk = distances[k]
-        ndk = new_distances[k]
-        for i in pid1:
-            if i == k:
-                continue
-            di = distances[i]
-            ndi = new_distances[i]
-            ndk[i] = ndi[k] = di[k]
-            for j in pid1:
-                if j == k or j == i:
-                    continue
-                ij = di[j]
-                ikj = di[k] + dk[j]
-                if ij - ikj == 1:  # A new shortest path == previous shortest path - 1
-                    pid2[i][j] = pid1[i][j]
-                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                  zip(pid1[i][k].items(), pid1[k][j].items())}
-                    ndi[j] = ikj
-                elif ij > ikj:  # A new shortest path
-                    pid2[i][j] = {}
-                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                  zip(pid1[i][k].items(), pid1[k][j].items())}
-                    ndi[j] = ikj
-                elif ij == ikj:  # Another shortest path
-                    pid1[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                       zip(pid1[i][k].items(), pid1[k][j].items())})
-                    ndi[j] = ij
-                elif ikj - ij == 1:  # Shortest+1 path
-                    pid2[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                       zip(pid1[i][k].items(), pid1[k][j].items())})
-                    ndi[j] = ij
-                else:
-                    ndi[j] = ij
-        distances = new_distances
-    return pid1, pid2, distances
-
-
-def _c_set(pid1, pid2, pid1l):
-    c_set = []
-    seen = set()
-    for i, p1i in pid1.items():
-        seen.add(i)
-        di = pid1l[i]
-        p2i = pid2[i]
-
-        for j, p1ij in p1i.items():
-            if j in seen:
-                continue
-            p1ij = list(p1ij.values())
-            p2ij = list(p2i[j].values())
-            dij = di[j] * 2
-
-            if len(p1ij) == 1:  # one shortest
-                if not p2ij:  # need shortest + 1 path
-                    continue
-                c_set.append((dij + 1, p1ij, p2ij))
-            elif not p2ij:  # one or more odd rings
-                c_set.append((dij, p1ij, None))
-            else:  # odd and even rings found (e.g. bicycle)
-                c_set.append((dij, p1ij, None))
-                c_set.append((dij + 1, p1ij, p2ij))
-
-    for c_num, p1ij, p2ij in sorted(c_set, key=itemgetter(0)):
-        if c_num % 2:  # odd rings
-            for c1 in p1ij:
-                for c2 in p2ij:
-                    c = c1 + c2[-2:0:-1]
-                    if len(c) == len(set(c)):
-                        yield _canonic_ring(c)
-        else:
-            for c1, c2 in zip(p1ij, p1ij[1:]):
-                c = c1 + c2[-2:0:-1]
-                if len(c) == len(set(c)):
-                    yield _canonic_ring(c)
-
-
-def _canonic_ring(ring: Tuple[int, ...]) -> Tuple[int, ...]:
-    n = min(ring)
-    ndx = ring.index(n)
-    if ndx == 0:
-        if ring[-1] < ring[1]:
-            return n, *ring[:0:-1]
-        return ring
-    elif ndx == len(ring) - 1:
-        if ring[0] > ring[-2]:
-            return ring[::-1]
-        return n, *ring[:-1]
-    if ring[ndx + 1] > ring[ndx - 1]:
-        return *ring[ndx::-1], *ring[:ndx:-1]
-    return *ring[ndx:], *ring[:ndx]
-
-
-def _ring_scissors(ring: Tuple[int, ...], n: int, m: int) -> Tuple[int, ...]:
-    ndx = ring.index(n)
-    mdx = ring.index(m)
-    if ndx == 0:
-        if mdx == 1:
-            return n, *ring[:0:-1]
-        return ring
-    elif ndx == len(ring) - 1:
-        if mdx == 0:
-            return ring[::-1]
-        return n, *ring[:-1]
-    if ndx < mdx:
-        return *ring[ndx::-1], *ring[:ndx:-1]
-    return *ring[ndx:], *ring[:ndx]
-
-
-def _ring_adjacency(ring: Tuple[int, ...]) -> Dict[int, List[int]]:
-    adj = {ring[0]: [ring[-1]]}  # ring adjacency matrix
-    for n, m in zip(ring, ring[1:]):
-        adj[n].append(m)
-        adj[m] = [n]
-    adj[m].append(ring[0])
-    return adj
-
-
-def _is_condensed_ring(c, sssr, seen_rings):
-    # create graph of connected neighbour rings
-    ck = seen_rings[c]
-    neighbors = {x: set() for x in sssr if len(seen_rings[x].keys() & ck.keys()) > 1}
-    if len(neighbors) > 1:
-        for (i, iv), (j, jv) in combinations(neighbors.items(), 2):
-            if len(seen_rings[i].keys() & seen_rings[j].keys()) > 1:
-                iv.add(j)
-                jv.add(i)
-        # check if hold rings is combination of existing. (123654) is combo of (1254) and (2365)
-        #
-        # 1--2--3
-        # |  |  |
-        # 4--5--6
-        #
-        # modified NX.dfs_labeled_edges
-        # https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.\
-        # traversal.depth_first_search.dfs_labeled_edges.html
-        depth_limit = len(neighbors) - 1
-        for start, nbrs in neighbors.items():
-            if not nbrs:
-                continue
-            stack = [(start, seen_rings[start], depth_limit, iter(nbrs), {start})]
-            while stack:
-                parent, p_adj, depth_now, children, seen = stack[-1]
-                try:
-                    child = next(children)
-                except StopIteration:
-                    stack.pop()
-                else:
-                    if child not in seen:
-                        common = p_adj.keys() & seen_rings[child].keys()
-                        if len(common) > 2:  # only terminal common atoms required
-                            term = {n for n in common if len(common.intersection(p_adj[n])) == 1}
-                            if len(term) != 2:  # skip multiple contacts
-                                continue
-                            common.difference_update(term)
-                            n, m = term
-                            mc = _canonic_ring(
-                                    (*_ring_scissors(tuple(x for x in parent if x not in common), n, m),
-                                     *_ring_scissors(tuple(x for x in child if x not in common), m, n)[1:-1]))
-                        elif len(common) == 2:
-                            n, m = common
-                            mc = _canonic_ring((*_ring_scissors(parent, n, m), *_ring_scissors(child, m, n)[1:-1]))
-                        else:  # point connections
-                            continue
-                        if c == mc:  # macrocycle found
-                            return True
-                        elif depth_now and 2 < len(mc) <= len(c) + 1:
-                            stack.append((mc, _ring_adjacency(mc), depth_now - 1, iter(neighbors[child]),
-                                          {child} | seen))
-    return False
-
-
-def _get_unique_chord(ring: Tuple[int, ...], common: Set[int]) -> Optional[Tuple[int, ...]]:
-    lc = len(common)
-    if len(ring) == lc:
-        if common == set(ring):
-            return ()
-    else:
-        if common == set(ring[:lc]):
-            return *ring[lc - 1:], ring[0]
-        for _ in range(len(ring) - 1):
-            ring = (*ring[1:], ring[0])
-            if common == set(ring[:lc]):
-                return *ring[lc - 1:], ring[0]
-
-
-def _connected_rings(rings, seen_rings):
-    rings = rings.copy()
-    out = []
-    for i in range(len(rings)):
-        c = rings[i]
-        ck = seen_rings[c]
-        for j in range(i + 1, len(rings)):
-            r = rings[j]
-            rk = seen_rings[r]
-            common = rk.keys() & ck.keys()
-            if len(common) == 2:  # one common bond
-                n, m = common
-                if m in ck[n] and m in rk[n]:  # only common bond!
-                    c = _canonic_ring((*_ring_scissors(c, n, m), *_ring_scissors(r, m, n)[1:-1]))
-                    ck = _ring_adjacency(c)
-                    rings[j] = c
-                    seen_rings[c] = ck
-                    break
-            elif len(common) > 2:
-                cc = _get_unique_chord(c, common)
-                if cc is None:  # skip multitouched rings
-                    continue
-                r = _get_unique_chord(r, common)
-                if r is None:
-                    continue
-                if cc:
-                    if r:
-                        if r[0] == cc[0]:
-                            r = r[::-1]
-                        c = _canonic_ring((*cc, *r[1:-1]))
-                        ck = _ring_adjacency(c)
-                        rings[j] = c
-                        seen_rings[c] = ck
-                        break
-                    else:
-                        c = _canonic_ring(cc)
-                        ck = _ring_adjacency(c)
-                        rings[j] = c
-                        seen_rings[c] = ck
-                        break
-                elif r:
-                    c = _canonic_ring(r)
-                    ck = _ring_adjacency(c)
-                    rings[j] = c
-                    seen_rings[c] = ck
-                    break
-        else:  # isolated ring[s] found
-            out.append(c)
-    return out
-
-
-def _rings_filter(rings, n_sssr):
-    c = next(rings)
-    if n_sssr == 1:
-        return c,
-
-    seen_rings = {c}
-    sssr_atoms = set(c)
-    sssr = [c]
-    hold = []
-    for c in rings:
-        if c in seen_rings:
-            continue
-        seen_rings.add(c)
-        if sssr_atoms.issuperset(c):  # potentially condensed ring
-            hold.append(c)
-            continue
-        sssr_atoms.update(c)
-        sssr.append(c)
-        if len(sssr) == n_sssr:
-            return tuple(sssr)
-
-    # now we have set of plug rings (cuban fullerene), besiege rings and condensed trash
-    seen_rings = {c: _ring_adjacency(c) for c in seen_rings}  # prepare adjacency
-    condensed_rings = _connected_rings(sssr, seen_rings)  # collection of contours of condensed rings
-
-    for c in hold:
-        if c in condensed_rings or _is_condensed_ring(c, sssr, seen_rings):
-            continue
-        condensed_rings.insert(0, c)
-        condensed_rings = _connected_rings(condensed_rings, seen_rings)
-        sssr.append(c)
-        if len(sssr) == n_sssr:
-            return tuple(sorted(sssr, key=len))
-
-    raise ImplementationError('SSSR count not reached')
-
-
-__all__ = ['Rings']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict, deque
+from functools import cached_property
+from itertools import combinations
+from operator import itemgetter
+from typing import Any, Dict, List, Optional, Set, Tuple, TYPE_CHECKING, Union
+from ..exceptions import ImplementationError
+
+
+if TYPE_CHECKING:
+    from chython.containers.graph import Graph
+
+
+class Rings:
+    __slots__ = ()
+
+    @cached_property
+    def sssr(self) -> Tuple[Tuple[int, ...], ...]:
+        """
+        Smallest Set of Smallest Rings. Special bonds ignored.
+
+        Based on idea of PID matrices from:
+        Lee, C. J., Kang, Y.-M., Cho, K.-H., & No, K. T. (2009).
+        A robust method for searching the smallest set of smallest rings with a path-included distance matrix.
+        Proceedings of the National Academy of Sciences of the United States of America, 106(41), 17355–17358.
+        https://doi.org/10.1073/pnas.0813040106
+
+        :return rings atoms numbers
+        """
+        if self.rings_count:
+            return _sssr(self.not_special_connectivity, self.rings_count)
+        return ()
+
+    @cached_property
+    def aromatic_rings(self: 'Graph') -> Tuple[Tuple[int, ...], ...]:
+        """
+        Aromatic rings atoms numbers
+        """
+        bonds = self._bonds
+        return tuple(ring for ring in self.sssr if bonds[ring[0]][ring[-1]] == 4
+                     and all(bonds[n][m] == 4 for n, m in zip(ring, ring[1:])))
+
+    @cached_property
+    def atoms_rings(self) -> Dict[int, Tuple[Tuple[int, ...]]]:
+        """
+        Dict of atoms rings which contains it.
+        """
+        rings = defaultdict(list)
+        for r in self.sssr:
+            for n in r:
+                rings[n].append(r)
+        return {n: tuple(rs) for n, rs in rings.items()}
+
+    @cached_property
+    def atoms_rings_sizes(self) -> Dict[int, Tuple[int, ...]]:
+        """
+        Sizes of rings containing atom.
+        """
+        return {n: tuple(len(r) for r in rs) for n, rs in self.atoms_rings.items()}
+
+    @cached_property
+    def ring_atoms(self):
+        """
+        Atoms in rings. Not SSSR based fast algorithm.
+        """
+        bonds = _skin_graph(self.not_special_connectivity)
+        if not bonds:
+            return set()
+
+        in_rings = set()
+        atoms = set(bonds)
+        while atoms:
+            stack = deque([(atoms.pop(), 0, 0)])
+            path = []
+            seen = set()
+            while stack:
+                c, p, d = stack.pop()
+                if len(path) > d:
+                    path = path[:d]
+                if c in in_rings:
+                    continue
+                path.append(c)
+                seen.add(c)
+
+                d += 1
+                for n in bonds[c]:
+                    if n == p:
+                        continue
+                    elif n in seen:
+                        in_rings.update(path[path.index(n):])
+                    else:
+                        stack.append((n, c, d))
+
+            atoms.difference_update(seen)
+        return in_rings
+
+    @cached_property
+    def rings_count(self) -> int:
+        """
+        SSSR rings count. Ignored rings with special bonds.
+        """
+        bonds = self.not_special_connectivity
+        return sum(len(x) for x in bonds.values()) // 2 - len(bonds) + len(_connected_components(bonds))
+
+    @cached_property
+    def not_special_connectivity(self: 'Graph') -> Dict[int, Set[int]]:
+        """
+        Graph connectivity without special bonds.
+        """
+        bonds = {}
+        for n, ms in self._bonds.items():
+            bonds[n] = ngb = set()
+            for m, b in ms.items():
+                if b != 8:
+                    ngb.add(m)
+        return bonds
+
+    @cached_property
+    def connected_components(self: 'Graph') -> Tuple[Tuple[int, ...], ...]:
+        """
+        Isolated components of single graph. E.g. salts as ion pair.
+        """
+        if not self._atoms:
+            return ()
+        return tuple(tuple(x) for x in _connected_components(self._bonds))
+
+    @property
+    def connected_components_count(self) -> int:
+        """
+        Number of components in graph
+        """
+        return len(self.connected_components)
+
+    @cached_property
+    def skin_graph(self: 'Graph') -> Dict[int, Set[int]]:
+        """
+        Graph without terminal atoms. Only rings and linkers
+        """
+        return _skin_graph(self._bonds)
+
+
+def _sssr(bonds: Dict[int, Union[Set[int], Dict[int, Any]]], n_sssr: int) -> Tuple[Tuple[int, ...], ...]:
+    """
+    Smallest Set of Smallest Rings of any adjacency matrix.
+    Number of rings required.
+    """
+    bonds = _skin_graph(bonds)
+    paths = _bfs(bonds)
+    pid1, pid2, dist = _make_pid(paths)
+    return _rings_filter(_c_set(pid1, pid2, dist), n_sssr)
+
+
+def _connected_components(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> List[Set[int]]:
+    atoms = set(bonds)
+    components = []
+    while atoms:
+        start = atoms.pop()
+        seen = {start}
+        queue = deque([start])
+        while queue:
+            current = queue.popleft()
+            for i in bonds[current]:
+                if i not in seen:
+                    queue.append(i)
+                    seen.add(i)
+        components.append(seen)
+        atoms.difference_update(seen)
+    return components
+
+
+def _skin_graph(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> Dict[int, Set[int]]:
+    """
+    Graph without terminal nodes. Only rings and linkers
+    """
+    bonds = {n: set(ms) for n, ms in bonds.items() if ms}
+    while True:  # skip not-cycle chains
+        try:
+            n = next(n for n, ms in bonds.items() if len(ms) <= 1)
+        except StopIteration:
+            break
+        for m in bonds.pop(n):
+            bonds[m].discard(n)
+    return bonds
+
+
+def _bfs(bonds):
+    atoms = set(bonds)
+    terminated = []
+    tail = atoms.pop()
+    next_stack = {x: [tail, x] for x in bonds[tail]}
+
+    while True:
+        next_front = set()
+        found_odd = set()
+        stack, next_stack = next_stack, {}
+        for tail, path in stack.items():
+            neighbors = bonds[tail] & atoms
+            next_front.add(tail)
+
+            if len(neighbors) == 1:
+                n = neighbors.pop()
+                if n in found_odd:
+                    if len(path) != 1:
+                        terminated.append(tuple(path))  # save second ring closure
+                    next_stack[n] = [n]  # maybe we have another path?
+                else:
+                    path.append(n)
+                    if n in stack:  # odd rings
+                        found_odd.add(tail)
+                        terminated.append(tuple(path))  # found ring closure. save path.
+                    elif n in next_stack:  # even rings
+                        terminated.append(tuple(path))
+                        if len(next_stack[n]) != 1:  # prevent bicycle case
+                            terminated.append(tuple(next_stack[n]))
+                            next_stack[n] = [n]
+                    else:
+                        next_stack[n] = path  # grow must go on
+            elif neighbors:
+                if len(path) != 1:
+                    terminated.append(tuple(path))  # save path.
+                for n in neighbors:
+                    if n in found_odd:
+                        if n in stack:
+                            if n in next_stack:
+                                del next_stack[n]
+                        else:
+                            next_stack[n] = [n]
+                    else:
+                        path = [tail, n]
+                        if n in stack:  # odd rings
+                            found_odd.add(tail)
+                            terminated.append(tuple(path))
+                        elif n in next_stack:  # even rings
+                            terminated.append(tuple(path))
+                            if len(next_stack[n]) != 1:  # prevent bicycle case
+                                terminated.append(tuple(next_stack[n]))
+                                next_stack[n] = [n]
+                        else:
+                            next_stack[n] = path
+
+        atoms.difference_update(next_front)
+        if not atoms:
+            break
+        elif not next_stack:
+            tail = atoms.pop()
+            next_stack = {x: [tail, x] for x in bonds[tail] & atoms}
+    return terminated
+
+
+def _make_pid(paths: List[List[int]]):
+    pid1 = defaultdict(lambda: defaultdict(dict))
+    pid2 = defaultdict(lambda: defaultdict(dict))
+    distances = defaultdict(lambda: defaultdict(lambda: 1e9))
+    chains = sorted(paths, key=len)
+    for c in chains:
+        di = len(c) - 1
+        n, m = c[0], c[-1]
+        nn, mm = c[1], c[-2]
+        if n in distances and m in distances[n] and distances[n][m] != di:
+            pid2[n][m][(nn, mm)] = c
+            pid2[m][n][(mm, nn)] = c[::-1]
+        else:
+            pid1[n][m][(nn, mm)] = c
+            pid1[m][n][(mm, nn)] = c[::-1]
+            distances[n][m] = distances[m][n] = di
+
+    for k in pid1:
+        new_distances = defaultdict(dict)
+        dk = distances[k]
+        ndk = new_distances[k]
+        for i in pid1:
+            if i == k:
+                continue
+            di = distances[i]
+            ndi = new_distances[i]
+            ndk[i] = ndi[k] = di[k]
+            for j in pid1:
+                if j == k or j == i:
+                    continue
+                ij = di[j]
+                ikj = di[k] + dk[j]
+                if ij - ikj == 1:  # A new shortest path == previous shortest path - 1
+                    pid2[i][j] = pid1[i][j]
+                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                  zip(pid1[i][k].items(), pid1[k][j].items())}
+                    ndi[j] = ikj
+                elif ij > ikj:  # A new shortest path
+                    pid2[i][j] = {}
+                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                  zip(pid1[i][k].items(), pid1[k][j].items())}
+                    ndi[j] = ikj
+                elif ij == ikj:  # Another shortest path
+                    pid1[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                       zip(pid1[i][k].items(), pid1[k][j].items())})
+                    ndi[j] = ij
+                elif ikj - ij == 1:  # Shortest+1 path
+                    pid2[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                       zip(pid1[i][k].items(), pid1[k][j].items())})
+                    ndi[j] = ij
+                else:
+                    ndi[j] = ij
+        distances = new_distances
+    return pid1, pid2, distances
+
+
+def _c_set(pid1, pid2, pid1l):
+    c_set = []
+    seen = set()
+    for i, p1i in pid1.items():
+        seen.add(i)
+        di = pid1l[i]
+        p2i = pid2[i]
+
+        for j, p1ij in p1i.items():
+            if j in seen:
+                continue
+            p1ij = list(p1ij.values())
+            p2ij = list(p2i[j].values())
+            dij = di[j] * 2
+
+            if len(p1ij) == 1:  # one shortest
+                if not p2ij:  # need shortest + 1 path
+                    continue
+                c_set.append((dij + 1, p1ij, p2ij))
+            elif not p2ij:  # one or more odd rings
+                c_set.append((dij, p1ij, None))
+            else:  # odd and even rings found (e.g. bicycle)
+                c_set.append((dij, p1ij, None))
+                c_set.append((dij + 1, p1ij, p2ij))
+
+    for c_num, p1ij, p2ij in sorted(c_set, key=itemgetter(0)):
+        if c_num % 2:  # odd rings
+            for c1 in p1ij:
+                for c2 in p2ij:
+                    c = c1 + c2[-2:0:-1]
+                    if len(c) == len(set(c)):
+                        yield _canonic_ring(c)
+        else:
+            for c1, c2 in zip(p1ij, p1ij[1:]):
+                c = c1 + c2[-2:0:-1]
+                if len(c) == len(set(c)):
+                    yield _canonic_ring(c)
+
+
+def _canonic_ring(ring: Tuple[int, ...]) -> Tuple[int, ...]:
+    n = min(ring)
+    ndx = ring.index(n)
+    if ndx == 0:
+        if ring[-1] < ring[1]:
+            return n, *ring[:0:-1]
+        return ring
+    elif ndx == len(ring) - 1:
+        if ring[0] > ring[-2]:
+            return ring[::-1]
+        return n, *ring[:-1]
+    if ring[ndx + 1] > ring[ndx - 1]:
+        return *ring[ndx::-1], *ring[:ndx:-1]
+    return *ring[ndx:], *ring[:ndx]
+
+
+def _ring_scissors(ring: Tuple[int, ...], n: int, m: int) -> Tuple[int, ...]:
+    ndx = ring.index(n)
+    mdx = ring.index(m)
+    if ndx == 0:
+        if mdx == 1:
+            return n, *ring[:0:-1]
+        return ring
+    elif ndx == len(ring) - 1:
+        if mdx == 0:
+            return ring[::-1]
+        return n, *ring[:-1]
+    if ndx < mdx:
+        return *ring[ndx::-1], *ring[:ndx:-1]
+    return *ring[ndx:], *ring[:ndx]
+
+
+def _ring_adjacency(ring: Tuple[int, ...]) -> Dict[int, List[int]]:
+    adj = {ring[0]: [ring[-1]]}  # ring adjacency matrix
+    for n, m in zip(ring, ring[1:]):
+        adj[n].append(m)
+        adj[m] = [n]
+    adj[m].append(ring[0])
+    return adj
+
+
+def _is_condensed_ring(c, sssr, seen_rings):
+    # create graph of connected neighbour rings
+    ck = seen_rings[c]
+    neighbors = {x: set() for x in sssr if len(seen_rings[x].keys() & ck.keys()) > 1}
+    if len(neighbors) > 1:
+        for (i, iv), (j, jv) in combinations(neighbors.items(), 2):
+            if len(seen_rings[i].keys() & seen_rings[j].keys()) > 1:
+                iv.add(j)
+                jv.add(i)
+        # check if hold rings is combination of existing. (123654) is combo of (1254) and (2365)
+        #
+        # 1--2--3
+        # |  |  |
+        # 4--5--6
+        #
+        # modified NX.dfs_labeled_edges
+        # https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.\
+        # traversal.depth_first_search.dfs_labeled_edges.html
+        depth_limit = len(neighbors) - 1
+        for start, nbrs in neighbors.items():
+            if not nbrs:
+                continue
+            stack = [(start, seen_rings[start], depth_limit, iter(nbrs), {start})]
+            while stack:
+                parent, p_adj, depth_now, children, seen = stack[-1]
+                try:
+                    child = next(children)
+                except StopIteration:
+                    stack.pop()
+                else:
+                    if child not in seen:
+                        common = p_adj.keys() & seen_rings[child].keys()
+                        if len(common) > 2:  # only terminal common atoms required
+                            term = {n for n in common if len(common.intersection(p_adj[n])) == 1}
+                            if len(term) != 2:  # skip multiple contacts
+                                continue
+                            common.difference_update(term)
+                            n, m = term
+                            mc = _canonic_ring(
+                                    (*_ring_scissors(tuple(x for x in parent if x not in common), n, m),
+                                     *_ring_scissors(tuple(x for x in child if x not in common), m, n)[1:-1]))
+                        elif len(common) == 2:
+                            n, m = common
+                            mc = _canonic_ring((*_ring_scissors(parent, n, m), *_ring_scissors(child, m, n)[1:-1]))
+                        else:  # point connections
+                            continue
+                        if c == mc:  # macrocycle found
+                            return True
+                        elif depth_now and 2 < len(mc) <= len(c) + 1:
+                            stack.append((mc, _ring_adjacency(mc), depth_now - 1, iter(neighbors[child]),
+                                          {child} | seen))
+    return False
+
+
+def _get_unique_chord(ring: Tuple[int, ...], common: Set[int]) -> Optional[Tuple[int, ...]]:
+    lc = len(common)
+    if len(ring) == lc:
+        if common == set(ring):
+            return ()
+    else:
+        if common == set(ring[:lc]):
+            return *ring[lc - 1:], ring[0]
+        for _ in range(len(ring) - 1):
+            ring = (*ring[1:], ring[0])
+            if common == set(ring[:lc]):
+                return *ring[lc - 1:], ring[0]
+
+
+def _connected_rings(rings, seen_rings):
+    rings = rings.copy()
+    out = []
+    for i in range(len(rings)):
+        c = rings[i]
+        ck = seen_rings[c]
+        for j in range(i + 1, len(rings)):
+            r = rings[j]
+            rk = seen_rings[r]
+            common = rk.keys() & ck.keys()
+            if len(common) == 2:  # one common bond
+                n, m = common
+                if m in ck[n] and m in rk[n]:  # only common bond!
+                    c = _canonic_ring((*_ring_scissors(c, n, m), *_ring_scissors(r, m, n)[1:-1]))
+                    ck = _ring_adjacency(c)
+                    rings[j] = c
+                    seen_rings[c] = ck
+                    break
+            elif len(common) > 2:
+                cc = _get_unique_chord(c, common)
+                if cc is None:  # skip multitouched rings
+                    continue
+                r = _get_unique_chord(r, common)
+                if r is None:
+                    continue
+                if cc:
+                    if r:
+                        if r[0] == cc[0]:
+                            r = r[::-1]
+                        c = _canonic_ring((*cc, *r[1:-1]))
+                        ck = _ring_adjacency(c)
+                        rings[j] = c
+                        seen_rings[c] = ck
+                        break
+                    else:
+                        c = _canonic_ring(cc)
+                        ck = _ring_adjacency(c)
+                        rings[j] = c
+                        seen_rings[c] = ck
+                        break
+                elif r:
+                    c = _canonic_ring(r)
+                    ck = _ring_adjacency(c)
+                    rings[j] = c
+                    seen_rings[c] = ck
+                    break
+        else:  # isolated ring[s] found
+            out.append(c)
+    return out
+
+
+def _rings_filter(rings, n_sssr):
+    c = next(rings)
+    if n_sssr == 1:
+        return c,
+
+    seen_rings = {c}
+    sssr_atoms = set(c)
+    sssr = [c]
+    hold = []
+    for c in rings:
+        if c in seen_rings:
+            continue
+        seen_rings.add(c)
+        if sssr_atoms.issuperset(c):  # potentially condensed ring
+            hold.append(c)
+            continue
+        sssr_atoms.update(c)
+        sssr.append(c)
+        if len(sssr) == n_sssr:
+            return tuple(sssr)
+
+    # now we have set of plug rings (cuban fullerene), besiege rings and condensed trash
+    seen_rings = {c: _ring_adjacency(c) for c in seen_rings}  # prepare adjacency
+    condensed_rings = _connected_rings(sssr, seen_rings)  # collection of contours of condensed rings
+
+    for c in hold:
+        if c in condensed_rings or _is_condensed_ring(c, sssr, seen_rings):
+            continue
+        condensed_rings.insert(0, c)
+        condensed_rings = _connected_rings(condensed_rings, seen_rings)
+        sssr.append(c)
+        if len(sssr) == n_sssr:
+            return tuple(sorted(sssr, key=len))
+
+    raise ImplementationError('SSSR count not reached')
+
+
+__all__ = ['Rings']
```

### Comparing `chython-1.64/chython/algorithms/standardize/__init__.py` & `chython-1.8/chython/files/test/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,30 +1,18 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .molecule import *
-from .reaction import *
-from .resonance import *
-from .salts import *
-from .saturation import *
-
-
-class StandardizeMolecule(Standardize, Resonance, Saturation, Salts):
-    __slots__ = ()
-
-
-__all__ = ['StandardizeMolecule', 'StandardizeReaction']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.64/chython/algorithms/standardize/_groups.py` & `chython-1.8/chython/algorithms/standardize/_groups.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,1058 +1,916 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from lazy_object_proxy import Proxy
-from ...periodictable import ListElement
-
-
-def _rules_single():
-    """
-    rules without overlapping. these rules can match once to same set of atoms.
-    """
-    from ... import smarts
-    from ...containers import QueryContainer
-
-    rules = []
-    raw_rules = []
-
-    #
-    #  [A*] - [A*] >> A = A or [A*] = [A*] >> A # A
-    #
-    # atoms = ({'atom': 'A', 'is_radical': True}, {'atom': 'A', 'is_radical': True})
-    # bonds = ((1, 2, 1),)
-    # atom_fix = {1: (0, False), 2: (0, False)}
-    # bonds_fix = ((1, 2, 2),)
-    # raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-    # bonds = ((1, 2, 2),)
-    # bonds_fix = ((1, 2, 3),)
-    # raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A         A
-    #     |         |
-    #     P    >>  [P+]
-    #   / | \     / | \
-    #  A  A  A   A  A  A
-    #
-    q = smarts('[P;D4;x0;z1]')
-    atom_fix = {1: (1, None)}
-    bonds_fix = ()
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    #
-    # A   H   A     A     H   A
-    #  \ / \ /       \  .. \ /
-    #   B   B    >>   B     B
-    #  / \ / \       / \  .. \
-    # A   H   A     A   H     A
-    #
-    q = smarts('[B;z1:1]1[H;D2:3][B;z1:2][H;D2:4]1')
-    atom_fix = {}
-    bonds_fix = ((1, 3, 8), (2, 4, 8))
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    # OGB DS
-    #
-    # O*  A  [O-]  A
-    #  \ /     \  /
-    #   N  >>  [N+]
-    #   |       ||
-    #  C,N*     C,N
-    #
-    q = smarts('[O;D1;z1][N;D3;z1][C,N;z1] |^1:0,2|')
-    atom_fix = {1: (-1, False), 2: (1, None), 3: (0, False)}
-    bonds_fix = ((2, 3, 2),)
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    #
-    #       |            |
-    # O* -- S -- O* >> O=S=O
-    #       |            |
-    #
-    q = smarts('[O,S;D1;z1][S;D4;z1][O;D1;z1] |^1:0,2|')
-    atom_fix = {1: (0, False), 3: (0, False)}
-    bonds_fix = ((1, 2, 2), (2, 3, 2))
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    #
-    #      A         A
-    #     //        //
-    # B - N >> B .. N
-    #     \          \
-    #      A          A
-    #
-    atoms = ({'atom': 'B'}, {'atom': 'N', 'neighbors': 3, 'hybridization': 2})
-    bonds = ((1, 2, 1),)
-    atom_fix = {}
-    bonds_fix = ((1, 2, 8),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A             A
-    #     |             |
-    # B = N - A >> B .. N - A
-    #     |             |
-    #     A             A
-    #
-    atoms = ({'atom': 'B', 'hybridization': (1, 2)}, {'atom': 'N', 'neighbors': 4, 'hybridization': (1, 2)})
-    bonds = ((1, 2, (1, 2)),)
-    atom_fix = {}
-    bonds_fix = ((1, 2, 8),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # R2S - B >> R2S .. B
-    #
-    atoms = ({'atom': 'B', 'hybridization': 1}, {'atom': ListElement(['O', 'S']), 'hybridization': 1, 'neighbors': 3})
-    bonds = ((1, 2, 1),)
-    atom_fix = {}
-    bonds_fix = ((1, 2, 8),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  [B-] = [N+] >>  B - N
-    #
-    atoms = ({'atom': 'B', 'charge': -1, 'hybridization': 2},
-             {'atom': 'N', 'charge': 1, 'neighbors': (1, 2, 3), 'hybridization': 2})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #        [A-]                 A
-    #         |                   |
-    # [A-] - [B+3] - [A-] >> A - [B-] - A
-    #         |                   |
-    #        [A-]                 A
-    #
-    atoms = ({'atom': 'B', 'charge': 3, 'neighbors': 4}, {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1},
-             {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1))
-    atom_fix = {1: (-4, None), 2: (1, None), 3: (1, None), 4: (1, None), 5: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #        A             A
-    #        |             |
-    # [A-] - B - A >> A - [B-] - A
-    #        |             |
-    #        A             A
-    #
-    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1}, {'atom': 'A', 'charge': -1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #      A             A
-    #      |             |
-    # A -  B - A >> A - [B-] - A
-    #      |             |
-    #      A             A
-    #
-    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1},)
-    bonds = ()
-    atom_fix = {1: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A         A
-    #     |         |
-    #     N    >>  [N+]
-    #   / | \     / | \
-    #  A  A  A   A  A  A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 1},)
-    bonds = ()
-    atom_fix = {1: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #  aci-nitro
-    #      O          O
-    #     //         //
-    # C = N  >> C - [N+]
-    #      \         \
-    #       OH       [O-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
-    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 4, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #            O               [O-]
-    #           //               /
-    # [C,N,O] = N  >> [C,N,O] = [N+]
-    #           \                \
-    #            A                A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': ListElement(['C', 'N', 'O'])},
-             {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix aci-nitro
-    #       [O-]          [O-]
-    #       /             /
-    # C = [N+ ] >>  C - [N+]
-    #      \             \\
-    #       OH            O
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3}, {'atom': 'O', 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 3, 2), (1, 4, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    # fix CN(=O)=N(=O)C
-    #
-    # [N+] = N = O >> [N+] = [N+] - O-
-    #        |                |
-    #        A                A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Fix CN(=O)=N(=N)C
-    # [N+] = N = N - ? >> [N+] = [N+] - [N-] - ?
-    #        |                    |
-    #        A                    A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # For N-case not unique!
-    #          N             [N-]
-    #         //             /
-    # [C,N] = N  >> [C,N] = [N+]
-    #         \              \
-    #          A              A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': ListElement(['C', 'N'])}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [N-] - [N+] = O >> N = [N+] - [O-]
-    #         |               |
-    #         A               A
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'charge': -1, 'hybridization': 1, 'neighbors': (1, 2)})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #         O              [O-]
-    #        //              /
-    # [A-] - N   >> [A-] - [N+]
-    #        \\             \\
-    #         O              O
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'A', 'charge': -1})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # O : N : O      O = [N+] - [O-]
-    #     |      >>       |
-    #     A               A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 4), (1, 3, 4), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Nitrite
-    #
-    #   O        [O-]
-    #  //        /
-    # [N-]  >>  N
-    #  \\       \\
-    #   O        O
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'charge': -1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [O,C,N] = N # N >> [O,C,N] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': ListElement(['O', 'C', 'N'])})
-    bonds = ((1, 2, 3), (1, 3, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [C,N,O-] - [N+] # N  >> [C,N,O] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1},
-             {'atom': ListElement(['N', 'C', 'O']), 'charge': -1, 'hybridization': 1})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  A - [N+] # N = [N-]  >> A - N = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
-             {'atom': 'N', 'charge': -1, 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 3), (1, 3, 2), (2, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - N = N = N >> A - N = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 2},
-             {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 2))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - NH - N # N >> A - N = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 1},
-             {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 3))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [N-] # N = N - A >> [N-] == [N+] == N - A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1},
-             {'atom': 'N', 'hybridization': 2, 'neighbors': 2})
-    bonds = ((1, 2, 3), (1, 3, 2))
-    atom_fix = {1: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [N-] == N # N >> [N-] == [N+] == [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1}, {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 3))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ((1, 3, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - C # N = NH >> A - [CH] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'C', 'neighbors': (1, 2)}, {'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 3), (2, 3, 2))
-    atom_fix = {2: (1, None), 3: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # note: order dependent
-    # A - C # N = [O,N] >> A - C # [N+] - [O,N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 2), (1, 3, 3))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [NH2,OH,SH] - N # C - A >> [NH,O,S-] - [N+] # C - A
-    #
-    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - [NH] - N # C >> A - [N-] - [N+] # C
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [NH2,OH,SH] - [N+] # [C-] >> [NH,O,S-] - [N+] # [CH]
-    #
-    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
-             {'atom': 'C', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 3: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # A - [NH] - [N+] # [C-] >> A - [N-] - [N+] # [CH]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
-             {'atom': 'C', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 3: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # A - N # C >> A - [N+] # [C-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'C', 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix old diazo rule
-    #
-    # A - [C-] = [N+] = [NH] >> A - [CH] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 2), (2, 3, 2))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #    |           |
-    #  - N -   >> - [N+] -
-    #    \\          |
-    #    [O,N]      [O,N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # N-oxide radical
-    #
-    #    |         |
-    #  - N*  >>  - N
-    #    \\        |
-    #     O        O*
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 2, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (0, False), 2: (0, True)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # false N-oxide radical
-    #
-    #    |        |
-    #  = N  >> = [N+]
-    #     \        \
-    #      O*       [O-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1, 'is_radical': True})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, False), 2: (-1, False)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # C           C
-    #  \           \
-    #   N # N >>   [N+] = [N-]
-    #  /           /
-    # C           C
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': 1}, {'atom': 'C'}, {'atom': 'C'})
-    bonds = ((1, 2, 3), (1, 3, 1), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  C - N = [N+]  >>  C - [N+] # N
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 1}, {'atom': 'C'})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 3),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  [N+] - [C-] = O  >>  N = C = O
-    #
-    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': 2},
-             {'atom': 'N', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  N # C - OH  >>  HN = C = O
-    #
-    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #  N # C - [O-]  >>  [N-] = C = O
-    #
-    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # - [N+] - [O-]  >>  - N = O
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     [O+]R         [O]R
-    #     //            /
-    # N - C  >> [N+] = C
-    #
-    atoms = ({'atom': 'C', 'hybridization': 2}, {'atom': 'O', 'neighbors': 2, 'hybridization': 2, 'charge': 1},
-             {'atom': 'N', 'hybridization': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #      [O,S]H    [O,S]
-    #      /         //
-    # N = C  >> NH - C
-    #
-    atoms = ({'atom': 'C', 'hybridization': 2}, {'atom': ListElement(['O', 'S']), 'neighbors': 1},
-             {'atom': 'N', 'hybridization': 2})
-    bonds = ((1, 2, 1), (1, 3, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (1, 3, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # fix pyridin-2-one. note: only after amide rule
-    #
-    atoms = ({'atom': 'C', 'neighbors': 3}, {'atom': ListElement(['O', 'S']), 'neighbors': 1},
-             {'atom': 'N', 'neighbors': 2}, {'atom': 'A', 'hybridization': 2}, {'atom': 'A', 'hybridization': 2},
-             {'atom': 'A', 'hybridization': 2}, {'atom': 'A', 'hybridization': 2})
-    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 1), (3, 7, 1), (4, 5, (1, 2)), (5, 6, (1, 2)), (6, 7, (1, 2)))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    # todo:
-    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5]=,:[C:6][C:7](=[O:1])[C:8]=,:[C:9]1
-    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5](=[O:1])[C:6]=,:[C:7]-,:[C:8]=,:[C:9]1
-
-    #
-    #       OH          O
-    #      /           //
-    # C = C    >> C - C
-    #      \           \
-    #      [O,N]       [O,N]
-    #
-    atoms = ({'atom': 'O', 'neighbors': 1}, {'atom': ListElement(['O', 'N'])}, {'atom': 'C'}, {'atom': 'C'})
-    bonds = ((1, 3, 1), (2, 3, 1), (3, 4, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 3, 2), (3, 4, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # fix pyridin. note: don't move.
-    #
-    atoms = ({'atom': 'C', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'N', 'neighbors': 2},
-             {'atom': 'C', 'hybridization': 1}, {'atom': 'A', 'hybridization': 2},
-             {'atom': 'A', 'hybridization': 2}, {'atom': 'A', 'hybridization': 2})
-    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 1), (3, 7, 2), (4, 5, 1), (5, 6, (1, 2)), (6, 7, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (1, 4, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #       A                   A
-    #       |                   |
-    #  A - [P+] - [O-]  >>  A - P = O
-    #       |                   |
-    #       A                   A
-    #
-    atoms = ({'atom': 'P', 'charge': 1, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #       A                   A
-    #       |                   |
-    #  A - [P-] - [C+]  >>  A - P = C
-    #       |                   |
-    #       A                   A
-    #
-    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2, 3), 'hybridization': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #   F   F         F   F
-    #    \ /           \ /
-    # F - P - F >> F - [P-] - F
-    #    / \           / \
-    #   F   F         F   F
-    #
-    atoms = ({'atom': 'P', 'neighbors': 6}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
-             {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
-             {'atom': 'F', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1), (1, 6, 1), (1, 7, 1))
-    atom_fix = {1: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O               O
-    #     \\              \\
-    # A - [P-] - A  >> A - P - A
-    #     //              /
-    #     O              [O-]
-    #
-    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'A'}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1), (1, 5, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O           [O-]
-    #     \\            \
-    # A -  P - A  >> A - P - A
-    #     /             //
-    #   [S-]            S
-    #
-    atoms = ({'atom': 'P', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O'},
-             {'atom': 'S', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O           [OH]
-    #     \\            \
-    # A -  P - A  >> A - P - A
-    #     /             //
-    #   [SH]            S
-    #
-    atoms = ({'atom': 'P', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O'},
-             {'atom': 'S', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #     A                A
-    #     \\               \\
-    # A -  S - [S-]  >> A - S - [O-]
-    #     //               //
-    #     O                S
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4}, {'atom': 'O'}, {'atom': 'S', 'charge': -1, 'neighbors': 1},
-             {'atom': 'A'}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 2), (1, 5, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A                A
-    #     \\               \
-    # A -  S - [SH]  >> A - S - [OH]
-    #     //               //
-    #     O                S
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4}, {'atom': 'O'}, {'atom': 'S', 'neighbors': 1}, {'atom': 'A'}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 2), (1, 5, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #           A                   A
-    #          /                   /
-    # [O-] - [S,Si,Se+]  >>  O = [S,Si,Se]
-    #          \                   \
-    #           A                   A
-    #
-    atoms = ({'atom': ListElement(['S', 'Se', 'Si']), 'charge': 1, 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #       A?                  A?
-    #       |                   |
-    #  A = [S+] - [O-]  >>  A = S = O
-    #       |                   |
-    #       A?                  A?
-    #
-    atoms = ({'atom': 'S', 'charge': 1, 'neighbors': (2, 4), 'hybridization': 2},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #       [O-]          O
-    #       /            //
-    # A = [S+2]  >>  A = S
-    #       \            \\
-    #       [O-]          O
-    #
-    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 3, 'hybridization': 2},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1))
-    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #          A                  A
-    #          |                  |
-    # [O-] - [S+2] - [O-] >>  O = S = O
-    #          |                  |
-    #          A                  A
-    #
-    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1))
-    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  A - [S-] - [C+]  >>  A - S = C
-    #       |                   |
-    #       A                   A
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  O              O
-    #  \\             \\
-    #  [S-] - A  >>    S - A
-    #  //             /
-    #  O            [O-]
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O             [O-]
-    #     \\             \
-    # A - [S-] = O >> A - S = O
-    #     //             //
-    #     O              O
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 2), (1, 5, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  O              [O-]
-    #  \\              \
-    #  [S-] - [S-] >>   S = S
-    #  //              /
-    #  O              [O-]
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'S', 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
-    atom_fix = {1: (1, None), 2: (1, None), 3: (-1, None), 4: (-1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 1), (1, 4, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #    A            A
-    #    \            \
-    # A - S = O >> A - S = O
-    #    /            //
-    #  [OH]           O
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #    A            A
-    #    \            \
-    # A - S = O >> A - S = O
-    #    /            //
-    #  [NH]           N
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 3, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #      A{1,3}               A{1,3}
-    #      |                    |
-    #  N = S - [OH]  >>  [NH] - S = O
-    #
-    atoms = ({'atom': 'S', 'neighbors': (3, 5), 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2})
-    bonds = ((1, 2, 1), (1, 3, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (1, 3, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # C # C - [O,NH,S]H  >> C=C=[O,NH,S]
-    #
-    atoms = ({'atom': ListElement(['O', 'S', 'N']), 'neighbors': 1}, {'atom': 'C', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (2, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # C # C - [NH]R  >> C=C=NR
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'C', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (2, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    # Carbon Monoxide
-    #
-    # [CX1] = O  >> [С-] # [O+]
-    #
-    atoms = ({'atom': 'C', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (-1, False), 2: (1, None)}
-    bonds_fix = ((1, 2, 3),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Ozone
-    #
-    # [O*] -- O -- [O*]  >>  O == [O+] -- [O-]
-    #
-    atoms = ({'atom': 'O', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 2},
-             {'atom': 'O', 'neighbors': 1, 'is_radical': True})
-    bonds = ((1, 2, 1), (2, 3, 1))
-    atom_fix = {1: (0, False), 2: (1, None), 3: (-1, False)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # only after [A-] - [C+] rules!
-    #  [C+] - N(R2)  >> C = [N+](R2)
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1, 'heteroatoms': 0},
-             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # low priority for hetero-N
-    #  [C+] - N(X2)  >> C = [N+](X2)
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  [C+] = N(R)  >>  C # [N+](R)
-    #
-    atoms = ({'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 2, 'heteroatoms': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 3),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Br-ion + I-ion
-    #
-    #        A           A
-    #        |           |
-    # [Br-].[I+] >> Br - I
-    #        |           |
-    #        A           A
-    #
-    atoms = ({'atom': 'Br', 'charge': -1, 'neighbors': 0},
-             {'atom': 'I', 'charge': 1, 'neighbors': 2, 'hybridization': 1},)
-    bonds = ()
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix rdkit
-    # [Cl,Br,I+] - [O-] >> X = O
-    #
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': 1, 'neighbors': 2, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix rdkit
-    # A-[Hal+2]([O-])2
-    #
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': 2, 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1))
-    atom_fix = {1: (-3, None), 2: (1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix rdkit
-    # A-[Hal+3]([O-])3
-    #
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': 3, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1))
-    atom_fix = {1: (-3, None), 2: (1, None), 3: (1, None), 4: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2), (1, 4, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix reaxys [Cl-]=O > Cl-[O-]
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    compiled_rules = []
-    for atoms, bonds, atom_fix, bonds_fix, is_tautomer in raw_rules:
-        q = QueryContainer()
-        for a in atoms:
-            q.add_atom(**a)
-        for n, m, b in bonds:
-            q.add_bond(n, m, b)
-
-        any_atoms = [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix]
-        compiled_rules.append((q, atom_fix, bonds_fix, any_atoms, is_tautomer))
-
-    return [(q, atom_fix, bonds_fix,
-             [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix], is_tautomer)
-            for q, atom_fix, bonds_fix, is_tautomer in rules] + compiled_rules  # todo: remove compiled
-
-
-def _rules_double():
-    from ... import smarts
-
-    rules = []
-
-    #
-    #     [OH]                O
-    #      |                 //
-    #  N = S = A  >>  [NH] - S = A
-    #      |                 |
-    #      A                 A
-    #
-    q = smarts('[S;D4;z3:1]([O;D1:2])(=[N;D1,D2;z2:3])(=[A])[A]')
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (1, 3, 1))
-    rules.append((q, atom_fix, bonds_fix, True))
-
-    return [(q, atom_fix, bonds_fix,
-             [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix], is_tautomer)
-            for q, atom_fix, bonds_fix, is_tautomer in rules]
-
-
-single_rules = Proxy(_rules_single)
-double_rules = Proxy(_rules_double)
-
-
-__all__ = ['single_rules', 'double_rules']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from lazy_object_proxy import Proxy
+from ...periodictable import ListElement
+
+
+def _rules_single():
+    """
+    rules without overlapping. these rules can match once to same set of atoms.
+    """
+    from ...containers import QueryContainer
+
+    raw_rules = []
+
+    #
+    #  [A*] - [A*] >> A = A or [A*] = [A*] >> A # A
+    #
+    atoms = ({'atom': 'A', 'is_radical': True}, {'atom': 'A', 'is_radical': True})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (0, False), 2: (0, False)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+    bonds = ((1, 2, 2),)
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A   H   A     A     H   A
+    #  \ / \ /       \  .. \ /
+    #   B   B    >>   B     B
+    #  / \ / \       / \  .. \
+    # A   H   A     A   H     A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1}, {'atom': 'B', 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'H', 'neighbors': 2}, {'atom': 'H', 'neighbors': 2})
+    bonds = ((1, 3, 1), (1, 4, 1), (2, 3, 1), (2, 4, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 8), (2, 4, 8))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      A            A
+    #     //           //
+    # B - N >> [B-] - [N+]
+    #     \            \
+    #      A            A
+    #
+    atoms = ({'atom': 'B'}, {'atom': 'N', 'neighbors': 3, 'hybridization': 2})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     A   A             A      A
+    #     |   |             |      |
+    # A - B = N - A >> A - [B-] - [N+] - A
+    #     |   |             |      |
+    #     A   A             A      A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 2}, {'atom': 'N', 'neighbors': 4, 'hybridization': 2})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #   A      A       A   A
+    #   |      |       |   |
+    #  [B-] = [N+] >>  B - N
+    #   |      |       |   |
+    #   A      A       A   A
+    #
+    atoms = ({'atom': 'B', 'charge': -1, 'neighbors': 3, 'hybridization': 2},
+             {'atom': 'N', 'charge': 1, 'neighbors': 3, 'hybridization': 2})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #        [A-]                 A
+    #         |                   |
+    # [A-] - [B+3] - [A-] >> A - [B-] - A
+    #         |                   |
+    #        [A-]                 A
+    #
+    atoms = ({'atom': 'B', 'charge': 3, 'neighbors': 4}, {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1},
+             {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1))
+    atom_fix = {1: (-4, None), 2: (1, None), 3: (1, None), 4: (1, None), 5: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #        A             A
+    #        |             |
+    # [A-] - B - A >> A - [B-] - A
+    #        |             |
+    #        A             A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4}, {'atom': 'A', 'charge': -1}, {'atom': 'A'}, {'atom': 'A'}, {'atom': 'A'})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1))
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      A             A
+    #      |             |
+    # A -  B - A >> A - [B-] - A
+    #      |             |
+    #      A             A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1},)
+    bonds = ()
+    atom_fix = {1: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     A         A
+    #     |         |
+    #     N    >>  [N+]
+    #   / | \     / | \
+    #  A  A  A   A  A  A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 1},)
+    bonds = ()
+    atom_fix = {1: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #  aci-nitro
+    #      O          O
+    #     //         //
+    # C = N  >> C - [N+]
+    #      \         \
+    #       OH       [O-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
+    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 4, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #            O               [O-]
+    #           //               /
+    # [C,N,O] = N  >> [C,N,O] = [N+]
+    #           \                \
+    #            A                A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': ListElement(['C', 'N', 'O'])},
+             {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # fix aci-nitro
+    #       [O-]          [O-]
+    #       /             /
+    # C = [N+ ] >>  C - [N+]
+    #      \             \\
+    #       OH            O
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3}, {'atom': 'O', 'charge': -1, 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 2), (1, 4, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # fix CN(=O)=N(=O)C
+    #
+    # [N+] = N = O >> [N+] = [N+] - O-
+    #        |                |
+    #        A                A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Fix CN(=O)=N(=N)C
+    # [N+] = N = N - ? >> [N+] = [N+] - [N-] - ?
+    #        |                    |
+    #        A                    A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # For N-case not unique!
+    #          N             [N-]
+    #         //             /
+    # [C,N] = N  >> [C,N] = [N+]
+    #         \              \
+    #          A              A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': ListElement(['C', 'N'])}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [N-] - [N+] = O >> N = [N+] - [O-]
+    #         |               |
+    #         A               A
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'charge': -1, 'hybridization': 1, 'neighbors': (1, 2)})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #         O              [O-]
+    #        //              /
+    # [A-] - N   >> [A-] - [N+]
+    #        \\             \\
+    #         O              O
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'A', 'charge': -1})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # O : N : O      O = [N+] - [O-]
+    #     |      >>       |
+    #     A               A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 4), (1, 3, 4), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Nitrite
+    #
+    #   O        [O-]
+    #  //        /
+    # [N-]  >>  N
+    #  \\       \\
+    #   O        O
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'charge': -1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 2), (1, 3, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [O,C,N] = N # N >> [O,C,N] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': ListElement(['O', 'C', 'N'])})
+    bonds = ((1, 2, 3), (1, 3, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [C,N,O-] - [N+] # N  >> [C,N,O] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1},
+             {'atom': ListElement(['N', 'C', 'O']), 'charge': -1, 'hybridization': 1})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  A - [N+] # N = [N-]  >> A - N = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
+             {'atom': 'N', 'charge': -1, 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 3), (1, 3, 2), (2, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - N = N = N >> A - N = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 2},
+             {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 2), (1, 3, 2))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - NH - N # N >> A - N = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 1},
+             {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 3))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [N-] # N = N - A >> [N-] == [N+] == N - A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1},
+             {'atom': 'N', 'hybridization': 2, 'neighbors': 2})
+    bonds = ((1, 2, 3), (1, 3, 2))
+    atom_fix = {1: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [N-] == N # N >> [N-] == [N+] == [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1}, {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 2), (1, 3, 3))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ((1, 3, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - C # N = NH >> A - [CH] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'C', 'neighbors': (1, 2)}, {'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 3), (2, 3, 2))
+    atom_fix = {2: (1, None), 3: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # note: order dependent
+    # A - C # N = [O,N] >> A - C # [N+] - [O,N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 2), (1, 3, 3))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [NH2,OH,SH] - N # C - A >> [NH,O,S-] - [N+] # C
+    #
+    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - [NH] - N # C >> A - [N-] - [N+] # C
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [NH2,OH,SH] - [N+] # [C-] >> [NH,O,S-] - [N+] # [CH]
+    #
+    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
+             {'atom': 'C', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 3: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - [NH] - [N+] # [C-] >> A - [N-] - [N+] # [CH]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
+             {'atom': 'C', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 3: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - N # C >> A - [N+] # [C-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'C', 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # fix old diazo rule
+    #
+    # A - [C-] = [N+] = [NH] >> A - [CH] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 2), (2, 3, 2))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #    |           |
+    #  - N -   >> - [N+] -
+    #    \\          |
+    #    [O,N]      [O,N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # N-oxide radical
+    #
+    #    |         |
+    #  - N*  >>  - N
+    #    \\        |
+    #     O        O*
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 2, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (0, False), 2: (0, True)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # C           C
+    #  \           \
+    #   N # N >>   [N+] = [N-]
+    #  /           /
+    # C           C
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': 1}, {'atom': 'C'}, {'atom': 'C'})
+    bonds = ((1, 2, 3), (1, 3, 1), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  C - N = [N+]  >>  C - [N+] # N
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 1}, {'atom': 'C'})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  [N+] - [C-] = O  >>  N = C = O
+    #
+    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': 2},
+             {'atom': 'N', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  N # C - OH  >>  HN = C = O
+    #
+    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  N # C - [O-]  >>  [N-] = C = O
+    #
+    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # - [N+] - [O-]  >>  - N = O
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     [O+]R         [O]R
+    #     //            /
+    # N - C  >> [N+] = C
+    #
+    atoms = ({'atom': 'C', 'hybridization': 2}, {'atom': 'O', 'neighbors': 2, 'hybridization': 2, 'charge': 1},
+             {'atom': 'N', 'hybridization': 1})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      [O,S]H    [O,S]
+    #      /         //
+    # N = C  >> NH - C
+    #
+    atoms = ({'atom': 'C', 'hybridization': 2}, {'atom': ListElement(['O', 'S']), 'neighbors': 1},
+             {'atom': 'N', 'hybridization': 2})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # fix pyridin-2-one. note: only after amide rule
+    #
+    atoms = ({'atom': 'C', 'neighbors': 3}, {'atom': ListElement(['O', 'S']), 'neighbors': 1},
+             {'atom': 'N', 'neighbors': 2}, {'atom': 'A', 'hybridization': 2}, {'atom': 'A', 'hybridization': 2},
+             {'atom': 'A', 'hybridization': 2}, {'atom': 'A', 'hybridization': 2})
+    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 1), (3, 7, 1), (4, 5, (1, 2)), (5, 6, (1, 2)), (6, 7, (1, 2)))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # todo:
+    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5]=,:[C:6][C:7](=[O:1])[C:8]=,:[C:9]1
+    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5](=[O:1])[C:6]=,:[C:7]-,:[C:8]=,:[C:9]1
+
+    #
+    #       OH          O
+    #      /           //
+    # C = C    >> C - C
+    #      \           \
+    #      [O,N]       [O,N]
+    #
+    atoms = ({'atom': 'O', 'neighbors': 1}, {'atom': ListElement(['O', 'N'])}, {'atom': 'C'}, {'atom': 'C'})
+    bonds = ((1, 3, 1), (2, 3, 1), (3, 4, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 2), (3, 4, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       A                   A
+    #       |                   |
+    #  A - [P+] - [O-]  >>  A - P = O
+    #       |                   |
+    #       A                   A
+    #
+    atoms = ({'atom': 'P', 'charge': 1, 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       A                   A
+    #       |                   |
+    #  A - [P-] - [C+]  >>  A - P = C
+    #       |                   |
+    #       A                   A
+    #
+    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2, 3), 'hybridization': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #   F   F         F   F
+    #    \ /           \ /
+    # F - P - F >> F - [P-] - F
+    #    / \           / \
+    #   F   F         F   F
+    #
+    atoms = ({'atom': 'P', 'neighbors': 6}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
+             {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
+             {'atom': 'F', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1), (1, 6, 1), (1, 7, 1))
+    atom_fix = {1: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     O               O
+    #     \\              \\
+    # A - [P-] - A  >> A - P - A
+    #     //              /
+    #     O              [O-]
+    #
+    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'A'}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1), (1, 5, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #           A                   A
+    #          /                   /
+    # [O-] - [S,Si,Se+]  >>  O = [S,Si,Se]
+    #          \                   \
+    #           A                   A
+    #
+    atoms = ({'atom': ListElement(['S', 'Se', 'Si']), 'charge': 1, 'neighbors': 3, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       A?                  A?
+    #       |                   |
+    #  A = [S+] - [O-]  >>  A = S = O
+    #       |                   |
+    #       A?                  A?
+    #
+    atoms = ({'atom': 'S', 'charge': 1, 'neighbors': (2, 4), 'hybridization': 2},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       [O-]          O
+    #       /            //
+    # A = [S+2]  >>  A = S
+    #       \            \\
+    #       [O-]          O
+    #
+    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 3, 'hybridization': 2},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 1))
+    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #          A                  A
+    #          |                  |
+    # [O-] - [S+2] - [O-] >>  O = S = O
+    #          |                  |
+    #          A                  A
+    #
+    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 1))
+    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  A - [S-] - [C+]  >>  A - S = C
+    #       |                   |
+    #       A                   A
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3, 'hybridization': 1},
+             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  O              O
+    #  \\             \\
+    #  [S-] - A  >>    S - A
+    #  //             /
+    #  O            [O-]
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     O             [O-]
+    #     \\             \
+    # A - [S-] = O >> A - S = O
+    #     //             //
+    #     O              O
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 2), (1, 5, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  O              [O-]
+    #  \\              \
+    #  [S-] - [S-] >>   S = S
+    #  //              /
+    #  O              [O-]
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'S', 'charge': -1, 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
+    atom_fix = {1: (1, None), 2: (1, None), 3: (-1, None), 4: (-1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 1), (1, 4, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #    A            A
+    #    \            \
+    # A - S = O >> A - S = O
+    #    /            //
+    #  [OH]           O
+    #
+    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #    A            A
+    #    \            \
+    # A - S = O >> A - S = O
+    #    /            //
+    #  [NH]           N
+    #
+    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 1})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      A{1,3}               A{1,3}
+    #      |                    |
+    #  N = S - [OH]  >>  [NH] - S = O
+    #
+    atoms = ({'atom': 'S', 'neighbors': (3, 5), 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # C # C - [O,NH,S]H  >> C=C=[O,NH,S]
+    #
+    atoms = ({'atom': ListElement(['O', 'S', 'N']), 'neighbors': 1}, {'atom': 'C', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (2, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # C # C - [NH]R  >> C=C=NR
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'C', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (2, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Carbon Monoxide
+    #
+    # [CX1] = O  >> [С-] # [O+]
+    #
+    atoms = ({'atom': 'C', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (-1, False), 2: (1, None)}
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Ozone
+    #
+    # [O*] -- O -- [O*]  >>  O == [O+] -- [O-]
+    #
+    atoms = ({'atom': 'O', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 2},
+             {'atom': 'O', 'neighbors': 1, 'is_radical': True})
+    bonds = ((1, 2, 1), (2, 3, 1))
+    atom_fix = {1: (0, False), 2: (1, None), 3: (-1, False)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # only after [A-] - [C+] rules!
+    #  [C+] - N(R2)  >> C = [N+](R2)
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1, 'heteroatoms': 0},
+             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # low priority for hetero-N
+    #  [C+] - N(X2)  >> C = [N+](R2)
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1},
+             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  [C+] = N(R)  >>  C # [N+](R)
+    #
+    atoms = ({'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 2, 'heteroatoms': 1})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Br-ion + I-ion
+    #
+    #        A           A
+    #        |           |
+    # [Br-].[I+] >> Br - I
+    #        |           |
+    #        A           A
+    #
+    atoms = ({'atom': 'Br', 'charge': -1, 'neighbors': 0},
+             {'atom': 'I', 'charge': 1, 'neighbors': 2, 'hybridization': 1},)
+    bonds = ()
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  [I+] - [O-] >> I = O
+    #
+    atoms = ({'atom': 'I', 'charge': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    compiled_rules = []
+    for atoms, bonds, atom_fix, bonds_fix in raw_rules:
+        q = QueryContainer()
+        for a in atoms:
+            q.add_atom(**a)
+        for n, m, b in bonds:
+            q.add_bond(n, m, b)
+
+        any_atoms = [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix]
+        compiled_rules.append((q, atom_fix, bonds_fix, any_atoms))
+    return compiled_rules
+
+
+def _rules_double():
+    from ...containers import QueryContainer
+
+    raw_rules = []
+
+    #
+    #     [OH]                O
+    #      |                 //
+    #  N = S = A  >>  [NH] - S = A
+    #      |                 |
+    #      A                 A
+    #
+    atoms = ({'atom': 'S', 'neighbors': 4}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2}, {'atom': 'A'}, {'atom': 'A'})
+    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2), (1, 5, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    compiled_rules = []
+    for atoms, bonds, atom_fix, bonds_fix in raw_rules:
+        q = QueryContainer()
+        for a in atoms:
+            q.add_atom(**a)
+        for n, m, b in bonds:
+            q.add_bond(n, m, b)
+
+        any_atoms = [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix]
+        compiled_rules.append((q, atom_fix, bonds_fix, any_atoms))
+    return compiled_rules
+
+
+single_rules = Proxy(_rules_single)
+double_rules = Proxy(_rules_double)
+
+
+__all__ = ['single_rules', 'double_rules']
```

### Comparing `chython-1.64/chython/algorithms/standardize/resonance.py` & `chython-1.8/chython/algorithms/standardize/resonance.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,187 +1,172 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from typing import List, TYPE_CHECKING, Union
-from ...exceptions import ValenceError
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-
-class Resonance:
-    __slots__ = ()
-
-    def fix_resonance(self: Union['MoleculeContainer', 'Resonance'], *, logging=False,
-                      _fix_stereo=True) -> Union[bool, List[int]]:
-        """
-        Transform biradical or dipole resonance structures into neutral form. Return True if structure form changed.
-
-        :param logging: return list of changed atoms.
-        """
-        atoms = self._atoms
-        charges = self._charges
-        radicals = self._radicals
-        bonds = self._bonds
-        calc_implicit = self._calc_implicit
-        entries, exits, rads, constrains, nitrogen_cat, nitrogen_ani, sulfur_cat = self.__entries()
-        hs = set()
-        while len(rads) > 1:
-            n = rads.pop()
-            for path in self.__find_delocalize_path(n, rads, constrains, True):
-                radicals[n] = False
-                hs.add(n)
-                for n, m, b in path:
-                    hs.add(m)
-                    bonds[n][m]._Bond__order = b  # noqa
-                radicals[m] = False  # noqa
-                rads.discard(m)
-                break  # path found
-            # path not found. atom n keep as is
-        while entries and exits:
-            n = entries.pop()
-            for path in self.__find_delocalize_path(n, exits, constrains, False):
-                l, m, b = path[-1]
-                if n in nitrogen_cat and m in nitrogen_ani:
-                    continue
-
-                c_m = charges[m] - 1
-                if m in sulfur_cat:  # prevent X-[S+]=X >> X=S=X
-                    if b != 1:
-                        continue
-                else:  # check cations end valence.
-                    try:
-                        atoms[m].valence_rules(c_m, radicals[m], sum(int(y) for x, y in bonds[m].items() if x != l) + b)
-                    except ValenceError:
-                        continue
-
-                charges[n] += 1
-                hs.add(n)
-                for n, m, b in path:
-                    hs.add(m)
-                    bonds[n][m]._Bond__order = b  # noqa
-                charges[m] = c_m
-                exits.discard(m)
-                break  # path from negative atom to positive atom found.
-            # path not found. keep negative atom n as is
-        if hs:
-            for n in hs:
-                calc_implicit(n)
-            self.flush_cache()
-            if _fix_stereo:
-                self.fix_stereo()
-            if logging:
-                return list(hs)
-            return True
-        elif logging:
-            return []
-        return False
-
-    def __find_delocalize_path(self: 'MoleculeContainer', start, finish, constrains, odd_only):
-        bonds = self._bonds
-        stack = [(start, n, 0, b.order + 1) for n, b in bonds[start].items() if n in constrains and b.order < 3]
-        path = []
-        seen = {start}
-        while stack:
-            last, current, depth, order = stack.pop()
-            if len(path) > depth:
-                seen.difference_update(x for _, x, _ in path[depth:])
-                path = path[:depth]
-
-            path.append((last, current, order))
-
-            if current in finish:
-                if odd_only:  # radicals!
-                    if len(path) % 2:
-                        yield path
-                    else:  # invalid path
-                        continue
-                elif depth:  # one bonded ignored. we search double bond transfer! A=A-A >> A-A=A.
-                    yield path
-
-            depth += 1
-            seen.add(current)
-            diff = -1 if depth % 2 else 1
-            stack.extend((current, n, depth, bo) for n, b in bonds[current].items()
-                         if n not in seen and n in constrains and 1 <= (bo := b.order + diff) <= 3)
-
-    def __entries(self: 'MoleculeContainer'):
-        hybridization = self.hybridization
-        neighbors = self.neighbors
-        charges = self._charges
-        radicals = self._radicals
-        bonds = self._bonds
-        atoms = self._atoms
-        errors = {n for n, h in self._hydrogens.items() if h is None}
-
-        transfer = set()
-        entries = set()
-        exits = set()
-        rads = set()
-        nitrogen_cat = set()
-        nitrogen_ani = set()
-        sulfur_cat = set()
-        for n, a in atoms.items():
-            if a.atomic_number not in {5, 6, 7, 8, 14, 15, 16, 33, 34, 52}:
-                # filter non-organic set, halogens and aromatics
-                continue
-            elif radicals[n]:
-                rads.add(n)
-            elif charges[n] == -1:
-                if (lb := len(bonds[n])) == 4 and a.atomic_number == 5:  # skip boron
-                    continue
-                elif lb == 6 and a.atomic_number == 15:  # skip [P-]X6
-                    continue
-                if n in errors:  # only valid anions accepted
-                    continue
-                entries.add(n)
-            elif charges[n] == 1:
-                lb = len(bonds[n])
-                if a.atomic_number == 7:
-                    if lb == 4:  # skip ammonia
-                        continue
-                    elif lb == 2 and hybridization(n) == 3:  # skip Azide
-                        (n1, b1), (n2, b2) = bonds[n].items()
-                        if b1.order == b2.order == 2 and (charges[n1] == -1 and atoms[n1].atomic_number == 7 or
-                                                          charges[n2] == -1 and atoms[n2].atomic_number == 7):
-                            continue
-                    elif lb == 3 and hybridization(n) == 2:  # X=[N+](-X)-X - prevent N-N migration
-                        nitrogen_ani.add(n)
-                elif a.atomic_number == 15 and lb == 4:  # skip [P+]R4
-                    continue
-                elif a.atomic_number == 16:
-                    if lb == 2 and hybridization(n) == 2:  # ad-hoc for X-[S+]=X
-                        sulfur_cat.add(n)
-                    elif lb == 3 and hybridization(n) == 1:  # ad-hoc for X-[S+](-X)-X
-                        continue
-                exits.add(n)
-            transfer.add(n)
-
-        if exits or entries:  # try to move cation to nitrogen. saturation fixup.
-            for n, a in self._atoms.items():
-                if a.atomic_number == 7 and not charges[n]:
-                    if hybridization(n) == 1 and neighbors(n) <= 3:  # any amine - potential e-donor
-                        entries.add(n)
-                        nitrogen_cat.add(n)
-                    elif hybridization(n) == 3 and neighbors(n) == 1:  # N#X-[X-] >> [N-]=X=X
-                        exits.add(n)
-                        nitrogen_ani.add(n)
-        return entries, exits, rads, transfer, nitrogen_cat, nitrogen_ani, sulfur_cat
-
-
-__all__ = ['Resonance']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from typing import List, TYPE_CHECKING, Union
+from ...exceptions import ValenceError
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+
+class Resonance:
+    __slots__ = ()
+
+    def fix_resonance(self: Union['MoleculeContainer', 'Resonance'], *, logging=False) ->\
+            Union[bool, List[int]]:
+        """
+        Transform biradical or dipole resonance structures into neutral form. Return True if structure form changed.
+
+        :param logging: return list of changed atoms.
+        """
+        atoms = self._atoms
+        charges = self._charges
+        radicals = self._radicals
+        bonds = self._bonds
+        entries, exits, rads, constrains, nitrogen_cat, nitrogen_ani, sulfur_cat = self.__entries()
+        hs = set()
+        while len(rads) > 1:
+            n = rads.pop()
+            for path in self.__find_delocalize_path(n, rads, constrains, True):
+                radicals[n] = False
+                hs.add(n)
+                for n, m, b in path:
+                    hs.add(m)
+                    bonds[n][m]._Bond__order = b
+                radicals[m] = False
+                rads.discard(m)
+                break  # path found
+            # path not found. atom n keep as is
+        while entries and exits:
+            n = entries.pop()
+            for path in self.__find_delocalize_path(n, exits, constrains, False):
+                l, m, b = path[-1]
+                if n in nitrogen_cat:
+                    if m in nitrogen_ani:
+                        continue
+                    c_n = 1
+                else:
+                    c_n = 0
+                c_m = -1 if m in nitrogen_ani else 0
+                if m in sulfur_cat:  # prevent X-[S+]=X >> X=S=X
+                    if b != 1:
+                        continue
+                else:  # check cations end valence.
+                    try:
+                        atoms[m].valence_rules(c_m, radicals[m], sum(int(y) for x, y in bonds[m].items() if x != l) + b)
+                    except ValenceError:
+                        continue
+
+                charges[n] = c_n
+                hs.add(n)
+                for n, m, b in path:
+                    hs.add(m)
+                    bonds[n][m]._Bond__order = b
+                charges[m] = c_m
+                exits.discard(m)
+                break  # path from negative atom to positive atom found.
+            # path not found. keep negative atom n as is
+        if hs:
+            for n in hs:
+                self._calc_implicit(n)
+            self.flush_cache()
+            if logging:
+                return list(hs)
+            return True
+        if logging:
+            return []
+        return False
+
+    def __find_delocalize_path(self: 'MoleculeContainer', start, finish, constrains, odd_only):
+        bonds = self._bonds
+        stack = [(start, n, 0, b.order + 1) for n, b in bonds[start].items() if n in constrains and b.order < 3]
+        path = []
+        seen = {start}
+        while stack:
+            last, current, depth, order = stack.pop()
+            if len(path) > depth:
+                seen.difference_update(x for _, x, _ in path[depth:])
+                path = path[:depth]
+
+            path.append((last, current, order))
+
+            if current in finish:
+                if odd_only:  # radicals!
+                    if len(path) % 2:
+                        yield path
+                    else:  # invalid path
+                        continue
+                elif depth:  # one bonded ignored. we search double bond transfer! A=A-A >> A-A=A.
+                    yield path
+
+            depth += 1
+            seen.add(current)
+            diff = -1 if depth % 2 else 1
+            stack.extend((current, n, depth, bo) for n, b in bonds[current].items()
+                         if n not in seen and n in constrains and 1 <= (bo := b.order + diff) <= 3)
+
+    def __entries(self: 'MoleculeContainer'):
+        hybridization = self.hybridization
+        neighbors = self.neighbors
+        charges = self._charges
+        radicals = self._radicals
+        bonds = self._bonds
+        errors = set(self.check_valence())
+
+        transfer = set()
+        entries = set()
+        exits = set()
+        rads = set()
+        nitrogen_cat = set()
+        nitrogen_ani = set()
+        sulfur_cat = set()
+        for n, a in self._atoms.items():
+            if a.atomic_number not in {5, 6, 7, 8, 14, 15, 16, 33, 34, 52}:
+                # filter non-organic set, halogens and aromatics
+                continue
+            elif radicals[n]:
+                rads.add(n)
+            elif charges[n] == -1:
+                if (lb := len(bonds[n])) == 4 and a.atomic_number == 5:  # skip boron
+                    continue
+                elif lb == 6 and a.atomic_number == 15:  # skip [P-]X6
+                    continue
+                if n in errors:  # only valid anions accepted
+                    continue
+                entries.add(n)
+            elif charges[n] == 1:
+                if (lb := len(bonds[n])) == 4 and a.atomic_number == 7:  # skip ammonia
+                    continue
+                if a.atomic_number == 16 and lb == 2 and hybridization(n) == 2:  # ad-hoc for X-[S+]=X
+                    sulfur_cat.add(n)
+                exits.add(n)
+            transfer.add(n)
+
+        if exits or entries:  # try to move cation to nitrogen. saturation fixup.
+            for n, a in self._atoms.items():
+                if a.atomic_number == 7 and not charges[n]:
+                    if hybridization(n) == 1 and neighbors(n) == 3:
+                        entries.add(n)
+                        nitrogen_cat.add(n)
+                    elif hybridization(n) == 3 and neighbors(n) == 1:  # N#X-[X-] >> [N-]=X=X
+                        exits.add(n)
+                        nitrogen_ani.add(n)
+        return entries, exits, rads, transfer, nitrogen_cat, nitrogen_ani, sulfur_cat
+
+
+__all__ = ['Resonance']
```

### Comparing `chython-1.64/chython/algorithms/standardize/saturation.py` & `chython-1.8/chython/algorithms/standardize/saturation.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,372 +1,369 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from itertools import product
-from operator import itemgetter
-from random import shuffle
-from typing import TYPE_CHECKING, Dict, Optional, Union, List
-from ...containers.bonds import Bond
-from ...exceptions import ValenceError
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-# atom, charge, unsaturation
-tuned_priority = {(7, 0, 0): -3,  # amine
-                  (7, 0, 1): -3,  # X=N-X
-                  (7, 0, 2): -3,  # X#N
-                  (7, 1, 1): -2,  # X=[N+](-X)-X
-                  (7, 1, 2): -2,  # X=[N+]=X
-                  (7, -1, 0): -1,  # X-[N-]-X
-                  (7, -1, 1): -1,  # X=[N-]
-                  (8, 0, 0): -2,  # X-O-X
-                  (8, 0, 1): -2,  # X=O
-                  (8, -1, 0): -1,  # X-[O-]
-                  (8, 1, 1): -1,  # X=[O+]-X
-                  (16, 0, 0): -3,  # X-S-X
-                  (16, 0, 2): -2,  # X-S(-X)(=X)=X
-                  (16, 0, 1): -2,  # X-S(-X)(=X)
-                  (16, 0, 2): -2,  # X=S=X
-                  (16, 0, 0): -1,  # X-S(-X)(-X)-X
-                  (16, 0, 1): -1,  # X-[S+](-X)(-X)
-                  (16, 1, 1): -1,  # X=[S+]-X
-                  }
-charge_priority = {0: 0, -1: 1, 1: 2, 2: 3, 3: 4, -2: 5, 4: 6, -3: 7, -4: 8}
-
-
-class Saturation:
-    __slots__ = ()
-
-    def saturate(self: 'MoleculeContainer', neighbors_distances: Optional[Dict[int, Dict[int, float]]] = None,
-                 reset_electrons: bool = True, expected_charge: int = 0, expected_radicals_count: int = 0,
-                 allow_errors: bool = True, logging: bool = False) -> Union[bool, List[str]]:
-        """
-        Saturate molecules with double and triple bonds and charges and radical states to correct valences of atoms.
-        Note: works only with fully explicit hydrogens!
-
-        :param neighbors_distances: If given longest bonds can be removed if need.
-        :param reset_electrons: Can change charges and radicals if need.
-        :param expected_charge: Reset charge to given. Works only with reset_electrons=True.
-        :param expected_radicals_count: Reset radical atoms count to given. Works only with reset_electrons=True.
-        :param allow_errors: allow unbalanced result.
-        :param logging: return log.
-        """
-        if any(b != 1 for _, _, b in self.bonds()):
-            raise ValenceError('only single bonded skeleton can be saturated')
-        atoms = self._atoms
-        if not reset_electrons:
-            expected_radicals_count = any(self._radicals.values())
-            expected_charge = int(self)
-
-        sat, adjacency = _find_possible_valences(atoms, neighbors_distances or self._bonds,
-                                                 {x: None for x in self._atoms} if reset_electrons else self._charges,
-                                                 {x: None for x in self._atoms} if reset_electrons else self._radicals,
-                                                 neighbors_distances is not None)
-        charges = {}  # new charge states
-        radicals = {}  # new radical states
-        bonds = {n: {} for n in atoms}  # new bonds
-
-        seen = set()
-        unsaturated = {}
-        for n, env in adjacency.items():  # set single bonds in molecule. collect unsaturated atoms
-            s = sat[n]
-            if len(s) == 1:
-                c, r, h = s.pop()
-                if not h:
-                    seen.add(n)
-                    charges[n] = c
-                    radicals[n] = r
-                    for m in env:
-                        if m not in seen:
-                            bonds[n][m] = bonds[m][n] = b = Bond(1)
-                            b._attach_graph(self, n, m)
-                else:
-                    unsaturated[n] = [(c, r, h)]
-            else:
-                # radicals have the lowest priority
-                # tuned priority
-                # multiple bonds have higher priority
-                # charges priority: 0>-1>1>2>3>-2>4>-3>-4
-                unsaturated[n] = sorted(s, key=lambda x: (x[1],
-                                                          tuned_priority.get((atoms[n].atomic_number, x[0], x[2]), 0),
-                                                          -x[2], charge_priority[x[0]]))
-
-        log = []
-        if (need_radicals := expected_radicals_count - sum(radicals.values())) < 0:
-            log.append('Radical state not balanced')
-            if not allow_errors:
-                if logging:
-                    return log
-                return False
-            need_radicals = 0  # reset to zero
-
-        if unsaturated:
-            # create graph of unsaturated atoms
-            bonds_graph = {n: {m for m in adjacency[n] if m in unsaturated} for n in unsaturated}
-            order = list(unsaturated)
-            # try to saturate with different random states
-            for _ in range(len(unsaturated)):
-                shuffle(order)
-                sb, sa, log_ = _saturate({n: bonds_graph[n].copy() for n in order}, unsaturated, need_radicals,
-                                         expected_charge - sum(charges.values()))
-                if not log_:  # success
-                    break
-            else:  # failed
-                if log_ == 1:
-                    log.append('Charge state not balanced')
-                elif log_ == 2:
-                    log.append('Radical state not balanced')
-                else:
-                    log.append('Charge state not balanced')
-                    log.append('Radical state not balanced')
-                if not allow_errors:  # all attempts failed
-                    if logging:
-                        return log
-                    return False
-
-            for n, m, b in sb:
-                bonds[n][m] = bonds[m][n] = b = Bond(b)
-                b._attach_graph(self, n, m)
-            for n, c, r in sa:
-                charges[n] = c
-                radicals[n] = r
-        elif expected_charge != sum(charges.values()):  # check charge for saturated case
-            log.append('Charge state not balanced')
-            if not allow_errors:
-                if logging:
-                    return log
-                return False
-        # reset molecule
-        self._bonds = bonds
-        self._radicals = radicals
-        self._charges = charges
-        self._hydrogens = {x: 0 for x in atoms}  # reset invalid hydrogens counts.
-        self.flush_cache()
-        if logging:
-            if not log:  # check for errors
-                log.append('Saturated successfully')
-            else:
-                log.append('Saturated with errors')
-            return log
-        return True
-
-
-def _find_possible_valences(atoms, neighbors_distances, charges, radicals, allow_deleting=True):
-    if allow_deleting:
-        possible_bonds = {n: md.copy() for n, md in neighbors_distances.items()}
-    else:
-        possible_bonds = {n: list(md) for n, md in neighbors_distances.items()}
-    while True:
-        saturation = defaultdict(set)
-        for n, env in possible_bonds.items():
-            env_atoms = None
-            el = len(env)
-            dc = charges[n]
-            dr = radicals[n]
-            for charge, is_radical, valence, implicit, explicit_dict in atoms[n]._compiled_saturation_rules:
-                if valence < el or dc is not None and dc != charge or dr is not None and dr != is_radical:
-                    continue  # skip impossible rules
-                if explicit_dict:
-                    if env_atoms is None:  # lazy caching
-                        env_atoms = defaultdict(int)
-                        for m in env:
-                            env_atoms[atoms[m].atomic_number] += 1
-                    env_atoms_copy = env_atoms.copy()
-                    for (b, a), c in explicit_dict.items():  # stage 1. find explicit valence
-                        if env_atoms_copy[a] < c:  # `c` always > 0
-                            break  # rule not matched
-                        env_atoms_copy[a] -= c
-                    else:  # stage 2. find possible valence
-                        if unmatched := sum(env_atoms_copy.values()):  # number of atoms outside rule
-                            if implicit >= unmatched:
-                                # number of implicit H should be greater or equal to number of neighbors
-                                saturation[n].add((charge, is_radical, valence - el))
-                        else:  # pattern fully matched. difference bw valence and connectivity is unsaturation.
-                            saturation[n].add((charge, is_radical, valence - el))
-                else:   # unspecific rule. found possible valence
-                    saturation[n].add((charge, is_radical, valence - el))
-            if n not in saturation:  # valence not found
-                break
-        else:  # all atoms passed
-            break
-        if allow_deleting:
-            out = max(env.items(), key=itemgetter(1))[0]
-            del possible_bonds[out][n]
-            del possible_bonds[n][out]
-        else:
-            raise ValenceError('Structure has invalid atoms neighbors count and electron states')
-    return saturation, possible_bonds
-
-
-def _saturate(bonds, atoms, expected_radicals_count, expected_charge):
-    atoms = {k: v.copy() for k, v in atoms.items()}
-    dots = []
-    saturation = []
-    electrons = []
-    while True:
-        # get isolated atoms. atoms should be charged or radical
-        to_del = []
-        for n, env in bonds.items():
-            if not env:
-                es = [(n, c, r) for c, r, h in atoms[n] if not h]
-                if not es:
-                    raise ValenceError('Saturation impossible. '
-                                       f"Isolated atom ({n}) doesn't have appropriate charge-radical state")
-                to_del.append(n)
-                dots.append(es)
-        for n in to_del:
-            del bonds[n]
-        if not bonds:
-            break
-
-        try:  # get terminal atom
-            n = next(n for n, ms in bonds.items() if len(ms) == 1)
-        except StopIteration:
-            # get ring or linker atom
-            n, _ = min(bonds.items(), key=lambda x: len(x[1]))
-            m = bonds[n].pop()
-            bonds[m].discard(n)
-
-            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
-                if nh == mh:
-                    saturation.append((n, m, nh + 1))
-                    electrons.append((n, nc, nr))
-                    electrons.append((m, mc, mr))
-
-                    for x in bonds.pop(n):
-                        saturation.append((n, x, 1))
-                        bonds[x].discard(n)
-                    for x in bonds.pop(m):
-                        saturation.append((m, x, 1))
-                        bonds[x].discard(m)
-                    break
-                elif nh < mh:
-                    electrons.append((n, nc, nr))
-                    saturation.append((n, m, nh + 1))
-                    atoms[m].pop(i)
-                    atoms[m].insert(i, (mc, mr, mh - nh))
-
-                    for x in bonds.pop(n):
-                        saturation.append((n, x, 1))
-                        bonds[x].discard(n)
-                    break
-                elif nh > mh:
-                    electrons.append((m, mc, mr))
-                    saturation.append((n, m, mh + 1))
-                    atoms[n].pop(i)
-                    atoms[n].insert(i, (nc, nr, nh - mh))
-
-                    for x in bonds.pop(m):
-                        saturation.append((m, x, 1))
-                        bonds[x].discard(m)
-                    break
-        else:
-            m = bonds.pop(n).pop()
-            bonds[m].discard(n)
-
-            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
-                if nh == mh:
-                    saturation.append((n, m, nh + 1))
-                    electrons.append((n, nc, nr))
-                    electrons.append((m, mc, mr))
-                    for x in bonds.pop(m):
-                        saturation.append((m, x, 1))
-                        bonds[x].discard(m)
-                    break
-                elif nh < mh and bonds[m]:
-                    electrons.append((n, nc, nr))
-                    saturation.append((n, m, nh + 1))
-                    atoms[m].pop(i)
-                    atoms[m].insert(i, (mc, mr, mh - nh))
-                    break
-            else:
-                saturation.append((n, m, 1))
-                if not bonds[m]:
-                    del bonds[m]
-
-    combo_ua = []  # possible single atoms electron states
-    for s in dots:
-        if len(s) == 1:
-            electrons.extend(s)
-        elif s:
-            combo_ua.append(s)
-
-    # if < 0 - we already in bad situation
-    # if > 0 - we need more radicals
-    need_radical = expected_radicals_count - sum(x for _, _, x in electrons)
-    need_charge = expected_charge - sum(x for _, x, _ in electrons)
-    if combo_ua:
-        # try randomly set charges and radicals.
-        # first pick required radical states.
-        # second try to minimize charge delta.
-        for attempt in range(1, len(combo_ua) + 1):
-            shuffle(combo_ua)
-            charges_radicals = []
-            rad = []
-            chg = []
-            for atom in combo_ua:
-                if len(rad) < need_radical:  # pick radicals
-                    r = next((x for x in atom if x[2]), None)
-                    if r:  # pick random radical states
-                        rad.append(r)
-                    else:  # not radical
-                        chg.append(atom)
-                else:  # pick not radical states
-                    c = [x for x in atom if not x[2]]
-                    if len(c) > 1:
-                        chg.append(c)
-                    elif c:
-                        charges_radicals.extend(c)
-                    elif attempt == len(combo_ua):  # all states has radical. balancing impossible
-                        chg.append(atom)  # fuck it horse. we in last attempt
-                    else:  # do next attempt
-                        break
-            else:
-                charges_radicals.extend(rad)
-                current_charge = need_charge - sum(x for _, x, _ in charges_radicals)
-                current_radical = need_radical - len(rad)
-                for x in chg:
-                    n, c, r = min(x, key=lambda x: abs(current_charge - x[1]))
-                    charges_radicals.append((n, c, r))
-                    current_charge -= c
-                    current_radical -= r
-
-                if current_radical:  # radical unbalanced
-                    if current_charge:
-                        log = 3
-                    else:
-                        log = 2
-                elif current_charge:
-                    log = 1
-                else:  # balanced!
-                    log = 0
-                    break
-
-        electrons.extend(charges_radicals)
-    elif need_radical:
-        log = 3 if need_charge else 2
-    elif need_charge:
-        log = 1
-    else:
-        log = 0
-    return saturation, electrons, log
-
-
-__all__ = ['Saturation']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from itertools import product
+from operator import itemgetter
+from random import shuffle
+from typing import TYPE_CHECKING, Dict, Optional, Union, List
+from ...containers.bonds import Bond
+from ...exceptions import ValenceError
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+# atom, charge, unsaturation
+tuned_priority = {(7, 0, 0): -3,  # amine
+                  (7, 0, 1): -3,  # X=N-X
+                  (7, 0, 2): -3,  # X#N
+                  (7, 1, 1): -2,  # X=[N+](-X)-X
+                  (7, 1, 2): -2,  # X=[N+]=X
+                  (7, -1, 0): -1,  # X-[N-]-X
+                  (7, -1, 1): -1,  # X=[N-]
+                  (8, 0, 0): -2,  # X-O-X
+                  (8, 0, 1): -2,  # X=O
+                  (8, -1, 0): -1,  # X-[O-]
+                  (8, 1, 1): -1,  # X=[O+]-X
+                  (16, 0, 0): -3,  # X-S-X
+                  (16, 0, 2): -2,  # X-S(-X)(=X)=X
+                  (16, 0, 1): -2,  # X-S(-X)(=X)
+                  (16, 0, 2): -2,  # X=S=X
+                  (16, 0, 0): -1,  # X-S(-X)(-X)-X
+                  (16, 0, 1): -1,  # X-[S+](-X)(-X)
+                  (16, 1, 1): -1,  # X=[S+]-X
+                  }
+charge_priority = {0: 0, -1: 1, 1: 2, 2: 3, 3: 4, -2: 5, 4: 6, -3: 7, -4: 8}
+
+
+class Saturation:
+    __slots__ = ()
+
+    def saturate(self: 'MoleculeContainer', neighbors_distances: Optional[Dict[int, Dict[int, float]]] = None,
+                 reset_electrons: bool = True, expected_charge: int = 0, expected_radicals_count: int = 0,
+                 allow_errors: bool = True, logging: bool = False) -> Union[bool, List[str]]:
+        """
+        Saturate molecules with double and triple bonds and charges and radical states to correct valences of atoms.
+        Note: works only with fully explicit hydrogens!
+
+        :param neighbors_distances: If given longest bonds can be removed if need.
+        :param reset_electrons: Can change charges and radicals if need.
+        :param expected_charge: Reset charge to given. Works only with reset_electrons=True.
+        :param expected_radicals_count: Reset radical atoms count to given. Works only with reset_electrons=True.
+        :param allow_errors: allow unbalanced result.
+        :param logging: return log.
+        """
+        if any(b != 1 for _, _, b in self.bonds()):
+            raise ValenceError('only single bonded skeleton can be saturated')
+        atoms = self._atoms
+        if not reset_electrons:
+            expected_radicals_count = any(self._radicals.values())
+            expected_charge = int(self)
+
+        sat, adjacency = _find_possible_valences(atoms, neighbors_distances or self._bonds,
+                                                 {x: None for x in self._atoms} if reset_electrons else self._charges,
+                                                 {x: None for x in self._atoms} if reset_electrons else self._radicals,
+                                                 neighbors_distances is not None)
+        charges = {}  # new charge states
+        radicals = {}  # new radical states
+        bonds = {n: {} for n in atoms}  # new bonds
+
+        seen = set()
+        unsaturated = {}
+        for n, env in adjacency.items():  # set single bonds in molecule. collect unsaturated atoms
+            s = sat[n]
+            if len(s) == 1:
+                c, r, h = s.pop()
+                if not h:
+                    seen.add(n)
+                    charges[n] = c
+                    radicals[n] = r
+                    for m in env:
+                        if m not in seen:
+                            bonds[n][m] = bonds[m][n] = Bond(1)
+                else:
+                    unsaturated[n] = [(c, r, h)]
+            else:
+                # radicals have the lowest priority
+                # tuned priority
+                # multiple bonds have higher priority
+                # charges priority: 0>-1>1>2>3>-2>4>-3>-4
+                unsaturated[n] = sorted(s, key=lambda x: (x[1],
+                                                          tuned_priority.get((atoms[n].atomic_number, x[0], x[2]), 0),
+                                                          -x[2], charge_priority[x[0]]))
+
+        log = []
+        if (need_radicals := expected_radicals_count - sum(radicals.values())) < 0:
+            log.append('Radical state not balanced')
+            if not allow_errors:
+                if logging:
+                    return log
+                return False
+            need_radicals = 0  # reset to zero
+
+        if unsaturated:
+            # create graph of unsaturated atoms
+            bonds_graph = {n: {m for m in adjacency[n] if m in unsaturated} for n in unsaturated}
+            order = list(unsaturated)
+            # try to saturate with different random states
+            for _ in range(len(unsaturated)):
+                shuffle(order)
+                sb, sa, log_ = _saturate({n: bonds_graph[n].copy() for n in order}, unsaturated, need_radicals,
+                                         expected_charge - sum(charges.values()))
+                if not log_:  # success
+                    break
+            else:  # failed
+                if log_ == 1:
+                    log.append('Charge state not balanced')
+                elif log_ == 2:
+                    log.append('Radical state not balanced')
+                else:
+                    log.append('Charge state not balanced')
+                    log.append('Radical state not balanced')
+                if not allow_errors:  # all attempts failed
+                    if logging:
+                        return log
+                    return False
+
+            for n, m, b in sb:
+                bonds[n][m] = bonds[m][n] = Bond(b)
+            for n, c, r in sa:
+                charges[n] = c
+                radicals[n] = r
+        elif expected_charge != sum(charges.values()):  # check charge for saturated case
+            log.append('Charge state not balanced')
+            if not allow_errors:
+                if logging:
+                    return log
+                return False
+        # reset molecule
+        self._bonds = bonds
+        self._radicals = radicals
+        self._charges = charges
+        self._hydrogens = {x: 0 for x in atoms}  # reset invalid hydrogens counts.
+        self.flush_cache()
+        if logging:
+            if not log:  # check for errors
+                log.append('Saturated successfully')
+            else:
+                log.append('Saturated with errors')
+            return log
+        return True
+
+
+def _find_possible_valences(atoms, neighbors_distances, charges, radicals, allow_deleting=True):
+    if allow_deleting:
+        possible_bonds = {n: md.copy() for n, md in neighbors_distances.items()}
+    else:
+        possible_bonds = {n: list(md) for n, md in neighbors_distances.items()}
+    while True:
+        saturation = defaultdict(set)
+        for n, env in possible_bonds.items():
+            env_atoms = None
+            el = len(env)
+            dc = charges[n]
+            dr = radicals[n]
+            for charge, is_radical, valence, implicit, explicit_dict in atoms[n]._compiled_saturation_rules:
+                if valence < el or dc is not None and dc != charge or dr is not None and dr != is_radical:
+                    continue  # skip impossible rules
+                if explicit_dict:
+                    if env_atoms is None:  # lazy caching
+                        env_atoms = defaultdict(int)
+                        for m in env:
+                            env_atoms[atoms[m].atomic_number] += 1
+                    env_atoms_copy = env_atoms.copy()
+                    for (b, a), c in explicit_dict.items():  # stage 1. find explicit valence
+                        if env_atoms_copy[a] < c:  # `c` always > 0
+                            break  # rule not matched
+                        env_atoms_copy[a] -= c
+                    else:  # stage 2. find possible valence
+                        if unmatched := sum(env_atoms_copy.values()):  # number of atoms outside rule
+                            if implicit >= unmatched:
+                                # number of implicit H should be greater or equal to number of neighbors
+                                saturation[n].add((charge, is_radical, valence - el))
+                        else:  # pattern fully matched. difference bw valence and connectivity is unsaturation.
+                            saturation[n].add((charge, is_radical, valence - el))
+                else:   # unspecific rule. found possible valence
+                    saturation[n].add((charge, is_radical, valence - el))
+            if n not in saturation:  # valence not found
+                break
+        else:  # all atoms passed
+            break
+        if allow_deleting:
+            out = max(env.items(), key=itemgetter(1))[0]
+            del possible_bonds[out][n]
+            del possible_bonds[n][out]
+        else:
+            raise ValenceError('Structure has invalid atoms neighbors count and electron states')
+    return saturation, possible_bonds
+
+
+def _saturate(bonds, atoms, expected_radicals_count, expected_charge):
+    atoms = {k: v.copy() for k, v in atoms.items()}
+    dots = []
+    saturation = []
+    electrons = []
+    while True:
+        # get isolated atoms. atoms should be charged or radical
+        to_del = []
+        for n, env in bonds.items():
+            if not env:
+                es = [(n, c, r) for c, r, h in atoms[n] if not h]
+                if not es:
+                    return  # saturation impossible
+                to_del.append(n)
+                dots.append(es)
+        for n in to_del:
+            del bonds[n]
+        if not bonds:
+            break
+
+        try:  # get terminal atom
+            n = next(n for n, ms in bonds.items() if len(ms) == 1)
+        except StopIteration:
+            # get ring or linker atom
+            n, _ = min(bonds.items(), key=lambda x: len(x[1]))
+            m = bonds[n].pop()
+            bonds[m].discard(n)
+
+            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
+                if nh == mh:
+                    saturation.append((n, m, nh + 1))
+                    electrons.append((n, nc, nr))
+                    electrons.append((m, mc, mr))
+
+                    for x in bonds.pop(n):
+                        saturation.append((n, x, 1))
+                        bonds[x].discard(n)
+                    for x in bonds.pop(m):
+                        saturation.append((m, x, 1))
+                        bonds[x].discard(m)
+                    break
+                elif nh < mh:
+                    electrons.append((n, nc, nr))
+                    saturation.append((n, m, nh + 1))
+                    atoms[m].pop(i)
+                    atoms[m].insert(i, (mc, mr, mh - nh))
+
+                    for x in bonds.pop(n):
+                        saturation.append((n, x, 1))
+                        bonds[x].discard(n)
+                    break
+                elif nh > mh:
+                    electrons.append((m, mc, mr))
+                    saturation.append((n, m, mh + 1))
+                    atoms[n].pop(i)
+                    atoms[n].insert(i, (nc, nr, nh - mh))
+
+                    for x in bonds.pop(m):
+                        saturation.append((m, x, 1))
+                        bonds[x].discard(m)
+                    break
+        else:
+            m = bonds.pop(n).pop()
+            bonds[m].discard(n)
+
+            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
+                if nh == mh:
+                    saturation.append((n, m, nh + 1))
+                    electrons.append((n, nc, nr))
+                    electrons.append((m, mc, mr))
+                    for x in bonds.pop(m):
+                        saturation.append((m, x, 1))
+                        bonds[x].discard(m)
+                    break
+                elif nh < mh and bonds[m]:
+                    electrons.append((n, nc, nr))
+                    saturation.append((n, m, nh + 1))
+                    atoms[m].pop(i)
+                    atoms[m].insert(i, (mc, mr, mh - nh))
+                    break
+            else:
+                saturation.append((n, m, 1))
+                if not bonds[m]:
+                    del bonds[m]
+
+    combo_ua = []  # possible single atoms electron states
+    for s in dots:
+        if len(s) == 1:
+            electrons.extend(s)
+        elif s:
+            combo_ua.append(s)
+
+    # if < 0 - we already in bad situation
+    # if > 0 - we need more radicals
+    need_radical = expected_radicals_count - sum(x for _, _, x in electrons)
+    need_charge = expected_charge - sum(x for _, x, _ in electrons)
+    if combo_ua:
+        # try randomly set charges and radicals.
+        # first pick required radical states.
+        # second try to minimize charge delta.
+        for attempt in range(1, len(combo_ua) + 1):
+            shuffle(combo_ua)
+            charges_radicals = []
+            rad = []
+            chg = []
+            for atom in combo_ua:
+                if len(rad) < need_radical:  # pick radicals
+                    r = next((x for x in atom if x[2]), None)
+                    if r:  # pick random radical states
+                        rad.append(r)
+                    else:  # not radical
+                        chg.append(atom)
+                else:  # pick not radical states
+                    c = [x for x in atom if not x[2]]
+                    if len(c) > 1:
+                        chg.append(c)
+                    elif c:
+                        charges_radicals.extend(c)
+                    elif attempt == len(combo_ua):  # all states has radical. balancing impossible
+                        chg.append(atom)  # fuck it horse. we in last attempt
+                    else:  # do next attempt
+                        break
+            else:
+                charges_radicals.extend(rad)
+                current_charge = need_charge - sum(x for _, x, _ in charges_radicals)
+                current_radical = need_radical - len(rad)
+                for x in chg:
+                    n, c, r = min(x, key=lambda x: abs(current_charge - x[1]))
+                    charges_radicals.append((n, c, r))
+                    current_charge -= c
+                    current_radical -= r
+
+                if current_radical:  # radical unbalanced
+                    if current_charge:
+                        log = 3
+                    else:
+                        log = 2
+                elif current_charge:
+                    log = 1
+                else:  # balanced!
+                    log = 0
+                    break
+
+        electrons.extend(charges_radicals)
+    elif need_radical:
+        log = 3 if need_charge else 2
+    elif need_charge:
+        log = 1
+    else:
+        log = 0
+    return saturation, electrons, log
+
+
+__all__ = ['Saturation']
```

### Comparing `chython-1.64/chython/algorithms/stereo/__init__.py` & `chython-1.8/chython/algorithms/stereo/__init__.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .graph import *
-from .molecule import *
-
-
-__all__ = ['MoleculeStereo', 'Stereo']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .graph import *
+from .molecule import *
+
+
+__all__ = ['MoleculeStereo', 'Stereo']
```

### Comparing `chython-1.64/chython/algorithms/stereo/graph.py` & `chython-1.8/chython/algorithms/stereo/graph.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,437 +1,435 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from functools import cached_property
-from typing import Dict, Optional, Tuple, TYPE_CHECKING, Union
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer, QueryContainer
-    Container = Union[MoleculeContainer, QueryContainer]
-
-
-_heteroatoms = {5, 6, 7, 8, 14, 15, 16, 17, 33, 34, 35, 52, 53}
-
-# 1  2
-#  \ |
-#   \|
-#    n---3
-#   /
-#  /
-# 0
-_tetrahedron_translate = {(0, 1, 2): False, (1, 2, 0): False, (2, 0, 1): False,
-                          (0, 2, 1): True, (1, 0, 2): True, (2, 1, 0): True,
-                          (0, 3, 1): False, (3, 1, 0): False, (1, 0, 3): False,
-                          (0, 1, 3): True, (1, 3, 0): True, (3, 0, 1): True,
-                          (0, 2, 3): False, (2, 3, 0): False, (3, 0, 2): False,
-                          (0, 3, 2): True, (3, 2, 0): True, (2, 0, 3): True,
-                          (1, 3, 2): False, (3, 2, 1): False, (2, 1, 3): False,
-                          (1, 2, 3): True, (2, 3, 1): True, (3, 1, 2): True}
-# 2       1
-#  \     /
-#   n---m
-#  /     \
-# 0       3
-_alkene_translate = {(0, 1): False, (1, 0): False, (0, 3): True, (3, 0): True,
-                     (2, 3): False, (3, 2): False, (2, 1): True, (1, 2): True}
-
-# allowed atoms. these atoms have stable covalent bonds.
-_organic_subset = {1, 5, 6, 7, 8, 9, 14, 15, 16, 17, 33, 34, 35, 52, 53}
-
-
-class Stereo:
-    __slots__ = ()
-
-    @cached_property
-    def cumulenes(self) -> Tuple[Tuple[int, ...], ...]:
-        """
-        Alkenes, allenes and cumulenes atoms numbers.
-        """
-        return tuple(self._cumulenes())
-
-    @cached_property
-    def tetrahedrons(self: 'Container') -> Tuple[int, ...]:
-        """
-        Carbon sp3 atoms numbers.
-        """
-        atoms = self._atoms
-        bonds = self._bonds
-        charges = self._charges
-        radicals = self._radicals
-
-        tetra = []
-        for n, atom in atoms.items():
-            if atom.atomic_number == 6 and not charges[n] and not radicals[n]:
-                env = bonds[n]
-                if all(int(x) == 1 for x in env.values()):
-                    if sum(int(x) for x in env.values()) > 4:
-                        continue
-                    tetra.append(n)
-        return tuple(tetra)
-
-    def clean_stereo(self: 'Container'):
-        """
-        Remove stereo data.
-        """
-        self._atoms_stereo.clear()
-        self._allenes_stereo.clear()
-        self._cis_trans_stereo.clear()
-        self.flush_cache()
-
-    def get_mapping(self: 'Container', other: 'Container', **kwargs):
-        atoms_stereo = self._atoms_stereo
-        allenes_stereo = self._allenes_stereo
-        cis_trans_stereo = self._cis_trans_stereo
-        if atoms_stereo or allenes_stereo or cis_trans_stereo:
-            other_atoms_stereo = other._atoms_stereo
-            other_allenes_stereo = other._allenes_stereo
-            other_cis_trans_stereo = other._cis_trans_stereo
-            other_translate_tetrahedron_sign = other._translate_tetrahedron_sign
-            other_translate_allene_sign = other._translate_allene_sign
-            other_translate_cis_trans_sign = other._translate_cis_trans_sign
-
-            tetrahedrons = self._stereo_tetrahedrons
-            cis_trans = self._stereo_cis_trans
-            allenes = self._stereo_allenes
-
-            for mapping in super().get_mapping(other, **kwargs):
-                for n, s in atoms_stereo.items():
-                    m = mapping[n]
-                    if m not in other_atoms_stereo:  # self stereo atom not stereo in other
-                        break
-                    # translate stereo mark in other in order of self tetrahedron
-                    if other_translate_tetrahedron_sign(m, [mapping[x] for x in tetrahedrons[n]]) != s:
-                        break
-                else:
-                    for n, s in allenes_stereo.items():
-                        m = mapping[n]
-                        if m not in other_allenes_stereo:  # self stereo allene not stereo in other
-                            break
-                        # translate stereo mark in other in order of self allene
-                        nn, nm, *_ = allenes[n]
-                        if other_translate_allene_sign(m, mapping[nn], mapping[nm]) != s:
-                            break
-                    else:
-                        for nm, s in cis_trans_stereo.items():
-                            n, m = nm
-                            on, om = mapping[n], mapping[m]
-                            if (on, om) not in other_cis_trans_stereo:
-                                if (om, on) not in other_cis_trans_stereo:
-                                    break  # self stereo cis_trans not stereo in other
-                                else:
-                                    nn, nm, *_ = cis_trans[nm]
-                                    if other_translate_cis_trans_sign(om, on, mapping[nm], mapping[nn]) != s:
-                                        break
-                            else:
-                                nn, nm, *_ = cis_trans[nm]
-                                if other_translate_cis_trans_sign(on, om, mapping[nn], mapping[nm]) != s:
-                                    break
-                        else:
-                            yield mapping
-        else:
-            yield from super().get_mapping(other, **kwargs)
-
-    def _translate_tetrahedron_sign(self: 'Container', n, env, s=None):
-        """
-        Get sign of chiral tetrahedron atom for specified neighbors order
-
-        :param n: stereo atom
-        :param env: neighbors order
-        :param s: if None, use existing sign else translate given to molecule
-        """
-        if s is None:
-            s = self._atoms_stereo[n]
-
-        order = self._stereo_tetrahedrons[n]
-        if len(order) == 3:
-            if len(env) == 4:  # hydrogen atom passed to env
-                atoms = self._atoms
-                # hydrogen always last in order
-                try:
-                    order = (*order, next(x for x in env if atoms[x].atomic_number == 1))  # see translate scheme
-                except StopIteration:
-                    raise KeyError
-            elif len(env) != 3:  # pyramid or tetrahedron expected
-                raise ValueError('invalid atoms list')
-        elif len(env) not in (3, 4):  # pyramid or tetrahedron expected
-            raise ValueError('invalid atoms list')
-
-        translate = tuple(order.index(x) for x in env[:3])
-        if _tetrahedron_translate[translate]:
-            return not s
-        return s
-
-    def _translate_cis_trans_sign(self: 'Container', n, m, nn, nm, s=None):
-        """
-        Get sign for specified opposite neighbors
-
-        :param n: first double bonded atom
-        :param m: last double bonded atom
-        :param nn: neighbor of first atom
-        :param nm: neighbor of last atom
-        :param s: if None, use existing sign else translate given to molecule
-        """
-        if s is None:
-            try:
-                s = self._cis_trans_stereo[(n, m)]
-            except KeyError:
-                s = self._cis_trans_stereo[(m, n)]
-                n, m = m, n  # in alkenes sign not order depended
-                nn, nm = nm, nn
-
-        atoms = self._atoms
-        n0, n1, n2, n3 = self._stereo_cis_trans[(n, m)]
-        if nn == n0:  # same start
-            t0 = 0
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n1:
-            t0 = 1
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
-            t0 = 2
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
-            t0 = 3
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        else:
-            raise KeyError
-
-        if _alkene_translate[(t0, t1)]:
-            return not s
-        return s
-
-    def _translate_allene_sign(self: 'Container', c, nn, nm, s=None):
-        """
-        get sign for specified opposite neighbors
-
-        :param c: central double bonded atom
-        :param nn: neighbor of first double bonded atom
-        :param nm: neighbor of last double bonded atom
-        :param s: if None, use existing sign else translate given to molecule
-        """
-        if s is None:
-            s = self._allenes_stereo[c]
-
-        atoms = self._atoms
-        n0, n1, n2, n3 = self._stereo_allenes[c]
-        if nn == n0:  # same start
-            t0 = 0
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n1:
-            t0 = 1
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
-            t0 = 2
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
-            t0 = 3
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        else:
-            raise KeyError
-
-        if _alkene_translate[(t0, t1)]:
-            return not s
-        return s
-
-    def _cumulenes(self: 'Container', heteroatoms=False):
-        atoms = self._atoms
-        bonds = self._bonds
-
-        adj = defaultdict(set)  # double bonds adjacency matrix
-        if heteroatoms:
-            for n, atom in atoms.items():
-                if atom.atomic_number in _heteroatoms:
-                    adj_n = adj[n].add
-                    for m, bond in bonds[n].items():
-                        if int(bond) == 2 and atoms[m].atomic_number in _heteroatoms:
-                            adj_n(m)
-        else:
-            for n, atom in atoms.items():
-                if atom.atomic_number == 6:
-                    adj_n = adj[n].add
-                    for m, bond in bonds[n].items():
-                        if int(bond) == 2 and atoms[m].atomic_number == 6:
-                            adj_n(m)
-        if not adj:
-            return ()
-
-        terminals = [x for x, y in adj.items() if len(y) == 1]
-        cumulenes = []
-        while terminals:
-            n = terminals.pop(0)
-            m = adj[n].pop()
-            path = [n, m]
-            while m not in terminals:
-                adj_m = adj[m]
-                if len(adj_m) > 2:  # not cumulene. SO3 etc.
-                    cumulenes.extend(zip(path, path[1:]))  # keep single double bonds.
-                    break
-                adj_m.discard(n)
-                n, m = m, adj_m.pop()
-                path.append(m)
-            else:
-                terminals.remove(m)
-                adj[m].pop()
-                cumulenes.append(tuple(path))
-        return cumulenes
-
-    @cached_property
-    def _stereo_cumulenes(self: 'Container') -> Dict[Tuple[int, ...], Tuple[int, int, Optional[int], Optional[int]]]:
-        """
-        Cumulenes which contains at least one non-hydrogen neighbor on both ends
-        """
-        # 5       4
-        #  \     /
-        #   2---3
-        #  /     \
-        # 1       6
-        bonds = self._bonds
-        atoms = self._atoms
-        cumulenes = {}
-        for path in self.cumulenes:
-            nf = bonds[path[0]]
-            nl = bonds[path[-1]]
-            n1, m1 = path[1], path[-2]
-            if any(b.order == 3 or atoms[m].atomic_number not in _organic_subset and b.order != 8
-                   for m, b in nf.items() if m != n1):
-                continue  # skip X=C=C structures and metal-carbon complexes
-            if any(b.order == 3 or atoms[m].atomic_number not in _organic_subset and b.order != 8
-                   for m, b in nl.items() if m != m1):
-                continue  # skip X=C=C structures and metal-carbon complexes
-            nn = [x for x, b in nf.items() if x != n1 and atoms[x].atomic_number != 1 and b.order != 8]
-            mn = [x for x, b in nl.items() if x != m1 and atoms[x].atomic_number != 1 and b.order != 8]
-            if nn and mn:
-                sn = nn[1] if len(nn) == 2 else None
-                sm = mn[1] if len(mn) == 2 else None
-                cumulenes[path] = (nn[0], mn[0], sn, sm)
-        return cumulenes
-
-    @cached_property
-    def _stereo_tetrahedrons(self: 'Container') -> Dict[int, Union[Tuple[int, int, int], Tuple[int, int, int, int]]]:
-        """
-        Tetrahedrons which contains at least 3 non-hydrogen neighbors
-        """
-        #    2
-        #    |
-        # 1--K--3
-        #    |
-        #    4?
-        atoms = self._atoms
-        bonds = self._bonds
-        tetrahedrons = {}
-        for n in self.tetrahedrons:
-            if any(atoms[x].atomic_number not in _organic_subset for x in bonds[n]):
-                continue  # skip metal-carbon complexes
-            env = tuple(x for x in bonds[n] if atoms[x].atomic_number != 1)
-            if len(env) in (3, 4):
-                tetrahedrons[n] = env
-        return tetrahedrons
-
-    @cached_property
-    def _stereo_cis_trans(self) -> Dict[Tuple[int, int], Tuple[int, int, Optional[int], Optional[int]]]:
-        """
-        Cis-trans bonds which contains at least one non-hydrogen neighbor on both ends
-        """
-        return {(n, m): env for (n, *mid, m), env in self._stereo_cumulenes.items() if not len(mid) % 2}
-
-    @cached_property
-    def _stereo_cis_trans_paths(self) -> Dict[Tuple[int, int], Tuple[int, ...]]:
-        return {(path[0], path[-1]): path for path in self._stereo_cumulenes if not len(path) % 2}
-
-    @cached_property
-    def _stereo_cis_trans_terminals(self) -> Dict[int, Tuple[int, int]]:
-        """
-        Cis-Trans terminal atoms to cis-trans key mapping
-        """
-        terminals = {}
-        for nm in self._stereo_cis_trans_paths:
-            n, m = nm
-            terminals[n] = terminals[m] = nm
-        return terminals
-
-    @cached_property
-    def _stereo_allenes(self) -> Dict[int, Tuple[int, int, Optional[int], Optional[int]]]:
-        """
-        Allenes which contains at least one non-hydrogen neighbor on both ends
-        """
-        return {path[len(path) // 2]: env for path, env in self._stereo_cumulenes.items() if len(path) % 2}
-
-    @cached_property
-    def _stereo_allenes_centers(self) -> Dict[int, int]:
-        """
-        Allene terminal atom to center mapping
-        """
-        terminals = {}
-        for c, (n, m) in self._stereo_allenes_terminals.items():
-            terminals[n] = terminals[m] = c
-        return terminals
-
-    @cached_property
-    def _stereo_allenes_terminals(self) -> Dict[int, Tuple[int, int]]:
-        """
-        Allene center atom to terminals mapping
-        """
-        return {c: (path[0], path[-1]) for c, path in self._stereo_allenes_paths.items()}
-
-    @cached_property
-    def _stereo_allenes_paths(self) -> Dict[int, Tuple[int, ...]]:
-        return {path[len(path) // 2]: path for path in self._stereo_cumulenes if len(path) % 2}
-
-
-__all__ = ['Stereo']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from functools import cached_property
+from typing import Dict, Optional, Tuple, TYPE_CHECKING, Union
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer, QueryContainer
+    Container = Union[MoleculeContainer, QueryContainer]
+
+
+_heteroatoms = {5, 6, 7, 8, 14, 15, 16, 17, 33, 34, 35, 52, 53}
+
+# 1  2
+#  \ |
+#   \|
+#    n---3
+#   /
+#  /
+# 0
+_tetrahedron_translate = {(0, 1, 2): False, (1, 2, 0): False, (2, 0, 1): False,
+                          (0, 2, 1): True, (1, 0, 2): True, (2, 1, 0): True,
+                          (0, 3, 1): False, (3, 1, 0): False, (1, 0, 3): False,
+                          (0, 1, 3): True, (1, 3, 0): True, (3, 0, 1): True,
+                          (0, 2, 3): False, (2, 3, 0): False, (3, 0, 2): False,
+                          (0, 3, 2): True, (3, 2, 0): True, (2, 0, 3): True,
+                          (1, 3, 2): False, (3, 2, 1): False, (2, 1, 3): False,
+                          (1, 2, 3): True, (2, 3, 1): True, (3, 1, 2): True}
+# 2       1
+#  \     /
+#   n---m
+#  /     \
+# 0       3
+_alkene_translate = {(0, 1): False, (1, 0): False, (0, 3): True, (3, 0): True,
+                     (2, 3): False, (3, 2): False, (2, 1): True, (1, 2): True}
+
+# allowed atoms. these atoms have stable covalent bonds.
+_organic_subset = {1, 5, 6, 7, 8, 9, 14, 15, 16, 17, 33, 34, 35, 52, 53}
+
+
+class Stereo:
+    __slots__ = ()
+
+    @cached_property
+    def cumulenes(self) -> Tuple[Tuple[int, ...], ...]:
+        """
+        Alkenes, allenes and cumulenes atoms numbers.
+        """
+        return tuple(self._cumulenes())
+
+    @cached_property
+    def tetrahedrons(self: 'Container') -> Tuple[int, ...]:
+        """
+        Carbon sp3 atoms numbers.
+        """
+        atoms = self._atoms
+        bonds = self._bonds
+        charges = self._charges
+        radicals = self._radicals
+
+        tetra = []
+        for n, atom in atoms.items():
+            if atom.atomic_number == 6 and not charges[n] and not radicals[n]:
+                env = bonds[n]
+                if all(x == 1 for x in env.values()):
+                    if sum(int(x) for x in env.values()) > 4:
+                        continue
+                    tetra.append(n)
+        return tuple(tetra)
+
+    def clean_stereo(self: 'Container'):
+        """
+        Remove stereo data.
+        """
+        self._atoms_stereo.clear()
+        self._allenes_stereo.clear()
+        self._cis_trans_stereo.clear()
+        self.flush_cache()
+
+    def get_mapping(self: 'Container', other: 'Container', **kwargs):
+        atoms_stereo = self._atoms_stereo
+        allenes_stereo = self._allenes_stereo
+        cis_trans_stereo = self._cis_trans_stereo
+        if atoms_stereo or allenes_stereo or cis_trans_stereo:
+            other_atoms_stereo = other._atoms_stereo
+            other_allenes_stereo = other._allenes_stereo
+            other_cis_trans_stereo = other._cis_trans_stereo
+            other_translate_tetrahedron_sign = other._translate_tetrahedron_sign
+            other_translate_allene_sign = other._translate_allene_sign
+            other_translate_cis_trans_sign = other._translate_cis_trans_sign
+
+            tetrahedrons = self._stereo_tetrahedrons
+            cis_trans = self._stereo_cis_trans
+            allenes = self._stereo_allenes
+
+            for mapping in super().get_mapping(other, **kwargs):
+                for n, s in atoms_stereo.items():
+                    m = mapping[n]
+                    if m not in other_atoms_stereo:  # self stereo atom not stereo in other
+                        break
+                    # translate stereo mark in other in order of self tetrahedron
+                    if other_translate_tetrahedron_sign(m, [mapping[x] for x in tetrahedrons[n]]) != s:
+                        break
+                else:
+                    for n, s in allenes_stereo.items():
+                        m = mapping[n]
+                        if m not in other_allenes_stereo:  # self stereo allene not stereo in other
+                            break
+                        # translate stereo mark in other in order of self allene
+                        nn, nm, *_ = allenes[n]
+                        if other_translate_allene_sign(m, mapping[nn], mapping[nm]) != s:
+                            break
+                    else:
+                        for nm, s in cis_trans_stereo.items():
+                            n, m = nm
+                            on, om = mapping[n], mapping[m]
+                            if (on, om) not in other_cis_trans_stereo:
+                                if (om, on) not in other_cis_trans_stereo:
+                                    break  # self stereo cis_trans not stereo in other
+                                else:
+                                    nn, nm, *_ = cis_trans[nm]
+                                    if other_translate_cis_trans_sign(om, on, mapping[nm], mapping[nn]) != s:
+                                        break
+                            else:
+                                nn, nm, *_ = cis_trans[nm]
+                                if other_translate_cis_trans_sign(on, om, mapping[nn], mapping[nm]) != s:
+                                    break
+                        else:
+                            yield mapping
+        else:
+            yield from super().get_mapping(other, **kwargs)
+
+    def _translate_tetrahedron_sign(self: 'Container', n, env, s=None):
+        """
+        Get sign of chiral tetrahedron atom for specified neighbors order
+
+        :param n: stereo atom
+        :param env: neighbors order
+        :param s: if None, use existing sign else translate given to molecule
+        """
+        if s is None:
+            s = self._atoms_stereo[n]
+
+        order = self._stereo_tetrahedrons[n]
+        if len(order) == 3:
+            if len(env) == 4:  # hydrogen atom passed to env
+                atoms = self._atoms
+                # hydrogen always last in order
+                try:
+                    order = (*order, next(x for x in env if atoms[x].atomic_number == 1))  # see translate scheme
+                except StopIteration:
+                    raise KeyError
+            elif len(env) != 3:  # pyramid or tetrahedron expected
+                raise ValueError('invalid atoms list')
+        elif len(env) not in (3, 4):  # pyramid or tetrahedron expected
+            raise ValueError('invalid atoms list')
+
+        translate = tuple(order.index(x) for x in env[:3])
+        if _tetrahedron_translate[translate]:
+            return not s
+        return s
+
+    def _translate_cis_trans_sign(self: 'Container', n, m, nn, nm, s=None):
+        """
+        Get sign for specified opposite neighbors
+
+        :param n: first double bonded atom
+        :param m: last double bonded atom
+        :param nn: neighbor of first atom
+        :param nm: neighbor of last atom
+        :param s: if None, use existing sign else translate given to molecule
+        """
+        if s is None:
+            try:
+                s = self._cis_trans_stereo[(n, m)]
+            except KeyError:
+                s = self._cis_trans_stereo[(m, n)]
+                n, m = m, n  # in alkenes sign not order depended
+                nn, nm = nm, nn
+
+        atoms = self._atoms
+        n0, n1, n2, n3 = self._stereo_cis_trans[(n, m)]
+        if nn == n0:  # same start
+            t0 = 0
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n1:
+            t0 = 1
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
+            t0 = 2
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
+            t0 = 3
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        else:
+            raise KeyError
+
+        if _alkene_translate[(t0, t1)]:
+            return not s
+        return s
+
+    def _translate_allene_sign(self: 'Container', c, nn, nm, s=None):
+        """
+        get sign for specified opposite neighbors
+
+        :param c: central double bonded atom
+        :param nn: neighbor of first double bonded atom
+        :param nm: neighbor of last double bonded atom
+        :param s: if None, use existing sign else translate given to molecule
+        """
+        if s is None:
+            s = self._allenes_stereo[c]
+
+        atoms = self._atoms
+        n0, n1, n2, n3 = self._stereo_allenes[c]
+        if nn == n0:  # same start
+            t0 = 0
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n1:
+            t0 = 1
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
+            t0 = 2
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
+            t0 = 3
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        else:
+            raise KeyError
+
+        if _alkene_translate[(t0, t1)]:
+            return not s
+        return s
+
+    def _cumulenes(self: 'Container', heteroatoms=False):
+        atoms = self._atoms
+        bonds = self._bonds
+
+        adj = defaultdict(set)  # double bonds adjacency matrix
+        if heteroatoms:
+            for n, atom in atoms.items():
+                if atom.atomic_number in _heteroatoms:
+                    adj_n = adj[n].add
+                    for m, bond in bonds[n].items():
+                        if bond == 2 and atoms[m].atomic_number in _heteroatoms:
+                            adj_n(m)
+        else:
+            for n, atom in atoms.items():
+                if atom.atomic_number == 6:
+                    adj_n = adj[n].add
+                    for m, bond in bonds[n].items():
+                        if bond == 2 and atoms[m].atomic_number == 6:
+                            adj_n(m)
+        if not adj:
+            return ()
+
+        terminals = [x for x, y in adj.items() if len(y) == 1]
+        cumulenes = []
+        while terminals:
+            n = terminals.pop(0)
+            m = adj[n].pop()
+            path = [n, m]
+            while m not in terminals:
+                adj_m = adj[m]
+                if len(adj_m) > 2:  # not cumulene. SO3 etc.
+                    cumulenes.extend(zip(path, path[1:]))  # keep single double bonds.
+                    break
+                adj_m.discard(n)
+                n, m = m, adj_m.pop()
+                path.append(m)
+            else:
+                terminals.remove(m)
+                adj[m].pop()
+                cumulenes.append(tuple(path))
+        return cumulenes
+
+    @cached_property
+    def _stereo_cumulenes(self: 'Container') -> Dict[Tuple[int, ...], Tuple[int, int, Optional[int], Optional[int]]]:
+        """
+        Cumulenes which contains at least one non-hydrogen neighbor on both ends
+        """
+        # 5       4
+        #  \     /
+        #   2---3
+        #  /     \
+        # 1       6
+        bonds = self._bonds
+        atoms = self._atoms
+        cumulenes = {}
+        for path in self.cumulenes:
+            nf = bonds[path[0]]
+            nl = bonds[path[-1]]
+            n1, m1 = path[1], path[-2]
+            if any(b not in (1, 4) and atoms[m].atomic_number not in _organic_subset for m, b in nf.items() if m != n1)\
+                    or any(b not in (1, 4) and atoms[m].atomic_number not in _organic_subset
+                           for m, b in nl.items() if m != m1):
+                continue  # skip X=C=C structures and metal-carbon complexes
+            nn = [x for x in nf if x != n1 and atoms[x].atomic_number != 1]
+            mn = [x for x in nl if x != m1 and atoms[x].atomic_number != 1]
+            if nn and mn:
+                sn = nn[1] if len(nn) == 2 else None
+                sm = mn[1] if len(mn) == 2 else None
+                cumulenes[path] = (nn[0], mn[0], sn, sm)
+        return cumulenes
+
+    @cached_property
+    def _stereo_tetrahedrons(self: 'Container') -> Dict[int, Union[Tuple[int, int, int], Tuple[int, int, int, int]]]:
+        """
+        Tetrahedrons which contains at least 3 non-hydrogen neighbors
+        """
+        #    2
+        #    |
+        # 1--K--3
+        #    |
+        #    4?
+        atoms = self._atoms
+        bonds = self._bonds
+        tetrahedrons = {}
+        for n in self.tetrahedrons:
+            if any(atoms[x].atomic_number not in _organic_subset for x in bonds[n]):
+                continue  # skip metal-carbon complexes
+            env = tuple(x for x in bonds[n] if atoms[x].atomic_number != 1)
+            if len(env) in (3, 4):
+                tetrahedrons[n] = env
+        return tetrahedrons
+
+    @cached_property
+    def _stereo_cis_trans(self) -> Dict[Tuple[int, int], Tuple[int, int, Optional[int], Optional[int]]]:
+        """
+        Cis-trans bonds which contains at least one non-hydrogen neighbor on both ends
+        """
+        return {(n, m): env for (n, *mid, m), env in self._stereo_cumulenes.items() if not len(mid) % 2}
+
+    @cached_property
+    def _stereo_cis_trans_paths(self) -> Dict[Tuple[int, int], Tuple[int, ...]]:
+        return {(path[0], path[-1]): path for path in self._stereo_cumulenes if not len(path) % 2}
+
+    @cached_property
+    def _stereo_cis_trans_terminals(self) -> Dict[int, Tuple[int, int]]:
+        """
+        Cis-Trans terminal atoms to cis-trans key mapping
+        """
+        terminals = {}
+        for nm in self._stereo_cis_trans_paths:
+            n, m = nm
+            terminals[n] = terminals[m] = nm
+        return terminals
+
+    @cached_property
+    def _stereo_allenes(self) -> Dict[int, Tuple[int, int, Optional[int], Optional[int]]]:
+        """
+        Allenes which contains at least one non-hydrogen neighbor on both ends
+        """
+        return {path[len(path) // 2]: env for path, env in self._stereo_cumulenes.items() if len(path) % 2}
+
+    @cached_property
+    def _stereo_allenes_centers(self) -> Dict[int, int]:
+        """
+        Allene terminal atom to center mapping
+        """
+        terminals = {}
+        for c, (n, m) in self._stereo_allenes_terminals.items():
+            terminals[n] = terminals[m] = c
+        return terminals
+
+    @cached_property
+    def _stereo_allenes_terminals(self) -> Dict[int, Tuple[int, int]]:
+        """
+        Allene center atom to terminals mapping
+        """
+        return {c: (path[0], path[-1]) for c, path in self._stereo_allenes_paths.items()}
+
+    @cached_property
+    def _stereo_allenes_paths(self) -> Dict[int, Tuple[int, ...]]:
+        return {path[len(path) // 2]: path for path in self._stereo_cumulenes if len(path) % 2}
+
+
+__all__ = ['Stereo']
```

### Comparing `chython-1.64/chython/algorithms/stereo/molecule.py` & `chython-1.8/chython/algorithms/stereo/molecule.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,822 +1,754 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from functools import cached_property
-from itertools import combinations, product
-from logging import getLogger, INFO
-from typing import Dict, Set, Tuple, Union, TYPE_CHECKING
-from .graph import Stereo
-from ..morgan import _morgan
-from ...exceptions import AtomNotFound, IsChiral, NotChiral
-
-
-logger = getLogger('chython.stereo')
-logger.setLevel(INFO)
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-
-def _pyramid_sign(n, u, v, w):
-    #
-    #  |   n /
-    #  |   |\
-    #  |   | \
-    #  |  /|  \
-    #  | / u---v
-    #  |/___\_/___
-    #        w
-    #
-    nx, ny, nz = n
-    ux, uy, uz = u
-    vx, vy, vz = v
-    wx, wy, wz = w
-
-    q1x = ux - nx
-    q1y = uy - ny
-    q1z = uz - nz
-    q2x = vx - nx
-    q2y = vy - ny
-    q2z = vz - nz
-    q3x = wx - nx
-    q3y = wy - ny
-    q3z = wz - nz
-
-    vol = q1x * (q2y * q3z - q2z * q3y) + q1y * (q2z * q3x - q2x * q3z) + q1z * (q2x * q3y - q2y * q3x)
-    if vol > 0:
-        return 1
-    elif vol < 0:
-        return -1
-    return 0
-
-
-def _cis_trans_sign(n, u, v, w):
-    # n      w
-    #  \    /
-    #   u--v
-    #  /    \
-    # x      x
-    nx, ny = n
-    ux, uy = u
-    vx, vy = v
-    wx, wy = w
-
-    q1x = ux - nx
-    q1y = uy - ny
-    q2x = vx - ux
-    q2y = vy - uy
-    q3x = wx - vx
-    q3y = wy - vy
-
-    # cross vectors
-    q1q2z = q1x * q2y - q1y * q2x
-    q2q3z = q2x * q3y - q2y * q3x
-
-    dot = q1q2z * q2q3z
-    if dot > 0:
-        return 1
-    elif dot < 0:
-        return -1
-    return 0
-
-
-def _allene_sign(n, u, v, w):
-    # n    w
-    # |   /
-    # u--v
-    nx, ny, nz = n
-    ux, uy = u
-    vx, vy = v
-    wx, wy, wz = w
-
-    q1x = ux - nx
-    q1y = uy - ny
-    q1z = -nz
-    q2x = vx - ux
-    q2y = vy - uy
-    q3x = wx - vx
-    q3y = wy - vy
-    q3z = wz
-
-    # cross vectors
-    q1q2x = -q1z * q2y
-    q1q2y = q1z * q2x
-    q1q2z = q1x * q2y - q1y * q2x
-    q2q3x = q2y * q3z
-    q2q3y = -q2x * q3z
-    q2q3z = q2x * q3y - q2y * q3x
-
-    q1q2q3x = q1q2y * q2q3z - q1q2z * q2q3y
-    q1q2q3y = q1q2z * q2q3x - q1q2x * q2q3z
-
-    dot = q1q2q3x * q2x + q1q2q3y * q2y
-    if dot > 0:
-        return 1
-    elif dot < 0:
-        return -1
-    return 0
-
-
-class MoleculeStereo(Stereo):
-    __slots__ = ()
-
-    def add_wedge(self: 'MoleculeContainer', n: int, m: int, mark: bool, *, clean_cache=True):
-        """
-        Add stereo data by wedge notation of bonds. Use it for tetrahedrons of allenes.
-
-        :param n: number of atom from which wedge bond started
-        :param m: number of atom to which wedge bond coming
-        :param mark: up bond is True, down is False
-        """
-        if n not in self._atoms:
-            raise AtomNotFound
-        if n in self._atoms_stereo:
-            raise IsChiral
-
-        plane = self._plane
-        if n in self._chiral_tetrahedrons:
-            if m not in self._bonds[n]:
-                raise AtomNotFound
-            th = self._stereo_tetrahedrons[n]
-            if self._atoms[m].atomic_number == 1:
-                s = _pyramid_sign((*plane[m], mark), *((*plane[x], 0) for x in th))
-            else:
-                order = [(*plane[x], mark if x == m else 0) for x in th]
-                if len(order) == 3:
-                    if len(self._bonds[n]) == 4:  # explicit hydrogen
-                        x = next(x for x in self._bonds[n] if x not in th)
-                        s = _pyramid_sign((*plane[x], 0), *order)
-                    else:
-                        s = _pyramid_sign((*plane[n], 0), *order)
-                else:
-                    s = _pyramid_sign(order[-1], *order[:3])
-            if s:
-                self._atoms_stereo[n] = s > 0
-                if clean_cache:
-                    self.flush_cache()
-        else:
-            c = self._stereo_allenes_centers.get(n)
-            if c:
-                if c in self._allenes_stereo:
-                    raise IsChiral
-                elif c not in self._chiral_allenes:
-                    raise NotChiral
-
-                t1, t2 = self._stereo_allenes_terminals[c]
-                order = self._stereo_allenes[c]
-                if self._atoms[m].atomic_number == 1:
-                    if t1 == n:
-                        m1 = order[1]
-                    else:
-                        t1, t2 = t2, t1
-                        m1 = order[0]
-                    r = True
-                else:
-                    w = order.index(m)
-                    if w == 0:
-                        m1 = order[1]
-                        r = False
-                    elif w == 1:
-                        m1 = order[0]
-                        t1, t2 = t2, t1
-                        r = False
-                    elif w == 2:
-                        m1 = order[1]
-                        r = True
-                    else:
-                        m1 = order[0]
-                        t1, t2 = t2, t1
-                        r = True
-                s = _allene_sign((*plane[m], mark), plane[t1], plane[t2], (*plane[m1], 0))
-                if s:
-                    self._allenes_stereo[c] = s < 0 if r else s > 0
-                    if clean_cache:
-                        self.flush_cache()
-            else:
-                # only tetrahedrons and allenes supported
-                raise NotChiral
-
-    def calculate_cis_trans_from_2d(self: 'MoleculeContainer', *, clean_cache=True):
-        """
-        Calculate cis-trans stereo bonds from given 2d coordinates. Unusable for SMILES and INCHI.
-        """
-        cis_trans_stereo = self._cis_trans_stereo
-        plane = self._plane
-        flag = False
-        while self._chiral_cis_trans:
-            stereo = {}
-            for nm in self._chiral_cis_trans:
-                n, m = nm
-                n1, m1, *_ = self._stereo_cis_trans[nm]
-                s = _cis_trans_sign(plane[n1], plane[n], plane[m], plane[m1])
-                if s:
-                    stereo[nm] = s > 0
-            if stereo:
-                cis_trans_stereo.update(stereo)
-                flag = True
-                self.flush_stereo_cache()
-            else:
-                break
-        if flag and clean_cache:
-            self.flush_cache()
-
-    def add_atom_stereo(self: 'MoleculeContainer', n: int, env: Tuple[int, ...], mark: bool, *, clean_cache=True):
-        """
-        Add stereo data for specified neighbors bypass. Use it for tetrahedrons or allenes.
-
-        :param n: number of tetrahedron atom or central atom of allene.
-        :param env: numbers of atoms with specified bypass
-        :param mark: clockwise or anti bypass.
-
-        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html>
-        """
-        if n not in self._atoms:
-            raise AtomNotFound
-        if n in self._atoms_stereo or n in self._allenes_stereo:
-            raise IsChiral
-        if not isinstance(mark, bool):
-            raise TypeError('stereo mark should be bool')
-
-        if n in self._chiral_tetrahedrons:
-            self._atoms_stereo[n] = self._translate_tetrahedron_sign(n, env, mark)
-            if clean_cache:
-                self.flush_cache()
-        elif n in self._chiral_allenes:
-            self._allenes_stereo[n] = self._translate_allene_sign(n, *env, mark)
-            if clean_cache:
-                self.flush_cache()
-        else:  # only tetrahedrons supported
-            raise NotChiral
-
-    def add_cis_trans_stereo(self: 'MoleculeContainer', n: int, m: int, n1: int, n2: int, mark: bool, *,
-                             clean_cache=True):
-        """
-        Add stereo data to cis-trans double bonds (not allenes).
-
-        n1/n=m/n2
-
-        :param n: number of starting atom of double bonds chain (alkenes of cumulenes)
-        :param m: number of ending atom of double bonds chain (alkenes of cumulenes)
-        :param n1: number of neighboring atom of starting atom
-        :param n2: number of neighboring atom of ending atom
-        :param mark: cis or trans
-
-        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html
-        """
-        atoms = self._atoms
-        if n not in atoms or m not in atoms or n1 not in atoms or n2 not in atoms:
-            raise AtomNotFound
-        if not isinstance(mark, bool):
-            raise TypeError('stereo mark should be bool')
-        if (n, m) in self._cis_trans_stereo or (m, n) in self._cis_trans_stereo:
-            raise IsChiral
-
-        if (n, m) in self._chiral_cis_trans:
-            self._cis_trans_stereo[(n, m)] = self._translate_cis_trans_sign(n, m, n1, n2, mark)
-            if clean_cache:
-                self.flush_cache()
-        elif (m, n) in self._chiral_cis_trans:
-            self._cis_trans_stereo[(m, n)] = self._translate_cis_trans_sign(m, n, n2, n1, mark)
-            if clean_cache:
-                self.flush_cache()
-        else:
-            raise NotChiral
-
-    def flush_stereo_cache(self):
-        """
-        Flush chiral morgan and chiral centers cache.
-        """
-        self.__dict__.pop('_chiral_morgan', None)
-        self.__dict__.pop('_MoleculeStereo__chiral_centers', None)
-
-    def fix_stereo(self: 'MoleculeContainer'):
-        """
-        Reset stereo marks.
-        """
-        if self._atoms_stereo:  # filter tetrahedrons
-            stereo_tetrahedrons = self._stereo_tetrahedrons
-            atoms_stereo = {k: v for k, v in self._atoms_stereo.items() if k in stereo_tetrahedrons}
-            self._atoms_stereo = self_atoms_stereo = {}
-        else:
-            atoms_stereo = {}
-
-        if self._allenes_stereo:  # filter allenes
-            stereo_allenes = self._stereo_allenes
-            allenes_stereo = {k: v for k, v in self._allenes_stereo.items() if k in stereo_allenes}
-            self._allenes_stereo = self_allenes_stereo = {}
-        else:
-            allenes_stereo = {}
-
-        if self._cis_trans_stereo:  # filter cis-trans
-            stereo_cis_trans = self._stereo_cis_trans
-            cis_trans_stereo = {k: v for k, v in self._cis_trans_stereo.items() if k in stereo_cis_trans}
-            self._cis_trans_stereo = self_stereo_cis_trans = {}
-        else:
-            cis_trans_stereo = {}
-
-        old_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
-        while old_stereo:
-            chiral_tetrahedrons = self._chiral_tetrahedrons
-            chiral_allenes = self._chiral_allenes
-            chiral_cis_trans = self._chiral_cis_trans
-
-            tmp = {}
-            for n, s in atoms_stereo.items():
-                if n in chiral_tetrahedrons:
-                    self_atoms_stereo[n] = s
-                else:
-                    tmp[n] = s
-            atoms_stereo = tmp
-
-            tmp = {}
-            for n, s in allenes_stereo.items():
-                if n in chiral_allenes:
-                    self_allenes_stereo[n] = s
-                else:
-                    tmp[n] = s
-            allenes_stereo = tmp
-
-            tmp = {}
-            for n, s in cis_trans_stereo.items():
-                if n in chiral_cis_trans:
-                    self_stereo_cis_trans[n] = s
-                else:
-                    tmp[n] = s
-            cis_trans_stereo = tmp
-
-            fail_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
-            if fail_stereo == old_stereo:
-                break
-            old_stereo = fail_stereo
-            self.flush_stereo_cache()
-
-    @cached_property
-    def _wedge_map(self: Union['MoleculeContainer', 'MoleculeStereo']):
-        atoms_stereo = self._atoms_stereo
-        allenes_centers = self._stereo_allenes_centers
-        atoms = self._atoms
-
-        space = []
-        solved = []
-        seen = set()
-        for n, s in self._allenes_stereo.items():
-            env = self._stereo_allenes[n]
-            term = self._stereo_allenes_terminals[n]
-            orders = [(*env[:2], *term, n, True), (*env[1::-1], *term[::-1], n, True)]
-            if env[2]:
-                orders.append((env[2], env[1], *term, n, True))
-            if env[3]:
-                orders.append((env[3], env[0], *term[::-1], n, True))
-            space.append(orders)
-        for n, s in self._atoms_stereo.items():
-            order = list(self._stereo_tetrahedrons[n])
-            orders = [(*order, n, False)]
-            for _ in range(1, len(order)):
-                order = order.copy()
-                order.append(order.pop(0))
-                orders.append((*order, n, False))
-            space.append(orders)
-
-        while space:
-            ls = len(space)
-            unsolved = []
-            for orders in space:
-                good = []
-                if orders[0][-1]:
-                    for x in orders:
-                        if (x0 := x[0]) in seen or x0 not in atoms_stereo and x0 not in allenes_centers:
-                            good.append(x)
-                            seen.add(x[2])
-                    if good:
-                        solved.append(max(good, key=lambda x: (atoms[x[0]].in_ring, atoms[x[0]].atomic_number)))
-                    else:
-                        unsolved.append(orders)
-                else:
-                    for x in orders:
-                        if (x0 := x[0]) in seen or x0 not in atoms_stereo and x0 not in allenes_centers:
-                            good.append(x)
-                    if good:
-                        seen.add(x[-2])
-                        solved.append(max(good, key=lambda x: (atoms[x[0]].in_ring, atoms[x[0]].atomic_number)))
-                    else:
-                        unsolved.append(orders)
-            space = unsolved
-            if len(unsolved) == ls:
-                break
-
-        solved = [y for x in solved if (y := self.__wedge_sign(x))]
-        if not space:
-            return solved
-
-        for orders in product(*space):
-            used = set()
-            wedge = []
-            for order in orders:
-                if order[-1]:  # allene
-                    if (order[0], order[2]) in used:
-                        break
-                    used.add((order[2], order[0]))
-                    wedge.append(self.__wedge_sign(order))
-                else:  # TH
-                    n = order[-2]
-                    if (order[0], n) in used:
-                        break
-                    used.add((n, order[0]))
-                    wedge.append(self.__wedge_sign(order))
-            else:  # found
-                solved.extend(wedge)
-                return solved
-        logger.info('wedge stereo mapping failed')
-        return solved
-
-    def __wedge_sign(self: 'MoleculeContainer', order):
-        plane = self._plane
-
-        if order[-1]:  # allene
-            s = self._translate_allene_sign(order[-2], *order[:2])
-            v = _allene_sign((*plane[order[0]], 1), plane[order[2]], plane[order[3]], (*plane[order[1]], 0))
-            if not v:
-                logger.info(f'need 2d clean. allenes wedge stereo ambiguous for atom {order[-2]}')
-            if s:
-                return order[2], order[0], v
-            else:
-                return order[2], order[0], -v
-        else:  # TH
-            n = order[-2]
-            s = self._translate_tetrahedron_sign(n, order[:-2])
-            # need recalculation if XY changed
-            if len(order) == 5:
-                v = _pyramid_sign((*plane[n], 0),
-                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
-            else:
-                v = _pyramid_sign((*plane[order[3]], 0),
-                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
-            if not v:
-                logger.info(f'need 2d clean. tetrahedron wedge stereo ambiguous for atom {n}')
-            if s:
-                return n, order[0], v
-            else:
-                return n, order[0], -v
-
-    @property
-    def _chiral_tetrahedrons(self) -> Set[int]:
-        return self.__chiral_centers[0]
-
-    @property
-    def _chiral_cis_trans(self) -> Set[Tuple[int, int]]:
-        return self.__chiral_centers[1]
-
-    @property
-    def _chiral_allenes(self) -> Set[int]:
-        return self.__chiral_centers[2]
-
-    @cached_property
-    def _chiral_morgan(self: Union['MoleculeContainer', 'MoleculeStereo']) -> Dict[int, int]:
-        if not self._atoms_stereo and not self._allenes_stereo and not self._cis_trans_stereo:
-            return self.atoms_order
-        morgan = self.atoms_order.copy()
-        atoms_stereo = set(self._atoms_stereo)
-        cis_trans_stereo = set(self._cis_trans_stereo)
-        allenes_stereo = set(self._allenes_stereo)
-        while True:
-            # try iteratively differentiate stereo atoms.
-            morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups = \
-                self.__differentiation(morgan, atoms_stereo, cis_trans_stereo, allenes_stereo)
-            if not atoms_groups and not cis_trans_groups and not allenes_groups:
-                break
-            # for some rings differentiation by morgan impossible. try randomly set new weights.
-            # sometimes this will lead to pseudo chiral centers and non-unique morgan.
-            for group in atoms_groups:
-                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
-                    morgan[n] = -morgan[n]
-            for group in cis_trans_groups:
-                for n, _ in group[:len(group) // 2]:  # set new weight in half of group randomly.
-                    morgan[n] = -morgan[n]
-            for group in allenes_groups:
-                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
-                    morgan[n] = -morgan[n]
-            morgan = _morgan(morgan, self.int_adjacency)
-        return morgan
-
-    @cached_property
-    def _rings_tetrahedrons_linkers(self: 'MoleculeContainer') -> Dict[int, Tuple[int, int, int, int]]:
-        """
-        Ring-linkers tetrahedrons.
-
-        Values are neighbors in first and second rings.
-        """
-        out = {}
-        tetrahedrons = self._stereo_tetrahedrons
-        for n, r in self.atoms_rings.items():
-            if n in tetrahedrons:
-                for nr, mr in combinations(r, 2):
-                    if len(set(nr).intersection(mr)) == 1:
-                        ni = nr.index(n)
-                        mi = mr.index(n)
-                        out[n] = (nr[ni - 1], nr[ni - len(nr) + 1], mr[mi - 1], mr[mi - len(mr) + 1])
-                        break
-        return out
-
-    @cached_property
-    def _rings_tetrahedrons(self: 'MoleculeContainer') -> Dict[int, Union[Tuple[int, int], Tuple[int], Tuple]]:
-        """
-        Tetrahedrons in rings, except ring-linkers.
-
-        Values are out of ring atoms.
-        """
-        out = {}
-        atoms_rings = self.atoms_rings
-        tetrahedrons = self._stereo_tetrahedrons
-        points = self._rings_tetrahedrons_linkers
-        environment = self.not_special_connectivity
-        for n, r in atoms_rings.items():
-            if n in tetrahedrons and n not in points:
-                out[n] = tuple(environment[n].difference(atoms_rings))
-        return out
-
-    @cached_property
-    def _rings_cumulenes_linkers(self: 'MoleculeContainer') -> Dict[Tuple[int, int], Tuple[int, int, int, int]]:
-        """
-        Ring-linkers cumulenes except chords.
-
-        Values are neighbors in first and second rings.
-        """
-        out = {}
-        ar = self.atoms_rings
-        chord = self._rings_cumulenes
-        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
-            if n in ar and m in ar and (n, m) not in chord:
-                out[(n, m)] = (n1, n2, m1, m2)
-        return out
-
-    @cached_property
-    def _rings_cumulenes(self: 'MoleculeContainer') -> Set[Tuple[int, int]]:
-        """
-        Cumulenes in rings always chiral.
-        """
-        out = set()
-        ar = self.atoms_rings
-        for n, *_, m in self._stereo_cumulenes:
-            if n in ar and m in ar and not set(ar[n]).isdisjoint(ar[m]):
-                out.add((n, m))
-        return out
-
-    @cached_property
-    def _rings_cumulenes_attached(self: 'MoleculeContainer') -> Dict[Tuple[int, int],
-                                                                     Union[Tuple[int, int], Tuple[int]]]:
-        """
-        Cumulenes attached to rings.
-
-        Values are out of ring atoms.
-        """
-        ar = self.atoms_rings
-        out = {}
-        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
-            if n in ar:
-                if m in ar:
-                    continue
-                if m2:
-                    out[(n, m)] = (m1, m2)
-                else:
-                    out[(n, m)] = (m1,)
-            elif m in ar:
-                if n2:
-                    out[(n, m)] = (n1, n2)
-                else:
-                    out[(n, m)] = (n1,)
-        return out
-
-    @cached_property
-    def __chiral_centers(self: Union['MoleculeStereo', 'MoleculeContainer']):
-        atoms_rings = self.atoms_rings
-        tetrahedrons = self._stereo_tetrahedrons
-        cis_trans = self._stereo_cis_trans
-        allenes_centers = self._stereo_allenes_centers
-        cis_trans_terminals = self._stereo_cis_trans_terminals
-        morgan = self._chiral_morgan
-
-        # find new chiral atoms and bonds.
-        # tetrahedron is chiral if all its neighbors are unique.
-        chiral_t = {n for n, env in tetrahedrons.items() if len({morgan[x] for x in env}) == len(env)}
-        # tetrahedrons-linkers is chiral if in each rings neighbors are unique.
-        chiral_t.update(n for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items()
-                        if morgan[n1] != morgan[n2] and morgan[m1] != morgan[m2])
-
-        # required for axes detection.
-        graph = {}
-        stereogenic = set()
-        pseudo = {}
-
-        # double bond is chiral if neighbors of each terminal atom is unique.
-        # ring-linkers and rings-attached also takes into account.
-        chiral_c = set()
-        chiral_a = set()
-        for path, (n1, m1, n2, m2) in self._stereo_cumulenes.items():
-            if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
-                n, m = path[0], path[-1]
-                if len(path) % 2:
-                    chiral_a.add(path[len(path) // 2])
-                else:
-                    chiral_c.add((n, m))
-                stereogenic.add(n)
-                stereogenic.add(m)
-        # ring cumulenes always chiral. can be already added.
-        for nm in self._rings_cumulenes:
-            n, m = nm
-            if any(len(x) < 8 for x in atoms_rings[n]):  # skip small rings.
-                if nm in chiral_c:  # remove already added small rings cumulenes.
-                    chiral_c.discard(nm)
-                elif n in allenes_centers and (c := allenes_centers[n]) in chiral_a:
-                    chiral_a.discard(c)
-                continue
-            elif nm in cis_trans:
-                chiral_c.add(nm)
-            else:
-                chiral_a.add(allenes_centers[n])
-            pseudo[m] = n
-            graph[n] = set()
-            stereogenic.add(n)
-
-        # find chiral axes. build graph of stereogenic atoms in rings.
-        # atoms connected then located in same ring or cumulene.
-        for n, env in self._rings_tetrahedrons.items():
-            if len(env) == 2:  # one or zero non-ring neighbors stereogenic.
-                n1, n2 = env
-                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
-                    continue
-            graph[n] = set()
-            stereogenic.add(n)  # non-linker tetrahedrons in rings - stereogenic.
-        for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items():
-            graph[n] = set()
-            if morgan[n1] != morgan[n2] or morgan[m1] != morgan[m2]:
-                stereogenic.add(n)  # linkers with at least one unsymmetric ring.
-        for n, m in self._rings_cumulenes_linkers:
-            graph[n] = {m}
-            graph[m] = {n}
-            # stereogenic atoms already found.
-        for (n, m), env in self._rings_cumulenes_attached.items():
-            if len(env) == 2:
-                n1, n2 = env
-                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
-                    continue
-            if n in atoms_rings:
-                graph[n] = set()  # non ring endpoints not required.
-                stereogenic.add(n)  # mark as stereogenic
-            else:
-                graph[m] = set()
-                stereogenic.add(m)
-
-        if len(graph) > 1:  # add bonds to graph. bonds connects atoms in same rings and terminal atoms of cumulenes.
-            for n, ms in graph.items():
-                for r in atoms_rings[n]:
-                    for m in r:
-                        if n == m:
-                            continue
-                        elif m in graph:
-                            ms.add(m)
-                        elif m in pseudo and (m := pseudo[m]) != n:
-                            ms.add(m)
-            # remove not stereogenic terminals.
-            while True:
-                try:
-                    n = next(n for n, ms in graph.items() if not ms or len(ms) == 1 and n not in stereogenic)
-                except StopIteration:
-                    break
-                for m in graph.pop(n):
-                    graph[m].discard(n)
-            # update chiral atoms.
-            for n in graph:
-                if n in tetrahedrons:
-                    chiral_t.add(n)
-                elif n in allenes_centers:
-                    chiral_a.add(allenes_centers[n])
-                else:
-                    chiral_c.add(cis_trans_terminals[n])
-
-        # skip already marked.
-        chiral_t.difference_update(self._atoms_stereo)
-        chiral_a.difference_update(self._allenes_stereo)
-        chiral_c.difference_update(self._cis_trans_stereo)
-        return chiral_t, chiral_c, chiral_a
-
-    def __differentiation(self: Union['MoleculeStereo', 'MoleculeContainer'], morgan,
-                          atoms_stereo, cis_trans_stereo, allenes_stereo):
-        bonds = self.int_adjacency
-
-        tetrahedrons = self._stereo_tetrahedrons
-        cis_trans = self._stereo_cis_trans
-        allenes = self._stereo_allenes
-
-        translate_tetrahedron = self._translate_tetrahedron_sign
-        translate_cis_trans = self._translate_cis_trans_sign
-        translate_allene = self._translate_allene_sign
-
-        while True:
-            morgan_update = {}
-            atoms_groups = []
-            cis_trans_groups = []
-            allenes_groups = []
-            # recalculate morgan weights with taking into account existing stereo marks.
-            if atoms_stereo:
-                grouped_stereo = defaultdict(list)
-                for n in atoms_stereo:
-                    grouped_stereo[morgan[n]].append(n)  # collect equal stereo atoms.
-                for group in grouped_stereo.values():
-                    if not len(group) % 2:  # only even number of equal stereo atoms give new stereo center.
-                        # process only truly stereogenic.
-                        if len(env := tetrahedrons[group[0]]) == len({morgan[x] for x in env}):
-                            s = [n for n in group if translate_tetrahedron(n, sorted(tetrahedrons[n], key=morgan.get))]
-                            if 0 < len(s) < len(group):  # RS pair required.
-                                for m in s:
-                                    morgan_update[m] = -morgan[m]
-                            for n in group:  # prevent checks repeating.
-                                atoms_stereo.discard(n)
-                        else:  # stereo group in rings. unambiguous environment order impossible.
-                            atoms_groups.append(group)
-
-            if cis_trans_stereo:
-                grouped_stereo = defaultdict(list)
-                for nm in cis_trans_stereo:
-                    n, m = nm
-                    if (mn := morgan[n]) <= (mm := morgan[m]):
-                        grouped_stereo[mn].append((n, nm))
-                    else:
-                        grouped_stereo[mm].append((m, nm))
-                for group in grouped_stereo.values():
-                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
-                        n1, m1, n2, m2 = cis_trans[group[0][1]]
-                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
-                            s = []
-                            for x, nm in group:
-                                n, m = nm
-                                n1, m1, n2, m2 = cis_trans[nm]
-                                if n2 is None:
-                                    a = n1
-                                else:
-                                    a = min(n1, n2, key=morgan.get)
-                                if m2 is None:
-                                    b = m1
-                                else:
-                                    b = min(m1, m2, key=morgan.get)
-                                if translate_cis_trans(n, m, a, b):
-                                    s.append(x)
-                            if 0 < len(s) < len(group):  # RS pair required.
-                                for n in s:
-                                    morgan_update[n] = -morgan[n]
-                                for _, nm in group:
-                                    cis_trans_stereo.discard(nm)
-                        else:
-                            cis_trans_groups.append(group)
-
-            if allenes_stereo:
-                grouped_stereo = defaultdict(list)
-                for c in allenes_stereo:
-                    grouped_stereo[morgan[c]].append(c)
-                for group in grouped_stereo.values():
-                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
-                        n1, m1, n2, m2 = allenes[group[0]]
-                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
-                            s = []
-                            for c in group:
-                                n1, m1, n2, m2 = allenes[c]
-                                if n2 is None:
-                                    a = n1
-                                else:
-                                    a = min(n1, n2, key=morgan.get)
-                                if m2 is None:
-                                    b = m1
-                                else:
-                                    b = min(m1, m2, key=morgan.get)
-                                if translate_allene(c, a, b):
-                                    s.append(c)
-                            if 0 < len(s) < len(group):  # RS pair required.
-                                for c in s:
-                                    morgan_update[c] = -morgan[c]
-                                for c in group:
-                                    allenes_stereo.discard(c)
-                        else:
-                            allenes_groups.append(group)
-            if not morgan_update:
-                break
-            morgan = _morgan({**morgan, **morgan_update}, bonds)
-        return morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups
-
-
-__all__ = ['MoleculeStereo']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from functools import cached_property
+from itertools import combinations
+from logging import info
+from typing import Dict, Set, Tuple, Union, TYPE_CHECKING
+from .graph import Stereo
+from ..morgan import _morgan
+from ...exceptions import AtomNotFound, IsChiral, NotChiral
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+
+def _pyramid_sign(n, u, v, w):
+    #
+    #  |   n /
+    #  |   |\
+    #  |   | \
+    #  |  /|  \
+    #  | / u---v
+    #  |/___\_/___
+    #        w
+    #
+    nx, ny, nz = n
+    ux, uy, uz = u
+    vx, vy, vz = v
+    wx, wy, wz = w
+
+    q1x = ux - nx
+    q1y = uy - ny
+    q1z = uz - nz
+    q2x = vx - nx
+    q2y = vy - ny
+    q2z = vz - nz
+    q3x = wx - nx
+    q3y = wy - ny
+    q3z = wz - nz
+
+    vol = q1x * (q2y * q3z - q2z * q3y) + q1y * (q2z * q3x - q2x * q3z) + q1z * (q2x * q3y - q2y * q3x)
+    if vol > 0:
+        return 1
+    elif vol < 0:
+        return -1
+    return 0
+
+
+def _cis_trans_sign(n, u, v, w):
+    # n      w
+    #  \    /
+    #   u--v
+    #  /    \
+    # x      x
+    nx, ny = n
+    ux, uy = u
+    vx, vy = v
+    wx, wy = w
+
+    q1x = ux - nx
+    q1y = uy - ny
+    q2x = vx - ux
+    q2y = vy - uy
+    q3x = wx - vx
+    q3y = wy - vy
+
+    # cross vectors
+    q1q2z = q1x * q2y - q1y * q2x
+    q2q3z = q2x * q3y - q2y * q3x
+
+    dot = q1q2z * q2q3z
+    if dot > 0:
+        return 1
+    elif dot < 0:
+        return -1
+    return 0
+
+
+def _allene_sign(n, u, v, w):
+    # n    w
+    # |   /
+    # u--v
+    nx, ny, nz = n
+    ux, uy = u
+    vx, vy = v
+    wx, wy, wz = w
+
+    q1x = ux - nx
+    q1y = uy - ny
+    q1z = -nz
+    q2x = vx - ux
+    q2y = vy - uy
+    q3x = wx - vx
+    q3y = wy - vy
+    q3z = wz
+
+    # cross vectors
+    q1q2x = -q1z * q2y
+    q1q2y = q1z * q2x
+    q1q2z = q1x * q2y - q1y * q2x
+    q2q3x = q2y * q3z
+    q2q3y = -q2x * q3z
+    q2q3z = q2x * q3y - q2y * q3x
+
+    q1q2q3x = q1q2y * q2q3z - q1q2z * q2q3y
+    q1q2q3y = q1q2z * q2q3x - q1q2x * q2q3z
+
+    dot = q1q2q3x * q2x + q1q2q3y * q2y
+    if dot > 0:
+        return 1
+    elif dot < 0:
+        return -1
+    return 0
+
+
+class MoleculeStereo(Stereo):
+    __slots__ = ()
+
+    def add_wedge(self: 'MoleculeContainer', n: int, m: int, mark: bool, *, clean_cache=True):
+        """
+        Add stereo data by wedge notation of bonds. Use it for tetrahedrons of allenes.
+
+        :param n: number of atom from which wedge bond started
+        :param m: number of atom to which wedge bond coming
+        :param mark: up bond is True, down is False
+        """
+        if n not in self._atoms:
+            raise AtomNotFound
+        if n in self._atoms_stereo:
+            raise IsChiral
+
+        plane = self._plane
+        if n in self._chiral_tetrahedrons:
+            if m not in self._bonds[n]:
+                raise AtomNotFound
+
+            if self._atoms[m].atomic_number == 1:
+                s = _pyramid_sign((*plane[m], mark), *((*plane[x], 0) for x in self._stereo_tetrahedrons[n]))
+            else:
+                order = [(*plane[x], mark if x == m else 0) for x in self._stereo_tetrahedrons[n]]
+                if len(order) == 3:
+                    s = _pyramid_sign((*plane[n], 0), *order)
+                else:
+                    s = _pyramid_sign(order[-1], *order[:3])
+            if s:
+                self._atoms_stereo[n] = s > 0
+                if clean_cache:
+                    self.flush_cache()
+        else:
+            c = self._stereo_allenes_centers.get(n)
+            if c:
+                if c in self._allenes_stereo:
+                    raise IsChiral
+                elif c not in self._chiral_allenes:
+                    raise NotChiral
+
+                order = self._stereo_allenes[c]
+                t1, t2 = self._stereo_allenes_terminals[c]
+                w = order.index(m)
+                if w == 0:
+                    m1 = order[1]
+                    r = False
+                elif w == 1:
+                    m1 = order[0]
+                    t1, t2 = t2, t1
+                    r = False
+                elif w == 2:
+                    m1 = order[1]
+                    r = True
+                else:
+                    m1 = order[0]
+                    t1, t2 = t2, t1
+                    r = True
+                s = _allene_sign((*plane[m], mark), plane[t1], plane[t2], (*plane[m1], 0))
+                if s:
+                    self._allenes_stereo[c] = s < 0 if r else s > 0
+                    if clean_cache:
+                        self.flush_cache()
+            else:
+                # only tetrahedrons and allenes supported
+                raise NotChiral
+
+    def calculate_cis_trans_from_2d(self: 'MoleculeContainer', *, clean_cache=True):
+        """
+        Calculate cis-trans stereo bonds from given 2d coordinates. Unusable for SMILES and INCHI.
+        """
+        cis_trans_stereo = self._cis_trans_stereo
+        plane = self._plane
+        flag = False
+        while self._chiral_cis_trans:
+            stereo = {}
+            for nm in self._chiral_cis_trans:
+                n, m = nm
+                n1, m1, *_ = self._stereo_cis_trans[nm]
+                s = _cis_trans_sign(plane[n1], plane[n], plane[m], plane[m1])
+                if s:
+                    stereo[nm] = s > 0
+            if stereo:
+                cis_trans_stereo.update(stereo)
+                flag = True
+                self.flush_stereo_cache()
+            else:
+                break
+        if flag and clean_cache:
+            self.flush_cache()
+
+    def add_atom_stereo(self: 'MoleculeContainer', n: int, env: Tuple[int, ...], mark: bool, *, clean_cache=True):
+        """
+        Add stereo data for specified neighbors bypass. Use it for tetrahedrons of allenes.
+
+        :param n: number of tetrahedron atom or central atom of allene.
+        :param env: numbers of atoms with specified bypass
+        :param mark: clockwise or anti bypass.
+
+        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html>
+        """
+        if n not in self._atoms:
+            raise AtomNotFound
+        if n in self._atoms_stereo or n in self._allenes_stereo:
+            raise IsChiral
+        if not isinstance(mark, bool):
+            raise TypeError('stereo mark should be bool')
+
+        if n in self._chiral_tetrahedrons:
+            self._atoms_stereo[n] = self._translate_tetrahedron_sign(n, env, mark)
+            if clean_cache:
+                self.flush_cache()
+        elif n in self._chiral_allenes:
+            self._allenes_stereo[n] = self._translate_allene_sign(n, *env, mark)
+            if clean_cache:
+                self.flush_cache()
+        else:  # only tetrahedrons supported
+            raise NotChiral
+
+    def add_cis_trans_stereo(self: 'MoleculeContainer', n: int, m: int, n1: int, n2: int, mark: bool, *,
+                             clean_cache=True):
+        """
+        Add stereo data to cis-trans double bonds (not allenes).
+
+        n1/n=m/n2
+
+        :param n: number of starting atom of double bonds chain (alkenes of cumulenes)
+        :param m: number of ending atom of double bonds chain (alkenes of cumulenes)
+        :param n1: number of neighboring atom of starting atom
+        :param n2: number of neighboring atom of ending atom
+        :param mark: cis or trans
+
+        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html
+        """
+        atoms = self._atoms
+        if n not in atoms or m not in atoms or n1 not in atoms or n2 not in atoms:
+            raise AtomNotFound
+        if not isinstance(mark, bool):
+            raise TypeError('stereo mark should be bool')
+        if (n, m) in self._cis_trans_stereo or (m, n) in self._cis_trans_stereo:
+            raise IsChiral
+
+        if (n, m) in self._chiral_cis_trans:
+            self._cis_trans_stereo[(n, m)] = self._translate_cis_trans_sign(n, m, n1, n2, mark)
+            if clean_cache:
+                self.flush_cache()
+        elif (m, n) in self._chiral_cis_trans:
+            self._cis_trans_stereo[(m, n)] = self._translate_cis_trans_sign(m, n, n2, n1, mark)
+            if clean_cache:
+                self.flush_cache()
+        else:
+            raise NotChiral
+
+    def flush_stereo_cache(self):
+        """
+        Flush chiral morgan and chiral centers cache.
+        """
+        self.__dict__.pop('_chiral_morgan', None)
+        self.__dict__.pop('_MoleculeStereo__chiral_centers', None)
+
+    def fix_stereo(self: 'MoleculeContainer'):
+        """
+        Reset stereo marks.
+        """
+        if self._atoms_stereo:  # filter tetrahedrons
+            stereo_tetrahedrons = self._stereo_tetrahedrons
+            atoms_stereo = {k: v for k, v in self._atoms_stereo.items() if k in stereo_tetrahedrons}
+            self._atoms_stereo = self_atoms_stereo = {}
+        else:
+            atoms_stereo = {}
+
+        if self._allenes_stereo:  # filter allenes
+            stereo_allenes = self._stereo_allenes
+            allenes_stereo = {k: v for k, v in self._allenes_stereo.items() if k in stereo_allenes}
+            self._allenes_stereo = self_allenes_stereo = {}
+        else:
+            allenes_stereo = {}
+
+        if self._cis_trans_stereo:  # filter cis-trans
+            stereo_cis_trans = self._stereo_cis_trans
+            cis_trans_stereo = {k: v for k, v in self._cis_trans_stereo.items() if k in stereo_cis_trans}
+            self._cis_trans_stereo = self_stereo_cis_trans = {}
+        else:
+            cis_trans_stereo = {}
+
+        old_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
+        while old_stereo:
+            chiral_tetrahedrons = self._chiral_tetrahedrons
+            chiral_allenes = self._chiral_allenes
+            chiral_cis_trans = self._chiral_cis_trans
+
+            tmp = {}
+            for n, s in atoms_stereo.items():
+                if n in chiral_tetrahedrons:
+                    self_atoms_stereo[n] = s
+                else:
+                    tmp[n] = s
+            atoms_stereo = tmp
+
+            tmp = {}
+            for n, s in allenes_stereo.items():
+                if n in chiral_allenes:
+                    self_allenes_stereo[n] = s
+                else:
+                    tmp[n] = s
+            allenes_stereo = tmp
+
+            tmp = {}
+            for n, s in cis_trans_stereo.items():
+                if n in chiral_cis_trans:
+                    self_stereo_cis_trans[n] = s
+                else:
+                    tmp[n] = s
+            cis_trans_stereo = tmp
+
+            fail_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
+            if fail_stereo == old_stereo:
+                break
+            old_stereo = fail_stereo
+            self.flush_stereo_cache()
+
+    @cached_property
+    def _wedge_map(self: 'MoleculeContainer'):
+        plane = self._plane
+        atoms_stereo = self._atoms_stereo
+        allenes_centers = self._stereo_allenes_centers
+        atoms = self._atoms
+        used = set()
+        wedge = []
+        for n, s in self._allenes_stereo.items():
+            env = self._stereo_allenes[n]
+            term = self._stereo_allenes_terminals[n]
+            order = [(*env[:2], *term), (*env[1::-1], *term[::-1])]
+            if env[2]:
+                order.append((env[2], env[1], *term))
+                order.append((env[1], env[2], *term[::-1]))
+            if env[3]:
+                order.append((env[3], env[0], *term[::-1]))
+                order.append((env[0], env[3], *term))
+            order = sorted(order, key=lambda x: (x[0] in atoms_stereo, x[0] in allenes_centers,
+                                                 -atoms[x[0]].atomic_number))
+            while (order[0][0], order[0][2]) in used:
+                order.append(order.pop(0))
+            order = order[0]
+            used.add((order[2], order[0]))
+            s = self._translate_allene_sign(n, *order[:2])
+            v = _allene_sign((*plane[order[0]], 1), plane[order[2]], plane[order[3]], (*plane[order[1]], 0))
+            if not v:
+                info(f'need 2d clean. wedge stereo ambiguous for atom {{{n}}}')
+            if s:
+                wedge.append((order[2], order[0], v))
+            else:
+                wedge.append((order[2], order[0], -v))
+
+        for n, s in atoms_stereo.items():
+            order = sorted(self._stereo_tetrahedrons[n], key=lambda x: (x in atoms_stereo, x in allenes_centers,
+                                                                        -atoms[x].atomic_number, atoms[x].in_ring))
+            while (order[0], n) in used:
+                order.append(order.pop(0))
+            used.add((n, order[0]))
+
+            s = self._translate_tetrahedron_sign(n, order)
+            # need recalculation if XY changed
+            if len(order) == 3:
+                v = _pyramid_sign((*plane[n], 0),
+                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
+            else:
+                v = _pyramid_sign((*plane[order[3]], 0),
+                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
+            if not v:
+                info(f'need 2d clean. wedge stereo ambiguous for atom {{{n}}}')
+            if s:
+                wedge.append((n, order[0], v))
+            else:
+                wedge.append((n, order[0], -v))
+        return tuple(wedge)
+
+    @property
+    def _chiral_tetrahedrons(self) -> Set[int]:
+        return self.__chiral_centers[0]
+
+    @property
+    def _chiral_cis_trans(self) -> Set[Tuple[int, int]]:
+        return self.__chiral_centers[1]
+
+    @property
+    def _chiral_allenes(self) -> Set[int]:
+        return self.__chiral_centers[2]
+
+    @cached_property
+    def _chiral_morgan(self: Union['MoleculeContainer', 'MoleculeStereo']) -> Dict[int, int]:
+        if not self._atoms_stereo and not self._allenes_stereo and not self._cis_trans_stereo:
+            return self.atoms_order
+        morgan = self.atoms_order.copy()
+        atoms_stereo = set(self._atoms_stereo)
+        cis_trans_stereo = set(self._cis_trans_stereo)
+        allenes_stereo = set(self._allenes_stereo)
+        while True:
+            # try iteratively differentiate stereo atoms.
+            morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups = \
+                self.__differentiation(morgan, atoms_stereo, cis_trans_stereo, allenes_stereo)
+            if not atoms_groups and not cis_trans_groups and not allenes_groups:
+                break
+            # for some rings differentiation by morgan impossible. try randomly set new weights.
+            # sometimes this will lead to pseudo chiral centers and non-unique morgan.
+            for group in atoms_groups:
+                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
+                    morgan[n] = -morgan[n]
+            for group in cis_trans_groups:
+                for n, _ in group[:len(group) // 2]:  # set new weight in half of group randomly.
+                    morgan[n] = -morgan[n]
+            for group in allenes_groups:
+                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
+                    morgan[n] = -morgan[n]
+            morgan = _morgan(morgan, self.int_adjacency)
+        return morgan
+
+    @cached_property
+    def _rings_tetrahedrons_linkers(self: 'MoleculeContainer') -> Dict[int, Tuple[int, int, int, int]]:
+        """
+        Ring-linkers tetrahedrons.
+
+        Values are neighbors in first and second rings.
+        """
+        out = {}
+        tetrahedrons = self._stereo_tetrahedrons
+        for n, r in self.atoms_rings.items():
+            if n in tetrahedrons:
+                for nr, mr in combinations(r, 2):
+                    if len(set(nr).intersection(mr)) == 1:
+                        ni = nr.index(n)
+                        mi = mr.index(n)
+                        out[n] = (nr[ni - 1], nr[ni - len(nr) + 1], mr[mi - 1], mr[mi - len(mr) + 1])
+                        break
+        return out
+
+    @cached_property
+    def _rings_tetrahedrons(self: 'MoleculeContainer') -> Dict[int, Union[Tuple[int, int], Tuple[int], Tuple]]:
+        """
+        Tetrahedrons in rings, except ring-linkers.
+
+        Values are out of ring atoms.
+        """
+        out = {}
+        atoms_rings = self.atoms_rings
+        tetrahedrons = self._stereo_tetrahedrons
+        points = self._rings_tetrahedrons_linkers
+        environment = self.not_special_connectivity
+        for n, r in atoms_rings.items():
+            if n in tetrahedrons and n not in points:
+                out[n] = tuple(environment[n].difference(atoms_rings))
+        return out
+
+    @cached_property
+    def _rings_cumulenes_linkers(self: 'MoleculeContainer') -> Dict[Tuple[int, int], Tuple[int, int, int, int]]:
+        """
+        Ring-linkers cumulenes except chords.
+
+        Values are neighbors in first and second rings.
+        """
+        out = {}
+        ar = self.atoms_rings
+        chord = self._rings_cumulenes
+        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
+            if n in ar and m in ar and (n, m) not in chord:
+                out[(n, m)] = (n1, n2, m1, m2)
+        return out
+
+    @cached_property
+    def _rings_cumulenes(self: 'MoleculeContainer') -> Set[Tuple[int, int]]:
+        """
+        Cumulenes in rings always chiral.
+        """
+        out = set()
+        ar = self.atoms_rings
+        for n, *_, m in self._stereo_cumulenes:
+            if n in ar and m in ar and not set(ar[n]).isdisjoint(ar[m]):
+                out.add((n, m))
+        return out
+
+    @cached_property
+    def _rings_cumulenes_attached(self: 'MoleculeContainer') -> Dict[Tuple[int, int],
+                                                                     Union[Tuple[int, int], Tuple[int]]]:
+        """
+        Cumulenes attached to rings.
+
+        Values are out of ring atoms.
+        """
+        ar = self.atoms_rings
+        out = {}
+        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
+            if n in ar:
+                if m in ar:
+                    continue
+                if m2:
+                    out[(n, m)] = (m1, m2)
+                else:
+                    out[(n, m)] = (m1,)
+            elif m in ar:
+                if n2:
+                    out[(n, m)] = (n1, n2)
+                else:
+                    out[(n, m)] = (n1,)
+        return out
+
+    @cached_property
+    def __chiral_centers(self: Union['MoleculeStereo', 'MoleculeContainer']):
+        atoms_rings = self.atoms_rings
+        tetrahedrons = self._stereo_tetrahedrons
+        cis_trans = self._stereo_cis_trans
+        allenes_centers = self._stereo_allenes_centers
+        cis_trans_terminals = self._stereo_cis_trans_terminals
+        morgan = self._chiral_morgan
+
+        # find new chiral atoms and bonds.
+        # tetrahedron is chiral if all its neighbors are unique.
+        chiral_t = {n for n, env in tetrahedrons.items() if len({morgan[x] for x in env}) == len(env)}
+        # tetrahedrons-linkers is chiral if in each rings neighbors are unique.
+        chiral_t.update(n for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items()
+                        if morgan[n1] != morgan[n2] and morgan[m1] != morgan[m2])
+
+        # required for axes detection.
+        graph = {}
+        stereogenic = set()
+        pseudo = {}
+
+        # double bond is chiral if neighbors of each terminal atom is unique.
+        # ring-linkers and rings-attached also takes into account.
+        chiral_c = set()
+        chiral_a = set()
+        for path, (n1, m1, n2, m2) in self._stereo_cumulenes.items():
+            if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
+                n, m = path[0], path[-1]
+                if len(path) % 2:
+                    chiral_a.add(path[len(path) // 2])
+                else:
+                    chiral_c.add((n, m))
+                stereogenic.add(n)
+                stereogenic.add(m)
+        # ring cumulenes always chiral. can be already added.
+        for nm in self._rings_cumulenes:
+            n, m = nm
+            if any(len(x) < 8 for x in atoms_rings[n]):  # skip small rings.
+                if nm in chiral_c:  # remove already added small rings cumulenes.
+                    chiral_c.discard(nm)
+                elif (c := allenes_centers[n]) in chiral_a:
+                    chiral_a.discard(c)
+                continue
+            elif nm in cis_trans:
+                chiral_c.add(nm)
+            else:
+                chiral_a.add(allenes_centers[n])
+            pseudo[m] = n
+            graph[n] = set()
+            stereogenic.add(n)
+
+        # find chiral axes. build graph of stereogenic atoms in rings.
+        # atoms connected then located in same ring or cumulene.
+        for n, env in self._rings_tetrahedrons.items():
+            if len(env) == 2:  # one or zero non-ring neighbors stereogenic.
+                n1, n2 = env
+                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
+                    continue
+            graph[n] = set()
+            stereogenic.add(n)  # non-linker tetrahedrons in rings - stereogenic.
+        for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items():
+            graph[n] = set()
+            if morgan[n1] != morgan[n2] or morgan[m1] != morgan[m2]:
+                stereogenic.add(n)  # linkers with at least one unsymmetric ring.
+        for n, m in self._rings_cumulenes_linkers:
+            graph[n] = {m}
+            graph[m] = {n}
+            # stereogenic atoms already found.
+        for (n, m), env in self._rings_cumulenes_attached.items():
+            if len(env) == 2:
+                n1, n2 = env
+                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
+                    continue
+            if n in atoms_rings:
+                graph[n] = set()  # non ring endpoints not required.
+                stereogenic.add(n)  # mark as stereogenic
+            else:
+                graph[m] = set()
+                stereogenic.add(m)
+
+        if len(graph) > 1:  # add bonds to graph. bonds connects atoms in same rings and terminal atoms of cumulenes.
+            for n, ms in graph.items():
+                for r in atoms_rings[n]:
+                    for m in r:
+                        if n == m:
+                            continue
+                        elif m in graph:
+                            ms.add(m)
+                        elif m in pseudo and (m := pseudo[m]) != n:
+                            ms.add(m)
+            # remove not stereogenic terminals.
+            while True:
+                try:
+                    n = next(n for n, ms in graph.items() if not ms or len(ms) == 1 and n not in stereogenic)
+                except StopIteration:
+                    break
+                for m in graph.pop(n):
+                    graph[m].discard(n)
+            # update chiral atoms.
+            for n in graph:
+                if n in tetrahedrons:
+                    chiral_t.add(n)
+                elif n in allenes_centers:
+                    chiral_a.add(allenes_centers[n])
+                else:
+                    chiral_c.add(cis_trans_terminals[n])
+
+        # skip already marked.
+        chiral_t.difference_update(self._atoms_stereo)
+        chiral_a.difference_update(self._allenes_stereo)
+        chiral_c.difference_update(self._cis_trans_stereo)
+        return chiral_t, chiral_c, chiral_a
+
+    def __differentiation(self: Union['MoleculeStereo', 'MoleculeContainer'], morgan,
+                          atoms_stereo, cis_trans_stereo, allenes_stereo):
+        bonds = self.int_adjacency
+
+        tetrahedrons = self._stereo_tetrahedrons
+        cis_trans = self._stereo_cis_trans
+        allenes = self._stereo_allenes
+
+        translate_tetrahedron = self._translate_tetrahedron_sign
+        translate_cis_trans = self._translate_cis_trans_sign
+        translate_allene = self._translate_allene_sign
+
+        while True:
+            morgan_update = {}
+            atoms_groups = []
+            cis_trans_groups = []
+            allenes_groups = []
+            # recalculate morgan weights with taking into account existing stereo marks.
+            if atoms_stereo:
+                grouped_stereo = defaultdict(list)
+                for n in atoms_stereo:
+                    grouped_stereo[morgan[n]].append(n)  # collect equal stereo atoms.
+                for group in grouped_stereo.values():
+                    if not len(group) % 2:  # only even number of equal stereo atoms give new stereo center.
+                        # process only truly stereogenic.
+                        if len(env := tetrahedrons[group[0]]) == len({morgan[x] for x in env}):
+                            s = [n for n in group if translate_tetrahedron(n, sorted(tetrahedrons[n], key=morgan.get))]
+                            if 0 < len(s) < len(group):  # RS pair required.
+                                for m in s:
+                                    morgan_update[m] = -morgan[m]
+                            for n in group:  # prevent checks repeating.
+                                atoms_stereo.discard(n)
+                        else:  # stereo group in rings. unambiguous environment order impossible.
+                            atoms_groups.append(group)
+
+            if cis_trans_stereo:
+                grouped_stereo = defaultdict(list)
+                for nm in cis_trans_stereo:
+                    n, m = nm
+                    if (mn := morgan[n]) <= (mm := morgan[m]):
+                        grouped_stereo[mn].append((n, nm))
+                    else:
+                        grouped_stereo[mm].append((m, nm))
+                for group in grouped_stereo.values():
+                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
+                        n1, m1, n2, m2 = cis_trans[group[0][1]]
+                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
+                            s = []
+                            for x, nm in group:
+                                n, m = nm
+                                n1, m1, n2, m2 = cis_trans[nm]
+                                if n2 is None:
+                                    a = n1
+                                else:
+                                    a = min(n1, n2, key=morgan.get)
+                                if m2 is None:
+                                    b = m1
+                                else:
+                                    b = min(m1, m2, key=morgan.get)
+                                if translate_cis_trans(n, m, a, b):
+                                    s.append(x)
+                            if 0 < len(s) < len(group):  # RS pair required.
+                                for n in s:
+                                    morgan_update[n] = -morgan[n]
+                                for _, nm in group:
+                                    cis_trans_stereo.discard(nm)
+                        else:
+                            cis_trans_groups.append(group)
+
+            if allenes_stereo:
+                grouped_stereo = defaultdict(list)
+                for c in allenes_stereo:
+                    grouped_stereo[morgan[c]].append(c)
+                for group in grouped_stereo.values():
+                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
+                        n1, m1, n2, m2 = allenes[group[0]]
+                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
+                            s = []
+                            for c in group:
+                                n1, m1, n2, m2 = allenes[c]
+                                if n2 is None:
+                                    a = n1
+                                else:
+                                    a = min(n1, n2, key=morgan.get)
+                                if m2 is None:
+                                    b = m1
+                                else:
+                                    b = min(m1, m2, key=morgan.get)
+                                if translate_allene(c, a, b):
+                                    s.append(c)
+                            if 0 < len(s) < len(group):  # RS pair required.
+                                for c in s:
+                                    morgan_update[c] = -morgan[c]
+                                for c in group:
+                                    allenes_stereo.discard(c)
+                        else:
+                            allenes_groups.append(group)
+            if not morgan_update:
+                break
+            morgan = _morgan({**morgan, **morgan_update}, bonds)
+        return morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups
+
+
+__all__ = ['MoleculeStereo']
```

### Comparing `chython-1.64/chython/algorithms/tautomers/test/__init__.py` & `chython-1.8/chython/algorithms/aromatics/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,18 +1,27 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .kekule import *
+from .thiele import *
+
+
+class Aromatize(Thiele, Kekule):
+    __slots__ = ()
+
+
+__all__ = ['Aromatize']
```

### Comparing `chython-1.64/chython/containers/__init__.py` & `chython-1.8/chython/files/_mdl/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,28 +1,27 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .bonds import *
-from .cgr import *
-from .molecule import *
-from .query import *
-from .reaction import *
-
-
-__all__ = [x for x in locals() if x.endswith('Container')]
-__all__.append('Bond')
-__all__.append('QueryBond')
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .emol import EMOLRead
+from .erxn import ERXNRead
+from .ewrite import EMDLWrite
+from .mol import MOLRead, common_isotopes
+from .parser import Parser, parse_error
+from .rxn import RXNRead
+from .stereo import MDLStereo
+from .read import MDLRead
+from .write import MDLWrite
```

### Comparing `chython-1.64/chython/containers/_cpack.c` & `chython-1.8/chython/containers/_unpack.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-/* Generated by Cython 0.29.34 */
+/* Generated by Cython 0.29.24 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-O3"
         ],
-        "name": "chython.containers._cpack",
+        "name": "chython.containers._unpack",
         "sources": [
-            "chython/containers/_cpack.pyx"
+            "chython/containers/_unpack.pyx"
         ]
     },
-    "module_name": "chython.containers._cpack"
+    "module_name": "chython.containers._unpack"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_34"
-#define CYTHON_HEX_VERSION 0x001D22F0
+#define CYTHON_ABI "0_29_24"
+#define CYTHON_HEX_VERSION 0x001D18F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -61,15 +61,14 @@
 #ifndef Py_HUGE_VAL
   #define Py_HUGE_VAL HUGE_VAL
 #endif
 #ifdef PYPY_VERSION
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
   #define CYTHON_USE_TYPE_SLOTS 0
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #if PY_VERSION_HEX < 0x03050000
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
@@ -98,22 +97,18 @@
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
 #elif defined(PYSTON_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #undef CYTHON_USE_ASYNC_SLOTS
   #define CYTHON_USE_ASYNC_SLOTS 0
@@ -143,67 +138,18 @@
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PY_NOGIL)
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 1
-  #ifndef CYTHON_USE_TYPE_SLOTS
-    #define CYTHON_USE_TYPE_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #ifndef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_INTERNALS
-    #define CYTHON_USE_UNICODE_INTERNALS 1
-  #endif
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #ifndef CYTHON_ASSUME_SAFE_MACROS
-    #define CYTHON_ASSUME_SAFE_MACROS 1
-  #endif
-  #ifndef CYTHON_UNPACK_METHODS
-    #define CYTHON_UNPACK_METHODS 1
-  #endif
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYTYPE_LOOKUP
     #define CYTHON_USE_PYTYPE_LOOKUP 0
   #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
@@ -215,72 +161,61 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
+    #define CYTHON_USE_PYLONG_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
-  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
+  #if PY_VERSION_HEX < 0x030300F0
     #undef CYTHON_USE_UNICODE_WRITER
     #define CYTHON_USE_UNICODE_WRITER 0
   #elif !defined(CYTHON_USE_UNICODE_WRITER)
     #define CYTHON_USE_UNICODE_WRITER 1
   #endif
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
-    #undef CYTHON_FAST_THREAD_STATE
-    #define CYTHON_FAST_THREAD_STATE 0
-  #elif !defined(CYTHON_FAST_THREAD_STATE)
+  #ifndef CYTHON_FAST_THREAD_STATE
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
   #ifndef CYTHON_FAST_PYCALL
-    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
+    #define CYTHON_FAST_PYCALL 1
   #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
+    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
   #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
-    #undef CYTHON_USE_EXC_INFO_STACK
-    #define CYTHON_USE_EXC_INFO_STACK 0
-  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
+  #ifndef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
-  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_MAJOR_VERSION < 3
-    #include "longintrepr.h"
-  #endif
+  #include "longintrepr.h"
   #undef SHIFT
   #undef BASE
   #undef MASK
   #ifdef SIZEOF_VOID_P
     enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
   #endif
 #endif
@@ -389,76 +324,17 @@
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
   #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-  #define __Pyx_DefaultClassType PyType_Type
-#if PY_VERSION_HEX >= 0x030B00A1
-    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
-                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
-                                                    PyObject *fv, PyObject *cell, PyObject* fn,
-                                                    PyObject *name, int fline, PyObject *lnos) {
-        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
-        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
-        const char *fn_cstr=NULL;
-        const char *name_cstr=NULL;
-        PyCodeObject* co=NULL;
-        PyObject *type, *value, *traceback;
-        PyErr_Fetch(&type, &value, &traceback);
-        if (!(kwds=PyDict_New())) goto end;
-        if (!(argcount=PyLong_FromLong(a))) goto end;
-        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
-        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
-        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
-        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
-        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
-        if (!(nlocals=PyLong_FromLong(l))) goto end;
-        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
-        if (!(stacksize=PyLong_FromLong(s))) goto end;
-        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
-        if (!(flags=PyLong_FromLong(f))) goto end;
-        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
-        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
-        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
-        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
-        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
-        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
-        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
-        Py_XDECREF((PyObject*)co);
-        co = (PyCodeObject*)call_result;
-        call_result = NULL;
-        if (0) {
-            cleanup_code_too:
-            Py_XDECREF((PyObject*)co);
-            co = NULL;
-        }
-        end:
-        Py_XDECREF(kwds);
-        Py_XDECREF(argcount);
-        Py_XDECREF(posonlyargcount);
-        Py_XDECREF(kwonlyargcount);
-        Py_XDECREF(nlocals);
-        Py_XDECREF(stacksize);
-        Py_XDECREF(replace);
-        Py_XDECREF(call_result);
-        Py_XDECREF(empty);
-        if (type) {
-            PyErr_Restore(type, value, traceback);
-        }
-        return co;
-    }
+#if PY_VERSION_HEX >= 0x030800A4 && PY_VERSION_HEX < 0x030800B2
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_New(a, 0, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #else
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
   #define __Pyx_DefaultClassType PyType_Type
 #endif
 #ifndef Py_TPFLAGS_CHECKTYPES
@@ -564,35 +440,35 @@
 #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
 #define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
 #else
 #define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
 #endif
 #if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
   #define CYTHON_PEP393_ENABLED 1
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_READY(op)       (0)
+  #if defined(PyUnicode_IS_READY)
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
   #else
-    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
-                                                0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_READY(op)       (0)
   #endif
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
   #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
   #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
   #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
   #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
   #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
+  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
+  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
   #else
-    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
-    #else
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
-    #endif
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
+  #endif
+  #else
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
   #endif
 #else
   #define CYTHON_PEP393_ENABLED 0
   #define PyUnicode_1BYTE_KIND  1
   #define PyUnicode_2BYTE_KIND  2
   #define PyUnicode_4BYTE_KIND  4
   #define __Pyx_PyUnicode_READY(op)       (0)
@@ -688,18 +564,18 @@
   #ifndef PyUnicode_InternFromString
     #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
   #endif
 #endif
 #if PY_VERSION_HEX < 0x030200A4
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
 #else
   #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
 #endif
 #if CYTHON_USE_ASYNC_SLOTS
@@ -716,18 +592,16 @@
     typedef struct {
         unaryfunc am_await;
         unaryfunc am_aiter;
         unaryfunc am_anext;
     } __Pyx_PyAsyncMethodsStruct;
 #endif
 
-#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
-  #if !defined(_USE_MATH_DEFINES)
-    #define _USE_MATH_DEFINES
-  #endif
+#if defined(WIN32) || defined(MS_WINDOWS)
+  #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
 #ifdef NAN
 #define __PYX_NAN() ((float) NAN)
 #else
 static CYTHON_INLINE float __PYX_NAN() {
   float value;
@@ -750,17 +624,18 @@
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
-#define __PYX_HAVE__chython__containers___cpack
-#define __PYX_HAVE_API__chython__containers___cpack
+#define __PYX_HAVE__chython__containers___unpack
+#define __PYX_HAVE_API__chython__containers___unpack
 /* Early includes */
+#include <math.h>
 #include "pythread.h"
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include "pystate.h"
 #ifdef _OPENMP
 #include <omp.h>
@@ -854,15 +729,14 @@
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
 #define __Pyx_PySequence_Tuple(obj)\
     (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
 #if CYTHON_ASSUME_SAFE_MACROS
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
 #else
 #define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
 #endif
 #define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
 #if PY_MAJOR_VERSION >= 3
@@ -967,15 +841,15 @@
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
 
 static const char *__pyx_f[] = {
-  "chython/containers/_cpack.pyx",
+  "chython\\containers\\_unpack.pyx",
   "stringsource",
 };
 /* MemviewSliceStruct.proto */
 struct __pyx_memoryview_obj;
 typedef struct {
   struct __pyx_memoryview_obj *memview;
   char *data;
@@ -986,47 +860,51 @@
 #define __Pyx_MemoryView_Len(m)  (m.shape[0])
 
 /* Atomics.proto */
 #include <pythread.h>
 #ifndef CYTHON_ATOMICS
     #define CYTHON_ATOMICS 1
 #endif
-#define __PYX_CYTHON_ATOMICS_ENABLED() CYTHON_ATOMICS
 #define __pyx_atomic_int_type int
-#if CYTHON_ATOMICS && (__GNUC__ >= 5 || (__GNUC__ == 4 &&\
-                    (__GNUC_MINOR__ > 1 ||\
-                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ >= 2))))
-    #define __pyx_atomic_incr_aligned(value) __sync_fetch_and_add(value, 1)
-    #define __pyx_atomic_decr_aligned(value) __sync_fetch_and_sub(value, 1)
+#if CYTHON_ATOMICS && __GNUC__ >= 4 && (__GNUC_MINOR__ > 1 ||\
+                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL >= 2)) &&\
+                    !defined(__i386__)
+    #define __pyx_atomic_incr_aligned(value, lock) __sync_fetch_and_add(value, 1)
+    #define __pyx_atomic_decr_aligned(value, lock) __sync_fetch_and_sub(value, 1)
     #ifdef __PYX_DEBUG_ATOMICS
         #warning "Using GNU atomics"
     #endif
-#elif CYTHON_ATOMICS && defined(_MSC_VER) && CYTHON_COMPILING_IN_NOGIL
-    #include <intrin.h>
+#elif CYTHON_ATOMICS && defined(_MSC_VER) && 0
+    #include <Windows.h>
     #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type long
-    #pragma intrinsic (_InterlockedExchangeAdd)
-    #define __pyx_atomic_incr_aligned(value) _InterlockedExchangeAdd(value, 1)
-    #define __pyx_atomic_decr_aligned(value) _InterlockedExchangeAdd(value, -1)
+    #define __pyx_atomic_int_type LONG
+    #define __pyx_atomic_incr_aligned(value, lock) InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) InterlockedDecrement(value)
     #ifdef __PYX_DEBUG_ATOMICS
         #pragma message ("Using MSVC atomics")
     #endif
+#elif CYTHON_ATOMICS && (defined(__ICC) || defined(__INTEL_COMPILER)) && 0
+    #define __pyx_atomic_incr_aligned(value, lock) _InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) _InterlockedDecrement(value)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Using Intel atomics"
+    #endif
 #else
     #undef CYTHON_ATOMICS
     #define CYTHON_ATOMICS 0
     #ifdef __PYX_DEBUG_ATOMICS
         #warning "Not using atomics"
     #endif
 #endif
 typedef volatile __pyx_atomic_int_type __pyx_atomic_int;
 #if CYTHON_ATOMICS
     #define __pyx_add_acquisition_count(memview)\
-             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview))
+             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
     #define __pyx_sub_acquisition_count(memview)\
-            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview))
+            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
 #else
     #define __pyx_add_acquisition_count(memview)\
             __pyx_add_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
     #define __pyx_sub_acquisition_count(memview)\
             __pyx_sub_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
 #endif
 
@@ -1081,15 +959,15 @@
 
 /*--- Type declarations ---*/
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "View.MemoryView":106
+/* "View.MemoryView":105
  * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 struct __pyx_array_obj {
@@ -1106,28 +984,28 @@
   PyObject *_format;
   void (*callback_free_data)(void *);
   int free_data;
   int dtype_is_object;
 };
 
 
-/* "View.MemoryView":280
+/* "View.MemoryView":279
  * 
  * @cname('__pyx_MemviewEnum')
  * cdef class Enum(object):             # <<<<<<<<<<<<<<
  *     cdef object name
  *     def __init__(self, name):
  */
 struct __pyx_MemviewEnum_obj {
   PyObject_HEAD
   PyObject *name;
 };
 
 
-/* "View.MemoryView":331
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 struct __pyx_memoryview_obj {
@@ -1142,15 +1020,15 @@
   Py_buffer view;
   int flags;
   int dtype_is_object;
   __Pyx_TypeInfo *typeinfo;
 };
 
 
-/* "View.MemoryView":967
+/* "View.MemoryView":965
  * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 struct __pyx_memoryviewslice_obj {
@@ -1159,29 +1037,29 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
-/* "View.MemoryView":106
+/* "View.MemoryView":105
  * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 
 struct __pyx_vtabstruct_array {
   PyObject *(*get_memview)(struct __pyx_array_obj *);
 };
 static struct __pyx_vtabstruct_array *__pyx_vtabptr_array;
 
 
-/* "View.MemoryView":331
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 
@@ -1193,15 +1071,15 @@
   PyObject *(*setitem_indexed)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
   PyObject *(*convert_item_to_object)(struct __pyx_memoryview_obj *, char *);
   PyObject *(*assign_item_from_object)(struct __pyx_memoryview_obj *, char *, PyObject *);
 };
 static struct __pyx_vtabstruct_memoryview *__pyx_vtabptr_memoryview;
 
 
-/* "View.MemoryView":967
+/* "View.MemoryView":965
  * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 
@@ -1280,14 +1158,20 @@
 #else
 #define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
 /* GetBuiltinName.proto */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name);
 
+/* None.proto */
+static CYTHON_INLINE long __Pyx_div_long(long, long);
+
+/* None.proto */
+static CYTHON_INLINE long __Pyx_mod_long(long, long);
+
 /* ListAppend.proto */
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
     PyListObject* L = (PyListObject*) list;
     Py_ssize_t len = Py_SIZE(list);
     if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
         Py_INCREF(x);
@@ -1330,21 +1214,14 @@
     (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                               int wraparound, int boundscheck);
 static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                      int is_list, int wraparound, int boundscheck);
 
-/* ObjectGetItem.proto */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
-#else
-#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
-#endif
-
 /* PyDictVersioning.proto */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 #define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
 #define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
     (version_var) = __PYX_GET_DICT_VERSION(dict);\
     (cache_var) = (value);
@@ -1365,26 +1242,26 @@
 #define __PYX_GET_DICT_VERSION(dict)  (0)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
 #define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
 #endif
 
 /* GetModuleGlobalName.proto */
 #if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  do {\
+#define __Pyx_GetModuleGlobalName(var, name)  {\
     static PY_UINT64_T __pyx_dict_version = 0;\
     static PyObject *__pyx_dict_cached_value = NULL;\
     (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
         (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
         __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
+}
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
     PY_UINT64_T __pyx_dict_version;\
     PyObject *__pyx_dict_cached_value;\
     (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
+}
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
 #define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
@@ -1405,29 +1282,21 @@
 #define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
 #endif
 #define __Pyx_BUILD_ASSERT_EXPR(cond)\
     (sizeof(char [1 - 2*!(cond)]) - 1)
 #ifndef Py_MEMBER_SIZE
 #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
 #endif
-#if CYTHON_FAST_PYCALL
   static size_t __pyx_pyframe_localsplus_offset = 0;
   #include "frameobject.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
   #define __Pxy_PyFrame_Initialize_Offsets()\
     ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
      (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
   #define __Pyx_PyFrame_GetLocalsplus(frame)\
     (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
-#endif // CYTHON_FAST_PYCALL
 #endif
 
 /* PyObjectCall.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
 #else
 #define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
@@ -1548,26 +1417,33 @@
 /* StrEquals.proto */
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
 #else
 #define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
 #endif
 
-/* DivInt[Py_ssize_t].proto */
+/* None.proto */
 static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t, Py_ssize_t);
 
 /* UnaryNegOverflows.proto */
 #define UNARY_NEG_WOULD_OVERFLOW(x)\
         (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
 
 static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *); /*proto*/
 /* GetAttr.proto */
 static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
 
+/* ObjectGetItem.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
+#else
+#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
+#endif
+
 /* decode_c_string_utf16.proto */
 static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
     int byteorder = 0;
     return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
 }
 static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
     int byteorder = -1;
@@ -1693,23 +1569,14 @@
     return PyList_SetSlice(L, PY_SSIZE_T_MAX, PY_SSIZE_T_MAX, v);
 #endif
 }
 
 /* None.proto */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
 
-/* DivInt[long].proto */
-static CYTHON_INLINE long __Pyx_div_long(long, long);
-
-/* PySequenceContains.proto */
-static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
-    int result = PySequence_Contains(seq, item);
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
-
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
 /* HasAttr.proto */
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
 /* PyObject_GenericGetAttrNoDict.proto */
@@ -1822,51 +1689,39 @@
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(PyObject *, int writable_flag);
 
 /* GCCDiagnostics.proto */
 #if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
 #define __Pyx_HAS_GCC_DIAGNOSTIC
 #endif
 
-/* MemviewDtypeToObject.proto */
-static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_char__const__(const char *itemp);
-
 /* MemviewSliceCopyTemplate.proto */
 static __Pyx_memviewslice
 __pyx_memoryview_copy_new_contig(const __Pyx_memviewslice *from_mvs,
                                  const char *mode, int ndim,
                                  size_t sizeof_dtype, int contig_flag,
                                  int dtype_is_object);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_char(unsigned char value);
-
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value);
 
 /* CIntFromPy.proto */
-static CYTHON_INLINE unsigned short __Pyx_PyInt_As_unsigned_short(PyObject *);
+static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_short(unsigned short value);
-
-/* CIntFromPy.proto */
-static CYTHON_INLINE unsigned char __Pyx_PyInt_As_unsigned_char(PyObject *);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_char(char value);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
-
 /* CIntFromPy.proto */
 static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *);
 
 /* CheckBinaryVersion.proto */
 static int __Pyx_check_binary_version(void);
 
 /* InitStrings.proto */
@@ -1883,28 +1738,30 @@
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryviewslice_assign_item_from_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
 
 /* Module declarations from 'cython.view' */
 
 /* Module declarations from 'cython' */
 
-/* Module declarations from 'cpython.mem' */
+/* Module declarations from 'libc.math' */
 
-/* Module declarations from 'chython.containers._cpack' */
+/* Module declarations from 'chython.containers._unpack' */
 static PyTypeObject *__pyx_array_type = 0;
 static PyTypeObject *__pyx_MemviewEnum_type = 0;
 static PyTypeObject *__pyx_memoryview_type = 0;
 static PyTypeObject *__pyx_memoryviewslice_type = 0;
+static int __pyx_v_7chython_10containers_7_unpack_common_isotopes[0x77];
 static PyObject *generic = 0;
 static PyObject *strided = 0;
 static PyObject *indirect = 0;
 static PyObject *contiguous = 0;
 static PyObject *indirect_contiguous = 0;
 static int __pyx_memoryview_thread_locks_used;
 static PyThread_type_lock __pyx_memoryview_thread_locks[8];
+static double __pyx_f_7chython_10containers_7_unpack_double_from2bytes(unsigned char, unsigned char); /*proto*/
 static struct __pyx_array_obj *__pyx_array_new(PyObject *, Py_ssize_t, char *, char *, char *); /*proto*/
 static void *__pyx_align_pointer(void *, size_t); /*proto*/
 static PyObject *__pyx_memoryview_new(PyObject *, int, int, __Pyx_TypeInfo *); /*proto*/
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *); /*proto*/
 static PyObject *_unellipsify(PyObject *, int); /*proto*/
 static PyObject *assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *, PyObject *); /*proto*/
@@ -1931,121 +1788,126 @@
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *, int, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *, int, size_t, void *, int); /*proto*/
 static void __pyx_memoryview__slice_assign_scalar(char *, Py_ssize_t *, Py_ssize_t *, int, size_t, void *); /*proto*/
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *, PyObject *); /*proto*/
 static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_char__const__ = { "const unsigned char", NULL, sizeof(unsigned char const ), { 0 }, 0, IS_UNSIGNED(unsigned char const ) ? 'U' : 'I', IS_UNSIGNED(unsigned char const ), 0 };
-#define __Pyx_MODULE_NAME "chython.containers._cpack"
-extern int __pyx_module_is_main_chython__containers___cpack;
-int __pyx_module_is_main_chython__containers___cpack = 0;
+#define __Pyx_MODULE_NAME "chython.containers._unpack"
+extern int __pyx_module_is_main_chython__containers___unpack;
+int __pyx_module_is_main_chython__containers___unpack = 0;
 
-/* Implementation of 'chython.containers._cpack' */
+/* Implementation of 'chython.containers._unpack' */
 static PyObject *__pyx_builtin_range;
 static PyObject *__pyx_builtin_object;
 static PyObject *__pyx_builtin_ValueError;
 static PyObject *__pyx_builtin_MemoryError;
 static PyObject *__pyx_builtin_enumerate;
 static PyObject *__pyx_builtin_TypeError;
 static PyObject *__pyx_builtin_Ellipsis;
 static PyObject *__pyx_builtin_id;
 static PyObject *__pyx_builtin_IndexError;
 static const char __pyx_k_O[] = "O";
 static const char __pyx_k_a[] = "a";
 static const char __pyx_k_b[] = "b";
 static const char __pyx_k_c[] = "c";
+static const char __pyx_k_d[] = "d";
 static const char __pyx_k_i[] = "i";
+static const char __pyx_k_j[] = "j";
 static const char __pyx_k_m[] = "m";
 static const char __pyx_k_n[] = "n";
+static const char __pyx_k_x[] = "x";
+static const char __pyx_k_y[] = "y";
 static const char __pyx_k_id[] = "id";
+static const char __pyx_k_na[] = "na";
+static const char __pyx_k_nb[] = "nb";
+static const char __pyx_k_nct[] = "nct";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_obj[] = "obj";
+static const char __pyx_k_tmp[] = "tmp";
 static const char __pyx_k_Bond[] = "Bond";
+static const char __pyx_k_atom[] = "atom";
 static const char __pyx_k_base[] = "base";
 static const char __pyx_k_bond[] = "bond";
 static const char __pyx_k_data[] = "data";
 static const char __pyx_k_dict[] = "__dict__";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_ndim[] = "ndim";
 static const char __pyx_k_pack[] = "pack";
-static const char __pyx_k_py_m[] = "py_m";
-static const char __pyx_k_py_n[] = "py_n";
 static const char __pyx_k_seen[] = "seen";
 static const char __pyx_k_size[] = "size";
 static const char __pyx_k_step[] = "step";
 static const char __pyx_k_stop[] = "stop";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_ASCII[] = "ASCII";
-static const char __pyx_k_atoms[] = "atoms";
 static const char __pyx_k_class[] = "__class__";
 static const char __pyx_k_error[] = "error";
 static const char __pyx_k_flags[] = "flags";
-static const char __pyx_k_py_xy[] = "py_xy";
 static const char __pyx_k_range[] = "range";
 static const char __pyx_k_shape[] = "shape";
 static const char __pyx_k_shift[] = "shift";
 static const char __pyx_k_start[] = "start";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_format[] = "format";
 static const char __pyx_k_import[] = "__import__";
+static const char __pyx_k_is_all[] = "is_all";
+static const char __pyx_k_is_tet[] = "is_tet";
 static const char __pyx_k_name_2[] = "__name__";
 static const char __pyx_k_object[] = "object";
 static const char __pyx_k_orders[] = "orders";
 static const char __pyx_k_pickle[] = "pickle";
-static const char __pyx_k_py_ngb[] = "py_ngb";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_struct[] = "struct";
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
-static const char __pyx_k_Bond__m[] = "_Bond__m";
-static const char __pyx_k_Bond__n[] = "_Bond__n";
 static const char __pyx_k_charges[] = "charges";
 static const char __pyx_k_ct_sign[] = "ct_sign";
 static const char __pyx_k_fortran[] = "fortran";
+static const char __pyx_k_mapping[] = "mapping";
 static const char __pyx_k_memview[] = "memview";
 static const char __pyx_k_Ellipsis[] = "Ellipsis";
-static const char __pyx_k_ct_count[] = "ct_count";
-static const char __pyx_k_ct_shift[] = "ct_shift";
+static const char __pyx_k_all_sign[] = "all_sign";
 static const char __pyx_k_getstate[] = "__getstate__";
+static const char __pyx_k_isotopes[] = "isotopes";
 static const char __pyx_k_itemsize[] = "itemsize";
 static const char __pyx_k_py_atoms[] = "py_atoms";
 static const char __pyx_k_py_bonds[] = "py_bonds";
 static const char __pyx_k_py_plane[] = "py_plane";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
 static const char __pyx_k_radicals[] = "radicals";
 static const char __pyx_k_setstate[] = "__setstate__";
+static const char __pyx_k_tet_sign[] = "tet_sign";
 static const char __pyx_k_TypeError[] = "TypeError";
-static const char __pyx_k_ct_stereo[] = "ct_stereo";
 static const char __pyx_k_enumerate[] = "enumerate";
 static const char __pyx_k_hydrogens[] = "hydrogens";
-static const char __pyx_k_is_chiral[] = "is_chiral";
 static const char __pyx_k_neighbors[] = "neighbors";
 static const char __pyx_k_pyx_state[] = "__pyx_state";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
 static const char __pyx_k_IndexError[] = "IndexError";
 static const char __pyx_k_ValueError[] = "ValueError";
-static const char __pyx_k_bond_shift[] = "bond_shift";
 static const char __pyx_k_py_charges[] = "py_charges";
 static const char __pyx_k_py_mapping[] = "py_mapping";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
 static const char __pyx_k_Bond__order[] = "_Bond__order";
 static const char __pyx_k_MemoryError[] = "MemoryError";
 static const char __pyx_k_PickleError[] = "PickleError";
-static const char __pyx_k_atoms_count[] = "atoms_count";
+static const char __pyx_k_cis_trans_1[] = "cis_trans_1";
+static const char __pyx_k_cis_trans_2[] = "cis_trans_2";
 static const char __pyx_k_connections[] = "connections";
+static const char __pyx_k_order_shift[] = "order_shift";
+static const char __pyx_k_pack_length[] = "pack_length";
 static const char __pyx_k_py_isotopes[] = "py_isotopes";
 static const char __pyx_k_py_radicals[] = "py_radicals";
-static const char __pyx_k_stereo_sign[] = "stereo_sign";
 static const char __pyx_k_py_hydrogens[] = "py_hydrogens";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
 static const char __pyx_k_stringsource[] = "stringsource";
-static const char __pyx_k_py_bonds_flat[] = "py_bonds_flat";
+static const char __pyx_k_isotope_shift[] = "isotope_shift";
 static const char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_View_MemoryView[] = "View.MemoryView";
 static const char __pyx_k_allocate_buffer[] = "allocate_buffer";
 static const char __pyx_k_dtype_is_object[] = "dtype_is_object";
 static const char __pyx_k_py_atoms_stereo[] = "py_atoms_stereo";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
@@ -2059,45 +1921,43 @@
 static const char __pyx_k_contiguous_and_direct[] = "<contiguous and direct>";
 static const char __pyx_k_MemoryView_of_r_object[] = "<MemoryView of %r object>";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
 static const char __pyx_k_Cannot_index_with_type_s[] = "Cannot index with type '%s'";
 static const char __pyx_k_chython_containers_bonds[] = "chython.containers.bonds";
 static const char __pyx_k_Invalid_shape_in_axis_d_d[] = "Invalid shape in axis %d: %d.";
-static const char __pyx_k_chython_containers__cpack[] = "chython.containers._cpack";
+static const char __pyx_k_chython_containers__unpack[] = "chython.containers._unpack";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
-static const char __pyx_k_chython_containers__cpack_pyx[] = "chython/containers/_cpack.pyx";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
+static const char __pyx_k_chython_containers__unpack_pyx[] = "chython\\containers\\_unpack.pyx";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))";
+static const char __pyx_k_Incompatible_checksums_s_vs_0xb0[] = "Incompatible checksums (%s vs 0xb068931 = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
 static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension %d (got %d and %d)";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
 static PyObject *__pyx_n_s_ASCII;
 static PyObject *__pyx_n_s_Bond;
-static PyObject *__pyx_n_s_Bond__m;
-static PyObject *__pyx_n_s_Bond__n;
 static PyObject *__pyx_n_s_Bond__order;
 static PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
 static PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
 static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
 static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
 static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
 static PyObject *__pyx_n_s_Ellipsis;
 static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
-static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
+static PyObject *__pyx_kp_s_Incompatible_checksums_s_vs_0xb0;
 static PyObject *__pyx_n_s_IndexError;
 static PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
 static PyObject *__pyx_kp_s_Invalid_mode_expected_c_or_fortr;
 static PyObject *__pyx_kp_s_Invalid_shape_in_axis_d_d;
 static PyObject *__pyx_n_s_MemoryError;
 static PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
 static PyObject *__pyx_kp_s_MemoryView_of_r_object;
@@ -2105,36 +1965,35 @@
 static PyObject *__pyx_kp_s_Out_of_bounds_on_buffer_access_a;
 static PyObject *__pyx_n_s_PickleError;
 static PyObject *__pyx_n_s_TypeError;
 static PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
 static PyObject *__pyx_n_s_ValueError;
 static PyObject *__pyx_n_s_View_MemoryView;
 static PyObject *__pyx_n_s_a;
+static PyObject *__pyx_n_s_all_sign;
 static PyObject *__pyx_n_s_allocate_buffer;
-static PyObject *__pyx_n_s_atoms;
-static PyObject *__pyx_n_s_atoms_count;
+static PyObject *__pyx_n_s_atom;
 static PyObject *__pyx_n_s_b;
 static PyObject *__pyx_n_s_base;
 static PyObject *__pyx_n_s_bond;
-static PyObject *__pyx_n_s_bond_shift;
 static PyObject *__pyx_n_s_c;
 static PyObject *__pyx_n_u_c;
 static PyObject *__pyx_n_s_charges;
-static PyObject *__pyx_n_s_chython_containers__cpack;
-static PyObject *__pyx_kp_s_chython_containers__cpack_pyx;
+static PyObject *__pyx_n_s_chython_containers__unpack;
+static PyObject *__pyx_kp_s_chython_containers__unpack_pyx;
 static PyObject *__pyx_n_s_chython_containers_bonds;
+static PyObject *__pyx_n_s_cis_trans_1;
+static PyObject *__pyx_n_s_cis_trans_2;
 static PyObject *__pyx_n_s_class;
 static PyObject *__pyx_n_s_cline_in_traceback;
 static PyObject *__pyx_n_s_connections;
 static PyObject *__pyx_kp_s_contiguous_and_direct;
 static PyObject *__pyx_kp_s_contiguous_and_indirect;
-static PyObject *__pyx_n_s_ct_count;
-static PyObject *__pyx_n_s_ct_shift;
 static PyObject *__pyx_n_s_ct_sign;
-static PyObject *__pyx_n_s_ct_stereo;
+static PyObject *__pyx_n_s_d;
 static PyObject *__pyx_n_s_data;
 static PyObject *__pyx_n_s_dict;
 static PyObject *__pyx_n_s_dtype_is_object;
 static PyObject *__pyx_n_s_encode;
 static PyObject *__pyx_n_s_enumerate;
 static PyObject *__pyx_n_s_error;
 static PyObject *__pyx_n_s_flags;
@@ -2143,49 +2002,54 @@
 static PyObject *__pyx_n_u_fortran;
 static PyObject *__pyx_n_s_getstate;
 static PyObject *__pyx_kp_s_got_differing_extents_in_dimensi;
 static PyObject *__pyx_n_s_hydrogens;
 static PyObject *__pyx_n_s_i;
 static PyObject *__pyx_n_s_id;
 static PyObject *__pyx_n_s_import;
-static PyObject *__pyx_n_s_is_chiral;
+static PyObject *__pyx_n_s_is_all;
+static PyObject *__pyx_n_s_is_tet;
+static PyObject *__pyx_n_s_isotope_shift;
+static PyObject *__pyx_n_s_isotopes;
 static PyObject *__pyx_n_s_itemsize;
 static PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
+static PyObject *__pyx_n_s_j;
 static PyObject *__pyx_n_s_m;
 static PyObject *__pyx_n_s_main;
+static PyObject *__pyx_n_s_mapping;
 static PyObject *__pyx_n_s_memview;
 static PyObject *__pyx_n_s_mode;
 static PyObject *__pyx_n_s_n;
+static PyObject *__pyx_n_s_na;
 static PyObject *__pyx_n_s_name;
 static PyObject *__pyx_n_s_name_2;
+static PyObject *__pyx_n_s_nb;
+static PyObject *__pyx_n_s_nct;
 static PyObject *__pyx_n_s_ndim;
 static PyObject *__pyx_n_s_neighbors;
 static PyObject *__pyx_n_s_new;
 static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
 static PyObject *__pyx_n_s_obj;
 static PyObject *__pyx_n_s_object;
+static PyObject *__pyx_n_s_order_shift;
 static PyObject *__pyx_n_s_orders;
 static PyObject *__pyx_n_s_pack;
+static PyObject *__pyx_n_s_pack_length;
 static PyObject *__pyx_n_s_pickle;
 static PyObject *__pyx_n_s_py_allenes_stereo;
 static PyObject *__pyx_n_s_py_atoms;
 static PyObject *__pyx_n_s_py_atoms_stereo;
 static PyObject *__pyx_n_s_py_bonds;
-static PyObject *__pyx_n_s_py_bonds_flat;
 static PyObject *__pyx_n_s_py_charges;
 static PyObject *__pyx_n_s_py_cis_trans_stereo;
 static PyObject *__pyx_n_s_py_hydrogens;
 static PyObject *__pyx_n_s_py_isotopes;
-static PyObject *__pyx_n_s_py_m;
 static PyObject *__pyx_n_s_py_mapping;
-static PyObject *__pyx_n_s_py_n;
-static PyObject *__pyx_n_s_py_ngb;
 static PyObject *__pyx_n_s_py_plane;
 static PyObject *__pyx_n_s_py_radicals;
-static PyObject *__pyx_n_s_py_xy;
 static PyObject *__pyx_n_s_pyx_PickleError;
 static PyObject *__pyx_n_s_pyx_checksum;
 static PyObject *__pyx_n_s_pyx_getbuffer;
 static PyObject *__pyx_n_s_pyx_result;
 static PyObject *__pyx_n_s_pyx_state;
 static PyObject *__pyx_n_s_pyx_type;
 static PyObject *__pyx_n_s_pyx_unpickle_Enum;
@@ -2199,27 +2063,30 @@
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shape;
 static PyObject *__pyx_n_s_shift;
 static PyObject *__pyx_n_s_size;
 static PyObject *__pyx_n_s_start;
 static PyObject *__pyx_n_s_step;
-static PyObject *__pyx_n_s_stereo_sign;
 static PyObject *__pyx_n_s_stop;
 static PyObject *__pyx_kp_s_strided_and_direct;
 static PyObject *__pyx_kp_s_strided_and_direct_or_indirect;
 static PyObject *__pyx_kp_s_strided_and_indirect;
 static PyObject *__pyx_kp_s_stringsource;
 static PyObject *__pyx_n_s_struct;
 static PyObject *__pyx_n_s_test;
+static PyObject *__pyx_n_s_tet_sign;
+static PyObject *__pyx_n_s_tmp;
 static PyObject *__pyx_kp_s_unable_to_allocate_array_data;
 static PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
 static PyObject *__pyx_n_s_unpack;
 static PyObject *__pyx_n_s_update;
-static PyObject *__pyx_pf_7chython_10containers_6_cpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data); /* proto */
+static PyObject *__pyx_n_s_x;
+static PyObject *__pyx_n_s_y;
+static PyObject *__pyx_pf_7chython_10containers_7_unpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_item); /* proto */
@@ -2258,1577 +2125,1644 @@
 static PyObject *__pyx_pf___pyx_memoryviewslice___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-static PyObject *__pyx_float_0_;
 static PyObject *__pyx_int_0;
 static PyObject *__pyx_int_1;
-static PyObject *__pyx_int_112105877;
-static PyObject *__pyx_int_136983863;
 static PyObject *__pyx_int_184977713;
 static PyObject *__pyx_int_neg_1;
 static PyObject *__pyx_tuple_;
 static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__4;
 static PyObject *__pyx_tuple__5;
 static PyObject *__pyx_tuple__6;
 static PyObject *__pyx_tuple__7;
 static PyObject *__pyx_tuple__8;
 static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_slice__16;
+static PyObject *__pyx_slice__15;
 static PyObject *__pyx_tuple__10;
 static PyObject *__pyx_tuple__11;
 static PyObject *__pyx_tuple__12;
 static PyObject *__pyx_tuple__13;
 static PyObject *__pyx_tuple__14;
-static PyObject *__pyx_tuple__15;
+static PyObject *__pyx_tuple__16;
 static PyObject *__pyx_tuple__17;
 static PyObject *__pyx_tuple__18;
 static PyObject *__pyx_tuple__19;
-static PyObject *__pyx_tuple__20;
 static PyObject *__pyx_tuple__21;
+static PyObject *__pyx_tuple__22;
 static PyObject *__pyx_tuple__23;
 static PyObject *__pyx_tuple__24;
 static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__26;
-static PyObject *__pyx_tuple__27;
-static PyObject *__pyx_tuple__28;
-static PyObject *__pyx_codeobj__22;
-static PyObject *__pyx_codeobj__29;
+static PyObject *__pyx_codeobj__20;
+static PyObject *__pyx_codeobj__27;
 /* Late includes */
 
-/* "chython/containers/_cpack.pyx":52
- * @cython.cdivision(True)
- * @cython.wraparound(False)
+/* "chython/containers/_unpack.pyx":25
+ * 
+ * @cython.boundscheck(False)
  * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
- *     cdef char *charges
- *     cdef unsigned char *atoms, *hydrogens, *radicals, *is_chiral, *neighbors, **orders, *seen
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7chython_10containers_6_cpack_1unpack(PyObject *__pyx_self, PyObject *__pyx_arg_data); /*proto*/
-static PyMethodDef __pyx_mdef_7chython_10containers_6_cpack_1unpack = {"unpack", (PyCFunction)__pyx_pw_7chython_10containers_6_cpack_1unpack, METH_O, 0};
-static PyObject *__pyx_pw_7chython_10containers_6_cpack_1unpack(PyObject *__pyx_self, PyObject *__pyx_arg_data) {
+static PyObject *__pyx_pw_7chython_10containers_7_unpack_1unpack(PyObject *__pyx_self, PyObject *__pyx_arg_data); /*proto*/
+static PyMethodDef __pyx_mdef_7chython_10containers_7_unpack_1unpack = {"unpack", (PyCFunction)__pyx_pw_7chython_10containers_7_unpack_1unpack, METH_O, 0};
+static PyObject *__pyx_pw_7chython_10containers_7_unpack_1unpack(PyObject *__pyx_self, PyObject *__pyx_arg_data) {
   __Pyx_memviewslice __pyx_v_data = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("unpack (wrapper)", 0);
   assert(__pyx_arg_data); {
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 52, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 25, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
-  __Pyx_AddTraceback("chython.containers._cpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("chython.containers._unpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   if (unlikely(((PyObject *)__pyx_v_data.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "data"); __PYX_ERR(0, 52, __pyx_L1_error)
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "data"); __PYX_ERR(0, 25, __pyx_L1_error)
   }
-  __pyx_r = __pyx_pf_7chython_10containers_6_cpack_unpack(__pyx_self, __pyx_v_data);
+  __pyx_r = __pyx_pf_7chython_10containers_7_unpack_unpack(__pyx_self, __pyx_v_data);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7chython_10containers_6_cpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data) {
-  char *__pyx_v_charges;
-  unsigned char *__pyx_v_atoms;
-  unsigned char *__pyx_v_hydrogens;
-  unsigned char *__pyx_v_radicals;
-  unsigned char *__pyx_v_is_chiral;
-  unsigned char *__pyx_v_neighbors;
-  unsigned char **__pyx_v_orders;
-  unsigned char *__pyx_v_seen;
-  unsigned short **__pyx_v_connections;
-  unsigned short *__pyx_v_ct_stereo;
-  int *__pyx_v_stereo_sign;
-  int *__pyx_v_ct_sign;
+static PyObject *__pyx_pf_7chython_10containers_7_unpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data) {
+  int __pyx_v_isotope_shift;
   unsigned char __pyx_v_a;
   unsigned char __pyx_v_b;
-  unsigned char __pyx_v_i;
-  unsigned short __pyx_v_size;
-  unsigned short __pyx_v_shift;
-  unsigned short __pyx_v_n;
-  unsigned short __pyx_v_m;
-  unsigned short __pyx_v_bond_shift;
-  unsigned short __pyx_v_atoms_count;
-  unsigned short __pyx_v_ct_count;
-  unsigned short __pyx_v_ct_shift;
-  PyObject *__pyx_v_py_xy = 0;
+  unsigned char __pyx_v_c;
+  unsigned char __pyx_v_d;
+  unsigned int __pyx_v_na;
+  unsigned int __pyx_v_nct;
+  unsigned int __pyx_v_i;
+  unsigned int __pyx_v_j;
+  unsigned int __pyx_v_n;
+  unsigned int __pyx_v_m;
+  unsigned int __pyx_v_pack_length;
+  unsigned int __pyx_v_shift;
+  unsigned int __pyx_v_order_shift;
+  unsigned int __pyx_v_nb;
+  unsigned int __pyx_v_mapping[0xFFF];
+  unsigned int __pyx_v_atom[0xFFF];
+  unsigned int __pyx_v_isotopes[0xFFF];
+  unsigned int __pyx_v_hydrogens[0xFFF];
+  unsigned int __pyx_v_neighbors[0xFFF];
+  unsigned int __pyx_v_orders[0xFFF];
+  unsigned int __pyx_v_cis_trans_1[0xFFF];
+  unsigned int __pyx_v_cis_trans_2[0xFFF];
+  unsigned int __pyx_v_connections[0x1FFE];
+  int __pyx_v_charges[0xFFF];
+  int __pyx_v_radicals[0xFFF];
+  int __pyx_v_is_tet[0xFFF];
+  int __pyx_v_is_all[0xFFF];
+  int __pyx_v_tet_sign[0xFFF];
+  int __pyx_v_all_sign[0xFFF];
+  int __pyx_v_ct_sign[0xFFF];
+  double __pyx_v_x[0xFFF];
+  double __pyx_v_y[0xFFF];
+  int __pyx_v_seen[0x1000];
   PyObject *__pyx_v_bond = 0;
-  PyObject *__pyx_v_py_n = 0;
-  PyObject *__pyx_v_py_m = 0;
-  PyObject *__pyx_v_py_mapping = 0;
-  PyObject *__pyx_v_py_atoms = 0;
-  PyObject *__pyx_v_py_isotopes = 0;
-  PyObject *__pyx_v_py_bonds_flat = 0;
   PyObject *__pyx_v_py_charges = 0;
   PyObject *__pyx_v_py_radicals = 0;
   PyObject *__pyx_v_py_hydrogens = 0;
   PyObject *__pyx_v_py_plane = 0;
   PyObject *__pyx_v_py_bonds = 0;
-  PyObject *__pyx_v_py_ngb = 0;
+  PyObject *__pyx_v_tmp = 0;
   PyObject *__pyx_v_py_atoms_stereo = 0;
   PyObject *__pyx_v_py_allenes_stereo = 0;
   PyObject *__pyx_v_py_cis_trans_stereo = 0;
+  PyObject *__pyx_v_py_mapping = 0;
+  PyObject *__pyx_v_py_atoms = 0;
+  PyObject *__pyx_v_py_isotopes = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  size_t __pyx_t_1;
-  long __pyx_t_2;
-  long __pyx_t_3;
-  unsigned short __pyx_t_4;
-  int __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
-  unsigned short __pyx_t_7;
-  unsigned char __pyx_t_8;
-  unsigned char __pyx_t_9;
-  unsigned char __pyx_t_10;
-  unsigned short __pyx_t_11;
-  PyObject *__pyx_t_12 = NULL;
-  int __pyx_t_13;
-  PyObject *__pyx_t_14 = NULL;
+  Py_ssize_t __pyx_t_1;
+  unsigned char __pyx_t_2;
+  unsigned char __pyx_t_3;
+  unsigned char __pyx_t_4;
+  unsigned int __pyx_t_5;
+  unsigned int __pyx_t_6;
+  unsigned int __pyx_t_7;
+  size_t __pyx_t_8;
+  long __pyx_t_9;
+  int __pyx_t_10;
+  long __pyx_t_11;
+  unsigned char __pyx_t_12;
+  PyObject *__pyx_t_13 = NULL;
+  int __pyx_t_14;
   PyObject *__pyx_t_15 = NULL;
   PyObject *__pyx_t_16 = NULL;
+  unsigned int __pyx_t_17;
+  unsigned int __pyx_t_18;
+  unsigned int __pyx_t_19;
+  PyObject *__pyx_t_20 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("unpack", 0);
 
-  /* "chython/containers/_cpack.pyx":59
- * 
- *     cdef unsigned char a, b, i
- *     cdef unsigned short size, shift = 1, n, m, bond_shift, atoms_count, ct_count = 0, ct_shift = 0             # <<<<<<<<<<<<<<
- * 
- *     cdef tuple py_xy
+  /* "chython/containers/_unpack.pyx":28
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
+ *     cdef unsigned int na, nct, i, j, n, m, pack_length, shift = 4, order_shift = 0, nb = 0             # <<<<<<<<<<<<<<
+ * 
+ *     cdef unsigned int[4095] mapping, atom, isotopes, hydrogens, neighbors, orders, cis_trans_1, cis_trans_2
+ */
+  __pyx_v_shift = 4;
+  __pyx_v_order_shift = 0;
+  __pyx_v_nb = 0;
+
+  /* "chython/containers/_unpack.pyx":43
+ * 
+ *     # lets extract data
+ *     a, b, c = data[1], data[2], data[3]             # <<<<<<<<<<<<<<
+ *     na = a << 4| (b & 0xf0) >> 4
+ *     nct = (b & 0x0f) << 8 | c
+ */
+  __pyx_t_1 = 1;
+  if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+  __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+  __pyx_t_1 = 2;
+  if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+  __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+  __pyx_t_1 = 3;
+  if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+  __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+  __pyx_v_a = __pyx_t_2;
+  __pyx_v_b = __pyx_t_3;
+  __pyx_v_c = __pyx_t_4;
+
+  /* "chython/containers/_unpack.pyx":44
+ *     # lets extract data
+ *     a, b, c = data[1], data[2], data[3]
+ *     na = a << 4| (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *     nct = (b & 0x0f) << 8 | c
+ * 
+ */
+  __pyx_v_na = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
+
+  /* "chython/containers/_unpack.pyx":45
+ *     a, b, c = data[1], data[2], data[3]
+ *     na = a << 4| (b & 0xf0) >> 4
+ *     nct = (b & 0x0f) << 8 | c             # <<<<<<<<<<<<<<
+ * 
+ *     for i in range(na):
+ */
+  __pyx_v_nct = (((__pyx_v_b & 0x0f) << 8) | __pyx_v_c);
+
+  /* "chython/containers/_unpack.pyx":47
+ *     nct = (b & 0x0f) << 8 | c
+ * 
+ *     for i in range(na):             # <<<<<<<<<<<<<<
+ *         a, b = data[shift], data[shift + 1]
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ */
+  __pyx_t_5 = __pyx_v_na;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
+
+    /* "chython/containers/_unpack.pyx":48
+ * 
+ *     for i in range(na):
+ *         a, b = data[shift], data[shift + 1]             # <<<<<<<<<<<<<<
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ *         seen[n] = False
+ */
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_4;
+    __pyx_v_b = __pyx_t_3;
+
+    /* "chython/containers/_unpack.pyx":49
+ *     for i in range(na):
+ *         a, b = data[shift], data[shift + 1]
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *         seen[n] = False
+ *         neighbors[i] = b & 0x0f
+ */
+    __pyx_t_9 = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
+    (__pyx_v_mapping[__pyx_v_i]) = __pyx_t_9;
+    __pyx_v_n = __pyx_t_9;
+
+    /* "chython/containers/_unpack.pyx":50
+ *         a, b = data[shift], data[shift + 1]
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ *         seen[n] = False             # <<<<<<<<<<<<<<
+ *         neighbors[i] = b & 0x0f
+ *         nb += b & 0x0f
  */
-  __pyx_v_shift = 1;
-  __pyx_v_ct_count = 0;
-  __pyx_v_ct_shift = 0;
+    (__pyx_v_seen[__pyx_v_n]) = 0;
 
-  /* "chython/containers/_cpack.pyx":68
+    /* "chython/containers/_unpack.pyx":51
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ *         seen[n] = False
+ *         neighbors[i] = b & 0x0f             # <<<<<<<<<<<<<<
+ *         nb += b & 0x0f
  * 
- *     # allocate memory
- *     size = len(data)             # <<<<<<<<<<<<<<
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
  */
-  __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_v_data); 
-  __pyx_v_size = __pyx_t_1;
-
-  /* "chython/containers/_cpack.pyx":69
- *     # allocate memory
- *     size = len(data)
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_atoms = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":70
- *     size = len(data)
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))             # <<<<<<<<<<<<<<
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_charges = ((char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(char)))));
-
-  /* "chython/containers/_cpack.pyx":71
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_radicals = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":72
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- */
-  __pyx_v_hydrogens = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":73
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- */
-  __pyx_v_is_chiral = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":74
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))             # <<<<<<<<<<<<<<
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- */
-  __pyx_v_stereo_sign = ((int *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(int)))));
-
-  /* "chython/containers/_cpack.pyx":75
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))             # <<<<<<<<<<<<<<
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_ct_stereo = ((unsigned short *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned short)))));
-
-  /* "chython/containers/_cpack.pyx":76
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))             # <<<<<<<<<<<<<<
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_ct_sign = ((int *)PyMem_Malloc(((((long)__pyx_v_size) / 6) * (sizeof(int)))));
-
-  /* "chython/containers/_cpack.pyx":77
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- */
-  __pyx_v_seen = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":78
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- */
-  __pyx_v_neighbors = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":79
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))             # <<<<<<<<<<<<<<
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- *     for n in range(size / 3):
- */
-  __pyx_v_connections = ((unsigned short **)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned short *)))));
-
-  /* "chython/containers/_cpack.pyx":80
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))             # <<<<<<<<<<<<<<
- *     for n in range(size / 3):
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))
- */
-  __pyx_v_orders = ((unsigned char **)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char *)))));
-
-  /* "chython/containers/_cpack.pyx":81
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- *     for n in range(size / 3):             # <<<<<<<<<<<<<<
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))
- *         orders[n] = <unsigned char*> PyMem_Malloc(15 * sizeof(unsigned char))
- */
-  __pyx_t_2 = (((long)__pyx_v_size) / 3);
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_n = __pyx_t_4;
+    (__pyx_v_neighbors[__pyx_v_i]) = (__pyx_v_b & 0x0f);
 
-    /* "chython/containers/_cpack.pyx":82
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- *     for n in range(size / 3):
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))             # <<<<<<<<<<<<<<
- *         orders[n] = <unsigned char*> PyMem_Malloc(15 * sizeof(unsigned char))
+    /* "chython/containers/_unpack.pyx":52
+ *         seen[n] = False
+ *         neighbors[i] = b & 0x0f
+ *         nb += b & 0x0f             # <<<<<<<<<<<<<<
  * 
+ *         a, b = data[shift + 2], data[shift + 3]
  */
-    (__pyx_v_connections[__pyx_v_n]) = ((unsigned short *)PyMem_Malloc((15 * (sizeof(unsigned short)))));
+    __pyx_v_nb = (__pyx_v_nb + (__pyx_v_b & 0x0f));
 
-    /* "chython/containers/_cpack.pyx":83
- *     for n in range(size / 3):
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))
- *         orders[n] = <unsigned char*> PyMem_Malloc(15 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
+    /* "chython/containers/_unpack.pyx":54
+ *         nb += b & 0x0f
  * 
- *     # unpack atom block to separate attributes arrays
+ *         a, b = data[shift + 2], data[shift + 3]             # <<<<<<<<<<<<<<
+ *         if a & 0x80:
+ *             is_tet[i] = True
  */
-    (__pyx_v_orders[__pyx_v_n]) = ((unsigned char *)PyMem_Malloc((15 * (sizeof(unsigned char)))));
-  }
+    __pyx_t_1 = (__pyx_v_shift + 2);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 3);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_3;
+    __pyx_v_b = __pyx_t_4;
 
-  /* "chython/containers/_cpack.pyx":86
+    /* "chython/containers/_unpack.pyx":55
  * 
- *     # unpack atom block to separate attributes arrays
- *     n = 0             # <<<<<<<<<<<<<<
- *     while shift < size:
- *         seen[n] = 0  # erase randomness
+ *         a, b = data[shift + 2], data[shift + 3]
+ *         if a & 0x80:             # <<<<<<<<<<<<<<
+ *             is_tet[i] = True
+ *             tet_sign[i] = a & 0x40
  */
-  __pyx_v_n = 0;
-
-  /* "chython/containers/_cpack.pyx":87
- *     # unpack atom block to separate attributes arrays
- *     n = 0
- *     while shift < size:             # <<<<<<<<<<<<<<
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]
- */
-  while (1) {
-    __pyx_t_5 = ((__pyx_v_shift < __pyx_v_size) != 0);
-    if (!__pyx_t_5) break;
-
-    /* "chython/containers/_cpack.pyx":88
- *     n = 0
- *     while shift < size:
- *         seen[n] = 0  # erase randomness             # <<<<<<<<<<<<<<
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack
- */
-    (__pyx_v_seen[__pyx_v_n]) = 0;
+    __pyx_t_10 = ((__pyx_v_a & 0x80) != 0);
+    if (__pyx_t_10) {
 
-    /* "chython/containers/_cpack.pyx":89
- *     while shift < size:
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]             # <<<<<<<<<<<<<<
- *         if a & 0x80 == 0:  # end of pack
- *             break
+      /* "chython/containers/_unpack.pyx":56
+ *         a, b = data[shift + 2], data[shift + 3]
+ *         if a & 0x80:
+ *             is_tet[i] = True             # <<<<<<<<<<<<<<
+ *             tet_sign[i] = a & 0x40
+ *         else:
  */
-    __pyx_t_1 = __pyx_v_shift;
-    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+      (__pyx_v_is_tet[__pyx_v_i]) = 1;
 
-    /* "chython/containers/_cpack.pyx":90
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack             # <<<<<<<<<<<<<<
- *             break
- *         atoms[n] = a & 0x7f
+      /* "chython/containers/_unpack.pyx":57
+ *         if a & 0x80:
+ *             is_tet[i] = True
+ *             tet_sign[i] = a & 0x40             # <<<<<<<<<<<<<<
+ *         else:
+ *             is_tet[i] = False
  */
-    __pyx_t_5 = (((__pyx_v_a & 0x80) == 0) != 0);
-    if (__pyx_t_5) {
+      (__pyx_v_tet_sign[__pyx_v_i]) = (__pyx_v_a & 0x40);
 
-      /* "chython/containers/_cpack.pyx":91
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack
- *             break             # <<<<<<<<<<<<<<
- *         atoms[n] = a & 0x7f
+      /* "chython/containers/_unpack.pyx":55
  * 
+ *         a, b = data[shift + 2], data[shift + 3]
+ *         if a & 0x80:             # <<<<<<<<<<<<<<
+ *             is_tet[i] = True
+ *             tet_sign[i] = a & 0x40
  */
-      goto __pyx_L6_break;
+      goto __pyx_L5;
+    }
 
-      /* "chython/containers/_cpack.pyx":90
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack             # <<<<<<<<<<<<<<
- *             break
- *         atoms[n] = a & 0x7f
+    /* "chython/containers/_unpack.pyx":59
+ *             tet_sign[i] = a & 0x40
+ *         else:
+ *             is_tet[i] = False             # <<<<<<<<<<<<<<
+ *         if a & 0x20:
+ *             is_all[i] = True
  */
+    /*else*/ {
+      (__pyx_v_is_tet[__pyx_v_i]) = 0;
     }
+    __pyx_L5:;
 
-    /* "chython/containers/_cpack.pyx":92
- *         if a & 0x80 == 0:  # end of pack
- *             break
- *         atoms[n] = a & 0x7f             # <<<<<<<<<<<<<<
- * 
- *         a = data[shift + 1]
+    /* "chython/containers/_unpack.pyx":60
+ *         else:
+ *             is_tet[i] = False
+ *         if a & 0x20:             # <<<<<<<<<<<<<<
+ *             is_all[i] = True
+ *             all_sign[i] = a & 0x10
  */
-    (__pyx_v_atoms[__pyx_v_n]) = (__pyx_v_a & 0x7f);
+    __pyx_t_10 = ((__pyx_v_a & 0x20) != 0);
+    if (__pyx_t_10) {
 
-    /* "chython/containers/_cpack.pyx":94
- *         atoms[n] = a & 0x7f
- * 
- *         a = data[shift + 1]             # <<<<<<<<<<<<<<
- *         hydrogens[n] = a >> 5
- *         charges[n] = ((a >> 1) & 0x0f) - 4
+      /* "chython/containers/_unpack.pyx":61
+ *             is_tet[i] = False
+ *         if a & 0x20:
+ *             is_all[i] = True             # <<<<<<<<<<<<<<
+ *             all_sign[i] = a & 0x10
+ *         else:
  */
-    __pyx_t_6 = (__pyx_v_shift + 1);
-    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_6)) )));
+      (__pyx_v_is_all[__pyx_v_i]) = 1;
 
-    /* "chython/containers/_cpack.pyx":95
- * 
- *         a = data[shift + 1]
- *         hydrogens[n] = a >> 5             # <<<<<<<<<<<<<<
- *         charges[n] = ((a >> 1) & 0x0f) - 4
- *         radicals[n] = a & 0x01
+      /* "chython/containers/_unpack.pyx":62
+ *         if a & 0x20:
+ *             is_all[i] = True
+ *             all_sign[i] = a & 0x10             # <<<<<<<<<<<<<<
+ *         else:
+ *             is_all[i] = False
  */
-    (__pyx_v_hydrogens[__pyx_v_n]) = (__pyx_v_a >> 5);
+      (__pyx_v_all_sign[__pyx_v_i]) = (__pyx_v_a & 0x10);
 
-    /* "chython/containers/_cpack.pyx":96
- *         a = data[shift + 1]
- *         hydrogens[n] = a >> 5
- *         charges[n] = ((a >> 1) & 0x0f) - 4             # <<<<<<<<<<<<<<
- *         radicals[n] = a & 0x01
- * 
+      /* "chython/containers/_unpack.pyx":60
+ *         else:
+ *             is_tet[i] = False
+ *         if a & 0x20:             # <<<<<<<<<<<<<<
+ *             is_all[i] = True
+ *             all_sign[i] = a & 0x10
  */
-    (__pyx_v_charges[__pyx_v_n]) = (((__pyx_v_a >> 1) & 0x0f) - 4);
+      goto __pyx_L6;
+    }
 
-    /* "chython/containers/_cpack.pyx":97
- *         hydrogens[n] = a >> 5
- *         charges[n] = ((a >> 1) & 0x0f) - 4
- *         radicals[n] = a & 0x01             # <<<<<<<<<<<<<<
+    /* "chython/containers/_unpack.pyx":64
+ *             all_sign[i] = a & 0x10
+ *         else:
+ *             is_all[i] = False             # <<<<<<<<<<<<<<
  * 
- *         a = data[shift + 2]
+ *         atom[i] = b & 0x7f
  */
-    (__pyx_v_radicals[__pyx_v_n]) = (__pyx_v_a & 0x01);
+    /*else*/ {
+      (__pyx_v_is_all[__pyx_v_i]) = 0;
+    }
+    __pyx_L6:;
 
-    /* "chython/containers/_cpack.pyx":99
- *         radicals[n] = a & 0x01
+    /* "chython/containers/_unpack.pyx":66
+ *             is_all[i] = False
  * 
- *         a = data[shift + 2]             # <<<<<<<<<<<<<<
- *         bond_shift = a & 0x0f
- *         b = a >> 4
+ *         atom[i] = b & 0x7f             # <<<<<<<<<<<<<<
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:
  */
-    __pyx_t_6 = (__pyx_v_shift + 2);
-    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_6)) )));
+    (__pyx_v_atom[__pyx_v_i]) = (__pyx_v_b & 0x7f);
 
-    /* "chython/containers/_cpack.pyx":100
+    /* "chython/containers/_unpack.pyx":67
  * 
- *         a = data[shift + 2]
- *         bond_shift = a & 0x0f             # <<<<<<<<<<<<<<
- *         b = a >> 4
- *         if b == 0b0011:
- */
-    __pyx_v_bond_shift = (__pyx_v_a & 0x0f);
-
-    /* "chython/containers/_cpack.pyx":101
- *         a = data[shift + 2]
- *         bond_shift = a & 0x0f
- *         b = a >> 4             # <<<<<<<<<<<<<<
- *         if b == 0b0011:
- *             is_chiral[n] = 1
- */
-    __pyx_v_b = (__pyx_v_a >> 4);
-
-    /* "chython/containers/_cpack.pyx":102
- *         bond_shift = a & 0x0f
- *         b = a >> 4
- *         if b == 0b0011:             # <<<<<<<<<<<<<<
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True
- */
-    switch (__pyx_v_b) {
-      case 3:
-
-      /* "chython/containers/_cpack.pyx":103
- *         b = a >> 4
- *         if b == 0b0011:
- *             is_chiral[n] = 1             # <<<<<<<<<<<<<<
- *             stereo_sign[n] = True
- *         elif b == 0b0010:
+ *         atom[i] = b & 0x7f
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7             # <<<<<<<<<<<<<<
+ *         if isotope_shift:
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
  */
-      (__pyx_v_is_chiral[__pyx_v_n]) = 1;
+    __pyx_v_isotope_shift = (((__pyx_v_a & 0x0f) << 1) | (__pyx_v_b >> 7));
 
-      /* "chython/containers/_cpack.pyx":104
- *         if b == 0b0011:
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True             # <<<<<<<<<<<<<<
- *         elif b == 0b0010:
- *             is_chiral[n] = 1
- */
-      (__pyx_v_stereo_sign[__pyx_v_n]) = 1;
-
-      /* "chython/containers/_cpack.pyx":102
- *         bond_shift = a & 0x0f
- *         b = a >> 4
- *         if b == 0b0011:             # <<<<<<<<<<<<<<
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True
- */
-      break;
-      case 2:
-
-      /* "chython/containers/_cpack.pyx":106
- *             stereo_sign[n] = True
- *         elif b == 0b0010:
- *             is_chiral[n] = 1             # <<<<<<<<<<<<<<
- *             stereo_sign[n] = False
+    /* "chython/containers/_unpack.pyx":68
+ *         atom[i] = b & 0x7f
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:             # <<<<<<<<<<<<<<
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
  *         else:
  */
-      (__pyx_v_is_chiral[__pyx_v_n]) = 1;
+    __pyx_t_10 = (__pyx_v_isotope_shift != 0);
+    if (__pyx_t_10) {
 
-      /* "chython/containers/_cpack.pyx":107
- *         elif b == 0b0010:
- *             is_chiral[n] = 1
- *             stereo_sign[n] = False             # <<<<<<<<<<<<<<
+      /* "chython/containers/_unpack.pyx":69
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift             # <<<<<<<<<<<<<<
  *         else:
- *             is_chiral[n] = 0
+ *             isotopes[i] = 0
  */
-      (__pyx_v_stereo_sign[__pyx_v_n]) = 0;
+      (__pyx_v_isotopes[__pyx_v_i]) = ((__pyx_v_7chython_10containers_7_unpack_common_isotopes[(__pyx_v_b & 0x7f)]) + __pyx_v_isotope_shift);
 
-      /* "chython/containers/_cpack.pyx":105
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True
- *         elif b == 0b0010:             # <<<<<<<<<<<<<<
- *             is_chiral[n] = 1
- *             stereo_sign[n] = False
+      /* "chython/containers/_unpack.pyx":68
+ *         atom[i] = b & 0x7f
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:             # <<<<<<<<<<<<<<
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
+ *         else:
  */
-      break;
-      default:
+      goto __pyx_L7;
+    }
 
-      /* "chython/containers/_cpack.pyx":109
- *             stereo_sign[n] = False
+    /* "chython/containers/_unpack.pyx":71
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
  *         else:
- *             is_chiral[n] = 0             # <<<<<<<<<<<<<<
+ *             isotopes[i] = 0             # <<<<<<<<<<<<<<
  * 
- *         shift += 3
+ *         a, b = data[shift + 4], data[shift + 5]
  */
-      (__pyx_v_is_chiral[__pyx_v_n]) = 0;
-      break;
+    /*else*/ {
+      (__pyx_v_isotopes[__pyx_v_i]) = 0;
     }
+    __pyx_L7:;
 
-    /* "chython/containers/_cpack.pyx":111
- *             is_chiral[n] = 0
+    /* "chython/containers/_unpack.pyx":73
+ *             isotopes[i] = 0
  * 
- *         shift += 3             # <<<<<<<<<<<<<<
- *         neighbors[n] = 0
- *         for i in range(bond_shift):
+ *         a, b = data[shift + 4], data[shift + 5]             # <<<<<<<<<<<<<<
+ *         x[i] = double_from2bytes(a, b)
+ *         a, b = data[shift + 6], data[shift + 7]
+ */
+    __pyx_t_1 = (__pyx_v_shift + 4);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 5);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_4;
+    __pyx_v_b = __pyx_t_3;
+
+    /* "chython/containers/_unpack.pyx":74
+ * 
+ *         a, b = data[shift + 4], data[shift + 5]
+ *         x[i] = double_from2bytes(a, b)             # <<<<<<<<<<<<<<
+ *         a, b = data[shift + 6], data[shift + 7]
+ *         y[i] = double_from2bytes(a, b)
+ */
+    (__pyx_v_x[__pyx_v_i]) = __pyx_f_7chython_10containers_7_unpack_double_from2bytes(__pyx_v_a, __pyx_v_b);
+
+    /* "chython/containers/_unpack.pyx":75
+ *         a, b = data[shift + 4], data[shift + 5]
+ *         x[i] = double_from2bytes(a, b)
+ *         a, b = data[shift + 6], data[shift + 7]             # <<<<<<<<<<<<<<
+ *         y[i] = double_from2bytes(a, b)
+ * 
+ */
+    __pyx_t_1 = (__pyx_v_shift + 6);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 7);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_3;
+    __pyx_v_b = __pyx_t_4;
+
+    /* "chython/containers/_unpack.pyx":76
+ *         x[i] = double_from2bytes(a, b)
+ *         a, b = data[shift + 6], data[shift + 7]
+ *         y[i] = double_from2bytes(a, b)             # <<<<<<<<<<<<<<
+ * 
+ *         a = data[shift + 8]
+ */
+    (__pyx_v_y[__pyx_v_i]) = __pyx_f_7chython_10containers_7_unpack_double_from2bytes(__pyx_v_a, __pyx_v_b);
+
+    /* "chython/containers/_unpack.pyx":78
+ *         y[i] = double_from2bytes(a, b)
+ * 
+ *         a = data[shift + 8]             # <<<<<<<<<<<<<<
+ *         hydrogens[i] = a >> 5
+ *         charges[i] = ((a >> 1) & 0x0f) - 4
  */
-    __pyx_v_shift = (__pyx_v_shift + 3);
+    __pyx_t_1 = (__pyx_v_shift + 8);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
 
-    /* "chython/containers/_cpack.pyx":112
+    /* "chython/containers/_unpack.pyx":79
  * 
- *         shift += 3
- *         neighbors[n] = 0             # <<<<<<<<<<<<<<
- *         for i in range(bond_shift):
- *             a, b = data[shift], data[shift + 1]
- */
-    (__pyx_v_neighbors[__pyx_v_n]) = 0;
-
-    /* "chython/containers/_cpack.pyx":113
- *         shift += 3
- *         neighbors[n] = 0
- *         for i in range(bond_shift):             # <<<<<<<<<<<<<<
- *             a, b = data[shift], data[shift + 1]
- *             shift += 2
+ *         a = data[shift + 8]
+ *         hydrogens[i] = a >> 5             # <<<<<<<<<<<<<<
+ *         charges[i] = ((a >> 1) & 0x0f) - 4
+ *         radicals[i] = a & 0x01
  */
-    __pyx_t_4 = __pyx_v_bond_shift;
-    __pyx_t_7 = __pyx_t_4;
-    for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
-      __pyx_v_i = __pyx_t_8;
+    (__pyx_v_hydrogens[__pyx_v_i]) = (__pyx_v_a >> 5);
 
-      /* "chython/containers/_cpack.pyx":114
- *         neighbors[n] = 0
- *         for i in range(bond_shift):
- *             a, b = data[shift], data[shift + 1]             # <<<<<<<<<<<<<<
- *             shift += 2
+    /* "chython/containers/_unpack.pyx":80
+ *         a = data[shift + 8]
+ *         hydrogens[i] = a >> 5
+ *         charges[i] = ((a >> 1) & 0x0f) - 4             # <<<<<<<<<<<<<<
+ *         radicals[i] = a & 0x01
  * 
  */
-      __pyx_t_1 = __pyx_v_shift;
-      __pyx_t_9 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
-      __pyx_t_6 = (__pyx_v_shift + 1);
-      __pyx_t_10 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_6)) )));
-      __pyx_v_a = __pyx_t_9;
-      __pyx_v_b = __pyx_t_10;
+    (__pyx_v_charges[__pyx_v_i]) = (((__pyx_v_a >> 1) & 0x0f) - 4);
 
-      /* "chython/containers/_cpack.pyx":115
- *         for i in range(bond_shift):
- *             a, b = data[shift], data[shift + 1]
- *             shift += 2             # <<<<<<<<<<<<<<
+    /* "chython/containers/_unpack.pyx":81
+ *         hydrogens[i] = a >> 5
+ *         charges[i] = ((a >> 1) & 0x0f) - 4
+ *         radicals[i] = a & 0x01             # <<<<<<<<<<<<<<
  * 
- *             m = n - (a << 4 | b >> 4)  # second atom index
+ *         shift += 9
  */
-      __pyx_v_shift = (__pyx_v_shift + 2);
+    (__pyx_v_radicals[__pyx_v_i]) = (__pyx_v_a & 0x01);
 
-      /* "chython/containers/_cpack.pyx":117
- *             shift += 2
+    /* "chython/containers/_unpack.pyx":83
+ *         radicals[i] = a & 0x01
  * 
- *             m = n - (a << 4 | b >> 4)  # second atom index             # <<<<<<<<<<<<<<
- *             b &= 0x0f
+ *         shift += 9             # <<<<<<<<<<<<<<
  * 
+ *     nb //= 2
  */
-      __pyx_v_m = (__pyx_v_n - ((__pyx_v_a << 4) | (__pyx_v_b >> 4)));
+    __pyx_v_shift = (__pyx_v_shift + 9);
+  }
 
-      /* "chython/containers/_cpack.pyx":118
- * 
- *             m = n - (a << 4 | b >> 4)  # second atom index
- *             b &= 0x0f             # <<<<<<<<<<<<<<
+  /* "chython/containers/_unpack.pyx":85
+ *         shift += 9
  * 
- *             if b < 8:
+ *     nb //= 2             # <<<<<<<<<<<<<<
+ *     for i in range(nb):
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
  */
-      __pyx_v_b = (__pyx_v_b & 0x0f);
+  __pyx_v_nb = __Pyx_div_long(__pyx_v_nb, 2);
 
-      /* "chython/containers/_cpack.pyx":120
- *             b &= 0x0f
+  /* "chython/containers/_unpack.pyx":86
  * 
- *             if b < 8:             # <<<<<<<<<<<<<<
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n
+ *     nb //= 2
+ *     for i in range(nb):             # <<<<<<<<<<<<<<
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
  */
-      __pyx_t_5 = ((__pyx_v_b < 8) != 0);
-      if (__pyx_t_5) {
+  __pyx_t_5 = __pyx_v_nb;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
 
-        /* "chython/containers/_cpack.pyx":121
- * 
- *             if b < 8:
- *                 connections[n][neighbors[n]] = m             # <<<<<<<<<<<<<<
- *                 connections[m][neighbors[m]] = n
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- */
-        ((__pyx_v_connections[__pyx_v_n])[(__pyx_v_neighbors[__pyx_v_n])]) = __pyx_v_m;
-
-        /* "chython/containers/_cpack.pyx":122
- *             if b < 8:
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n             # <<<<<<<<<<<<<<
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- *                 neighbors[n] += 1
- */
-        ((__pyx_v_connections[__pyx_v_m])[(__pyx_v_neighbors[__pyx_v_m])]) = __pyx_v_n;
-
-        /* "chython/containers/_cpack.pyx":123
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n
- *                 orders[m][neighbors[m]] = b + 1  # only single direction             # <<<<<<<<<<<<<<
- *                 neighbors[n] += 1
- *                 neighbors[m] += 1
- */
-        ((__pyx_v_orders[__pyx_v_m])[(__pyx_v_neighbors[__pyx_v_m])]) = (__pyx_v_b + 1);
-
-        /* "chython/containers/_cpack.pyx":124
- *                 connections[m][neighbors[m]] = n
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- *                 neighbors[n] += 1             # <<<<<<<<<<<<<<
- *                 neighbors[m] += 1
- *             else:  # CT stereo
- */
-        __pyx_t_11 = __pyx_v_n;
-        (__pyx_v_neighbors[__pyx_t_11]) = ((__pyx_v_neighbors[__pyx_t_11]) + 1);
-
-        /* "chython/containers/_cpack.pyx":125
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- *                 neighbors[n] += 1
- *                 neighbors[m] += 1             # <<<<<<<<<<<<<<
- *             else:  # CT stereo
- *                 ct_stereo[ct_shift] = m + 1
- */
-        __pyx_t_11 = __pyx_v_m;
-        (__pyx_v_neighbors[__pyx_t_11]) = ((__pyx_v_neighbors[__pyx_t_11]) + 1);
-
-        /* "chython/containers/_cpack.pyx":120
- *             b &= 0x0f
- * 
- *             if b < 8:             # <<<<<<<<<<<<<<
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n
+    /* "chython/containers/_unpack.pyx":87
+ *     nb //= 2
+ *     for i in range(nb):
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]             # <<<<<<<<<<<<<<
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c
  */
-        goto __pyx_L10;
-      }
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 2);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_4;
+    __pyx_v_b = __pyx_t_3;
+    __pyx_v_c = __pyx_t_2;
 
-      /* "chython/containers/_cpack.pyx":127
- *                 neighbors[m] += 1
- *             else:  # CT stereo
- *                 ct_stereo[ct_shift] = m + 1             # <<<<<<<<<<<<<<
- *                 ct_stereo[ct_shift + 1] = n + 1
- *                 ct_sign[ct_count] = b & 0x01
+    /* "chython/containers/_unpack.pyx":88
+ *     for i in range(nb):
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c
+ *         shift += 3
  */
-      /*else*/ {
-        (__pyx_v_ct_stereo[__pyx_v_ct_shift]) = (__pyx_v_m + 1);
+    (__pyx_v_connections[(__pyx_v_i * 2)]) = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
 
-        /* "chython/containers/_cpack.pyx":128
- *             else:  # CT stereo
- *                 ct_stereo[ct_shift] = m + 1
- *                 ct_stereo[ct_shift + 1] = n + 1             # <<<<<<<<<<<<<<
- *                 ct_sign[ct_count] = b & 0x01
- *                 ct_count += 1
- */
-        (__pyx_v_ct_stereo[(__pyx_v_ct_shift + 1)]) = (__pyx_v_n + 1);
-
-        /* "chython/containers/_cpack.pyx":129
- *                 ct_stereo[ct_shift] = m + 1
- *                 ct_stereo[ct_shift + 1] = n + 1
- *                 ct_sign[ct_count] = b & 0x01             # <<<<<<<<<<<<<<
- *                 ct_count += 1
- *                 ct_shift += 2
- */
-        (__pyx_v_ct_sign[__pyx_v_ct_count]) = (__pyx_v_b & 0x01);
-
-        /* "chython/containers/_cpack.pyx":130
- *                 ct_stereo[ct_shift + 1] = n + 1
- *                 ct_sign[ct_count] = b & 0x01
- *                 ct_count += 1             # <<<<<<<<<<<<<<
- *                 ct_shift += 2
- *         n += 1
- */
-        __pyx_v_ct_count = (__pyx_v_ct_count + 1);
-
-        /* "chython/containers/_cpack.pyx":131
- *                 ct_sign[ct_count] = b & 0x01
- *                 ct_count += 1
- *                 ct_shift += 2             # <<<<<<<<<<<<<<
- *         n += 1
- *     atoms_count = n
+    /* "chython/containers/_unpack.pyx":89
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c             # <<<<<<<<<<<<<<
+ *         shift += 3
+ * 
  */
-        __pyx_v_ct_shift = (__pyx_v_ct_shift + 2);
-      }
-      __pyx_L10:;
-    }
+    (__pyx_v_connections[((__pyx_v_i * 2) + 1)]) = (((__pyx_v_b & 0x0f) << 8) | __pyx_v_c);
 
-    /* "chython/containers/_cpack.pyx":132
- *                 ct_count += 1
- *                 ct_shift += 2
- *         n += 1             # <<<<<<<<<<<<<<
- *     atoms_count = n
+    /* "chython/containers/_unpack.pyx":90
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c
+ *         shift += 3             # <<<<<<<<<<<<<<
  * 
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):
  */
-    __pyx_v_n = (__pyx_v_n + 1);
+    __pyx_v_shift = (__pyx_v_shift + 3);
   }
-  __pyx_L6_break:;
 
-  /* "chython/containers/_cpack.pyx":133
- *                 ct_shift += 2
- *         n += 1
- *     atoms_count = n             # <<<<<<<<<<<<<<
+  /* "chython/containers/_unpack.pyx":92
+ *         shift += 3
+ * 
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):             # <<<<<<<<<<<<<<
+ *         a, b = data[shift], data[shift + 1]
+ *         orders[i * 5] = (a >> 4) + 1
+ */
+  if ((__Pyx_mod_long(__pyx_v_nb, 5) != 0)) {
+    __pyx_t_9 = (__Pyx_div_long(__pyx_v_nb, 5) + 1);
+  } else {
+    __pyx_t_9 = __Pyx_div_long(__pyx_v_nb, 5);
+  }
+  __pyx_t_11 = __pyx_t_9;
+  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_11; __pyx_t_5+=1) {
+    __pyx_v_i = __pyx_t_5;
+
+    /* "chython/containers/_unpack.pyx":93
+ * 
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):
+ *         a, b = data[shift], data[shift + 1]             # <<<<<<<<<<<<<<
+ *         orders[i * 5] = (a >> 4) + 1
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ */
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_2;
+    __pyx_v_b = __pyx_t_3;
+
+    /* "chython/containers/_unpack.pyx":94
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):
+ *         a, b = data[shift], data[shift + 1]
+ *         orders[i * 5] = (a >> 4) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ */
+    (__pyx_v_orders[(__pyx_v_i * 5)]) = ((__pyx_v_a >> 4) + 1);
+
+    /* "chython/containers/_unpack.pyx":95
+ *         a, b = data[shift], data[shift + 1]
+ *         orders[i * 5] = (a >> 4) + 1
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 1)]) = (((__pyx_v_a >> 1) & 0x07) + 1);
+
+    /* "chython/containers/_unpack.pyx":96
+ *         orders[i * 5] = (a >> 4) + 1
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ *         orders[i * 5 + 4] = (b & 0x07) + 1
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 2)]) = ((((__pyx_v_a & 0x01) << 2) | (__pyx_v_b >> 6)) + 1);
+
+    /* "chython/containers/_unpack.pyx":97
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 4] = (b & 0x07) + 1
+ *         shift += 2
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 3)]) = (((__pyx_v_b >> 3) & 0x07) + 1);
+
+    /* "chython/containers/_unpack.pyx":98
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ *         orders[i * 5 + 4] = (b & 0x07) + 1             # <<<<<<<<<<<<<<
+ *         shift += 2
+ * 
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 4)]) = ((__pyx_v_b & 0x07) + 1);
+
+    /* "chython/containers/_unpack.pyx":99
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ *         orders[i * 5 + 4] = (b & 0x07) + 1
+ *         shift += 2             # <<<<<<<<<<<<<<
+ * 
+ *     for i in range(nct):
+ */
+    __pyx_v_shift = (__pyx_v_shift + 2);
+  }
+
+  /* "chython/containers/_unpack.pyx":101
+ *         shift += 2
+ * 
+ *     for i in range(nct):             # <<<<<<<<<<<<<<
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ */
+  __pyx_t_5 = __pyx_v_nct;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
+
+    /* "chython/containers/_unpack.pyx":102
+ * 
+ *     for i in range(nct):
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]             # <<<<<<<<<<<<<<
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ */
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 2);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 3);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_12 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_3;
+    __pyx_v_b = __pyx_t_2;
+    __pyx_v_c = __pyx_t_4;
+    __pyx_v_d = __pyx_t_12;
+
+    /* "chython/containers/_unpack.pyx":103
+ *     for i in range(nct):
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ *         ct_sign[i] = d & 0x01
+ */
+    (__pyx_v_cis_trans_1[__pyx_v_i]) = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
+
+    /* "chython/containers/_unpack.pyx":104
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c             # <<<<<<<<<<<<<<
+ *         ct_sign[i] = d & 0x01
+ *         shift += 4
+ */
+    (__pyx_v_cis_trans_2[__pyx_v_i]) = (((__pyx_v_b & 0x0f) << 8) | __pyx_v_c);
+
+    /* "chython/containers/_unpack.pyx":105
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ *         ct_sign[i] = d & 0x01             # <<<<<<<<<<<<<<
+ *         shift += 4
+ *     pack_length = shift
+ */
+    (__pyx_v_ct_sign[__pyx_v_i]) = (__pyx_v_d & 0x01);
+
+    /* "chython/containers/_unpack.pyx":106
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ *         ct_sign[i] = d & 0x01
+ *         shift += 4             # <<<<<<<<<<<<<<
+ *     pack_length = shift
+ * 
+ */
+    __pyx_v_shift = (__pyx_v_shift + 4);
+  }
+
+  /* "chython/containers/_unpack.pyx":107
+ *         ct_sign[i] = d & 0x01
+ *         shift += 4
+ *     pack_length = shift             # <<<<<<<<<<<<<<
  * 
  *     # define returned data
  */
-  __pyx_v_atoms_count = __pyx_v_n;
+  __pyx_v_pack_length = __pyx_v_shift;
 
-  /* "chython/containers/_cpack.pyx":136
+  /* "chython/containers/_unpack.pyx":110
  * 
  *     # define returned data
  *     py_mapping = []             # <<<<<<<<<<<<<<
  *     py_atoms = []
  *     py_isotopes = []
  */
-  __pyx_t_12 = PyList_New(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 136, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_mapping = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 110, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_mapping = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":137
+  /* "chython/containers/_unpack.pyx":111
  *     # define returned data
  *     py_mapping = []
  *     py_atoms = []             # <<<<<<<<<<<<<<
  *     py_isotopes = []
- *     py_charges = {}
+ *     py_bonds = {}
  */
-  __pyx_t_12 = PyList_New(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_atoms = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 111, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_atoms = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":138
+  /* "chython/containers/_unpack.pyx":112
  *     py_mapping = []
  *     py_atoms = []
  *     py_isotopes = []             # <<<<<<<<<<<<<<
+ *     py_bonds = {}
  *     py_charges = {}
- *     py_radicals = {}
  */
-  __pyx_t_12 = PyList_New(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 138, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_isotopes = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 112, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_isotopes = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":139
+  /* "chython/containers/_unpack.pyx":113
  *     py_atoms = []
  *     py_isotopes = []
+ *     py_bonds = {}             # <<<<<<<<<<<<<<
+ *     py_charges = {}
+ *     py_radicals = {}
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 113, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_bonds = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":114
+ *     py_isotopes = []
+ *     py_bonds = {}
  *     py_charges = {}             # <<<<<<<<<<<<<<
  *     py_radicals = {}
  *     py_hydrogens = {}
  */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 139, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_charges = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 114, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_charges = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":140
- *     py_isotopes = []
+  /* "chython/containers/_unpack.pyx":115
+ *     py_bonds = {}
  *     py_charges = {}
  *     py_radicals = {}             # <<<<<<<<<<<<<<
  *     py_hydrogens = {}
  *     py_plane = {}
  */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 140, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_radicals = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 115, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_radicals = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":141
+  /* "chython/containers/_unpack.pyx":116
  *     py_charges = {}
  *     py_radicals = {}
  *     py_hydrogens = {}             # <<<<<<<<<<<<<<
  *     py_plane = {}
  *     py_atoms_stereo = {}
  */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 141, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_hydrogens = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 116, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_hydrogens = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":142
+  /* "chython/containers/_unpack.pyx":117
  *     py_radicals = {}
  *     py_hydrogens = {}
  *     py_plane = {}             # <<<<<<<<<<<<<<
  *     py_atoms_stereo = {}
  *     py_allenes_stereo = {}
  */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 142, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_plane = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 117, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_plane = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":143
+  /* "chython/containers/_unpack.pyx":118
  *     py_hydrogens = {}
  *     py_plane = {}
  *     py_atoms_stereo = {}             # <<<<<<<<<<<<<<
  *     py_allenes_stereo = {}
  *     py_cis_trans_stereo = {}
  */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 143, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_atoms_stereo = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 118, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_atoms_stereo = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":144
+  /* "chython/containers/_unpack.pyx":119
  *     py_plane = {}
  *     py_atoms_stereo = {}
  *     py_allenes_stereo = {}             # <<<<<<<<<<<<<<
  *     py_cis_trans_stereo = {}
- *     py_bonds = {}
+ * 
  */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 144, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_allenes_stereo = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 119, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_allenes_stereo = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":145
+  /* "chython/containers/_unpack.pyx":120
  *     py_atoms_stereo = {}
  *     py_allenes_stereo = {}
  *     py_cis_trans_stereo = {}             # <<<<<<<<<<<<<<
- *     py_bonds = {}
- *     py_bonds_flat = []
- */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 145, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_cis_trans_stereo = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
-
-  /* "chython/containers/_cpack.pyx":146
- *     py_allenes_stereo = {}
- *     py_cis_trans_stereo = {}
- *     py_bonds = {}             # <<<<<<<<<<<<<<
- *     py_bonds_flat = []
- *     py_xy = (0., 0.)
- */
-  __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 146, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_bonds = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
-
-  /* "chython/containers/_cpack.pyx":147
- *     py_cis_trans_stereo = {}
- *     py_bonds = {}
- *     py_bonds_flat = []             # <<<<<<<<<<<<<<
- *     py_xy = (0., 0.)
  * 
+ *     shift = 0
  */
-  __pyx_t_12 = PyList_New(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 147, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __pyx_v_py_bonds_flat = ((PyObject*)__pyx_t_12);
-  __pyx_t_12 = 0;
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_cis_trans_stereo = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
 
-  /* "chython/containers/_cpack.pyx":148
- *     py_bonds = {}
- *     py_bonds_flat = []
- *     py_xy = (0., 0.)             # <<<<<<<<<<<<<<
- * 
- *     for n in range(atoms_count):
- */
-  __Pyx_INCREF(__pyx_tuple_);
-  __pyx_v_py_xy = __pyx_tuple_;
-
-  /* "chython/containers/_cpack.pyx":150
- *     py_xy = (0., 0.)
+  /* "chython/containers/_unpack.pyx":122
+ *     py_cis_trans_stereo = {}
  * 
- *     for n in range(atoms_count):             # <<<<<<<<<<<<<<
- *         seen[n] = 1
- *         py_n = n + 1  # shared py int obj
+ *     shift = 0             # <<<<<<<<<<<<<<
+ *     for i in range(na):
+ *         n = mapping[i]
  */
-  __pyx_t_4 = __pyx_v_atoms_count;
-  __pyx_t_7 = __pyx_t_4;
-  for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_7; __pyx_t_11+=1) {
-    __pyx_v_n = __pyx_t_11;
+  __pyx_v_shift = 0;
 
-    /* "chython/containers/_cpack.pyx":151
+  /* "chython/containers/_unpack.pyx":123
  * 
- *     for n in range(atoms_count):
- *         seen[n] = 1             # <<<<<<<<<<<<<<
- *         py_n = n + 1  # shared py int obj
+ *     shift = 0
+ *     for i in range(na):             # <<<<<<<<<<<<<<
+ *         n = mapping[i]
  * 
  */
-    (__pyx_v_seen[__pyx_v_n]) = 1;
+  __pyx_t_5 = __pyx_v_na;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
 
-    /* "chython/containers/_cpack.pyx":152
- *     for n in range(atoms_count):
- *         seen[n] = 1
- *         py_n = n + 1  # shared py int obj             # <<<<<<<<<<<<<<
+    /* "chython/containers/_unpack.pyx":124
+ *     shift = 0
+ *     for i in range(na):
+ *         n = mapping[i]             # <<<<<<<<<<<<<<
  * 
  *         # fill intermediate data
  */
-    __pyx_t_12 = __Pyx_PyInt_From_long((__pyx_v_n + 1)); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 152, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    __Pyx_XDECREF_SET(__pyx_v_py_n, __pyx_t_12);
-    __pyx_t_12 = 0;
+    __pyx_v_n = (__pyx_v_mapping[__pyx_v_i]);
 
-    /* "chython/containers/_cpack.pyx":155
+    /* "chython/containers/_unpack.pyx":127
  * 
  *         # fill intermediate data
- *         py_mapping.append(py_n)             # <<<<<<<<<<<<<<
- *         py_atoms.append(atoms[n])
- *         py_isotopes.append(None)
- */
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_py_mapping, __pyx_v_py_n); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(0, 155, __pyx_L1_error)
+ *         py_mapping.append(n)             # <<<<<<<<<<<<<<
+ *         py_atoms.append(atom[i])
+ *         py_isotopes.append(isotopes[i] or None)
+ */
+    __pyx_t_13 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 127, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_mapping, __pyx_t_13); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 127, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-    /* "chython/containers/_cpack.pyx":156
+    /* "chython/containers/_unpack.pyx":128
  *         # fill intermediate data
- *         py_mapping.append(py_n)
- *         py_atoms.append(atoms[n])             # <<<<<<<<<<<<<<
- *         py_isotopes.append(None)
+ *         py_mapping.append(n)
+ *         py_atoms.append(atom[i])             # <<<<<<<<<<<<<<
+ *         py_isotopes.append(isotopes[i] or None)
  * 
  */
-    __pyx_t_12 = __Pyx_PyInt_From_unsigned_char((__pyx_v_atoms[__pyx_v_n])); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 156, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_py_atoms, __pyx_t_12); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(0, 156, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+    __pyx_t_13 = __Pyx_PyInt_From_unsigned_int((__pyx_v_atom[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 128, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_atoms, __pyx_t_13); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 128, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-    /* "chython/containers/_cpack.pyx":157
- *         py_mapping.append(py_n)
- *         py_atoms.append(atoms[n])
- *         py_isotopes.append(None)             # <<<<<<<<<<<<<<
+    /* "chython/containers/_unpack.pyx":129
+ *         py_mapping.append(n)
+ *         py_atoms.append(atom[i])
+ *         py_isotopes.append(isotopes[i] or None)             # <<<<<<<<<<<<<<
  * 
- *         py_charges[py_n] = charges[n]
+ *         py_charges[n] = charges[i]
  */
-    __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_py_isotopes, Py_None); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(0, 157, __pyx_L1_error)
-
-    /* "chython/containers/_cpack.pyx":159
- *         py_isotopes.append(None)
- * 
- *         py_charges[py_n] = charges[n]             # <<<<<<<<<<<<<<
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:
- */
-    __pyx_t_12 = __Pyx_PyInt_From_char((__pyx_v_charges[__pyx_v_n])); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 159, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    if (unlikely(PyDict_SetItem(__pyx_v_py_charges, __pyx_v_py_n, __pyx_t_12) < 0)) __PYX_ERR(0, 159, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-
-    /* "chython/containers/_cpack.pyx":160
- * 
- *         py_charges[py_n] = charges[n]
- *         py_radicals[py_n] = bool(radicals[n])             # <<<<<<<<<<<<<<
- *         if hydrogens[n] == 7:
- *             py_hydrogens[py_n] = None
- */
-    __pyx_t_12 = __Pyx_PyInt_From_unsigned_char((__pyx_v_radicals[__pyx_v_n])); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_12); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-    __pyx_t_12 = __Pyx_PyBool_FromLong((!(!__pyx_t_5))); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    if (unlikely(PyDict_SetItem(__pyx_v_py_radicals, __pyx_v_py_n, __pyx_t_12) < 0)) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+    if (!(__pyx_v_isotopes[__pyx_v_i])) {
+    } else {
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int((__pyx_v_isotopes[__pyx_v_i])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      __pyx_t_13 = __pyx_t_15;
+      __pyx_t_15 = 0;
+      goto __pyx_L16_bool_binop_done;
+    }
+    __Pyx_INCREF(Py_None);
+    __pyx_t_13 = Py_None;
+    __pyx_L16_bool_binop_done:;
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_isotopes, __pyx_t_13); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 129, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+    /* "chython/containers/_unpack.pyx":131
+ *         py_isotopes.append(isotopes[i] or None)
+ * 
+ *         py_charges[n] = charges[i]             # <<<<<<<<<<<<<<
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:
+ */
+    __pyx_t_13 = __Pyx_PyInt_From_int((__pyx_v_charges[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 131, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 131, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_charges, __pyx_t_15, __pyx_t_13) < 0)) __PYX_ERR(0, 131, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+    /* "chython/containers/_unpack.pyx":132
+ * 
+ *         py_charges[n] = charges[i]
+ *         py_radicals[n] = radicals[i]             # <<<<<<<<<<<<<<
+ *         if hydrogens[i] == 7:
+ *             py_hydrogens[n] = None
+ */
+    __pyx_t_13 = __Pyx_PyBool_FromLong((__pyx_v_radicals[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_radicals, __pyx_t_15, __pyx_t_13) < 0)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-    /* "chython/containers/_cpack.pyx":161
- *         py_charges[py_n] = charges[n]
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:             # <<<<<<<<<<<<<<
- *             py_hydrogens[py_n] = None
+    /* "chython/containers/_unpack.pyx":133
+ *         py_charges[n] = charges[i]
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:             # <<<<<<<<<<<<<<
+ *             py_hydrogens[n] = None
  *         else:
  */
-    __pyx_t_5 = (((__pyx_v_hydrogens[__pyx_v_n]) == 7) != 0);
-    if (__pyx_t_5) {
+    __pyx_t_10 = (((__pyx_v_hydrogens[__pyx_v_i]) == 7) != 0);
+    if (__pyx_t_10) {
 
-      /* "chython/containers/_cpack.pyx":162
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:
- *             py_hydrogens[py_n] = None             # <<<<<<<<<<<<<<
+      /* "chython/containers/_unpack.pyx":134
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:
+ *             py_hydrogens[n] = None             # <<<<<<<<<<<<<<
  *         else:
- *             py_hydrogens[py_n] = hydrogens[n]
+ *             py_hydrogens[n] = hydrogens[i]
  */
-      if (unlikely(PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_v_py_n, Py_None) < 0)) __PYX_ERR(0, 162, __pyx_L1_error)
+      __pyx_t_13 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 134, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_13);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_t_13, Py_None) < 0)) __PYX_ERR(0, 134, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-      /* "chython/containers/_cpack.pyx":161
- *         py_charges[py_n] = charges[n]
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:             # <<<<<<<<<<<<<<
- *             py_hydrogens[py_n] = None
+      /* "chython/containers/_unpack.pyx":133
+ *         py_charges[n] = charges[i]
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:             # <<<<<<<<<<<<<<
+ *             py_hydrogens[n] = None
  *         else:
  */
-      goto __pyx_L13;
+      goto __pyx_L18;
     }
 
-    /* "chython/containers/_cpack.pyx":164
- *             py_hydrogens[py_n] = None
+    /* "chython/containers/_unpack.pyx":136
+ *             py_hydrogens[n] = None
  *         else:
- *             py_hydrogens[py_n] = hydrogens[n]             # <<<<<<<<<<<<<<
+ *             py_hydrogens[n] = hydrogens[i]             # <<<<<<<<<<<<<<
+ *         py_plane[n] = (x[i], y[i])
  * 
- *         py_plane[py_n] = py_xy
  */
     /*else*/ {
-      __pyx_t_12 = __Pyx_PyInt_From_unsigned_char((__pyx_v_hydrogens[__pyx_v_n])); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 164, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_12);
-      if (unlikely(PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_v_py_n, __pyx_t_12) < 0)) __PYX_ERR(0, 164, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-    }
-    __pyx_L13:;
+      __pyx_t_13 = __Pyx_PyInt_From_unsigned_int((__pyx_v_hydrogens[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_13);
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_t_15, __pyx_t_13) < 0)) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+    }
+    __pyx_L18:;
+
+    /* "chython/containers/_unpack.pyx":137
+ *         else:
+ *             py_hydrogens[n] = hydrogens[i]
+ *         py_plane[n] = (x[i], y[i])             # <<<<<<<<<<<<<<
+ * 
+ *         if is_tet[i]:
+ */
+    __pyx_t_13 = PyFloat_FromDouble((__pyx_v_x[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_15 = PyFloat_FromDouble((__pyx_v_y[__pyx_v_i])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __pyx_t_16 = PyTuple_New(2); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __Pyx_GIVEREF(__pyx_t_13);
+    PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_13);
+    __Pyx_GIVEREF(__pyx_t_15);
+    PyTuple_SET_ITEM(__pyx_t_16, 1, __pyx_t_15);
+    __pyx_t_13 = 0;
+    __pyx_t_15 = 0;
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_plane, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
 
-    /* "chython/containers/_cpack.pyx":166
- *             py_hydrogens[py_n] = hydrogens[n]
+    /* "chython/containers/_unpack.pyx":139
+ *         py_plane[n] = (x[i], y[i])
  * 
- *         py_plane[py_n] = py_xy             # <<<<<<<<<<<<<<
+ *         if is_tet[i]:             # <<<<<<<<<<<<<<
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:
+ */
+    __pyx_t_10 = ((__pyx_v_is_tet[__pyx_v_i]) != 0);
+    if (__pyx_t_10) {
+
+      /* "chython/containers/_unpack.pyx":140
  * 
- *         if is_chiral[n]:
+ *         if is_tet[i]:
+ *             py_atoms_stereo[n] = tet_sign[i]             # <<<<<<<<<<<<<<
+ *         if is_all[i]:
+ *             py_allenes_stereo[n] = all_sign[i]
  */
-    if (unlikely(PyDict_SetItem(__pyx_v_py_plane, __pyx_v_py_n, __pyx_v_py_xy) < 0)) __PYX_ERR(0, 166, __pyx_L1_error)
+      __pyx_t_16 = __Pyx_PyBool_FromLong((__pyx_v_tet_sign[__pyx_v_i])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 140, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_16);
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 140, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_atoms_stereo, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 140, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
 
-    /* "chython/containers/_cpack.pyx":168
- *         py_plane[py_n] = py_xy
+      /* "chython/containers/_unpack.pyx":139
+ *         py_plane[n] = (x[i], y[i])
  * 
- *         if is_chiral[n]:             # <<<<<<<<<<<<<<
- *             if neighbors[n] == 2:  # allene
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
+ *         if is_tet[i]:             # <<<<<<<<<<<<<<
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:
  */
-    __pyx_t_5 = ((__pyx_v_is_chiral[__pyx_v_n]) != 0);
-    if (__pyx_t_5) {
+    }
 
-      /* "chython/containers/_cpack.pyx":169
+    /* "chython/containers/_unpack.pyx":141
+ *         if is_tet[i]:
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:             # <<<<<<<<<<<<<<
+ *             py_allenes_stereo[n] = all_sign[i]
  * 
- *         if is_chiral[n]:
- *             if neighbors[n] == 2:  # allene             # <<<<<<<<<<<<<<
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- *             else:
  */
-      __pyx_t_5 = (((__pyx_v_neighbors[__pyx_v_n]) == 2) != 0);
-      if (__pyx_t_5) {
+    __pyx_t_10 = ((__pyx_v_is_all[__pyx_v_i]) != 0);
+    if (__pyx_t_10) {
 
-        /* "chython/containers/_cpack.pyx":170
- *         if is_chiral[n]:
- *             if neighbors[n] == 2:  # allene
- *                 py_allenes_stereo[py_n] = stereo_sign[n]             # <<<<<<<<<<<<<<
- *             else:
- *                 py_atoms_stereo[py_n] = stereo_sign[n]
+      /* "chython/containers/_unpack.pyx":142
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:
+ *             py_allenes_stereo[n] = all_sign[i]             # <<<<<<<<<<<<<<
+ * 
+ *         tmp = {}
  */
-        __pyx_t_12 = __Pyx_PyBool_FromLong((__pyx_v_stereo_sign[__pyx_v_n])); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 170, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_12);
-        if (unlikely(PyDict_SetItem(__pyx_v_py_allenes_stereo, __pyx_v_py_n, __pyx_t_12) < 0)) __PYX_ERR(0, 170, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-
-        /* "chython/containers/_cpack.pyx":169
- * 
- *         if is_chiral[n]:
- *             if neighbors[n] == 2:  # allene             # <<<<<<<<<<<<<<
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- *             else:
+      __pyx_t_16 = __Pyx_PyBool_FromLong((__pyx_v_all_sign[__pyx_v_i])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 142, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_16);
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 142, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_allenes_stereo, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 142, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+      /* "chython/containers/_unpack.pyx":141
+ *         if is_tet[i]:
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:             # <<<<<<<<<<<<<<
+ *             py_allenes_stereo[n] = all_sign[i]
+ * 
  */
-        goto __pyx_L15;
-      }
+    }
 
-      /* "chython/containers/_cpack.pyx":172
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- *             else:
- *                 py_atoms_stereo[py_n] = stereo_sign[n]             # <<<<<<<<<<<<<<
+    /* "chython/containers/_unpack.pyx":144
+ *             py_allenes_stereo[n] = all_sign[i]
  * 
- *         py_bonds[py_n] = py_ngb = {}
+ *         tmp = {}             # <<<<<<<<<<<<<<
+ *         py_bonds[n] = tmp
+ *         seen[n] = True
  */
-      /*else*/ {
-        __pyx_t_12 = __Pyx_PyBool_FromLong((__pyx_v_stereo_sign[__pyx_v_n])); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 172, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_12);
-        if (unlikely(PyDict_SetItem(__pyx_v_py_atoms_stereo, __pyx_v_py_n, __pyx_t_12) < 0)) __PYX_ERR(0, 172, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-      }
-      __pyx_L15:;
+    __pyx_t_16 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 144, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __Pyx_XDECREF_SET(__pyx_v_tmp, ((PyObject*)__pyx_t_16));
+    __pyx_t_16 = 0;
 
-      /* "chython/containers/_cpack.pyx":168
- *         py_plane[py_n] = py_xy
+    /* "chython/containers/_unpack.pyx":145
  * 
- *         if is_chiral[n]:             # <<<<<<<<<<<<<<
- *             if neighbors[n] == 2:  # allene
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
+ *         tmp = {}
+ *         py_bonds[n] = tmp             # <<<<<<<<<<<<<<
+ *         seen[n] = True
+ *         for j in range(shift, shift + neighbors[i]):
  */
-    }
+    __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 145, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_bonds, __pyx_t_16, __pyx_v_tmp) < 0)) __PYX_ERR(0, 145, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
 
-    /* "chython/containers/_cpack.pyx":174
- *                 py_atoms_stereo[py_n] = stereo_sign[n]
- * 
- *         py_bonds[py_n] = py_ngb = {}             # <<<<<<<<<<<<<<
- *         for i in range(neighbors[n]):
- *             m = connections[n][i]
- */
-    __pyx_t_12 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 174, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    if (unlikely(PyDict_SetItem(__pyx_v_py_bonds, __pyx_v_py_n, __pyx_t_12) < 0)) __PYX_ERR(0, 174, __pyx_L1_error)
-    __Pyx_INCREF(__pyx_t_12);
-    __Pyx_XDECREF_SET(__pyx_v_py_ngb, __pyx_t_12);
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-
-    /* "chython/containers/_cpack.pyx":175
- * 
- *         py_bonds[py_n] = py_ngb = {}
- *         for i in range(neighbors[n]):             # <<<<<<<<<<<<<<
- *             m = connections[n][i]
- *             py_m = m + 1
- */
-    __pyx_t_8 = (__pyx_v_neighbors[__pyx_v_n]);
-    __pyx_t_10 = __pyx_t_8;
-    for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_10; __pyx_t_9+=1) {
-      __pyx_v_i = __pyx_t_9;
-
-      /* "chython/containers/_cpack.pyx":176
- *         py_bonds[py_n] = py_ngb = {}
- *         for i in range(neighbors[n]):
- *             m = connections[n][i]             # <<<<<<<<<<<<<<
- *             py_m = m + 1
- *             if seen[m]:  # bond partially exists. need back-connection.
+    /* "chython/containers/_unpack.pyx":146
+ *         tmp = {}
+ *         py_bonds[n] = tmp
+ *         seen[n] = True             # <<<<<<<<<<<<<<
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]
  */
-      __pyx_v_m = ((__pyx_v_connections[__pyx_v_n])[__pyx_v_i]);
+    (__pyx_v_seen[__pyx_v_n]) = 1;
 
-      /* "chython/containers/_cpack.pyx":177
- *         for i in range(neighbors[n]):
- *             m = connections[n][i]
- *             py_m = m + 1             # <<<<<<<<<<<<<<
+    /* "chython/containers/_unpack.pyx":147
+ *         py_bonds[n] = tmp
+ *         seen[n] = True
+ *         for j in range(shift, shift + neighbors[i]):             # <<<<<<<<<<<<<<
+ *             m = connections[j]
+ *             if seen[m]:  # bond partially exists. need back-connection.
+ */
+    __pyx_t_17 = (__pyx_v_shift + (__pyx_v_neighbors[__pyx_v_i]));
+    __pyx_t_18 = __pyx_t_17;
+    for (__pyx_t_19 = __pyx_v_shift; __pyx_t_19 < __pyx_t_18; __pyx_t_19+=1) {
+      __pyx_v_j = __pyx_t_19;
+
+      /* "chython/containers/_unpack.pyx":148
+ *         seen[n] = True
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]             # <<<<<<<<<<<<<<
  *             if seen[m]:  # bond partially exists. need back-connection.
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
+ *                 tmp[m] = py_bonds[m][n]
  */
-      __pyx_t_12 = __Pyx_PyInt_From_long((__pyx_v_m + 1)); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 177, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_12);
-      __Pyx_XDECREF_SET(__pyx_v_py_m, __pyx_t_12);
-      __pyx_t_12 = 0;
-
-      /* "chython/containers/_cpack.pyx":178
- *             m = connections[n][i]
- *             py_m = m + 1
+      __pyx_v_m = (__pyx_v_connections[__pyx_v_j]);
+
+      /* "chython/containers/_unpack.pyx":149
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]
  *             if seen[m]:  # bond partially exists. need back-connection.             # <<<<<<<<<<<<<<
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
+ *                 tmp[m] = py_bonds[m][n]
  *             else:
  */
-      __pyx_t_5 = ((__pyx_v_seen[__pyx_v_m]) != 0);
-      if (__pyx_t_5) {
+      __pyx_t_10 = ((__pyx_v_seen[__pyx_v_m]) != 0);
+      if (__pyx_t_10) {
 
-        /* "chython/containers/_cpack.pyx":179
- *             py_m = m + 1
+        /* "chython/containers/_unpack.pyx":150
+ *             m = connections[j]
  *             if seen[m]:  # bond partially exists. need back-connection.
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]             # <<<<<<<<<<<<<<
+ *                 tmp[m] = py_bonds[m][n]             # <<<<<<<<<<<<<<
  *             else:
  *                 bond = object.__new__(Bond)
  */
-        __pyx_t_12 = __Pyx_PyDict_GetItem(__pyx_v_py_bonds, __pyx_v_py_m); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 179, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_12);
-        __pyx_t_14 = __Pyx_PyObject_GetItem(__pyx_t_12, __pyx_v_py_n); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 179, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_14);
-        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-        if (unlikely(PyDict_SetItem(__pyx_v_py_ngb, __pyx_v_py_m, __pyx_t_14) < 0)) __PYX_ERR(0, 179, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
-
-        /* "chython/containers/_cpack.pyx":178
- *             m = connections[n][i]
- *             py_m = m + 1
+        __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_m); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        __pyx_t_15 = __Pyx_PyDict_GetItem(__pyx_v_py_bonds, __pyx_t_16); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_15);
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+        __pyx_t_16 = __Pyx_GetItemInt(__pyx_t_15, __pyx_v_n, unsigned int, 0, __Pyx_PyInt_From_unsigned_int, 0, 0, 0); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+        __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_m); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_15);
+        if (unlikely(PyDict_SetItem(__pyx_v_tmp, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+        /* "chython/containers/_unpack.pyx":149
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]
  *             if seen[m]:  # bond partially exists. need back-connection.             # <<<<<<<<<<<<<<
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
+ *                 tmp[m] = py_bonds[m][n]
  *             else:
  */
-        goto __pyx_L18;
+        goto __pyx_L23;
       }
 
-      /* "chython/containers/_cpack.pyx":181
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
+      /* "chython/containers/_unpack.pyx":152
+ *                 tmp[m] = py_bonds[m][n]
  *             else:
  *                 bond = object.__new__(Bond)             # <<<<<<<<<<<<<<
- *                 bond._Bond__order = orders[n][i]
- *                 bond._Bond__n = py_n
+ *                 bond._Bond__order = orders[order_shift]
+ *                 tmp[m] = bond
  */
       /*else*/ {
-        __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_builtin_object, __pyx_n_s_new); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 181, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_12);
-        __Pyx_GetModuleGlobalName(__pyx_t_15, __pyx_n_s_Bond); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 181, __pyx_L1_error)
+        __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_builtin_object, __pyx_n_s_new); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 152, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_15);
-        __pyx_t_16 = NULL;
-        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_12))) {
-          __pyx_t_16 = PyMethod_GET_SELF(__pyx_t_12);
-          if (likely(__pyx_t_16)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
-            __Pyx_INCREF(__pyx_t_16);
+        __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_Bond); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 152, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_13);
+        __pyx_t_20 = NULL;
+        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_15))) {
+          __pyx_t_20 = PyMethod_GET_SELF(__pyx_t_15);
+          if (likely(__pyx_t_20)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
+            __Pyx_INCREF(__pyx_t_20);
             __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_12, function);
+            __Pyx_DECREF_SET(__pyx_t_15, function);
           }
         }
-        __pyx_t_14 = (__pyx_t_16) ? __Pyx_PyObject_Call2Args(__pyx_t_12, __pyx_t_16, __pyx_t_15) : __Pyx_PyObject_CallOneArg(__pyx_t_12, __pyx_t_15);
-        __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
+        __pyx_t_16 = (__pyx_t_20) ? __Pyx_PyObject_Call2Args(__pyx_t_15, __pyx_t_20, __pyx_t_13) : __Pyx_PyObject_CallOneArg(__pyx_t_15, __pyx_t_13);
+        __Pyx_XDECREF(__pyx_t_20); __pyx_t_20 = 0;
+        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+        if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 152, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
         __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-        if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 181, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_14);
-        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-        __Pyx_XDECREF_SET(__pyx_v_bond, __pyx_t_14);
-        __pyx_t_14 = 0;
+        __Pyx_XDECREF_SET(__pyx_v_bond, __pyx_t_16);
+        __pyx_t_16 = 0;
 
-        /* "chython/containers/_cpack.pyx":182
+        /* "chython/containers/_unpack.pyx":153
  *             else:
  *                 bond = object.__new__(Bond)
- *                 bond._Bond__order = orders[n][i]             # <<<<<<<<<<<<<<
- *                 bond._Bond__n = py_n
- *                 bond._Bond__m = py_m
- */
-        __pyx_t_14 = __Pyx_PyInt_From_unsigned_char(((__pyx_v_orders[__pyx_v_n])[__pyx_v_i])); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 182, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_14);
-        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__order, __pyx_t_14) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+ *                 bond._Bond__order = orders[order_shift]             # <<<<<<<<<<<<<<
+ *                 tmp[m] = bond
+ *                 order_shift += 1
+ */
+        __pyx_t_16 = __Pyx_PyInt_From_unsigned_int((__pyx_v_orders[__pyx_v_order_shift])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 153, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__order, __pyx_t_16) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
 
-        /* "chython/containers/_cpack.pyx":183
+        /* "chython/containers/_unpack.pyx":154
  *                 bond = object.__new__(Bond)
- *                 bond._Bond__order = orders[n][i]
- *                 bond._Bond__n = py_n             # <<<<<<<<<<<<<<
- *                 bond._Bond__m = py_m
- *                 py_ngb[py_m] = bond
- */
-        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__n, __pyx_v_py_n) < 0) __PYX_ERR(0, 183, __pyx_L1_error)
-
-        /* "chython/containers/_cpack.pyx":184
- *                 bond._Bond__order = orders[n][i]
- *                 bond._Bond__n = py_n
- *                 bond._Bond__m = py_m             # <<<<<<<<<<<<<<
- *                 py_ngb[py_m] = bond
- *                 py_bonds_flat.append(bond)
- */
-        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__m, __pyx_v_py_m) < 0) __PYX_ERR(0, 184, __pyx_L1_error)
-
-        /* "chython/containers/_cpack.pyx":185
- *                 bond._Bond__n = py_n
- *                 bond._Bond__m = py_m
- *                 py_ngb[py_m] = bond             # <<<<<<<<<<<<<<
- *                 py_bonds_flat.append(bond)
+ *                 bond._Bond__order = orders[order_shift]
+ *                 tmp[m] = bond             # <<<<<<<<<<<<<<
+ *                 order_shift += 1
  * 
  */
-        if (unlikely(PyDict_SetItem(__pyx_v_py_ngb, __pyx_v_py_m, __pyx_v_bond) < 0)) __PYX_ERR(0, 185, __pyx_L1_error)
+        __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_m); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 154, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        if (unlikely(PyDict_SetItem(__pyx_v_tmp, __pyx_t_16, __pyx_v_bond) < 0)) __PYX_ERR(0, 154, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
 
-        /* "chython/containers/_cpack.pyx":186
- *                 bond._Bond__m = py_m
- *                 py_ngb[py_m] = bond
- *                 py_bonds_flat.append(bond)             # <<<<<<<<<<<<<<
+        /* "chython/containers/_unpack.pyx":155
+ *                 bond._Bond__order = orders[order_shift]
+ *                 tmp[m] = bond
+ *                 order_shift += 1             # <<<<<<<<<<<<<<
  * 
- *     ct_shift = 0
+ *         shift += neighbors[i]
  */
-        __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_py_bonds_flat, __pyx_v_bond); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(0, 186, __pyx_L1_error)
+        __pyx_v_order_shift = (__pyx_v_order_shift + 1);
       }
-      __pyx_L18:;
+      __pyx_L23:;
     }
-  }
 
-  /* "chython/containers/_cpack.pyx":188
- *                 py_bonds_flat.append(bond)
+    /* "chython/containers/_unpack.pyx":157
+ *                 order_shift += 1
  * 
- *     ct_shift = 0             # <<<<<<<<<<<<<<
- *     for n in range(ct_count):
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]
- */
-  __pyx_v_ct_shift = 0;
-
-  /* "chython/containers/_cpack.pyx":189
- * 
- *     ct_shift = 0
- *     for n in range(ct_count):             # <<<<<<<<<<<<<<
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]
- *         ct_shift += 2
- */
-  __pyx_t_4 = __pyx_v_ct_count;
-  __pyx_t_7 = __pyx_t_4;
-  for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_7; __pyx_t_11+=1) {
-    __pyx_v_n = __pyx_t_11;
-
-    /* "chython/containers/_cpack.pyx":190
- *     ct_shift = 0
- *     for n in range(ct_count):
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]             # <<<<<<<<<<<<<<
- *         ct_shift += 2
- * 
- */
-    __pyx_t_14 = __Pyx_PyBool_FromLong((__pyx_v_ct_sign[__pyx_v_n])); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_14);
-    __pyx_t_12 = __Pyx_PyInt_From_unsigned_short((__pyx_v_ct_stereo[__pyx_v_ct_shift])); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    __pyx_t_15 = __Pyx_PyInt_From_unsigned_short((__pyx_v_ct_stereo[(__pyx_v_ct_shift + 1)])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __pyx_t_16 = PyTuple_New(2); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_16);
-    __Pyx_GIVEREF(__pyx_t_12);
-    PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_12);
-    __Pyx_GIVEREF(__pyx_t_15);
-    PyTuple_SET_ITEM(__pyx_t_16, 1, __pyx_t_15);
-    __pyx_t_12 = 0;
-    __pyx_t_15 = 0;
-    if (unlikely(PyDict_SetItem(__pyx_v_py_cis_trans_stereo, __pyx_t_16, __pyx_t_14) < 0)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
-    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
-
-    /* "chython/containers/_cpack.pyx":191
- *     for n in range(ct_count):
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]
- *         ct_shift += 2             # <<<<<<<<<<<<<<
+ *         shift += neighbors[i]             # <<<<<<<<<<<<<<
  * 
- *     PyMem_Free(atoms)
+ *     for i in range(nct):
  */
-    __pyx_v_ct_shift = (__pyx_v_ct_shift + 2);
+    __pyx_v_shift = (__pyx_v_shift + (__pyx_v_neighbors[__pyx_v_i]));
   }
 
-  /* "chython/containers/_cpack.pyx":193
- *         ct_shift += 2
+  /* "chython/containers/_unpack.pyx":159
+ *         shift += neighbors[i]
  * 
- *     PyMem_Free(atoms)             # <<<<<<<<<<<<<<
- *     PyMem_Free(charges)
- *     PyMem_Free(radicals)
- */
-  PyMem_Free(__pyx_v_atoms);
-
-  /* "chython/containers/_cpack.pyx":194
+ *     for i in range(nct):             # <<<<<<<<<<<<<<
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]
  * 
- *     PyMem_Free(atoms)
- *     PyMem_Free(charges)             # <<<<<<<<<<<<<<
- *     PyMem_Free(radicals)
- *     PyMem_Free(hydrogens)
- */
-  PyMem_Free(__pyx_v_charges);
-
-  /* "chython/containers/_cpack.pyx":195
- *     PyMem_Free(atoms)
- *     PyMem_Free(charges)
- *     PyMem_Free(radicals)             # <<<<<<<<<<<<<<
- *     PyMem_Free(hydrogens)
- *     PyMem_Free(is_chiral)
- */
-  PyMem_Free(__pyx_v_radicals);
-
-  /* "chython/containers/_cpack.pyx":196
- *     PyMem_Free(charges)
- *     PyMem_Free(radicals)
- *     PyMem_Free(hydrogens)             # <<<<<<<<<<<<<<
- *     PyMem_Free(is_chiral)
- *     PyMem_Free(stereo_sign)
- */
-  PyMem_Free(__pyx_v_hydrogens);
-
-  /* "chython/containers/_cpack.pyx":197
- *     PyMem_Free(radicals)
- *     PyMem_Free(hydrogens)
- *     PyMem_Free(is_chiral)             # <<<<<<<<<<<<<<
- *     PyMem_Free(stereo_sign)
- *     PyMem_Free(ct_stereo)
- */
-  PyMem_Free(__pyx_v_is_chiral);
-
-  /* "chython/containers/_cpack.pyx":198
- *     PyMem_Free(hydrogens)
- *     PyMem_Free(is_chiral)
- *     PyMem_Free(stereo_sign)             # <<<<<<<<<<<<<<
- *     PyMem_Free(ct_stereo)
- *     PyMem_Free(ct_sign)
  */
-  PyMem_Free(__pyx_v_stereo_sign);
+  __pyx_t_5 = __pyx_v_nct;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
 
-  /* "chython/containers/_cpack.pyx":199
- *     PyMem_Free(is_chiral)
- *     PyMem_Free(stereo_sign)
- *     PyMem_Free(ct_stereo)             # <<<<<<<<<<<<<<
- *     PyMem_Free(ct_sign)
- *     PyMem_Free(neighbors)
- */
-  PyMem_Free(__pyx_v_ct_stereo);
-
-  /* "chython/containers/_cpack.pyx":200
- *     PyMem_Free(stereo_sign)
- *     PyMem_Free(ct_stereo)
- *     PyMem_Free(ct_sign)             # <<<<<<<<<<<<<<
- *     PyMem_Free(neighbors)
- *     PyMem_Free(seen)
- */
-  PyMem_Free(__pyx_v_ct_sign);
-
-  /* "chython/containers/_cpack.pyx":201
- *     PyMem_Free(ct_stereo)
- *     PyMem_Free(ct_sign)
- *     PyMem_Free(neighbors)             # <<<<<<<<<<<<<<
- *     PyMem_Free(seen)
- *     for n in range(size / 3):
- */
-  PyMem_Free(__pyx_v_neighbors);
-
-  /* "chython/containers/_cpack.pyx":202
- *     PyMem_Free(ct_sign)
- *     PyMem_Free(neighbors)
- *     PyMem_Free(seen)             # <<<<<<<<<<<<<<
- *     for n in range(size / 3):
- *         PyMem_Free(connections[n])
- */
-  PyMem_Free(__pyx_v_seen);
-
-  /* "chython/containers/_cpack.pyx":203
- *     PyMem_Free(neighbors)
- *     PyMem_Free(seen)
- *     for n in range(size / 3):             # <<<<<<<<<<<<<<
- *         PyMem_Free(connections[n])
- *         PyMem_Free(orders[n])
- */
-  __pyx_t_2 = (((long)__pyx_v_size) / 3);
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_n = __pyx_t_4;
-
-    /* "chython/containers/_cpack.pyx":204
- *     PyMem_Free(seen)
- *     for n in range(size / 3):
- *         PyMem_Free(connections[n])             # <<<<<<<<<<<<<<
- *         PyMem_Free(orders[n])
- *     PyMem_Free(connections)
- */
-    PyMem_Free((__pyx_v_connections[__pyx_v_n]));
-
-    /* "chython/containers/_cpack.pyx":205
- *     for n in range(size / 3):
- *         PyMem_Free(connections[n])
- *         PyMem_Free(orders[n])             # <<<<<<<<<<<<<<
- *     PyMem_Free(connections)
- *     PyMem_Free(orders)
- */
-    PyMem_Free((__pyx_v_orders[__pyx_v_n]));
-  }
-
-  /* "chython/containers/_cpack.pyx":206
- *         PyMem_Free(connections[n])
- *         PyMem_Free(orders[n])
- *     PyMem_Free(connections)             # <<<<<<<<<<<<<<
- *     PyMem_Free(orders)
+    /* "chython/containers/_unpack.pyx":160
  * 
- */
-  PyMem_Free(__pyx_v_connections);
-
-  /* "chython/containers/_cpack.pyx":207
- *         PyMem_Free(orders[n])
- *     PyMem_Free(connections)
- *     PyMem_Free(orders)             # <<<<<<<<<<<<<<
+ *     for i in range(nct):
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]             # <<<<<<<<<<<<<<
  * 
  *     return (py_mapping, py_atoms, py_isotopes,
  */
-  PyMem_Free(__pyx_v_orders);
+    __pyx_t_16 = __Pyx_PyBool_FromLong((__pyx_v_ct_sign[__pyx_v_i])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int((__pyx_v_cis_trans_1[__pyx_v_i])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __pyx_t_13 = __Pyx_PyInt_From_unsigned_int((__pyx_v_cis_trans_2[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_20 = PyTuple_New(2); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_20);
+    __Pyx_GIVEREF(__pyx_t_15);
+    PyTuple_SET_ITEM(__pyx_t_20, 0, __pyx_t_15);
+    __Pyx_GIVEREF(__pyx_t_13);
+    PyTuple_SET_ITEM(__pyx_t_20, 1, __pyx_t_13);
+    __pyx_t_15 = 0;
+    __pyx_t_13 = 0;
+    if (unlikely(PyDict_SetItem(__pyx_v_py_cis_trans_stereo, __pyx_t_20, __pyx_t_16) < 0)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+  }
 
-  /* "chython/containers/_cpack.pyx":209
- *     PyMem_Free(orders)
+  /* "chython/containers/_unpack.pyx":162
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]
  * 
  *     return (py_mapping, py_atoms, py_isotopes,             # <<<<<<<<<<<<<<
  *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
- *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, shift, py_bonds_flat)
+ *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, pack_length)
  */
   __Pyx_XDECREF(__pyx_r);
 
-  /* "chython/containers/_cpack.pyx":211
+  /* "chython/containers/_unpack.pyx":164
  *     return (py_mapping, py_atoms, py_isotopes,
  *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
- *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, shift, py_bonds_flat)             # <<<<<<<<<<<<<<
+ *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, pack_length)             # <<<<<<<<<<<<<<
+ * 
+ * 
  */
-  __pyx_t_14 = __Pyx_PyInt_From_unsigned_short(__pyx_v_shift); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 211, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_14);
+  __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_pack_length); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 164, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_16);
 
-  /* "chython/containers/_cpack.pyx":209
- *     PyMem_Free(orders)
+  /* "chython/containers/_unpack.pyx":162
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]
  * 
  *     return (py_mapping, py_atoms, py_isotopes,             # <<<<<<<<<<<<<<
  *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
- *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, shift, py_bonds_flat)
+ *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, pack_length)
  */
-  __pyx_t_16 = PyTuple_New(13); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 209, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_16);
+  __pyx_t_20 = PyTuple_New(12); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_20);
   __Pyx_INCREF(__pyx_v_py_mapping);
   __Pyx_GIVEREF(__pyx_v_py_mapping);
-  PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_v_py_mapping);
+  PyTuple_SET_ITEM(__pyx_t_20, 0, __pyx_v_py_mapping);
   __Pyx_INCREF(__pyx_v_py_atoms);
   __Pyx_GIVEREF(__pyx_v_py_atoms);
-  PyTuple_SET_ITEM(__pyx_t_16, 1, __pyx_v_py_atoms);
+  PyTuple_SET_ITEM(__pyx_t_20, 1, __pyx_v_py_atoms);
   __Pyx_INCREF(__pyx_v_py_isotopes);
   __Pyx_GIVEREF(__pyx_v_py_isotopes);
-  PyTuple_SET_ITEM(__pyx_t_16, 2, __pyx_v_py_isotopes);
+  PyTuple_SET_ITEM(__pyx_t_20, 2, __pyx_v_py_isotopes);
   __Pyx_INCREF(__pyx_v_py_charges);
   __Pyx_GIVEREF(__pyx_v_py_charges);
-  PyTuple_SET_ITEM(__pyx_t_16, 3, __pyx_v_py_charges);
+  PyTuple_SET_ITEM(__pyx_t_20, 3, __pyx_v_py_charges);
   __Pyx_INCREF(__pyx_v_py_radicals);
   __Pyx_GIVEREF(__pyx_v_py_radicals);
-  PyTuple_SET_ITEM(__pyx_t_16, 4, __pyx_v_py_radicals);
+  PyTuple_SET_ITEM(__pyx_t_20, 4, __pyx_v_py_radicals);
   __Pyx_INCREF(__pyx_v_py_hydrogens);
   __Pyx_GIVEREF(__pyx_v_py_hydrogens);
-  PyTuple_SET_ITEM(__pyx_t_16, 5, __pyx_v_py_hydrogens);
+  PyTuple_SET_ITEM(__pyx_t_20, 5, __pyx_v_py_hydrogens);
   __Pyx_INCREF(__pyx_v_py_plane);
   __Pyx_GIVEREF(__pyx_v_py_plane);
-  PyTuple_SET_ITEM(__pyx_t_16, 6, __pyx_v_py_plane);
+  PyTuple_SET_ITEM(__pyx_t_20, 6, __pyx_v_py_plane);
   __Pyx_INCREF(__pyx_v_py_bonds);
   __Pyx_GIVEREF(__pyx_v_py_bonds);
-  PyTuple_SET_ITEM(__pyx_t_16, 7, __pyx_v_py_bonds);
+  PyTuple_SET_ITEM(__pyx_t_20, 7, __pyx_v_py_bonds);
   __Pyx_INCREF(__pyx_v_py_atoms_stereo);
   __Pyx_GIVEREF(__pyx_v_py_atoms_stereo);
-  PyTuple_SET_ITEM(__pyx_t_16, 8, __pyx_v_py_atoms_stereo);
+  PyTuple_SET_ITEM(__pyx_t_20, 8, __pyx_v_py_atoms_stereo);
   __Pyx_INCREF(__pyx_v_py_allenes_stereo);
   __Pyx_GIVEREF(__pyx_v_py_allenes_stereo);
-  PyTuple_SET_ITEM(__pyx_t_16, 9, __pyx_v_py_allenes_stereo);
+  PyTuple_SET_ITEM(__pyx_t_20, 9, __pyx_v_py_allenes_stereo);
   __Pyx_INCREF(__pyx_v_py_cis_trans_stereo);
   __Pyx_GIVEREF(__pyx_v_py_cis_trans_stereo);
-  PyTuple_SET_ITEM(__pyx_t_16, 10, __pyx_v_py_cis_trans_stereo);
-  __Pyx_GIVEREF(__pyx_t_14);
-  PyTuple_SET_ITEM(__pyx_t_16, 11, __pyx_t_14);
-  __Pyx_INCREF(__pyx_v_py_bonds_flat);
-  __Pyx_GIVEREF(__pyx_v_py_bonds_flat);
-  PyTuple_SET_ITEM(__pyx_t_16, 12, __pyx_v_py_bonds_flat);
-  __pyx_t_14 = 0;
-  __pyx_r = __pyx_t_16;
+  PyTuple_SET_ITEM(__pyx_t_20, 10, __pyx_v_py_cis_trans_stereo);
+  __Pyx_GIVEREF(__pyx_t_16);
+  PyTuple_SET_ITEM(__pyx_t_20, 11, __pyx_t_16);
   __pyx_t_16 = 0;
+  __pyx_r = __pyx_t_20;
+  __pyx_t_20 = 0;
   goto __pyx_L0;
 
-  /* "chython/containers/_cpack.pyx":52
- * @cython.cdivision(True)
- * @cython.wraparound(False)
+  /* "chython/containers/_unpack.pyx":25
+ * 
+ * @cython.boundscheck(False)
  * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
- *     cdef char *charges
- *     cdef unsigned char *atoms, *hydrogens, *radicals, *is_chiral, *neighbors, **orders, *seen
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_12);
-  __Pyx_XDECREF(__pyx_t_14);
+  __Pyx_XDECREF(__pyx_t_13);
   __Pyx_XDECREF(__pyx_t_15);
   __Pyx_XDECREF(__pyx_t_16);
-  __Pyx_AddTraceback("chython.containers._cpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_20);
+  __Pyx_AddTraceback("chython.containers._unpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
-  __Pyx_XDECREF(__pyx_v_py_xy);
   __Pyx_XDECREF(__pyx_v_bond);
-  __Pyx_XDECREF(__pyx_v_py_n);
-  __Pyx_XDECREF(__pyx_v_py_m);
-  __Pyx_XDECREF(__pyx_v_py_mapping);
-  __Pyx_XDECREF(__pyx_v_py_atoms);
-  __Pyx_XDECREF(__pyx_v_py_isotopes);
-  __Pyx_XDECREF(__pyx_v_py_bonds_flat);
   __Pyx_XDECREF(__pyx_v_py_charges);
   __Pyx_XDECREF(__pyx_v_py_radicals);
   __Pyx_XDECREF(__pyx_v_py_hydrogens);
   __Pyx_XDECREF(__pyx_v_py_plane);
   __Pyx_XDECREF(__pyx_v_py_bonds);
-  __Pyx_XDECREF(__pyx_v_py_ngb);
+  __Pyx_XDECREF(__pyx_v_tmp);
   __Pyx_XDECREF(__pyx_v_py_atoms_stereo);
   __Pyx_XDECREF(__pyx_v_py_allenes_stereo);
   __Pyx_XDECREF(__pyx_v_py_cis_trans_stereo);
+  __Pyx_XDECREF(__pyx_v_py_mapping);
+  __Pyx_XDECREF(__pyx_v_py_atoms);
+  __Pyx_XDECREF(__pyx_v_py_isotopes);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":123
+/* "chython/containers/_unpack.pyx":177
+ * 
+ * 
+ * cdef double double_from2bytes(unsigned char a, unsigned char b):             # <<<<<<<<<<<<<<
+ *     cdef bint sign
+ *     cdef int e
+ */
+
+static double __pyx_f_7chython_10containers_7_unpack_double_from2bytes(unsigned char __pyx_v_a, unsigned char __pyx_v_b) {
+  int __pyx_v_sign;
+  int __pyx_v_e;
+  unsigned int __pyx_v_f;
+  double __pyx_v_x;
+  double __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  __Pyx_RefNannySetupContext("double_from2bytes", 0);
+
+  /* "chython/containers/_unpack.pyx":183
+ *     cdef double x
+ * 
+ *     sign = a >> 7             # <<<<<<<<<<<<<<
+ *     e = (a >> 2) & 0x1f
+ *     f = ((a & 0x03) << 8) | b
+ */
+  __pyx_v_sign = (__pyx_v_a >> 7);
+
+  /* "chython/containers/_unpack.pyx":184
+ * 
+ *     sign = a >> 7
+ *     e = (a >> 2) & 0x1f             # <<<<<<<<<<<<<<
+ *     f = ((a & 0x03) << 8) | b
+ * 
+ */
+  __pyx_v_e = ((__pyx_v_a >> 2) & 0x1f);
+
+  /* "chython/containers/_unpack.pyx":185
+ *     sign = a >> 7
+ *     e = (a >> 2) & 0x1f
+ *     f = ((a & 0x03) << 8) | b             # <<<<<<<<<<<<<<
+ * 
+ *     x = f / 1024.
+ */
+  __pyx_v_f = (((__pyx_v_a & 0x03) << 8) | __pyx_v_b);
+
+  /* "chython/containers/_unpack.pyx":187
+ *     f = ((a & 0x03) << 8) | b
+ * 
+ *     x = f / 1024.             # <<<<<<<<<<<<<<
+ *     if e:
+ *         x += 1.
+ */
+  __pyx_v_x = (((double)__pyx_v_f) / 1024.);
+
+  /* "chython/containers/_unpack.pyx":188
+ * 
+ *     x = f / 1024.
+ *     if e:             # <<<<<<<<<<<<<<
+ *         x += 1.
+ *         e -= 15
+ */
+  __pyx_t_1 = (__pyx_v_e != 0);
+  if (__pyx_t_1) {
+
+    /* "chython/containers/_unpack.pyx":189
+ *     x = f / 1024.
+ *     if e:
+ *         x += 1.             # <<<<<<<<<<<<<<
+ *         e -= 15
+ *     else:
+ */
+    __pyx_v_x = (__pyx_v_x + 1.);
+
+    /* "chython/containers/_unpack.pyx":190
+ *     if e:
+ *         x += 1.
+ *         e -= 15             # <<<<<<<<<<<<<<
+ *     else:
+ *         e = -14
+ */
+    __pyx_v_e = (__pyx_v_e - 15);
+
+    /* "chython/containers/_unpack.pyx":188
+ * 
+ *     x = f / 1024.
+ *     if e:             # <<<<<<<<<<<<<<
+ *         x += 1.
+ *         e -= 15
+ */
+    goto __pyx_L3;
+  }
+
+  /* "chython/containers/_unpack.pyx":192
+ *         e -= 15
+ *     else:
+ *         e = -14             # <<<<<<<<<<<<<<
+ * 
+ *     x = ldexp(x, e)
+ */
+  /*else*/ {
+    __pyx_v_e = -14;
+  }
+  __pyx_L3:;
+
+  /* "chython/containers/_unpack.pyx":194
+ *         e = -14
+ * 
+ *     x = ldexp(x, e)             # <<<<<<<<<<<<<<
+ *     if sign:
+ *         return -x
+ */
+  __pyx_v_x = ldexp(__pyx_v_x, __pyx_v_e);
+
+  /* "chython/containers/_unpack.pyx":195
+ * 
+ *     x = ldexp(x, e)
+ *     if sign:             # <<<<<<<<<<<<<<
+ *         return -x
+ *     return x
+ */
+  __pyx_t_1 = (__pyx_v_sign != 0);
+  if (__pyx_t_1) {
+
+    /* "chython/containers/_unpack.pyx":196
+ *     x = ldexp(x, e)
+ *     if sign:
+ *         return -x             # <<<<<<<<<<<<<<
+ *     return x
+ */
+    __pyx_r = (-__pyx_v_x);
+    goto __pyx_L0;
+
+    /* "chython/containers/_unpack.pyx":195
+ * 
+ *     x = ldexp(x, e)
+ *     if sign:             # <<<<<<<<<<<<<<
+ *         return -x
+ *     return x
+ */
+  }
+
+  /* "chython/containers/_unpack.pyx":197
+ *     if sign:
+ *         return -x
+ *     return x             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = __pyx_v_x;
+  goto __pyx_L0;
+
+  /* "chython/containers/_unpack.pyx":177
+ * 
+ * 
+ * cdef double double_from2bytes(unsigned char a, unsigned char b):             # <<<<<<<<<<<<<<
+ *     cdef bint sign
+ *     cdef int e
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -3872,21 +3806,21 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_shape)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_itemsize)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 123, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_format)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 123, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
           if (value) { values[3] = value; kw_args--; }
         }
@@ -3894,15 +3828,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allocate_buffer);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 123, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 122, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -3910,46 +3844,46 @@
         values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_shape = ((PyObject*)values[0]);
-    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L3_error)
+    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 122, __pyx_L3_error)
     __pyx_v_format = values[2];
     __pyx_v_mode = values[3];
     if (values[4]) {
-      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 124, __pyx_L3_error)
+      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L3_error)
     } else {
 
-      /* "View.MemoryView":124
+      /* "View.MemoryView":123
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,
  *                   mode="c", bint allocate_buffer=True):             # <<<<<<<<<<<<<<
  * 
  *         cdef int idx
  */
       __pyx_v_allocate_buffer = ((int)1);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 123, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 122, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 123, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 122, __pyx_L1_error)
   if (unlikely(((PyObject *)__pyx_v_format) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 123, __pyx_L1_error)
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 122, __pyx_L1_error)
   }
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v_shape, __pyx_v_itemsize, __pyx_v_format, __pyx_v_mode, __pyx_v_allocate_buffer);
 
-  /* "View.MemoryView":123
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -3983,579 +3917,579 @@
   Py_ssize_t __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
   __Pyx_INCREF(__pyx_v_format);
 
-  /* "View.MemoryView":130
+  /* "View.MemoryView":129
  *         cdef PyObject **p
  * 
  *         self.ndim = <int> len(shape)             # <<<<<<<<<<<<<<
  *         self.itemsize = itemsize
  * 
  */
   if (unlikely(__pyx_v_shape == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(1, 130, __pyx_L1_error)
+    __PYX_ERR(1, 129, __pyx_L1_error)
   }
-  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 130, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 129, __pyx_L1_error)
   __pyx_v_self->ndim = ((int)__pyx_t_1);
 
-  /* "View.MemoryView":131
+  /* "View.MemoryView":130
  * 
  *         self.ndim = <int> len(shape)
  *         self.itemsize = itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not self.ndim:
  */
   __pyx_v_self->itemsize = __pyx_v_itemsize;
 
-  /* "View.MemoryView":133
+  /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_self->ndim != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":134
+    /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 134, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 133, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 134, __pyx_L1_error)
+    __PYX_ERR(1, 133, __pyx_L1_error)
 
-    /* "View.MemoryView":133
+    /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":136
+  /* "View.MemoryView":135
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   __pyx_t_2 = ((__pyx_v_itemsize <= 0) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":137
+    /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 137, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 136, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 137, __pyx_L1_error)
+    __PYX_ERR(1, 136, __pyx_L1_error)
 
-    /* "View.MemoryView":136
+    /* "View.MemoryView":135
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":139
+  /* "View.MemoryView":138
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   __pyx_t_2 = PyBytes_Check(__pyx_v_format); 
   __pyx_t_4 = ((!(__pyx_t_2 != 0)) != 0);
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":140
+    /* "View.MemoryView":139
  * 
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 140, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_n_s_ASCII) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_n_s_ASCII);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 140, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":139
+    /* "View.MemoryView":138
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   }
 
-  /* "View.MemoryView":141
+  /* "View.MemoryView":140
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string             # <<<<<<<<<<<<<<
  *         self.format = self._format
  * 
  */
-  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(1, 141, __pyx_L1_error)
+  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(1, 140, __pyx_L1_error)
   __pyx_t_3 = __pyx_v_format;
   __Pyx_INCREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->_format);
   __Pyx_DECREF(__pyx_v_self->_format);
   __pyx_v_self->_format = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":142
+  /* "View.MemoryView":141
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format             # <<<<<<<<<<<<<<
  * 
  * 
  */
   if (unlikely(__pyx_v_self->_format == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(1, 142, __pyx_L1_error)
+    __PYX_ERR(1, 141, __pyx_L1_error)
   }
-  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(1, 142, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(1, 141, __pyx_L1_error)
   __pyx_v_self->format = __pyx_t_7;
 
-  /* "View.MemoryView":145
+  /* "View.MemoryView":144
  * 
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)             # <<<<<<<<<<<<<<
  *         self._strides = self._shape + self.ndim
  * 
  */
   __pyx_v_self->_shape = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * __pyx_v_self->ndim) * 2)));
 
-  /* "View.MemoryView":146
+  /* "View.MemoryView":145
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)
  *         self._strides = self._shape + self.ndim             # <<<<<<<<<<<<<<
  * 
  *         if not self._shape:
  */
   __pyx_v_self->_strides = (__pyx_v_self->_shape + __pyx_v_self->ndim);
 
-  /* "View.MemoryView":148
+  /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   __pyx_t_4 = ((!(__pyx_v_self->_shape != 0)) != 0);
   if (unlikely(__pyx_t_4)) {
 
-    /* "View.MemoryView":149
+    /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 149, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 148, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 149, __pyx_L1_error)
+    __PYX_ERR(1, 148, __pyx_L1_error)
 
-    /* "View.MemoryView":148
+    /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   }
 
-  /* "View.MemoryView":152
+  /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   __pyx_t_8 = 0;
   __pyx_t_3 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
   for (;;) {
     if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(1, 152, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(1, 151, __pyx_L1_error)
     #else
-    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 152, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 152, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_9;
     __pyx_v_idx = __pyx_t_8;
     __pyx_t_8 = (__pyx_t_8 + 1);
 
-    /* "View.MemoryView":153
+    /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     __pyx_t_4 = ((__pyx_v_dim <= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":154
+      /* "View.MemoryView":153
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))             # <<<<<<<<<<<<<<
  *             self._shape[idx] = dim
  * 
  */
-      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_GIVEREF(__pyx_t_5);
       PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
       __Pyx_GIVEREF(__pyx_t_6);
       PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_6);
       __pyx_t_5 = 0;
       __pyx_t_6 = 0;
-      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 154, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __PYX_ERR(1, 154, __pyx_L1_error)
+      __PYX_ERR(1, 153, __pyx_L1_error)
 
-      /* "View.MemoryView":153
+      /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     }
 
-    /* "View.MemoryView":155
+    /* "View.MemoryView":154
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim             # <<<<<<<<<<<<<<
  * 
  *         cdef char order
  */
     (__pyx_v_self->_shape[__pyx_v_idx]) = __pyx_v_dim;
 
-    /* "View.MemoryView":152
+    /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":158
+  /* "View.MemoryView":157
  * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 158, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 157, __pyx_L1_error)
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":159
+    /* "View.MemoryView":158
  *         cdef char order
  *         if mode == 'fortran':
  *             order = b'F'             # <<<<<<<<<<<<<<
  *             self.mode = u'fortran'
  *         elif mode == 'c':
  */
     __pyx_v_order = 'F';
 
-    /* "View.MemoryView":160
+    /* "View.MemoryView":159
  *         if mode == 'fortran':
  *             order = b'F'
  *             self.mode = u'fortran'             # <<<<<<<<<<<<<<
  *         elif mode == 'c':
  *             order = b'C'
  */
     __Pyx_INCREF(__pyx_n_u_fortran);
     __Pyx_GIVEREF(__pyx_n_u_fortran);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
     __pyx_v_self->mode = __pyx_n_u_fortran;
 
-    /* "View.MemoryView":158
+    /* "View.MemoryView":157
  * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
     goto __pyx_L10;
   }
 
-  /* "View.MemoryView":161
+  /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
  *         elif mode == 'c':             # <<<<<<<<<<<<<<
  *             order = b'C'
  *             self.mode = u'c'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 161, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 160, __pyx_L1_error)
   if (likely(__pyx_t_4)) {
 
-    /* "View.MemoryView":162
+    /* "View.MemoryView":161
  *             self.mode = u'fortran'
  *         elif mode == 'c':
  *             order = b'C'             # <<<<<<<<<<<<<<
  *             self.mode = u'c'
  *         else:
  */
     __pyx_v_order = 'C';
 
-    /* "View.MemoryView":163
+    /* "View.MemoryView":162
  *         elif mode == 'c':
  *             order = b'C'
  *             self.mode = u'c'             # <<<<<<<<<<<<<<
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  */
     __Pyx_INCREF(__pyx_n_u_c);
     __Pyx_GIVEREF(__pyx_n_u_c);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
     __pyx_v_self->mode = __pyx_n_u_c;
 
-    /* "View.MemoryView":161
+    /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
  *         elif mode == 'c':             # <<<<<<<<<<<<<<
  *             order = b'C'
  *             self.mode = u'c'
  */
     goto __pyx_L10;
   }
 
-  /* "View.MemoryView":165
+  /* "View.MemoryView":164
  *             self.mode = u'c'
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)             # <<<<<<<<<<<<<<
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,
  */
   /*else*/ {
-    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 165, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 165, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_10, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __PYX_ERR(1, 165, __pyx_L1_error)
+    __PYX_ERR(1, 164, __pyx_L1_error)
   }
   __pyx_L10:;
 
-  /* "View.MemoryView":167
+  /* "View.MemoryView":166
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,             # <<<<<<<<<<<<<<
  *                                              itemsize, self.ndim, order)
  * 
  */
   __pyx_v_self->len = __pyx_fill_contig_strides_array(__pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_itemsize, __pyx_v_self->ndim, __pyx_v_order);
 
-  /* "View.MemoryView":170
+  /* "View.MemoryView":169
  *                                              itemsize, self.ndim, order)
  * 
  *         self.free_data = allocate_buffer             # <<<<<<<<<<<<<<
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:
  */
   __pyx_v_self->free_data = __pyx_v_allocate_buffer;
 
-  /* "View.MemoryView":171
+  /* "View.MemoryView":170
  * 
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'             # <<<<<<<<<<<<<<
  *         if allocate_buffer:
  * 
  */
-  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 171, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 171, __pyx_L1_error)
+  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 170, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 170, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
   __pyx_v_self->dtype_is_object = __pyx_t_4;
 
-  /* "View.MemoryView":172
+  /* "View.MemoryView":171
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_4 = (__pyx_v_allocate_buffer != 0);
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":175
+    /* "View.MemoryView":174
  * 
  * 
  *             self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")
  */
     __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
 
-    /* "View.MemoryView":176
+    /* "View.MemoryView":175
  * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
  * 
  */
     __pyx_t_4 = ((!(__pyx_v_self->data != 0)) != 0);
     if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":177
+      /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 177, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 176, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __PYX_ERR(1, 177, __pyx_L1_error)
+      __PYX_ERR(1, 176, __pyx_L1_error)
 
-      /* "View.MemoryView":176
+      /* "View.MemoryView":175
  * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
  * 
  */
     }
 
-    /* "View.MemoryView":179
+    /* "View.MemoryView":178
  *                 raise MemoryError("unable to allocate array data.")
  * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     __pyx_t_4 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_4) {
 
-      /* "View.MemoryView":180
+      /* "View.MemoryView":179
  * 
  *             if self.dtype_is_object:
  *                 p = <PyObject **> self.data             # <<<<<<<<<<<<<<
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  */
       __pyx_v_p = ((PyObject **)__pyx_v_self->data);
 
-      /* "View.MemoryView":181
+      /* "View.MemoryView":180
  *             if self.dtype_is_object:
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):             # <<<<<<<<<<<<<<
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)
  */
       if (unlikely(__pyx_v_itemsize == 0)) {
         PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-        __PYX_ERR(1, 181, __pyx_L1_error)
+        __PYX_ERR(1, 180, __pyx_L1_error)
       }
       else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
         PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-        __PYX_ERR(1, 181, __pyx_L1_error)
+        __PYX_ERR(1, 180, __pyx_L1_error)
       }
       __pyx_t_1 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_itemsize);
       __pyx_t_9 = __pyx_t_1;
       for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11+=1) {
         __pyx_v_i = __pyx_t_11;
 
-        /* "View.MemoryView":182
+        /* "View.MemoryView":181
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None             # <<<<<<<<<<<<<<
  *                     Py_INCREF(Py_None)
  * 
  */
         (__pyx_v_p[__pyx_v_i]) = Py_None;
 
-        /* "View.MemoryView":183
+        /* "View.MemoryView":182
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
         Py_INCREF(Py_None);
       }
 
-      /* "View.MemoryView":179
+      /* "View.MemoryView":178
  *                 raise MemoryError("unable to allocate array data.")
  * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     }
 
-    /* "View.MemoryView":172
+    /* "View.MemoryView":171
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":123
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -4571,15 +4505,15 @@
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_format);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":186
+/* "View.MemoryView":185
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
@@ -4614,249 +4548,249 @@
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":187
+  /* "View.MemoryView":186
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1             # <<<<<<<<<<<<<<
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
   __pyx_v_bufmode = -1;
 
-  /* "View.MemoryView":188
+  /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
  *         if self.mode == u"c":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  */
-  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 188, __pyx_L1_error)
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 187, __pyx_L1_error)
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":189
+    /* "View.MemoryView":188
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
     __pyx_v_bufmode = (PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-    /* "View.MemoryView":188
+    /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
  *         if self.mode == u"c":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":190
+  /* "View.MemoryView":189
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  */
-  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 190, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 189, __pyx_L1_error)
   __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":191
+    /* "View.MemoryView":190
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  */
     __pyx_v_bufmode = (PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-    /* "View.MemoryView":190
+    /* "View.MemoryView":189
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":192
+  /* "View.MemoryView":191
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
   __pyx_t_1 = ((!((__pyx_v_flags & __pyx_v_bufmode) != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":193
+    /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 193, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 193, __pyx_L1_error)
+    __PYX_ERR(1, 192, __pyx_L1_error)
 
-    /* "View.MemoryView":192
+    /* "View.MemoryView":191
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
   }
 
-  /* "View.MemoryView":194
+  /* "View.MemoryView":193
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data             # <<<<<<<<<<<<<<
  *         info.len = self.len
  *         info.ndim = self.ndim
  */
   __pyx_t_4 = __pyx_v_self->data;
   __pyx_v_info->buf = __pyx_t_4;
 
-  /* "View.MemoryView":195
+  /* "View.MemoryView":194
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  *         info.len = self.len             # <<<<<<<<<<<<<<
  *         info.ndim = self.ndim
  *         info.shape = self._shape
  */
   __pyx_t_5 = __pyx_v_self->len;
   __pyx_v_info->len = __pyx_t_5;
 
-  /* "View.MemoryView":196
+  /* "View.MemoryView":195
  *         info.buf = self.data
  *         info.len = self.len
  *         info.ndim = self.ndim             # <<<<<<<<<<<<<<
  *         info.shape = self._shape
  *         info.strides = self._strides
  */
   __pyx_t_6 = __pyx_v_self->ndim;
   __pyx_v_info->ndim = __pyx_t_6;
 
-  /* "View.MemoryView":197
+  /* "View.MemoryView":196
  *         info.len = self.len
  *         info.ndim = self.ndim
  *         info.shape = self._shape             # <<<<<<<<<<<<<<
  *         info.strides = self._strides
  *         info.suboffsets = NULL
  */
   __pyx_t_7 = __pyx_v_self->_shape;
   __pyx_v_info->shape = __pyx_t_7;
 
-  /* "View.MemoryView":198
+  /* "View.MemoryView":197
  *         info.ndim = self.ndim
  *         info.shape = self._shape
  *         info.strides = self._strides             # <<<<<<<<<<<<<<
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  */
   __pyx_t_7 = __pyx_v_self->_strides;
   __pyx_v_info->strides = __pyx_t_7;
 
-  /* "View.MemoryView":199
+  /* "View.MemoryView":198
  *         info.shape = self._shape
  *         info.strides = self._strides
  *         info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *         info.itemsize = self.itemsize
  *         info.readonly = 0
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* "View.MemoryView":200
+  /* "View.MemoryView":199
  *         info.strides = self._strides
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize             # <<<<<<<<<<<<<<
  *         info.readonly = 0
  * 
  */
   __pyx_t_5 = __pyx_v_self->itemsize;
   __pyx_v_info->itemsize = __pyx_t_5;
 
-  /* "View.MemoryView":201
+  /* "View.MemoryView":200
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  *         info.readonly = 0             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   __pyx_v_info->readonly = 0;
 
-  /* "View.MemoryView":203
+  /* "View.MemoryView":202
  *         info.readonly = 0
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":204
+    /* "View.MemoryView":203
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
     __pyx_t_4 = __pyx_v_self->format;
     __pyx_v_info->format = __pyx_t_4;
 
-    /* "View.MemoryView":203
+    /* "View.MemoryView":202
  *         info.readonly = 0
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
     goto __pyx_L5;
   }
 
-  /* "View.MemoryView":206
+  /* "View.MemoryView":205
  *             info.format = self.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.obj = self
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L5:;
 
-  /* "View.MemoryView":208
+  /* "View.MemoryView":207
  *             info.format = NULL
  * 
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":186
+  /* "View.MemoryView":185
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
@@ -4878,15 +4812,15 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":212
+/* "View.MemoryView":211
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
@@ -4902,122 +4836,122 @@
 }
 
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":213
+  /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
   __pyx_t_1 = ((__pyx_v_self->callback_free_data != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":214
+    /* "View.MemoryView":213
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)             # <<<<<<<<<<<<<<
  *         elif self.free_data:
  *             if self.dtype_is_object:
  */
     __pyx_v_self->callback_free_data(__pyx_v_self->data);
 
-    /* "View.MemoryView":213
+    /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":215
+  /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,
  */
   __pyx_t_1 = (__pyx_v_self->free_data != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":216
+    /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  */
     __pyx_t_1 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":217
+      /* "View.MemoryView":216
  *         elif self.free_data:
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,             # <<<<<<<<<<<<<<
  *                                           self._strides, self.ndim, False)
  *             free(self.data)
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_self->data, __pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_self->ndim, 0);
 
-      /* "View.MemoryView":216
+      /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  */
     }
 
-    /* "View.MemoryView":219
+    /* "View.MemoryView":218
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  *             free(self.data)             # <<<<<<<<<<<<<<
  *         PyObject_Free(self._shape)
  * 
  */
     free(__pyx_v_self->data);
 
-    /* "View.MemoryView":215
+    /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":220
+  /* "View.MemoryView":219
  *                                           self._strides, self.ndim, False)
  *             free(self.data)
  *         PyObject_Free(self._shape)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   PyObject_Free(__pyx_v_self->_shape);
 
-  /* "View.MemoryView":212
+  /* "View.MemoryView":211
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":223
+/* "View.MemoryView":222
  * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
  * 
  */
 
@@ -5039,29 +4973,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":224
+  /* "View.MemoryView":223
  *     @property
  *     def memview(self):
  *         return self.get_memview()             # <<<<<<<<<<<<<<
  * 
  *     @cname('get_memview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 224, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 223, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":223
+  /* "View.MemoryView":222
  * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
  * 
  */
 
@@ -5072,15 +5006,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":227
+/* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5092,54 +5026,54 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_memview", 0);
 
-  /* "View.MemoryView":228
+  /* "View.MemoryView":227
  *     @cname('get_memview')
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE             # <<<<<<<<<<<<<<
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  */
   __pyx_v_flags = ((PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) | PyBUF_WRITABLE);
 
-  /* "View.MemoryView":229
+  /* "View.MemoryView":228
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":227
+  /* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5152,15 +5086,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":231
+/* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
@@ -5178,39 +5112,39 @@
 }
 
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":232
+  /* "View.MemoryView":231
  * 
  *     def __len__(self):
  *         return self._shape[0]             # <<<<<<<<<<<<<<
  * 
  *     def __getattr__(self, attr):
  */
   __pyx_r = (__pyx_v_self->_shape[0]);
   goto __pyx_L0;
 
-  /* "View.MemoryView":231
+  /* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":234
+/* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -5233,32 +5167,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getattr__", 0);
 
-  /* "View.MemoryView":235
+  /* "View.MemoryView":234
  * 
  *     def __getattr__(self, attr):
  *         return getattr(self.memview, attr)             # <<<<<<<<<<<<<<
  * 
  *     def __getitem__(self, item):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":234
+  /* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -5270,15 +5204,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":237
+/* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -5301,32 +5235,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":238
+  /* "View.MemoryView":237
  * 
  *     def __getitem__(self, item):
  *         return self.memview[item]             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(self, item, value):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":237
+  /* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -5338,15 +5272,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":240
+/* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -5368,27 +5302,27 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
 
-  /* "View.MemoryView":241
+  /* "View.MemoryView":240
  * 
  *     def __setitem__(self, item, value):
  *         self.memview[item] = value             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 241, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(1, 241, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":240
+  /* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -5434,15 +5368,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -5490,15 +5424,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -5513,15 +5447,15 @@
   __Pyx_AddTraceback("View.MemoryView.array.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":245
+/* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
@@ -5535,145 +5469,145 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("array_cwrapper", 0);
 
-  /* "View.MemoryView":249
+  /* "View.MemoryView":248
  *     cdef array result
  * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_buf == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":250
+    /* "View.MemoryView":249
  * 
  *     if buf == NULL:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))             # <<<<<<<<<<<<<<
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
     __pyx_t_2 = 0;
     __pyx_t_3 = 0;
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 250, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "View.MemoryView":249
+    /* "View.MemoryView":248
  *     cdef array result
  * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":252
+  /* "View.MemoryView":251
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
   /*else*/ {
-    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_t_3);
     __pyx_t_4 = 0;
     __pyx_t_5 = 0;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":253
+    /* "View.MemoryView":252
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)             # <<<<<<<<<<<<<<
  *         result.data = buf
  * 
  */
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 253, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 253, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 252, __pyx_L1_error)
 
-    /* "View.MemoryView":252
+    /* "View.MemoryView":251
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
-    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "View.MemoryView":254
+    /* "View.MemoryView":253
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)
  *         result.data = buf             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
     __pyx_v_result->data = __pyx_v_buf;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":256
+  /* "View.MemoryView":255
  *         result.data = buf
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(((PyObject *)__pyx_r));
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":245
+  /* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
@@ -5688,15 +5622,15 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":282
+/* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
@@ -5725,26 +5659,26 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(1, 282, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(1, 281, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_name = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 282, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.Enum.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v_name);
 
@@ -5754,42 +5688,42 @@
 }
 
 static int __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v_name) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "View.MemoryView":283
+  /* "View.MemoryView":282
  *     cdef object name
  *     def __init__(self, name):
  *         self.name = name             # <<<<<<<<<<<<<<
  *     def __repr__(self):
  *         return self.name
  */
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   __Pyx_GOTREF(__pyx_v_self->name);
   __Pyx_DECREF(__pyx_v_self->name);
   __pyx_v_self->name = __pyx_v_name;
 
-  /* "View.MemoryView":282
+  /* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":284
+/* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -5807,27 +5741,27 @@
 }
 
 static PyObject *__pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum_2__repr__(struct __pyx_MemviewEnum_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":285
+  /* "View.MemoryView":284
  *         self.name = name
  *     def __repr__(self):
  *         return self.name             # <<<<<<<<<<<<<<
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->name);
   __pyx_r = __pyx_v_self->name;
   goto __pyx_L0;
 
-  /* "View.MemoryView":284
+  /* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -6102,15 +6036,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":17
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
-  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
+  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
@@ -6127,98 +6061,98 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":299
+/* "View.MemoryView":298
  * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
 static void *__pyx_align_pointer(void *__pyx_v_memory, size_t __pyx_v_alignment) {
   Py_intptr_t __pyx_v_aligned_p;
   size_t __pyx_v_offset;
   void *__pyx_r;
   int __pyx_t_1;
 
-  /* "View.MemoryView":301
+  /* "View.MemoryView":300
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory             # <<<<<<<<<<<<<<
  *     cdef size_t offset
  * 
  */
   __pyx_v_aligned_p = ((Py_intptr_t)__pyx_v_memory);
 
-  /* "View.MemoryView":305
+  /* "View.MemoryView":304
  * 
  *     with cython.cdivision(True):
  *         offset = aligned_p % alignment             # <<<<<<<<<<<<<<
  * 
  *     if offset > 0:
  */
   __pyx_v_offset = (__pyx_v_aligned_p % __pyx_v_alignment);
 
-  /* "View.MemoryView":307
+  /* "View.MemoryView":306
  *         offset = aligned_p % alignment
  * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
  * 
  */
   __pyx_t_1 = ((__pyx_v_offset > 0) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":308
+    /* "View.MemoryView":307
  * 
  *     if offset > 0:
  *         aligned_p += alignment - offset             # <<<<<<<<<<<<<<
  * 
  *     return <void *> aligned_p
  */
     __pyx_v_aligned_p = (__pyx_v_aligned_p + (__pyx_v_alignment - __pyx_v_offset));
 
-    /* "View.MemoryView":307
+    /* "View.MemoryView":306
  *         offset = aligned_p % alignment
  * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
  * 
  */
   }
 
-  /* "View.MemoryView":310
+  /* "View.MemoryView":309
  *         aligned_p += alignment - offset
  * 
  *     return <void *> aligned_p             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((void *)__pyx_v_aligned_p);
   goto __pyx_L0;
 
-  /* "View.MemoryView":299
+  /* "View.MemoryView":298
  * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":346
+/* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -6255,47 +6189,47 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_flags)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 346, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype_is_object);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 346, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 345, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_obj = values[0];
-    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 346, __pyx_L3_error)
+    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     if (values[2]) {
-      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 346, __pyx_L3_error)
+      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     } else {
       __pyx_v_dtype_is_object = ((int)0);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 346, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_obj, __pyx_v_flags, __pyx_v_dtype_is_object);
 
@@ -6312,37 +6246,37 @@
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "View.MemoryView":347
+  /* "View.MemoryView":346
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj             # <<<<<<<<<<<<<<
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  */
   __Pyx_INCREF(__pyx_v_obj);
   __Pyx_GIVEREF(__pyx_v_obj);
   __Pyx_GOTREF(__pyx_v_self->obj);
   __Pyx_DECREF(__pyx_v_self->obj);
   __pyx_v_self->obj = __pyx_v_obj;
 
-  /* "View.MemoryView":348
+  /* "View.MemoryView":347
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj
  *         self.flags = flags             # <<<<<<<<<<<<<<
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  */
   __pyx_v_self->flags = __pyx_v_flags;
 
-  /* "View.MemoryView":349
+  /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   __pyx_t_2 = (((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))) == ((PyObject *)__pyx_memoryview_type));
@@ -6354,250 +6288,231 @@
   }
   __pyx_t_3 = (__pyx_v_obj != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":350
+    /* "View.MemoryView":349
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)             # <<<<<<<<<<<<<<
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  */
-    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 350, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 349, __pyx_L1_error)
 
-    /* "View.MemoryView":351
+    /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     __pyx_t_1 = ((((PyObject *)__pyx_v_self->view.obj) == NULL) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":352
+      /* "View.MemoryView":351
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None             # <<<<<<<<<<<<<<
  *                 Py_INCREF(Py_None)
  * 
  */
       ((Py_buffer *)(&__pyx_v_self->view))->obj = Py_None;
 
-      /* "View.MemoryView":353
+      /* "View.MemoryView":352
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
+ *         global __pyx_memoryview_thread_locks_used
  */
       Py_INCREF(Py_None);
 
-      /* "View.MemoryView":351
+      /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     }
 
-    /* "View.MemoryView":349
+    /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   }
 
   /* "View.MemoryView":355
- *                 Py_INCREF(Py_None)
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-  __pyx_t_1 = ((!(__PYX_CYTHON_ATOMICS_ENABLED() != 0)) != 0);
+  __pyx_t_1 = ((__pyx_memoryview_thread_locks_used < 8) != 0);
   if (__pyx_t_1) {
 
+    /* "View.MemoryView":356
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ */
+    __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+
     /* "View.MemoryView":357
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  */
-    __pyx_t_1 = ((__pyx_memoryview_thread_locks_used < 8) != 0);
-    if (__pyx_t_1) {
+    __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
 
-      /* "View.MemoryView":358
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:
+    /* "View.MemoryView":355
+ * 
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-      __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+  }
 
-      /* "View.MemoryView":359
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":358
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
  */
-      __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
+  __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
+  if (__pyx_t_1) {
 
-      /* "View.MemoryView":357
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+    /* "View.MemoryView":359
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
+ *             if self.lock is NULL:
+ *                 raise MemoryError
  */
-    }
+    __pyx_v_self->lock = PyThread_allocate_lock();
 
     /* "View.MemoryView":360
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+ *                 raise MemoryError
+ * 
  */
     __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
-    if (__pyx_t_1) {
+    if (unlikely(__pyx_t_1)) {
 
       /* "View.MemoryView":361
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
- *                 if self.lock is NULL:
- *                     raise MemoryError
- */
-      __pyx_v_self->lock = PyThread_allocate_lock();
-
-      /* "View.MemoryView":362
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
- * 
- */
-      __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
-      if (unlikely(__pyx_t_1)) {
-
-        /* "View.MemoryView":363
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
- *                     raise MemoryError             # <<<<<<<<<<<<<<
+ *                 raise MemoryError             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
-        PyErr_NoMemory(); __PYX_ERR(1, 363, __pyx_L1_error)
-
-        /* "View.MemoryView":362
- *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
- * 
- */
-      }
+      PyErr_NoMemory(); __PYX_ERR(1, 361, __pyx_L1_error)
 
       /* "View.MemoryView":360
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+ *                 raise MemoryError
+ * 
  */
     }
 
-    /* "View.MemoryView":355
- *                 Py_INCREF(Py_None)
- * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+    /* "View.MemoryView":358
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
+ *             if self.lock is NULL:
  */
   }
 
-  /* "View.MemoryView":365
- *                     raise MemoryError
+  /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":366
+    /* "View.MemoryView":364
  * 
  *         if flags & PyBUF_FORMAT:
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')             # <<<<<<<<<<<<<<
  *         else:
  *             self.dtype_is_object = dtype_is_object
  */
     __pyx_t_2 = (((__pyx_v_self->view.format[0]) == 'O') != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
-      goto __pyx_L12_bool_binop_done;
+      goto __pyx_L11_bool_binop_done;
     }
     __pyx_t_2 = (((__pyx_v_self->view.format[1]) == '\x00') != 0);
     __pyx_t_1 = __pyx_t_2;
-    __pyx_L12_bool_binop_done:;
+    __pyx_L11_bool_binop_done:;
     __pyx_v_self->dtype_is_object = __pyx_t_1;
 
-    /* "View.MemoryView":365
- *                     raise MemoryError
+    /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":368
+  /* "View.MemoryView":366
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  *             self.dtype_is_object = dtype_is_object             # <<<<<<<<<<<<<<
  * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  */
   /*else*/ {
     __pyx_v_self->dtype_is_object = __pyx_v_dtype_is_object;
   }
-  __pyx_L11:;
+  __pyx_L10:;
 
-  /* "View.MemoryView":370
+  /* "View.MemoryView":368
  *             self.dtype_is_object = dtype_is_object
  * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(             # <<<<<<<<<<<<<<
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL
  */
   __pyx_v_self->acquisition_count_aligned_p = ((__pyx_atomic_int *)__pyx_align_pointer(((void *)(&(__pyx_v_self->acquisition_count[0]))), (sizeof(__pyx_atomic_int))));
 
-  /* "View.MemoryView":372
+  /* "View.MemoryView":370
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(memoryview self):
  */
   __pyx_v_self->typeinfo = NULL;
 
-  /* "View.MemoryView":346
+  /* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -6608,15 +6523,15 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":374
+/* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
@@ -6639,215 +6554,215 @@
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   PyThread_type_lock __pyx_t_6;
   PyThread_type_lock __pyx_t_7;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":375
+  /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
   __pyx_t_1 = (__pyx_v_self->obj != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":376
+    /* "View.MemoryView":374
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)             # <<<<<<<<<<<<<<
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  */
     __Pyx_ReleaseBuffer((&__pyx_v_self->view));
 
-    /* "View.MemoryView":375
+    /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":377
+  /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   __pyx_t_2 = ((((Py_buffer *)(&__pyx_v_self->view))->obj == Py_None) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":379
+    /* "View.MemoryView":377
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL             # <<<<<<<<<<<<<<
  *             Py_DECREF(Py_None)
  * 
  */
     ((Py_buffer *)(&__pyx_v_self->view))->obj = NULL;
 
-    /* "View.MemoryView":380
+    /* "View.MemoryView":378
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  *             Py_DECREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *         cdef int i
  */
     Py_DECREF(Py_None);
 
-    /* "View.MemoryView":377
+    /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":384
+  /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   __pyx_t_2 = ((__pyx_v_self->lock != NULL) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":385
+    /* "View.MemoryView":383
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):             # <<<<<<<<<<<<<<
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  */
     __pyx_t_3 = __pyx_memoryview_thread_locks_used;
     __pyx_t_4 = __pyx_t_3;
     for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
       __pyx_v_i = __pyx_t_5;
 
-      /* "View.MemoryView":386
+      /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       __pyx_t_2 = (((__pyx_memoryview_thread_locks[__pyx_v_i]) == __pyx_v_self->lock) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":387
+        /* "View.MemoryView":385
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1             # <<<<<<<<<<<<<<
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  */
         __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used - 1);
 
-        /* "View.MemoryView":388
+        /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         __pyx_t_2 = ((__pyx_v_i != __pyx_memoryview_thread_locks_used) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":390
+          /* "View.MemoryView":388
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])             # <<<<<<<<<<<<<<
  *                     break
  *             else:
  */
           __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
           __pyx_t_7 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
 
-          /* "View.MemoryView":389
+          /* "View.MemoryView":387
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (             # <<<<<<<<<<<<<<
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break
  */
           (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_6;
           (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_7;
 
-          /* "View.MemoryView":388
+          /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         }
 
-        /* "View.MemoryView":391
+        /* "View.MemoryView":389
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break             # <<<<<<<<<<<<<<
  *             else:
  *                 PyThread_free_lock(self.lock)
  */
         goto __pyx_L6_break;
 
-        /* "View.MemoryView":386
+        /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       }
     }
     /*else*/ {
 
-      /* "View.MemoryView":393
+      /* "View.MemoryView":391
  *                     break
  *             else:
  *                 PyThread_free_lock(self.lock)             # <<<<<<<<<<<<<<
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  */
       PyThread_free_lock(__pyx_v_self->lock);
     }
     __pyx_L6_break:;
 
-    /* "View.MemoryView":384
+    /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   }
 
-  /* "View.MemoryView":374
+  /* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":395
+/* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -6865,107 +6780,107 @@
   Py_ssize_t __pyx_t_6;
   char *__pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_item_pointer", 0);
 
-  /* "View.MemoryView":397
+  /* "View.MemoryView":395
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf             # <<<<<<<<<<<<<<
  * 
  *         for dim, idx in enumerate(index):
  */
   __pyx_v_itemp = ((char *)__pyx_v_self->view.buf);
 
-  /* "View.MemoryView":399
+  /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   __pyx_t_1 = 0;
   if (likely(PyList_CheckExact(__pyx_v_index)) || PyTuple_CheckExact(__pyx_v_index)) {
     __pyx_t_2 = __pyx_v_index; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 399, __pyx_L1_error)
+    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 397, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 399, __pyx_L1_error)
+    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 397, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_4)) {
       if (likely(PyList_CheckExact(__pyx_t_2))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 399, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       }
     } else {
       __pyx_t_5 = __pyx_t_4(__pyx_t_2);
       if (unlikely(!__pyx_t_5)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 399, __pyx_L1_error)
+          else __PYX_ERR(1, 397, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_5);
     }
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_1;
     __pyx_t_1 = (__pyx_t_1 + 1);
 
-    /* "View.MemoryView":400
+    /* "View.MemoryView":398
  * 
  *         for dim, idx in enumerate(index):
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)             # <<<<<<<<<<<<<<
  * 
  *         return itemp
  */
-    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 400, __pyx_L1_error)
-    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 400, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 398, __pyx_L1_error)
+    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 398, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_7;
 
-    /* "View.MemoryView":399
+    /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":402
+  /* "View.MemoryView":400
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  *         return itemp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_itemp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":395
+  /* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -6977,15 +6892,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":405
+/* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
@@ -7015,143 +6930,143 @@
   PyObject *__pyx_t_5 = NULL;
   char *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":406
+  /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   __pyx_t_1 = (__pyx_v_index == __pyx_builtin_Ellipsis);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":407
+    /* "View.MemoryView":405
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:
  *             return self             # <<<<<<<<<<<<<<
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __pyx_r = ((PyObject *)__pyx_v_self);
     goto __pyx_L0;
 
-    /* "View.MemoryView":406
+    /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   }
 
-  /* "View.MemoryView":409
+  /* "View.MemoryView":407
  *             return self
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         cdef char *itemp
  */
-  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 409, __pyx_L1_error)
+  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 407, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (likely(__pyx_t_3 != Py_None)) {
     PyObject* sequence = __pyx_t_3;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 409, __pyx_L1_error)
+      __PYX_ERR(1, 407, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 409, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 409, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 409, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 407, __pyx_L1_error)
   }
   __pyx_v_have_slices = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_v_indices = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "View.MemoryView":412
+  /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 412, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 410, __pyx_L1_error)
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":413
+    /* "View.MemoryView":411
  *         cdef char *itemp
  *         if have_slices:
  *             return memview_slice(self, indices)             # <<<<<<<<<<<<<<
  *         else:
  *             itemp = self.get_item_pointer(indices)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 413, __pyx_L1_error)
+    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 411, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":412
+    /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
   }
 
-  /* "View.MemoryView":415
+  /* "View.MemoryView":413
  *             return memview_slice(self, indices)
  *         else:
  *             itemp = self.get_item_pointer(indices)             # <<<<<<<<<<<<<<
  *             return self.convert_item_to_object(itemp)
  * 
  */
   /*else*/ {
-    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(1, 415, __pyx_L1_error)
+    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(1, 413, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_6;
 
-    /* "View.MemoryView":416
+    /* "View.MemoryView":414
  *         else:
  *             itemp = self.get_item_pointer(indices)
  *             return self.convert_item_to_object(itemp)             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(memoryview self, object index, object value):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 416, __pyx_L1_error)
+    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 414, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":405
+  /* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
@@ -7166,15 +7081,15 @@
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_indices);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":418
+/* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
@@ -7202,182 +7117,182 @@
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
   __Pyx_INCREF(__pyx_v_index);
 
-  /* "View.MemoryView":419
+  /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
   __pyx_t_1 = (__pyx_v_self->view.readonly != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":420
+    /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 418, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 420, __pyx_L1_error)
+    __PYX_ERR(1, 418, __pyx_L1_error)
 
-    /* "View.MemoryView":419
+    /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":422
+  /* "View.MemoryView":420
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         if have_slices:
  */
-  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 422, __pyx_L1_error)
+  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (likely(__pyx_t_2 != Py_None)) {
     PyObject* sequence = __pyx_t_2;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 422, __pyx_L1_error)
+      __PYX_ERR(1, 420, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 422, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 422, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     #endif
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 422, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 420, __pyx_L1_error)
   }
   __pyx_v_have_slices = __pyx_t_3;
   __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_4);
   __pyx_t_4 = 0;
 
-  /* "View.MemoryView":424
+  /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 424, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 422, __pyx_L1_error)
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":425
+    /* "View.MemoryView":423
  * 
  *         if have_slices:
  *             obj = self.is_slice(value)             # <<<<<<<<<<<<<<
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)
  */
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 425, __pyx_L1_error)
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 423, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_v_obj = __pyx_t_2;
     __pyx_t_2 = 0;
 
-    /* "View.MemoryView":426
+    /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 426, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 424, __pyx_L1_error)
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":427
+      /* "View.MemoryView":425
  *             obj = self.is_slice(value)
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)             # <<<<<<<<<<<<<<
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)
  */
-      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 425, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 425, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-      /* "View.MemoryView":426
+      /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":429
+    /* "View.MemoryView":427
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)             # <<<<<<<<<<<<<<
  *         else:
  *             self.setitem_indexed(index, value)
  */
     /*else*/ {
-      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 429, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 427, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(1, 429, __pyx_L1_error)
-      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 429, __pyx_L1_error)
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 427, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":424
+    /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
     goto __pyx_L4;
   }
 
-  /* "View.MemoryView":431
+  /* "View.MemoryView":429
  *                 self.setitem_slice_assign_scalar(self[index], value)
  *         else:
  *             self.setitem_indexed(index, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef is_slice(self, obj):
  */
   /*else*/ {
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 431, __pyx_L1_error)
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 429, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
   __pyx_L4:;
 
-  /* "View.MemoryView":418
+  /* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
@@ -7394,15 +7309,15 @@
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":433
+/* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7420,26 +7335,26 @@
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_slice", 0);
   __Pyx_INCREF(__pyx_v_obj);
 
-  /* "View.MemoryView":434
+  /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_obj, __pyx_memoryview_type); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":435
+    /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
     {
@@ -7447,59 +7362,59 @@
       __Pyx_PyThreadState_assign
       __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_3);
       __Pyx_XGOTREF(__pyx_t_4);
       __Pyx_XGOTREF(__pyx_t_5);
       /*try:*/ {
 
-        /* "View.MemoryView":436
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 436, __pyx_L4_error)
+        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":437
+        /* "View.MemoryView":435
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)             # <<<<<<<<<<<<<<
  *             except TypeError:
  *                 return None
  */
-        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 437, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 435, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
 
-        /* "View.MemoryView":436
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 436, __pyx_L4_error)
+        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_INCREF(__pyx_v_obj);
         __Pyx_GIVEREF(__pyx_v_obj);
         PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_obj);
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_6);
         __Pyx_GIVEREF(__pyx_t_7);
         PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_7);
         __pyx_t_6 = 0;
         __pyx_t_7 = 0;
-        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 436, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF_SET(__pyx_v_obj, __pyx_t_7);
         __pyx_t_7 = 0;
 
-        /* "View.MemoryView":435
+        /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       }
@@ -7508,30 +7423,30 @@
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       goto __pyx_L9_try_end;
       __pyx_L4_error:;
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-      /* "View.MemoryView":438
+      /* "View.MemoryView":436
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  *             except TypeError:             # <<<<<<<<<<<<<<
  *                 return None
  * 
  */
       __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
       if (__pyx_t_9) {
         __Pyx_AddTraceback("View.MemoryView.memoryview.is_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 438, __pyx_L6_except_error)
+        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 436, __pyx_L6_except_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":439
+        /* "View.MemoryView":437
  *                                  self.dtype_is_object)
  *             except TypeError:
  *                 return None             # <<<<<<<<<<<<<<
  * 
  *         return obj
  */
         __Pyx_XDECREF(__pyx_r);
@@ -7540,15 +7455,15 @@
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         goto __pyx_L7_except_return;
       }
       goto __pyx_L6_except_error;
       __pyx_L6_except_error:;
 
-      /* "View.MemoryView":435
+      /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       __Pyx_XGIVEREF(__pyx_t_3);
@@ -7561,36 +7476,36 @@
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L0;
       __pyx_L9_try_end:;
     }
 
-    /* "View.MemoryView":434
+    /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   }
 
-  /* "View.MemoryView":441
+  /* "View.MemoryView":439
  *                 return None
  * 
  *         return obj             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assignment(self, dst, src):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_obj);
   __pyx_r = __pyx_v_obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":433
+  /* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7604,15 +7519,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":443
+/* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
@@ -7628,60 +7543,60 @@
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assignment", 0);
 
-  /* "View.MemoryView":447
+  /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 447, __pyx_L1_error)
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 447, __pyx_L1_error)
+  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 445, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 445, __pyx_L1_error)
 
-  /* "View.MemoryView":448
+  /* "View.MemoryView":446
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],             # <<<<<<<<<<<<<<
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  */
-  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 448, __pyx_L1_error)
-  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 448, __pyx_L1_error)
+  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 446, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 446, __pyx_L1_error)
 
-  /* "View.MemoryView":449
+  /* "View.MemoryView":447
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":447
+  /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 447, __pyx_L1_error)
+  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 445, __pyx_L1_error)
 
-  /* "View.MemoryView":443
+  /* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
@@ -7694,15 +7609,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":451
+/* "View.MemoryView":449
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
@@ -7727,204 +7642,204 @@
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assign_scalar", 0);
 
-  /* "View.MemoryView":453
+  /* "View.MemoryView":451
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  *         cdef int array[128]
  *         cdef void *tmp = NULL             # <<<<<<<<<<<<<<
  *         cdef void *item
  * 
  */
   __pyx_v_tmp = NULL;
 
-  /* "View.MemoryView":458
+  /* "View.MemoryView":456
  *         cdef __Pyx_memviewslice *dst_slice
  *         cdef __Pyx_memviewslice tmp_slice
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)             # <<<<<<<<<<<<<<
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 458, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 456, __pyx_L1_error)
   __pyx_v_dst_slice = __pyx_t_1;
 
-  /* "View.MemoryView":460
+  /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
   __pyx_t_2 = ((((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array))) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":461
+    /* "View.MemoryView":459
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)             # <<<<<<<<<<<<<<
  *             if tmp == NULL:
  *                 raise MemoryError
  */
     __pyx_v_tmp = PyMem_Malloc(__pyx_v_self->view.itemsize);
 
-    /* "View.MemoryView":462
+    /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     __pyx_t_2 = ((__pyx_v_tmp == NULL) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":463
+      /* "View.MemoryView":461
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  *             item = tmp
  *         else:
  */
-      PyErr_NoMemory(); __PYX_ERR(1, 463, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(1, 461, __pyx_L1_error)
 
-      /* "View.MemoryView":462
+      /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     }
 
-    /* "View.MemoryView":464
+    /* "View.MemoryView":462
  *             if tmp == NULL:
  *                 raise MemoryError
  *             item = tmp             # <<<<<<<<<<<<<<
  *         else:
  *             item = <void *> array
  */
     __pyx_v_item = __pyx_v_tmp;
 
-    /* "View.MemoryView":460
+    /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":466
+  /* "View.MemoryView":464
  *             item = tmp
  *         else:
  *             item = <void *> array             # <<<<<<<<<<<<<<
  * 
  *         try:
  */
   /*else*/ {
     __pyx_v_item = ((void *)__pyx_v_array);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":468
+  /* "View.MemoryView":466
  *             item = <void *> array
  * 
  *         try:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value
  */
   /*try:*/ {
 
-    /* "View.MemoryView":469
+    /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
     __pyx_t_2 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":470
+      /* "View.MemoryView":468
  *         try:
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value             # <<<<<<<<<<<<<<
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)
  */
       (((PyObject **)__pyx_v_item)[0]) = ((PyObject *)__pyx_v_value);
 
-      /* "View.MemoryView":469
+      /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
       goto __pyx_L8;
     }
 
-    /* "View.MemoryView":472
+    /* "View.MemoryView":470
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     /*else*/ {
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 472, __pyx_L6_error)
+      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 470, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __pyx_L8:;
 
-    /* "View.MemoryView":476
+    /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     __pyx_t_2 = ((__pyx_v_self->view.suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":477
+      /* "View.MemoryView":475
  * 
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)             # <<<<<<<<<<<<<<
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  *                                 item, self.dtype_is_object)
  */
-      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 477, __pyx_L6_error)
+      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 475, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-      /* "View.MemoryView":476
+      /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     }
 
-    /* "View.MemoryView":478
+    /* "View.MemoryView":476
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,             # <<<<<<<<<<<<<<
  *                                 item, self.dtype_is_object)
  *         finally:
  */
     __pyx_memoryview_slice_assign_scalar(__pyx_v_dst_slice, __pyx_v_dst->view.ndim, __pyx_v_self->view.itemsize, __pyx_v_item, __pyx_v_self->dtype_is_object);
   }
 
-  /* "View.MemoryView":481
+  /* "View.MemoryView":479
  *                                 item, self.dtype_is_object)
  *         finally:
  *             PyMem_Free(tmp)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_indexed(self, index, value):
  */
   /*finally:*/ {
@@ -7963,15 +7878,15 @@
       __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
       __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "View.MemoryView":451
+  /* "View.MemoryView":449
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
@@ -7984,15 +7899,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":483
+/* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8003,36 +7918,36 @@
   char *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_indexed", 0);
 
-  /* "View.MemoryView":484
+  /* "View.MemoryView":482
  * 
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)             # <<<<<<<<<<<<<<
  *         self.assign_item_from_object(itemp, value)
  * 
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 484, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 482, __pyx_L1_error)
   __pyx_v_itemp = __pyx_t_1;
 
-  /* "View.MemoryView":485
+  /* "View.MemoryView":483
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 485, __pyx_L1_error)
+  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 483, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":483
+  /* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8045,15 +7960,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":487
+/* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8075,39 +7990,39 @@
   size_t __pyx_t_10;
   int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":490
+  /* "View.MemoryView":488
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef bytes bytesitem
  * 
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 490, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 488, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":493
+  /* "View.MemoryView":491
  *         cdef bytes bytesitem
  * 
  *         bytesitem = itemp[:self.view.itemsize]             # <<<<<<<<<<<<<<
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 491, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_bytesitem = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":494
+  /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
   {
@@ -8115,24 +8030,24 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_4);
     /*try:*/ {
 
-      /* "View.MemoryView":495
+      /* "View.MemoryView":493
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)             # <<<<<<<<<<<<<<
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 495, __pyx_L3_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 495, __pyx_L3_error)
+      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -8141,94 +8056,94 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       {
-        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_9);
         if (__pyx_t_7) {
           __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
         }
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_6);
         __Pyx_INCREF(__pyx_v_bytesitem);
         __Pyx_GIVEREF(__pyx_v_bytesitem);
         PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_bytesitem);
         __pyx_t_6 = 0;
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_result = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "View.MemoryView":494
+      /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     }
 
-    /* "View.MemoryView":499
+    /* "View.MemoryView":497
  *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
     /*else:*/ {
       __pyx_t_10 = strlen(__pyx_v_self->view.format); 
       __pyx_t_11 = ((__pyx_t_10 == 1) != 0);
       if (__pyx_t_11) {
 
-        /* "View.MemoryView":500
+        /* "View.MemoryView":498
  *         else:
  *             if len(self.view.format) == 1:
  *                 return result[0]             # <<<<<<<<<<<<<<
  *             return result
  * 
  */
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 500, __pyx_L5_except_error)
+        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 498, __pyx_L5_except_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_r = __pyx_t_1;
         __pyx_t_1 = 0;
         goto __pyx_L6_except_return;
 
-        /* "View.MemoryView":499
+        /* "View.MemoryView":497
  *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
       }
 
-      /* "View.MemoryView":501
+      /* "View.MemoryView":499
  *             if len(self.view.format) == 1:
  *                 return result[0]
  *             return result             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
       __Pyx_XDECREF(__pyx_r);
@@ -8239,52 +8154,52 @@
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-    /* "View.MemoryView":496
+    /* "View.MemoryView":494
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:             # <<<<<<<<<<<<<<
  *             raise ValueError("Unable to convert item to object")
  *         else:
  */
     __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_9);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 496, __pyx_L5_except_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 494, __pyx_L5_except_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_6);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_9);
     __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_9 = 0;
     if (__pyx_t_8) {
       __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 496, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 494, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_9);
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_1);
 
-      /* "View.MemoryView":497
+      /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 497, __pyx_L5_except_error)
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 495, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_Raise(__pyx_t_6, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(1, 497, __pyx_L5_except_error)
+      __PYX_ERR(1, 495, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "View.MemoryView":494
+    /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     __Pyx_XGIVEREF(__pyx_t_2);
@@ -8296,15 +8211,15 @@
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":487
+  /* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8322,15 +8237,15 @@
   __Pyx_XDECREF(__pyx_v_bytesitem);
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":503
+/* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8356,88 +8271,88 @@
   char *__pyx_t_13;
   char *__pyx_t_14;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":506
+  /* "View.MemoryView":504
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef char c
  *         cdef bytes bytesvalue
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 506, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 504, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":511
+  /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
   __pyx_t_2 = PyTuple_Check(__pyx_v_value); 
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "View.MemoryView":512
+    /* "View.MemoryView":510
  * 
  *         if isinstance(value, tuple):
  *             bytesvalue = struct.pack(self.view.format, *value)             # <<<<<<<<<<<<<<
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 512, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 510, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "View.MemoryView":511
+    /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":514
+  /* "View.MemoryView":512
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)             # <<<<<<<<<<<<<<
  * 
  *         for i, c in enumerate(bytesvalue):
  */
   /*else*/ {
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = NULL;
     __pyx_t_7 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -8446,102 +8361,102 @@
         __Pyx_DECREF_SET(__pyx_t_6, function);
         __pyx_t_7 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     {
-      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_8);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
       __Pyx_GIVEREF(__pyx_t_1);
       PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
       __Pyx_INCREF(__pyx_v_value);
       __Pyx_GIVEREF(__pyx_v_value);
       PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_value);
       __pyx_t_1 = 0;
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 514, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 512, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":516
+  /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
   __pyx_t_9 = 0;
   if (unlikely(__pyx_v_bytesvalue == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
-    __PYX_ERR(1, 516, __pyx_L1_error)
+    __PYX_ERR(1, 514, __pyx_L1_error)
   }
   __Pyx_INCREF(__pyx_v_bytesvalue);
   __pyx_t_10 = __pyx_v_bytesvalue;
   __pyx_t_12 = PyBytes_AS_STRING(__pyx_t_10);
   __pyx_t_13 = (__pyx_t_12 + PyBytes_GET_SIZE(__pyx_t_10));
   for (__pyx_t_14 = __pyx_t_12; __pyx_t_14 < __pyx_t_13; __pyx_t_14++) {
     __pyx_t_11 = __pyx_t_14;
     __pyx_v_c = (__pyx_t_11[0]);
 
-    /* "View.MemoryView":517
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     __pyx_v_i = __pyx_t_9;
 
-    /* "View.MemoryView":516
+    /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
     __pyx_t_9 = (__pyx_t_9 + 1);
 
-    /* "View.MemoryView":517
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     (__pyx_v_itemp[__pyx_v_i]) = __pyx_v_c;
   }
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "View.MemoryView":503
+  /* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8561,15 +8476,15 @@
   __Pyx_XDECREF(__pyx_v_struct);
   __Pyx_XDECREF(__pyx_v_bytesvalue);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":520
+/* "View.MemoryView":518
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
@@ -8604,15 +8519,15 @@
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":521
+  /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   __pyx_t_2 = ((__pyx_v_flags & PyBUF_WRITABLE) != 0);
@@ -8622,268 +8537,268 @@
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_2 = (__pyx_v_self->view.readonly != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":522
+    /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 522, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 520, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 522, __pyx_L1_error)
+    __PYX_ERR(1, 520, __pyx_L1_error)
 
-    /* "View.MemoryView":521
+    /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":524
+  /* "View.MemoryView":522
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_ND) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":525
+    /* "View.MemoryView":523
  * 
  *         if flags & PyBUF_ND:
  *             info.shape = self.view.shape             # <<<<<<<<<<<<<<
  *         else:
  *             info.shape = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.shape;
     __pyx_v_info->shape = __pyx_t_4;
 
-    /* "View.MemoryView":524
+    /* "View.MemoryView":522
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
     goto __pyx_L6;
   }
 
-  /* "View.MemoryView":527
+  /* "View.MemoryView":525
  *             info.shape = self.view.shape
  *         else:
  *             info.shape = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_STRIDES:
  */
   /*else*/ {
     __pyx_v_info->shape = NULL;
   }
   __pyx_L6:;
 
-  /* "View.MemoryView":529
+  /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":530
+    /* "View.MemoryView":528
  * 
  *         if flags & PyBUF_STRIDES:
  *             info.strides = self.view.strides             # <<<<<<<<<<<<<<
  *         else:
  *             info.strides = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.strides;
     __pyx_v_info->strides = __pyx_t_4;
 
-    /* "View.MemoryView":529
+    /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
     goto __pyx_L7;
   }
 
-  /* "View.MemoryView":532
+  /* "View.MemoryView":530
  *             info.strides = self.view.strides
  *         else:
  *             info.strides = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_INDIRECT:
  */
   /*else*/ {
     __pyx_v_info->strides = NULL;
   }
   __pyx_L7:;
 
-  /* "View.MemoryView":534
+  /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_INDIRECT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":535
+    /* "View.MemoryView":533
  * 
  *         if flags & PyBUF_INDIRECT:
  *             info.suboffsets = self.view.suboffsets             # <<<<<<<<<<<<<<
  *         else:
  *             info.suboffsets = NULL
  */
     __pyx_t_4 = __pyx_v_self->view.suboffsets;
     __pyx_v_info->suboffsets = __pyx_t_4;
 
-    /* "View.MemoryView":534
+    /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
     goto __pyx_L8;
   }
 
-  /* "View.MemoryView":537
+  /* "View.MemoryView":535
  *             info.suboffsets = self.view.suboffsets
  *         else:
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   /*else*/ {
     __pyx_v_info->suboffsets = NULL;
   }
   __pyx_L8:;
 
-  /* "View.MemoryView":539
+  /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":540
+    /* "View.MemoryView":538
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.view.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
     __pyx_t_5 = __pyx_v_self->view.format;
     __pyx_v_info->format = __pyx_t_5;
 
-    /* "View.MemoryView":539
+    /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":542
+  /* "View.MemoryView":540
  *             info.format = self.view.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.buf = self.view.buf
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":544
+  /* "View.MemoryView":542
  *             info.format = NULL
  * 
  *         info.buf = self.view.buf             # <<<<<<<<<<<<<<
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  */
   __pyx_t_6 = __pyx_v_self->view.buf;
   __pyx_v_info->buf = __pyx_t_6;
 
-  /* "View.MemoryView":545
+  /* "View.MemoryView":543
  * 
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim             # <<<<<<<<<<<<<<
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  */
   __pyx_t_7 = __pyx_v_self->view.ndim;
   __pyx_v_info->ndim = __pyx_t_7;
 
-  /* "View.MemoryView":546
+  /* "View.MemoryView":544
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize             # <<<<<<<<<<<<<<
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  */
   __pyx_t_8 = __pyx_v_self->view.itemsize;
   __pyx_v_info->itemsize = __pyx_t_8;
 
-  /* "View.MemoryView":547
+  /* "View.MemoryView":545
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len             # <<<<<<<<<<<<<<
  *         info.readonly = self.view.readonly
  *         info.obj = self
  */
   __pyx_t_8 = __pyx_v_self->view.len;
   __pyx_v_info->len = __pyx_t_8;
 
-  /* "View.MemoryView":548
+  /* "View.MemoryView":546
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly             # <<<<<<<<<<<<<<
  *         info.obj = self
  * 
  */
   __pyx_t_1 = __pyx_v_self->view.readonly;
   __pyx_v_info->readonly = __pyx_t_1;
 
-  /* "View.MemoryView":549
+  /* "View.MemoryView":547
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":520
+  /* "View.MemoryView":518
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
@@ -8905,15 +8820,15 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":555
+/* "View.MemoryView":553
  * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
@@ -8937,49 +8852,49 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":556
+  /* "View.MemoryView":554
  *     @property
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&result.from_slice)
  *         return result
  */
-  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 556, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 554, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 556, __pyx_L1_error)
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 554, __pyx_L1_error)
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":557
+  /* "View.MemoryView":555
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)             # <<<<<<<<<<<<<<
  *         return result
  * 
  */
-  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 557, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 555, __pyx_L1_error)
 
-  /* "View.MemoryView":558
+  /* "View.MemoryView":556
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  *         return result             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":555
+  /* "View.MemoryView":553
  * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
@@ -8991,15 +8906,15 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":561
+/* "View.MemoryView":559
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
@@ -9017,42 +8932,42 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4base___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":562
+  /* "View.MemoryView":560
  *     @property
  *     def base(self):
  *         return self.obj             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->obj);
   __pyx_r = __pyx_v_self->obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":561
+  /* "View.MemoryView":559
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":565
+/* "View.MemoryView":563
  * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
  * 
  */
 
@@ -9079,41 +8994,41 @@
   Py_ssize_t *__pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":566
+  /* "View.MemoryView":564
  *     @property
  *     def shape(self):
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 566, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
   for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_length = (__pyx_t_2[0]);
-    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 566, __pyx_L1_error)
+    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 566, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 564, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 566, __pyx_L1_error)
+  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":565
+  /* "View.MemoryView":563
  * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
  * 
  */
 
@@ -9125,15 +9040,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":569
+/* "View.MemoryView":567
  * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
  * 
  */
 
@@ -9161,73 +9076,73 @@
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":570
+  /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   __pyx_t_1 = ((__pyx_v_self->view.strides == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":572
+    /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 570, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 572, __pyx_L1_error)
+    __PYX_ERR(1, 570, __pyx_L1_error)
 
-    /* "View.MemoryView":570
+    /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   }
 
-  /* "View.MemoryView":574
+  /* "View.MemoryView":572
  *             raise ValueError("Buffer view does not expose strides")
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 574, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
   for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
     __pyx_t_3 = __pyx_t_5;
     __pyx_v_stride = (__pyx_t_3[0]);
-    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 574, __pyx_L1_error)
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 574, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 572, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 574, __pyx_L1_error)
+  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":569
+  /* "View.MemoryView":567
  * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
  * 
  */
 
@@ -9239,15 +9154,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":577
+/* "View.MemoryView":575
  * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
@@ -9275,77 +9190,77 @@
   Py_ssize_t *__pyx_t_5;
   Py_ssize_t *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":578
+  /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.suboffsets == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":579
+    /* "View.MemoryView":577
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__13, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__12, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":578
+    /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   }
 
-  /* "View.MemoryView":581
+  /* "View.MemoryView":579
  *             return (-1,) * self.view.ndim
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 581, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_5 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
   for (__pyx_t_6 = __pyx_v_self->view.suboffsets; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
     __pyx_t_4 = __pyx_t_6;
     __pyx_v_suboffset = (__pyx_t_4[0]);
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 581, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(1, 581, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
-  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 581, __pyx_L1_error)
+  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":577
+  /* "View.MemoryView":575
  * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
@@ -9357,15 +9272,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":584
+/* "View.MemoryView":582
  * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
  * 
  */
 
@@ -9387,29 +9302,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":585
+  /* "View.MemoryView":583
  *     @property
  *     def ndim(self):
  *         return self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 585, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":584
+  /* "View.MemoryView":582
  * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
  * 
  */
 
@@ -9420,15 +9335,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":588
+/* "View.MemoryView":586
  * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
  * 
  */
 
@@ -9450,29 +9365,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":589
+  /* "View.MemoryView":587
  *     @property
  *     def itemsize(self):
  *         return self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 589, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":588
+  /* "View.MemoryView":586
  * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
  * 
  */
 
@@ -9483,15 +9398,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":592
+/* "View.MemoryView":590
  * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
  * 
  */
 
@@ -9515,35 +9430,35 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":593
+  /* "View.MemoryView":591
  *     @property
  *     def nbytes(self):
  *         return self.size * self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 593, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 593, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 593, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":592
+  /* "View.MemoryView":590
  * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
  * 
  */
 
@@ -9556,15 +9471,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":596
+/* "View.MemoryView":594
  * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
@@ -9593,98 +9508,98 @@
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":597
+  /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   __pyx_t_1 = (__pyx_v_self->_size == Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":598
+    /* "View.MemoryView":596
  *     def size(self):
  *         if self._size is None:
  *             result = 1             # <<<<<<<<<<<<<<
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  */
     __Pyx_INCREF(__pyx_int_1);
     __pyx_v_result = __pyx_int_1;
 
-    /* "View.MemoryView":600
+    /* "View.MemoryView":598
  *             result = 1
  * 
  *             for length in self.view.shape[:self.view.ndim]:             # <<<<<<<<<<<<<<
  *                 result *= length
  * 
  */
     __pyx_t_4 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
     for (__pyx_t_5 = __pyx_v_self->view.shape; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
       __pyx_t_3 = __pyx_t_5;
-      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 600, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 598, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_6);
       __pyx_t_6 = 0;
 
-      /* "View.MemoryView":601
+      /* "View.MemoryView":599
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  *                 result *= length             # <<<<<<<<<<<<<<
  * 
  *             self._size = result
  */
-      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 601, __pyx_L1_error)
+      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 599, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_6);
       __pyx_t_6 = 0;
     }
 
-    /* "View.MemoryView":603
+    /* "View.MemoryView":601
  *                 result *= length
  * 
  *             self._size = result             # <<<<<<<<<<<<<<
  * 
  *         return self._size
  */
     __Pyx_INCREF(__pyx_v_result);
     __Pyx_GIVEREF(__pyx_v_result);
     __Pyx_GOTREF(__pyx_v_self->_size);
     __Pyx_DECREF(__pyx_v_self->_size);
     __pyx_v_self->_size = __pyx_v_result;
 
-    /* "View.MemoryView":597
+    /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   }
 
-  /* "View.MemoryView":605
+  /* "View.MemoryView":603
  *             self._size = result
  * 
  *         return self._size             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_size);
   __pyx_r = __pyx_v_self->_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":596
+  /* "View.MemoryView":594
  * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
@@ -9697,15 +9612,15 @@
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":607
+/* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
@@ -9724,68 +9639,68 @@
 
 static Py_ssize_t __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(struct __pyx_memoryview_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":608
+  /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.ndim >= 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":609
+    /* "View.MemoryView":607
  *     def __len__(self):
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]             # <<<<<<<<<<<<<<
  * 
  *         return 0
  */
     __pyx_r = (__pyx_v_self->view.shape[0]);
     goto __pyx_L0;
 
-    /* "View.MemoryView":608
+    /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   }
 
-  /* "View.MemoryView":611
+  /* "View.MemoryView":609
  *             return self.view.shape[0]
  * 
  *         return 0             # <<<<<<<<<<<<<<
  * 
  *     def __repr__(self):
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":607
+  /* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":613
+/* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -9809,64 +9724,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":614
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":615
+  /* "View.MemoryView":613
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))             # <<<<<<<<<<<<<<
  * 
  *     def __str__(self):
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 615, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 613, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "View.MemoryView":614
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 614, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":613
+  /* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -9879,15 +9794,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":617
+/* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -9910,43 +9825,43 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__str__", 0);
 
-  /* "View.MemoryView":618
+  /* "View.MemoryView":616
  * 
  *     def __str__(self):
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":617
+  /* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -9958,15 +9873,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":621
+/* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -9991,39 +9906,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_c_contig", 0);
 
-  /* "View.MemoryView":624
+  /* "View.MemoryView":622
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 624, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 622, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":625
+  /* "View.MemoryView":623
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def is_f_contig(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 625, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":621
+  /* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10034,15 +9949,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":627
+/* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10067,39 +9982,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_f_contig", 0);
 
-  /* "View.MemoryView":630
+  /* "View.MemoryView":628
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 630, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 628, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":631
+  /* "View.MemoryView":629
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def copy(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 631, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 629, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":627
+  /* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10110,15 +10025,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":633
+/* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -10143,57 +10058,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy", 0);
 
-  /* "View.MemoryView":635
+  /* "View.MemoryView":633
  *     def copy(self):
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &mslice)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_F_CONTIGUOUS));
 
-  /* "View.MemoryView":637
+  /* "View.MemoryView":635
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  * 
  *         slice_copy(self, &mslice)             # <<<<<<<<<<<<<<
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,
  *                                    self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_mslice));
 
-  /* "View.MemoryView":638
+  /* "View.MemoryView":636
  * 
  *         slice_copy(self, &mslice)
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                    self.view.itemsize,
  *                                    flags|PyBUF_C_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 638, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 636, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":643
+  /* "View.MemoryView":641
  *                                    self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &mslice)             # <<<<<<<<<<<<<<
  * 
  *     def copy_fortran(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 643, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":633
+  /* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -10204,15 +10119,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":645
+/* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -10238,57 +10153,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy_fortran", 0);
 
-  /* "View.MemoryView":647
+  /* "View.MemoryView":645
  *     def copy_fortran(self):
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &src)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_C_CONTIGUOUS));
 
-  /* "View.MemoryView":649
+  /* "View.MemoryView":647
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  * 
  *         slice_copy(self, &src)             # <<<<<<<<<<<<<<
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,
  *                                 self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_src));
 
-  /* "View.MemoryView":650
+  /* "View.MemoryView":648
  * 
  *         slice_copy(self, &src)
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                 self.view.itemsize,
  *                                 flags|PyBUF_F_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 650, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 648, __pyx_L1_error)
   __pyx_v_dst = __pyx_t_1;
 
-  /* "View.MemoryView":655
+  /* "View.MemoryView":653
  *                                 self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &dst)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 655, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":645
+  /* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -10333,15 +10248,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -10389,15 +10304,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -10412,15 +10327,15 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":659
+/* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10432,64 +10347,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_cwrapper", 0);
 
-  /* "View.MemoryView":660
+  /* "View.MemoryView":658
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)             # <<<<<<<<<<<<<<
  *     result.typeinfo = typeinfo
  *     return result
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_o);
   __Pyx_GIVEREF(__pyx_v_o);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_o);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 660, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryview_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":661
+  /* "View.MemoryView":659
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo             # <<<<<<<<<<<<<<
  *     return result
  * 
  */
   __pyx_v_result->typeinfo = __pyx_v_typeinfo;
 
-  /* "View.MemoryView":662
+  /* "View.MemoryView":660
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_check')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":659
+  /* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10503,54 +10418,54 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":665
+/* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *__pyx_v_o) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("memoryview_check", 0);
 
-  /* "View.MemoryView":666
+  /* "View.MemoryView":664
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):
  *     return isinstance(o, memoryview)             # <<<<<<<<<<<<<<
  * 
  * cdef tuple _unellipsify(object index, int ndim):
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_o, __pyx_memoryview_type); 
   __pyx_r = __pyx_t_1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":665
+  /* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":668
+/* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
@@ -10576,243 +10491,243 @@
   int __pyx_t_10;
   PyObject *__pyx_t_11 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_unellipsify", 0);
 
-  /* "View.MemoryView":673
+  /* "View.MemoryView":671
  *     full slices.
  *     """
  *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
  *         tup = (index,)
  *     else:
  */
   __pyx_t_1 = PyTuple_Check(__pyx_v_index); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":674
+    /* "View.MemoryView":672
  *     """
  *     if not isinstance(index, tuple):
  *         tup = (index,)             # <<<<<<<<<<<<<<
  *     else:
  *         tup = index
  */
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 674, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 672, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_index);
     __Pyx_GIVEREF(__pyx_v_index);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_index);
     __pyx_v_tup = __pyx_t_3;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":673
+    /* "View.MemoryView":671
  *     full slices.
  *     """
  *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
  *         tup = (index,)
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":676
+  /* "View.MemoryView":674
  *         tup = (index,)
  *     else:
  *         tup = index             # <<<<<<<<<<<<<<
  * 
  *     result = []
  */
   /*else*/ {
     __Pyx_INCREF(__pyx_v_index);
     __pyx_v_tup = __pyx_v_index;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":678
+  /* "View.MemoryView":676
  *         tup = index
  * 
  *     result = []             # <<<<<<<<<<<<<<
  *     have_slices = False
  *     seen_ellipsis = False
  */
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 678, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 676, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_v_result = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":679
+  /* "View.MemoryView":677
  * 
  *     result = []
  *     have_slices = False             # <<<<<<<<<<<<<<
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  */
   __pyx_v_have_slices = 0;
 
-  /* "View.MemoryView":680
+  /* "View.MemoryView":678
  *     result = []
  *     have_slices = False
  *     seen_ellipsis = False             # <<<<<<<<<<<<<<
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  */
   __pyx_v_seen_ellipsis = 0;
 
-  /* "View.MemoryView":681
+  /* "View.MemoryView":679
  *     have_slices = False
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   __Pyx_INCREF(__pyx_int_0);
   __pyx_t_3 = __pyx_int_0;
   if (likely(PyList_CheckExact(__pyx_v_tup)) || PyTuple_CheckExact(__pyx_v_tup)) {
     __pyx_t_4 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
     __pyx_t_6 = NULL;
   } else {
-    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 681, __pyx_L1_error)
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 679, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 681, __pyx_L1_error)
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 679, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_6)) {
       if (likely(PyList_CheckExact(__pyx_t_4))) {
         if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 681, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
     } else {
       __pyx_t_7 = __pyx_t_6(__pyx_t_4);
       if (unlikely(!__pyx_t_7)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 681, __pyx_L1_error)
+          else __PYX_ERR(1, 679, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_7);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
     __pyx_t_7 = 0;
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_3);
-    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 681, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_3);
     __pyx_t_3 = __pyx_t_7;
     __pyx_t_7 = 0;
 
-    /* "View.MemoryView":682
+    /* "View.MemoryView":680
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
     __pyx_t_2 = (__pyx_v_item == __pyx_builtin_Ellipsis);
     __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":683
+      /* "View.MemoryView":681
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
       __pyx_t_1 = ((!(__pyx_v_seen_ellipsis != 0)) != 0);
       if (__pyx_t_1) {
 
-        /* "View.MemoryView":684
+        /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 684, __pyx_L1_error)
-        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 684, __pyx_L1_error)
+        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
+        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 682, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         { Py_ssize_t __pyx_temp;
           for (__pyx_temp=0; __pyx_temp < ((__pyx_v_ndim - __pyx_t_8) + 1); __pyx_temp++) {
-            __Pyx_INCREF(__pyx_slice__16);
-            __Pyx_GIVEREF(__pyx_slice__16);
-            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__16);
+            __Pyx_INCREF(__pyx_slice__15);
+            __Pyx_GIVEREF(__pyx_slice__15);
+            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__15);
           }
         }
-        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 684, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-        /* "View.MemoryView":685
+        /* "View.MemoryView":683
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True             # <<<<<<<<<<<<<<
  *             else:
  *                 result.append(slice(None))
  */
         __pyx_v_seen_ellipsis = 1;
 
-        /* "View.MemoryView":683
+        /* "View.MemoryView":681
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":687
+      /* "View.MemoryView":685
  *                 seen_ellipsis = True
  *             else:
  *                 result.append(slice(None))             # <<<<<<<<<<<<<<
  *             have_slices = True
  *         else:
  */
       /*else*/ {
-        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__16); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 687, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__15); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 685, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":688
+      /* "View.MemoryView":686
  *             else:
  *                 result.append(slice(None))
  *             have_slices = True             # <<<<<<<<<<<<<<
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  */
       __pyx_v_have_slices = 1;
 
-      /* "View.MemoryView":682
+      /* "View.MemoryView":680
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":690
+    /* "View.MemoryView":688
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  */
     /*else*/ {
@@ -10824,40 +10739,40 @@
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = ((!(PyIndex_Check(__pyx_v_item) != 0)) != 0);
       __pyx_t_1 = __pyx_t_10;
       __pyx_L9_bool_binop_done:;
       if (unlikely(__pyx_t_1)) {
 
-        /* "View.MemoryView":691
+        /* "View.MemoryView":689
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  *                 raise TypeError("Cannot index with type '%s'" % type(item))             # <<<<<<<<<<<<<<
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  */
-        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 691, __pyx_L1_error)
+        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 689, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 691, __pyx_L1_error)
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 689, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_Raise(__pyx_t_11, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        __PYX_ERR(1, 691, __pyx_L1_error)
+        __PYX_ERR(1, 689, __pyx_L1_error)
 
-        /* "View.MemoryView":690
+        /* "View.MemoryView":688
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  */
       }
 
-      /* "View.MemoryView":693
+      /* "View.MemoryView":691
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  *             have_slices = have_slices or isinstance(item, slice)             # <<<<<<<<<<<<<<
  *             result.append(item)
  * 
  */
       __pyx_t_10 = (__pyx_v_have_slices != 0);
@@ -10868,120 +10783,120 @@
       }
       __pyx_t_10 = PySlice_Check(__pyx_v_item); 
       __pyx_t_2 = (__pyx_t_10 != 0);
       __pyx_t_1 = __pyx_t_2;
       __pyx_L11_bool_binop_done:;
       __pyx_v_have_slices = __pyx_t_1;
 
-      /* "View.MemoryView":694
+      /* "View.MemoryView":692
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  *             result.append(item)             # <<<<<<<<<<<<<<
  * 
  *     nslices = ndim - len(result)
  */
-      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 694, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 692, __pyx_L1_error)
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":681
+    /* "View.MemoryView":679
  *     have_slices = False
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":696
+  /* "View.MemoryView":694
  *             result.append(item)
  * 
  *     nslices = ndim - len(result)             # <<<<<<<<<<<<<<
  *     if nslices:
  *         result.extend([slice(None)] * nslices)
  */
-  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 696, __pyx_L1_error)
+  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 694, __pyx_L1_error)
   __pyx_v_nslices = (__pyx_v_ndim - __pyx_t_5);
 
-  /* "View.MemoryView":697
+  /* "View.MemoryView":695
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
  * 
  */
   __pyx_t_1 = (__pyx_v_nslices != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":698
+    /* "View.MemoryView":696
  *     nslices = ndim - len(result)
  *     if nslices:
  *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
  * 
  *     return have_slices or nslices, tuple(result)
  */
-    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 698, __pyx_L1_error)
+    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     { Py_ssize_t __pyx_temp;
       for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
-        __Pyx_INCREF(__pyx_slice__16);
-        __Pyx_GIVEREF(__pyx_slice__16);
-        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__16);
+        __Pyx_INCREF(__pyx_slice__15);
+        __Pyx_GIVEREF(__pyx_slice__15);
+        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__15);
       }
     }
-    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 698, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 696, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "View.MemoryView":697
+    /* "View.MemoryView":695
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
  * 
  */
   }
 
-  /* "View.MemoryView":700
+  /* "View.MemoryView":698
  *         result.extend([slice(None)] * nslices)
  * 
  *     return have_slices or nslices, tuple(result)             # <<<<<<<<<<<<<<
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  */
   __Pyx_XDECREF(__pyx_r);
   if (!__pyx_v_have_slices) {
   } else {
-    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 700, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_3 = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L14_bool_binop_done;
   }
-  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 700, __pyx_L1_error)
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_3 = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_L14_bool_binop_done:;
-  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 700, __pyx_L1_error)
+  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 700, __pyx_L1_error)
+  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_4);
   PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_4);
   __pyx_t_3 = 0;
   __pyx_t_4 = 0;
   __pyx_r = ((PyObject*)__pyx_t_11);
   __pyx_t_11 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":668
+  /* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
@@ -10999,15 +10914,15 @@
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":702
+/* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
@@ -11021,60 +10936,60 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assert_direct_dimensions", 0);
 
-  /* "View.MemoryView":703
+  /* "View.MemoryView":701
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")
  */
   __pyx_t_2 = (__pyx_v_suboffsets + __pyx_v_ndim);
   for (__pyx_t_3 = __pyx_v_suboffsets; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
     __pyx_t_1 = __pyx_t_3;
     __pyx_v_suboffset = (__pyx_t_1[0]);
 
-    /* "View.MemoryView":704
+    /* "View.MemoryView":702
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
  * 
  */
     __pyx_t_4 = ((__pyx_v_suboffset >= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":705
+      /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 705, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 703, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(1, 705, __pyx_L1_error)
+      __PYX_ERR(1, 703, __pyx_L1_error)
 
-      /* "View.MemoryView":704
+      /* "View.MemoryView":702
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":702
+  /* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
@@ -11087,15 +11002,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":712
+/* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -11131,529 +11046,529 @@
   int __pyx_t_11;
   Py_ssize_t __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memview_slice", 0);
 
-  /* "View.MemoryView":713
+  /* "View.MemoryView":711
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim             # <<<<<<<<<<<<<<
  *     cdef bint negative_step
  *     cdef __Pyx_memviewslice src, dst
  */
   __pyx_v_new_ndim = 0;
   __pyx_v_suboffset_dim = -1;
 
-  /* "View.MemoryView":720
+  /* "View.MemoryView":718
  * 
  * 
  *     memset(&dst, 0, sizeof(dst))             # <<<<<<<<<<<<<<
  * 
  *     cdef _memoryviewslice memviewsliceobj
  */
   (void)(memset((&__pyx_v_dst), 0, (sizeof(__pyx_v_dst))));
 
-  /* "View.MemoryView":724
+  /* "View.MemoryView":722
  *     cdef _memoryviewslice memviewsliceobj
  * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(1, 724, __pyx_L1_error)
+      __PYX_ERR(1, 722, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "View.MemoryView":726
+  /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":727
+    /* "View.MemoryView":725
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview             # <<<<<<<<<<<<<<
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 727, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 725, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":728
+    /* "View.MemoryView":726
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, &src)
  */
     __pyx_v_p_src = (&__pyx_v_memviewsliceobj->from_slice);
 
-    /* "View.MemoryView":726
+    /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":730
+  /* "View.MemoryView":728
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  *         slice_copy(memview, &src)             # <<<<<<<<<<<<<<
  *         p_src = &src
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_src));
 
-    /* "View.MemoryView":731
+    /* "View.MemoryView":729
  *     else:
  *         slice_copy(memview, &src)
  *         p_src = &src             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_p_src = (&__pyx_v_src);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":737
+  /* "View.MemoryView":735
  * 
  * 
  *     dst.memview = p_src.memview             # <<<<<<<<<<<<<<
  *     dst.data = p_src.data
  * 
  */
   __pyx_t_4 = __pyx_v_p_src->memview;
   __pyx_v_dst.memview = __pyx_t_4;
 
-  /* "View.MemoryView":738
+  /* "View.MemoryView":736
  * 
  *     dst.memview = p_src.memview
  *     dst.data = p_src.data             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_5 = __pyx_v_p_src->data;
   __pyx_v_dst.data = __pyx_t_5;
 
-  /* "View.MemoryView":743
+  /* "View.MemoryView":741
  * 
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst             # <<<<<<<<<<<<<<
  *     cdef int *p_suboffset_dim = &suboffset_dim
  *     cdef Py_ssize_t start, stop, step
  */
   __pyx_v_p_dst = (&__pyx_v_dst);
 
-  /* "View.MemoryView":744
+  /* "View.MemoryView":742
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst
  *     cdef int *p_suboffset_dim = &suboffset_dim             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t start, stop, step
  *     cdef bint have_start, have_stop, have_step
  */
   __pyx_v_p_suboffset_dim = (&__pyx_v_suboffset_dim);
 
-  /* "View.MemoryView":748
+  /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   __pyx_t_6 = 0;
   if (likely(PyList_CheckExact(__pyx_v_indices)) || PyTuple_CheckExact(__pyx_v_indices)) {
     __pyx_t_3 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
     __pyx_t_8 = NULL;
   } else {
-    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 748, __pyx_L1_error)
+    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 746, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 748, __pyx_L1_error)
+    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 746, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_8)) {
       if (likely(PyList_CheckExact(__pyx_t_3))) {
         if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       } else {
         if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 748, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       }
     } else {
       __pyx_t_9 = __pyx_t_8(__pyx_t_3);
       if (unlikely(!__pyx_t_9)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 748, __pyx_L1_error)
+          else __PYX_ERR(1, 746, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_9);
     }
     __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_9);
     __pyx_t_9 = 0;
     __pyx_v_dim = __pyx_t_6;
     __pyx_t_6 = (__pyx_t_6 + 1);
 
-    /* "View.MemoryView":749
+    /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
     __pyx_t_2 = (PyIndex_Check(__pyx_v_index) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":753
+      /* "View.MemoryView":751
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  *                 index, 0, 0, # start, stop, step             # <<<<<<<<<<<<<<
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  */
-      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 753, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 751, __pyx_L1_error)
 
-      /* "View.MemoryView":750
+      /* "View.MemoryView":748
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 750, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 748, __pyx_L1_error)
 
-      /* "View.MemoryView":749
+      /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":756
+    /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
     __pyx_t_2 = (__pyx_v_index == Py_None);
     __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":757
+      /* "View.MemoryView":755
  *                 False)
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1             # <<<<<<<<<<<<<<
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  */
       (__pyx_v_p_dst->shape[__pyx_v_new_ndim]) = 1;
 
-      /* "View.MemoryView":758
+      /* "View.MemoryView":756
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0             # <<<<<<<<<<<<<<
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1
  */
       (__pyx_v_p_dst->strides[__pyx_v_new_ndim]) = 0;
 
-      /* "View.MemoryView":759
+      /* "View.MemoryView":757
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1             # <<<<<<<<<<<<<<
  *             new_ndim += 1
  *         else:
  */
       (__pyx_v_p_dst->suboffsets[__pyx_v_new_ndim]) = -1L;
 
-      /* "View.MemoryView":760
+      /* "View.MemoryView":758
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  *         else:
  *             start = index.start or 0
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
 
-      /* "View.MemoryView":756
+      /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":762
+    /* "View.MemoryView":760
  *             new_ndim += 1
  *         else:
  *             start = index.start or 0             # <<<<<<<<<<<<<<
  *             stop = index.stop or 0
  *             step = index.step or 0
  */
     /*else*/ {
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 760, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 760, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 760, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L7_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L7_bool_binop_done:;
       __pyx_v_start = __pyx_t_10;
 
-      /* "View.MemoryView":763
+      /* "View.MemoryView":761
  *         else:
  *             start = index.start or 0
  *             stop = index.stop or 0             # <<<<<<<<<<<<<<
  *             step = index.step or 0
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 763, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 761, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 763, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 761, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 763, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 761, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L9_bool_binop_done:;
       __pyx_v_stop = __pyx_t_10;
 
-      /* "View.MemoryView":764
+      /* "View.MemoryView":762
  *             start = index.start or 0
  *             stop = index.stop or 0
  *             step = index.step or 0             # <<<<<<<<<<<<<<
  * 
  *             have_start = index.start is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 764, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 762, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 764, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 762, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 764, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L11_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L11_bool_binop_done:;
       __pyx_v_step = __pyx_t_10;
 
-      /* "View.MemoryView":766
+      /* "View.MemoryView":764
  *             step = index.step or 0
  * 
  *             have_start = index.start is not None             # <<<<<<<<<<<<<<
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 766, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 764, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_start = __pyx_t_1;
 
-      /* "View.MemoryView":767
+      /* "View.MemoryView":765
  * 
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None             # <<<<<<<<<<<<<<
  *             have_step = index.step is not None
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 767, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 765, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_stop = __pyx_t_1;
 
-      /* "View.MemoryView":768
+      /* "View.MemoryView":766
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None             # <<<<<<<<<<<<<<
  * 
  *             slice_memviewslice(
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 768, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 766, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_step = __pyx_t_1;
 
-      /* "View.MemoryView":770
+      /* "View.MemoryView":768
  *             have_step = index.step is not None
  * 
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 770, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 768, __pyx_L1_error)
 
-      /* "View.MemoryView":776
+      /* "View.MemoryView":774
  *                 have_start, have_stop, have_step,
  *                 True)
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":748
+    /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":778
+  /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":780
+    /* "View.MemoryView":778
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_dtype_func,
  *                                     memview.dtype_is_object)
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 780, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 778, __pyx_L1_error) }
 
-    /* "View.MemoryView":781
+    /* "View.MemoryView":779
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  *     else:
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 781, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 779, __pyx_L1_error) }
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 779, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 777, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 779, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 777, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":778
+    /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   }
 
-  /* "View.MemoryView":784
+  /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":785
+    /* "View.MemoryView":783
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,
  *                                     memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 784, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 782, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
 
-    /* "View.MemoryView":784
+    /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 784, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 782, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":712
+  /* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -11667,15 +11582,15 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_memviewsliceobj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":809
+/* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -11686,95 +11601,95 @@
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":829
+  /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
   __pyx_t_1 = ((!(__pyx_v_is_slice != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":831
+    /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     __pyx_t_1 = ((__pyx_v_start < 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":832
+      /* "View.MemoryView":830
  * 
  *         if start < 0:
  *             start += shape             # <<<<<<<<<<<<<<
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  */
       __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-      /* "View.MemoryView":831
+      /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     }
 
-    /* "View.MemoryView":833
+    /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     __pyx_t_1 = (0 <= __pyx_v_start);
     if (__pyx_t_1) {
       __pyx_t_1 = (__pyx_v_start < __pyx_v_shape);
     }
     __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":834
+      /* "View.MemoryView":832
  *             start += shape
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
  *     else:
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 834, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 832, __pyx_L1_error)
 
-      /* "View.MemoryView":833
+      /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     }
 
-    /* "View.MemoryView":829
+    /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":837
+  /* "View.MemoryView":835
  *     else:
  * 
  *         negative_step = have_step != 0 and step < 0             # <<<<<<<<<<<<<<
  * 
  *         if have_step and step == 0:
  */
   /*else*/ {
@@ -11785,15 +11700,15 @@
       goto __pyx_L6_bool_binop_done;
     }
     __pyx_t_1 = ((__pyx_v_step < 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L6_bool_binop_done:;
     __pyx_v_negative_step = __pyx_t_2;
 
-    /* "View.MemoryView":839
+    /* "View.MemoryView":837
  *         negative_step = have_step != 0 and step < 0
  * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
     __pyx_t_1 = (__pyx_v_have_step != 0);
@@ -11803,639 +11718,639 @@
       goto __pyx_L9_bool_binop_done;
     }
     __pyx_t_1 = ((__pyx_v_step == 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L9_bool_binop_done:;
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":840
+      /* "View.MemoryView":838
  * 
  *         if have_step and step == 0:
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 840, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 838, __pyx_L1_error)
 
-      /* "View.MemoryView":839
+      /* "View.MemoryView":837
  *         negative_step = have_step != 0 and step < 0
  * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
     }
 
-    /* "View.MemoryView":843
+    /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
     __pyx_t_2 = (__pyx_v_have_start != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":844
+      /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
       __pyx_t_2 = ((__pyx_v_start < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":845
+        /* "View.MemoryView":843
  *         if have_start:
  *             if start < 0:
  *                 start += shape             # <<<<<<<<<<<<<<
  *                 if start < 0:
  *                     start = 0
  */
         __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-        /* "View.MemoryView":846
+        /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         __pyx_t_2 = ((__pyx_v_start < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":847
+          /* "View.MemoryView":845
  *                 start += shape
  *                 if start < 0:
  *                     start = 0             # <<<<<<<<<<<<<<
  *             elif start >= shape:
  *                 if negative_step:
  */
           __pyx_v_start = 0;
 
-          /* "View.MemoryView":846
+          /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         }
 
-        /* "View.MemoryView":844
+        /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
         goto __pyx_L12;
       }
 
-      /* "View.MemoryView":848
+      /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       __pyx_t_2 = ((__pyx_v_start >= __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":849
+        /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
         __pyx_t_2 = (__pyx_v_negative_step != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":850
+          /* "View.MemoryView":848
  *             elif start >= shape:
  *                 if negative_step:
  *                     start = shape - 1             # <<<<<<<<<<<<<<
  *                 else:
  *                     start = shape
  */
           __pyx_v_start = (__pyx_v_shape - 1);
 
-          /* "View.MemoryView":849
+          /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
           goto __pyx_L14;
         }
 
-        /* "View.MemoryView":852
+        /* "View.MemoryView":850
  *                     start = shape - 1
  *                 else:
  *                     start = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         /*else*/ {
           __pyx_v_start = __pyx_v_shape;
         }
         __pyx_L14:;
 
-        /* "View.MemoryView":848
+        /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       }
       __pyx_L12:;
 
-      /* "View.MemoryView":843
+      /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
       goto __pyx_L11;
     }
 
-    /* "View.MemoryView":854
+    /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
     /*else*/ {
       __pyx_t_2 = (__pyx_v_negative_step != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":855
+        /* "View.MemoryView":853
  *         else:
  *             if negative_step:
  *                 start = shape - 1             # <<<<<<<<<<<<<<
  *             else:
  *                 start = 0
  */
         __pyx_v_start = (__pyx_v_shape - 1);
 
-        /* "View.MemoryView":854
+        /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
         goto __pyx_L15;
       }
 
-      /* "View.MemoryView":857
+      /* "View.MemoryView":855
  *                 start = shape - 1
  *             else:
  *                 start = 0             # <<<<<<<<<<<<<<
  * 
  *         if have_stop:
  */
       /*else*/ {
         __pyx_v_start = 0;
       }
       __pyx_L15:;
     }
     __pyx_L11:;
 
-    /* "View.MemoryView":859
+    /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
     __pyx_t_2 = (__pyx_v_have_stop != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":860
+      /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
       __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":861
+        /* "View.MemoryView":859
  *         if have_stop:
  *             if stop < 0:
  *                 stop += shape             # <<<<<<<<<<<<<<
  *                 if stop < 0:
  *                     stop = 0
  */
         __pyx_v_stop = (__pyx_v_stop + __pyx_v_shape);
 
-        /* "View.MemoryView":862
+        /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":863
+          /* "View.MemoryView":861
  *                 stop += shape
  *                 if stop < 0:
  *                     stop = 0             # <<<<<<<<<<<<<<
  *             elif stop > shape:
  *                 stop = shape
  */
           __pyx_v_stop = 0;
 
-          /* "View.MemoryView":862
+          /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         }
 
-        /* "View.MemoryView":860
+        /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
         goto __pyx_L17;
       }
 
-      /* "View.MemoryView":864
+      /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       __pyx_t_2 = ((__pyx_v_stop > __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":865
+        /* "View.MemoryView":863
  *                     stop = 0
  *             elif stop > shape:
  *                 stop = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         __pyx_v_stop = __pyx_v_shape;
 
-        /* "View.MemoryView":864
+        /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       }
       __pyx_L17:;
 
-      /* "View.MemoryView":859
+      /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
       goto __pyx_L16;
     }
 
-    /* "View.MemoryView":867
+    /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
     /*else*/ {
       __pyx_t_2 = (__pyx_v_negative_step != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":868
+        /* "View.MemoryView":866
  *         else:
  *             if negative_step:
  *                 stop = -1             # <<<<<<<<<<<<<<
  *             else:
  *                 stop = shape
  */
         __pyx_v_stop = -1L;
 
-        /* "View.MemoryView":867
+        /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
         goto __pyx_L19;
       }
 
-      /* "View.MemoryView":870
+      /* "View.MemoryView":868
  *                 stop = -1
  *             else:
  *                 stop = shape             # <<<<<<<<<<<<<<
  * 
  *         if not have_step:
  */
       /*else*/ {
         __pyx_v_stop = __pyx_v_shape;
       }
       __pyx_L19:;
     }
     __pyx_L16:;
 
-    /* "View.MemoryView":872
+    /* "View.MemoryView":870
  *                 stop = shape
  * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
  * 
  */
     __pyx_t_2 = ((!(__pyx_v_have_step != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":873
+      /* "View.MemoryView":871
  * 
  *         if not have_step:
  *             step = 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_step = 1;
 
-      /* "View.MemoryView":872
+      /* "View.MemoryView":870
  *                 stop = shape
  * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
  * 
  */
     }
 
-    /* "View.MemoryView":877
+    /* "View.MemoryView":875
  * 
  *         with cython.cdivision(True):
  *             new_shape = (stop - start) // step             # <<<<<<<<<<<<<<
  * 
  *             if (stop - start) - step * new_shape:
  */
     __pyx_v_new_shape = ((__pyx_v_stop - __pyx_v_start) / __pyx_v_step);
 
-    /* "View.MemoryView":879
+    /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     __pyx_t_2 = (((__pyx_v_stop - __pyx_v_start) - (__pyx_v_step * __pyx_v_new_shape)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":880
+      /* "View.MemoryView":878
  * 
  *             if (stop - start) - step * new_shape:
  *                 new_shape += 1             # <<<<<<<<<<<<<<
  * 
  *         if new_shape < 0:
  */
       __pyx_v_new_shape = (__pyx_v_new_shape + 1);
 
-      /* "View.MemoryView":879
+      /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     }
 
-    /* "View.MemoryView":882
+    /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     __pyx_t_2 = ((__pyx_v_new_shape < 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":883
+      /* "View.MemoryView":881
  * 
  *         if new_shape < 0:
  *             new_shape = 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_new_shape = 0;
 
-      /* "View.MemoryView":882
+      /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     }
 
-    /* "View.MemoryView":886
+    /* "View.MemoryView":884
  * 
  * 
  *         dst.strides[new_ndim] = stride * step             # <<<<<<<<<<<<<<
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset
  */
     (__pyx_v_dst->strides[__pyx_v_new_ndim]) = (__pyx_v_stride * __pyx_v_step);
 
-    /* "View.MemoryView":887
+    /* "View.MemoryView":885
  * 
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape             # <<<<<<<<<<<<<<
  *         dst.suboffsets[new_ndim] = suboffset
  * 
  */
     (__pyx_v_dst->shape[__pyx_v_new_ndim]) = __pyx_v_new_shape;
 
-    /* "View.MemoryView":888
+    /* "View.MemoryView":886
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_dst->suboffsets[__pyx_v_new_ndim]) = __pyx_v_suboffset;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":891
+  /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
   __pyx_t_2 = (((__pyx_v_suboffset_dim[0]) < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":892
+    /* "View.MemoryView":890
  * 
  *     if suboffset_dim[0] < 0:
  *         dst.data += start * stride             # <<<<<<<<<<<<<<
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  */
     __pyx_v_dst->data = (__pyx_v_dst->data + (__pyx_v_start * __pyx_v_stride));
 
-    /* "View.MemoryView":891
+    /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
     goto __pyx_L23;
   }
 
-  /* "View.MemoryView":894
+  /* "View.MemoryView":892
  *         dst.data += start * stride
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride             # <<<<<<<<<<<<<<
  * 
  *     if suboffset >= 0:
  */
   /*else*/ {
     __pyx_t_3 = (__pyx_v_suboffset_dim[0]);
     (__pyx_v_dst->suboffsets[__pyx_t_3]) = ((__pyx_v_dst->suboffsets[__pyx_t_3]) + (__pyx_v_start * __pyx_v_stride));
   }
   __pyx_L23:;
 
-  /* "View.MemoryView":896
+  /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":897
+    /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
     __pyx_t_2 = ((!(__pyx_v_is_slice != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":898
+      /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
       __pyx_t_2 = ((__pyx_v_new_ndim == 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":899
+        /* "View.MemoryView":897
  *         if not is_slice:
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  */
         __pyx_v_dst->data = ((((char **)__pyx_v_dst->data)[0]) + __pyx_v_suboffset);
 
-        /* "View.MemoryView":898
+        /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
         goto __pyx_L26;
       }
 
-      /* "View.MemoryView":901
+      /* "View.MemoryView":899
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "             # <<<<<<<<<<<<<<
  *                                      "must be indexed and not sliced", dim)
  *         else:
  */
       /*else*/ {
 
-        /* "View.MemoryView":902
+        /* "View.MemoryView":900
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  *                                      "must be indexed and not sliced", dim)             # <<<<<<<<<<<<<<
  *         else:
  *             suboffset_dim[0] = new_ndim
  */
-        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 901, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 899, __pyx_L1_error)
       }
       __pyx_L26:;
 
-      /* "View.MemoryView":897
+      /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
       goto __pyx_L25;
     }
 
-    /* "View.MemoryView":904
+    /* "View.MemoryView":902
  *                                      "must be indexed and not sliced", dim)
  *         else:
  *             suboffset_dim[0] = new_ndim             # <<<<<<<<<<<<<<
  * 
  *     return 0
  */
     /*else*/ {
       (__pyx_v_suboffset_dim[0]) = __pyx_v_new_ndim;
     }
     __pyx_L25:;
 
-    /* "View.MemoryView":896
+    /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   }
 
-  /* "View.MemoryView":906
+  /* "View.MemoryView":904
  *             suboffset_dim[0] = new_ndim
  * 
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":809
+  /* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -12451,15 +12366,15 @@
     #endif
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":912
+/* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -12476,280 +12391,280 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("pybuffer_index", 0);
 
-  /* "View.MemoryView":914
+  /* "View.MemoryView":912
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t itemsize = view.itemsize
  *     cdef char *resultp
  */
   __pyx_v_suboffset = -1L;
 
-  /* "View.MemoryView":915
+  /* "View.MemoryView":913
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  *     cdef Py_ssize_t itemsize = view.itemsize             # <<<<<<<<<<<<<<
  *     cdef char *resultp
  * 
  */
   __pyx_t_1 = __pyx_v_view->itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":918
+  /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
   __pyx_t_2 = ((__pyx_v_view->ndim == 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":919
+    /* "View.MemoryView":917
  * 
  *     if view.ndim == 0:
  *         shape = view.len / itemsize             # <<<<<<<<<<<<<<
  *         stride = itemsize
  *     else:
  */
     if (unlikely(__pyx_v_itemsize == 0)) {
       PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 919, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
     else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
       PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(1, 919, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
     __pyx_v_shape = __Pyx_div_Py_ssize_t(__pyx_v_view->len, __pyx_v_itemsize);
 
-    /* "View.MemoryView":920
+    /* "View.MemoryView":918
  *     if view.ndim == 0:
  *         shape = view.len / itemsize
  *         stride = itemsize             # <<<<<<<<<<<<<<
  *     else:
  *         shape = view.shape[dim]
  */
     __pyx_v_stride = __pyx_v_itemsize;
 
-    /* "View.MemoryView":918
+    /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":922
+  /* "View.MemoryView":920
  *         stride = itemsize
  *     else:
  *         shape = view.shape[dim]             # <<<<<<<<<<<<<<
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  */
   /*else*/ {
     __pyx_v_shape = (__pyx_v_view->shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":923
+    /* "View.MemoryView":921
  *     else:
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]             # <<<<<<<<<<<<<<
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]
  */
     __pyx_v_stride = (__pyx_v_view->strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":924
+    /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     __pyx_t_2 = ((__pyx_v_view->suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":925
+      /* "View.MemoryView":923
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]             # <<<<<<<<<<<<<<
  * 
  *     if index < 0:
  */
       __pyx_v_suboffset = (__pyx_v_view->suboffsets[__pyx_v_dim]);
 
-      /* "View.MemoryView":924
+      /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":927
+  /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   __pyx_t_2 = ((__pyx_v_index < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":928
+    /* "View.MemoryView":926
  * 
  *     if index < 0:
  *         index += view.shape[dim]             # <<<<<<<<<<<<<<
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  */
     __pyx_v_index = (__pyx_v_index + (__pyx_v_view->shape[__pyx_v_dim]));
 
-    /* "View.MemoryView":929
+    /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     __pyx_t_2 = ((__pyx_v_index < 0) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":930
+      /* "View.MemoryView":928
  *         index += view.shape[dim]
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     if index >= shape:
  */
-      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 930, __pyx_L1_error)
+      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 930, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 930, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(1, 930, __pyx_L1_error)
+      __PYX_ERR(1, 928, __pyx_L1_error)
 
-      /* "View.MemoryView":929
+      /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     }
 
-    /* "View.MemoryView":927
+    /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   }
 
-  /* "View.MemoryView":932
+  /* "View.MemoryView":930
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   __pyx_t_2 = ((__pyx_v_index >= __pyx_v_shape) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":933
+    /* "View.MemoryView":931
  * 
  *     if index >= shape:
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     resultp = bufp + index * stride
  */
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 933, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 933, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 933, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 933, __pyx_L1_error)
+    __PYX_ERR(1, 931, __pyx_L1_error)
 
-    /* "View.MemoryView":932
+    /* "View.MemoryView":930
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   }
 
-  /* "View.MemoryView":935
+  /* "View.MemoryView":933
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     resultp = bufp + index * stride             # <<<<<<<<<<<<<<
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset
  */
   __pyx_v_resultp = (__pyx_v_bufp + (__pyx_v_index * __pyx_v_stride));
 
-  /* "View.MemoryView":936
+  /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":937
+    /* "View.MemoryView":935
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset             # <<<<<<<<<<<<<<
  * 
  *     return resultp
  */
     __pyx_v_resultp = ((((char **)__pyx_v_resultp)[0]) + __pyx_v_suboffset);
 
-    /* "View.MemoryView":936
+    /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   }
 
-  /* "View.MemoryView":939
+  /* "View.MemoryView":937
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  *     return resultp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_resultp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":912
+  /* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -12760,15 +12675,15 @@
   __Pyx_AddTraceback("View.MemoryView.pybuffer_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":945
+/* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
@@ -12788,90 +12703,90 @@
   int __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":946
+  /* "View.MemoryView":944
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:
  *     cdef int ndim = memslice.memview.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  */
   __pyx_t_1 = __pyx_v_memslice->memview->view.ndim;
   __pyx_v_ndim = __pyx_t_1;
 
-  /* "View.MemoryView":948
+  /* "View.MemoryView":946
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  *     cdef Py_ssize_t *shape = memslice.shape             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t *strides = memslice.strides
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->shape;
   __pyx_v_shape = __pyx_t_2;
 
-  /* "View.MemoryView":949
+  /* "View.MemoryView":947
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  *     cdef Py_ssize_t *strides = memslice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->strides;
   __pyx_v_strides = __pyx_t_2;
 
-  /* "View.MemoryView":953
+  /* "View.MemoryView":951
  * 
  *     cdef int i, j
  *     for i in range(ndim / 2):             # <<<<<<<<<<<<<<
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  */
   __pyx_t_3 = __Pyx_div_long(__pyx_v_ndim, 2);
   __pyx_t_4 = __pyx_t_3;
   for (__pyx_t_1 = 0; __pyx_t_1 < __pyx_t_4; __pyx_t_1+=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":954
+    /* "View.MemoryView":952
  *     cdef int i, j
  *     for i in range(ndim / 2):
  *         j = ndim - 1 - i             # <<<<<<<<<<<<<<
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]
  */
     __pyx_v_j = ((__pyx_v_ndim - 1) - __pyx_v_i);
 
-    /* "View.MemoryView":955
+    /* "View.MemoryView":953
  *     for i in range(ndim / 2):
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]             # <<<<<<<<<<<<<<
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  */
     __pyx_t_5 = (__pyx_v_strides[__pyx_v_j]);
     __pyx_t_6 = (__pyx_v_strides[__pyx_v_i]);
     (__pyx_v_strides[__pyx_v_i]) = __pyx_t_5;
     (__pyx_v_strides[__pyx_v_j]) = __pyx_t_6;
 
-    /* "View.MemoryView":956
+    /* "View.MemoryView":954
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]             # <<<<<<<<<<<<<<
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  */
     __pyx_t_6 = (__pyx_v_shape[__pyx_v_j]);
     __pyx_t_5 = (__pyx_v_shape[__pyx_v_i]);
     (__pyx_v_shape[__pyx_v_i]) = __pyx_t_6;
     (__pyx_v_shape[__pyx_v_j]) = __pyx_t_5;
 
-    /* "View.MemoryView":958
+    /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
     __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0) != 0);
@@ -12881,44 +12796,44 @@
       goto __pyx_L6_bool_binop_done;
     }
     __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0) != 0);
     __pyx_t_7 = __pyx_t_8;
     __pyx_L6_bool_binop_done:;
     if (__pyx_t_7) {
 
-      /* "View.MemoryView":959
+      /* "View.MemoryView":957
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
  * 
  *     return 1
  */
-      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 959, __pyx_L1_error)
+      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 957, __pyx_L1_error)
 
-      /* "View.MemoryView":958
+      /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":961
+  /* "View.MemoryView":959
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  *     return 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":945
+  /* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
@@ -12934,15 +12849,15 @@
     #endif
   }
   __pyx_r = 0;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":978
+/* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
@@ -12957,36 +12872,36 @@
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":979
+  /* "View.MemoryView":977
  * 
  *     def __dealloc__(self):
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
   __PYX_XDEC_MEMVIEW((&__pyx_v_self->from_slice), 1);
 
-  /* "View.MemoryView":978
+  /* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":981
+/* "View.MemoryView":979
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
@@ -12996,64 +12911,64 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":982
+  /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_object_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":983
+    /* "View.MemoryView":981
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)             # <<<<<<<<<<<<<<
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 983, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 981, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":982
+    /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   }
 
-  /* "View.MemoryView":985
+  /* "View.MemoryView":983
  *             return self.to_object_func(itemp)
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 985, __pyx_L1_error)
+    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 983, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":981
+  /* "View.MemoryView":979
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
@@ -13064,15 +12979,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":987
+/* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13083,58 +12998,58 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":988
+  /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_dtype_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":989
+    /* "View.MemoryView":987
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)             # <<<<<<<<<<<<<<
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)
  */
-    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 989, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 987, __pyx_L1_error)
 
-    /* "View.MemoryView":988
+    /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":991
+  /* "View.MemoryView":989
  *             self.to_dtype_func(itemp, value)
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 991, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 989, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":987
+  /* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13147,15 +13062,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":994
+/* "View.MemoryView":992
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
@@ -13173,27 +13088,27 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":995
+  /* "View.MemoryView":993
  *     @property
  *     def base(self):
  *         return self.from_object             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->from_object);
   __pyx_r = __pyx_v_self->from_object;
   goto __pyx_L0;
 
-  /* "View.MemoryView":994
+  /* "View.MemoryView":992
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
@@ -13234,15 +13149,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -13290,15 +13205,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -13313,15 +13228,15 @@
   __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1001
+/* "View.MemoryView":999
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
@@ -13341,351 +13256,351 @@
   Py_ssize_t *__pyx_t_8;
   Py_ssize_t __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_fromslice", 0);
 
-  /* "View.MemoryView":1009
+  /* "View.MemoryView":1007
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
   __pyx_t_1 = ((((PyObject *)__pyx_v_memviewslice.memview) == Py_None) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1010
+    /* "View.MemoryView":1008
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:
  *         return None             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1009
+    /* "View.MemoryView":1007
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
   }
 
-  /* "View.MemoryView":1015
+  /* "View.MemoryView":1013
  * 
  * 
  *     result = _memoryviewslice(None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     result.from_slice = memviewslice
  */
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1015, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1015, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(Py_None);
   PyTuple_SET_ITEM(__pyx_t_3, 0, Py_None);
   __Pyx_INCREF(__pyx_int_0);
   __Pyx_GIVEREF(__pyx_int_0);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_0);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1015, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":1017
+  /* "View.MemoryView":1015
  *     result = _memoryviewslice(None, 0, dtype_is_object)
  * 
  *     result.from_slice = memviewslice             # <<<<<<<<<<<<<<
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  */
   __pyx_v_result->from_slice = __pyx_v_memviewslice;
 
-  /* "View.MemoryView":1018
+  /* "View.MemoryView":1016
  * 
  *     result.from_slice = memviewslice
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)             # <<<<<<<<<<<<<<
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  */
   __PYX_INC_MEMVIEW((&__pyx_v_memviewslice), 1);
 
-  /* "View.MemoryView":1020
+  /* "View.MemoryView":1018
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base             # <<<<<<<<<<<<<<
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1020, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1018, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_result->from_object);
   __Pyx_DECREF(__pyx_v_result->from_object);
   __pyx_v_result->from_object = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":1021
+  /* "View.MemoryView":1019
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  *     result.typeinfo = memviewslice.memview.typeinfo             # <<<<<<<<<<<<<<
  * 
  *     result.view = memviewslice.memview.view
  */
   __pyx_t_4 = __pyx_v_memviewslice.memview->typeinfo;
   __pyx_v_result->__pyx_base.typeinfo = __pyx_t_4;
 
-  /* "View.MemoryView":1023
+  /* "View.MemoryView":1021
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  *     result.view = memviewslice.memview.view             # <<<<<<<<<<<<<<
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  */
   __pyx_t_5 = __pyx_v_memviewslice.memview->view;
   __pyx_v_result->__pyx_base.view = __pyx_t_5;
 
-  /* "View.MemoryView":1024
+  /* "View.MemoryView":1022
  * 
  *     result.view = memviewslice.memview.view
  *     result.view.buf = <void *> memviewslice.data             # <<<<<<<<<<<<<<
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  */
   __pyx_v_result->__pyx_base.view.buf = ((void *)__pyx_v_memviewslice.data);
 
-  /* "View.MemoryView":1025
+  /* "View.MemoryView":1023
  *     result.view = memviewslice.memview.view
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim             # <<<<<<<<<<<<<<
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  *     Py_INCREF(Py_None)
  */
   __pyx_v_result->__pyx_base.view.ndim = __pyx_v_ndim;
 
-  /* "View.MemoryView":1026
+  /* "View.MemoryView":1024
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None             # <<<<<<<<<<<<<<
  *     Py_INCREF(Py_None)
  * 
  */
   ((Py_buffer *)(&__pyx_v_result->__pyx_base.view))->obj = Py_None;
 
-  /* "View.MemoryView":1027
+  /* "View.MemoryView":1025
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  *     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
  */
   Py_INCREF(Py_None);
 
-  /* "View.MemoryView":1029
+  /* "View.MemoryView":1027
  *     Py_INCREF(Py_None)
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
  *         result.flags = PyBUF_RECORDS
  *     else:
  */
   __pyx_t_1 = ((((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)->flags & PyBUF_WRITABLE) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1030
+    /* "View.MemoryView":1028
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
  *         result.flags = PyBUF_RECORDS             # <<<<<<<<<<<<<<
  *     else:
  *         result.flags = PyBUF_RECORDS_RO
  */
     __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS;
 
-    /* "View.MemoryView":1029
+    /* "View.MemoryView":1027
  *     Py_INCREF(Py_None)
  * 
  *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
  *         result.flags = PyBUF_RECORDS
  *     else:
  */
     goto __pyx_L4;
   }
 
-  /* "View.MemoryView":1032
+  /* "View.MemoryView":1030
  *         result.flags = PyBUF_RECORDS
  *     else:
  *         result.flags = PyBUF_RECORDS_RO             # <<<<<<<<<<<<<<
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  */
   /*else*/ {
     __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS_RO;
   }
   __pyx_L4:;
 
-  /* "View.MemoryView":1034
+  /* "View.MemoryView":1032
  *         result.flags = PyBUF_RECORDS_RO
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape             # <<<<<<<<<<<<<<
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides
  * 
  */
   __pyx_v_result->__pyx_base.view.shape = ((Py_ssize_t *)__pyx_v_result->from_slice.shape);
 
-  /* "View.MemoryView":1035
+  /* "View.MemoryView":1033
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_v_result->__pyx_base.view.strides = ((Py_ssize_t *)__pyx_v_result->from_slice.strides);
 
-  /* "View.MemoryView":1038
+  /* "View.MemoryView":1036
  * 
  * 
  *     result.view.suboffsets = NULL             # <<<<<<<<<<<<<<
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
   __pyx_v_result->__pyx_base.view.suboffsets = NULL;
 
-  /* "View.MemoryView":1039
+  /* "View.MemoryView":1037
  * 
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  */
   __pyx_t_7 = (__pyx_v_result->from_slice.suboffsets + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->from_slice.suboffsets; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
     __pyx_v_suboffset = (__pyx_t_6[0]);
 
-    /* "View.MemoryView":1040
+    /* "View.MemoryView":1038
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
     __pyx_t_1 = ((__pyx_v_suboffset >= 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1041
+      /* "View.MemoryView":1039
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_result->__pyx_base.view.suboffsets = ((Py_ssize_t *)__pyx_v_result->from_slice.suboffsets);
 
-      /* "View.MemoryView":1042
+      /* "View.MemoryView":1040
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break             # <<<<<<<<<<<<<<
  * 
  *     result.view.len = result.view.itemsize
  */
       goto __pyx_L6_break;
 
-      /* "View.MemoryView":1040
+      /* "View.MemoryView":1038
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
     }
   }
   __pyx_L6_break:;
 
-  /* "View.MemoryView":1044
+  /* "View.MemoryView":1042
  *             break
  * 
  *     result.view.len = result.view.itemsize             # <<<<<<<<<<<<<<
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length
  */
   __pyx_t_9 = __pyx_v_result->__pyx_base.view.itemsize;
   __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
 
-  /* "View.MemoryView":1045
+  /* "View.MemoryView":1043
  * 
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         result.view.len *= length
  * 
  */
   __pyx_t_7 = (__pyx_v_result->__pyx_base.view.shape + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->__pyx_base.view.shape; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
-    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1045, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1043, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "View.MemoryView":1046
+    /* "View.MemoryView":1044
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length             # <<<<<<<<<<<<<<
  * 
  *     result.to_object_func = to_object_func
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1046, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1044, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1046, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1044, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 1046, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 1044, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
   }
 
-  /* "View.MemoryView":1048
+  /* "View.MemoryView":1046
  *         result.view.len *= length
  * 
  *     result.to_object_func = to_object_func             # <<<<<<<<<<<<<<
  *     result.to_dtype_func = to_dtype_func
  * 
  */
   __pyx_v_result->to_object_func = __pyx_v_to_object_func;
 
-  /* "View.MemoryView":1049
+  /* "View.MemoryView":1047
  * 
  *     result.to_object_func = to_object_func
  *     result.to_dtype_func = to_dtype_func             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   __pyx_v_result->to_dtype_func = __pyx_v_to_dtype_func;
 
-  /* "View.MemoryView":1051
+  /* "View.MemoryView":1049
  *     result.to_dtype_func = to_dtype_func
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":1001
+  /* "View.MemoryView":999
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
@@ -13699,15 +13614,15 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1054
+/* "View.MemoryView":1052
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
@@ -13719,79 +13634,79 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_slice_from_memview", 0);
 
-  /* "View.MemoryView":1057
+  /* "View.MemoryView":1055
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1058
+    /* "View.MemoryView":1056
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview             # <<<<<<<<<<<<<<
  *         return &obj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 1058, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 1056, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":1059
+    /* "View.MemoryView":1057
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview
  *         return &obj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, mslice)
  */
     __pyx_r = (&__pyx_v_obj->from_slice);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1057
+    /* "View.MemoryView":1055
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   }
 
-  /* "View.MemoryView":1061
+  /* "View.MemoryView":1059
  *         return &obj.from_slice
  *     else:
  *         slice_copy(memview, mslice)             # <<<<<<<<<<<<<<
  *         return mslice
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, __pyx_v_mslice);
 
-    /* "View.MemoryView":1062
+    /* "View.MemoryView":1060
  *     else:
  *         slice_copy(memview, mslice)
  *         return mslice             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_slice_copy')
  */
     __pyx_r = __pyx_v_mslice;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1054
+  /* "View.MemoryView":1052
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
@@ -13802,15 +13717,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_obj);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1065
+/* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
@@ -13823,120 +13738,120 @@
   Py_ssize_t *__pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   __Pyx_RefNannySetupContext("slice_copy", 0);
 
-  /* "View.MemoryView":1069
+  /* "View.MemoryView":1067
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  * 
  *     shape = memview.view.shape             # <<<<<<<<<<<<<<
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets
  */
   __pyx_t_1 = __pyx_v_memview->view.shape;
   __pyx_v_shape = __pyx_t_1;
 
-  /* "View.MemoryView":1070
+  /* "View.MemoryView":1068
  * 
  *     shape = memview.view.shape
  *     strides = memview.view.strides             # <<<<<<<<<<<<<<
  *     suboffsets = memview.view.suboffsets
  * 
  */
   __pyx_t_1 = __pyx_v_memview->view.strides;
   __pyx_v_strides = __pyx_t_1;
 
-  /* "View.MemoryView":1071
+  /* "View.MemoryView":1069
  *     shape = memview.view.shape
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets             # <<<<<<<<<<<<<<
  * 
  *     dst.memview = <__pyx_memoryview *> memview
  */
   __pyx_t_1 = __pyx_v_memview->view.suboffsets;
   __pyx_v_suboffsets = __pyx_t_1;
 
-  /* "View.MemoryView":1073
+  /* "View.MemoryView":1071
  *     suboffsets = memview.view.suboffsets
  * 
  *     dst.memview = <__pyx_memoryview *> memview             # <<<<<<<<<<<<<<
  *     dst.data = <char *> memview.view.buf
  * 
  */
   __pyx_v_dst->memview = ((struct __pyx_memoryview_obj *)__pyx_v_memview);
 
-  /* "View.MemoryView":1074
+  /* "View.MemoryView":1072
  * 
  *     dst.memview = <__pyx_memoryview *> memview
  *     dst.data = <char *> memview.view.buf             # <<<<<<<<<<<<<<
  * 
  *     for dim in range(memview.view.ndim):
  */
   __pyx_v_dst->data = ((char *)__pyx_v_memview->view.buf);
 
-  /* "View.MemoryView":1076
+  /* "View.MemoryView":1074
  *     dst.data = <char *> memview.view.buf
  * 
  *     for dim in range(memview.view.ndim):             # <<<<<<<<<<<<<<
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  */
   __pyx_t_2 = __pyx_v_memview->view.ndim;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_dim = __pyx_t_4;
 
-    /* "View.MemoryView":1077
+    /* "View.MemoryView":1075
  * 
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]             # <<<<<<<<<<<<<<
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
  */
     (__pyx_v_dst->shape[__pyx_v_dim]) = (__pyx_v_shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":1078
+    /* "View.MemoryView":1076
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]             # <<<<<<<<<<<<<<
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
  * 
  */
     (__pyx_v_dst->strides[__pyx_v_dim]) = (__pyx_v_strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":1079
+    /* "View.MemoryView":1077
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_object')
  */
     if ((__pyx_v_suboffsets != 0)) {
       __pyx_t_5 = (__pyx_v_suboffsets[__pyx_v_dim]);
     } else {
       __pyx_t_5 = -1L;
     }
     (__pyx_v_dst->suboffsets[__pyx_v_dim]) = __pyx_t_5;
   }
 
-  /* "View.MemoryView":1065
+  /* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1082
+/* "View.MemoryView":1080
  * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
@@ -13946,38 +13861,38 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_copy", 0);
 
-  /* "View.MemoryView":1085
+  /* "View.MemoryView":1083
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)             # <<<<<<<<<<<<<<
  *     return memoryview_copy_from_slice(memview, &memviewslice)
  * 
  */
   __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_memviewslice));
 
-  /* "View.MemoryView":1086
+  /* "View.MemoryView":1084
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)
  *     return memoryview_copy_from_slice(memview, &memviewslice)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1086, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1084, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1082
+  /* "View.MemoryView":1080
  * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
@@ -13988,15 +13903,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1089
+/* "View.MemoryView":1087
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
@@ -14011,99 +13926,99 @@
   int (*__pyx_t_4)(char *, PyObject *);
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_copy_from_slice", 0);
 
-  /* "View.MemoryView":1096
+  /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1097
+    /* "View.MemoryView":1095
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func             # <<<<<<<<<<<<<<
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  */
     __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
     __pyx_v_to_object_func = __pyx_t_3;
 
-    /* "View.MemoryView":1098
+    /* "View.MemoryView":1096
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func             # <<<<<<<<<<<<<<
  *     else:
  *         to_object_func = NULL
  */
     __pyx_t_4 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
     __pyx_v_to_dtype_func = __pyx_t_4;
 
-    /* "View.MemoryView":1096
+    /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1100
+  /* "View.MemoryView":1098
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  *         to_object_func = NULL             # <<<<<<<<<<<<<<
  *         to_dtype_func = NULL
  * 
  */
   /*else*/ {
     __pyx_v_to_object_func = NULL;
 
-    /* "View.MemoryView":1101
+    /* "View.MemoryView":1099
  *     else:
  *         to_object_func = NULL
  *         to_dtype_func = NULL             # <<<<<<<<<<<<<<
  * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  */
     __pyx_v_to_dtype_func = NULL;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1103
+  /* "View.MemoryView":1101
  *         to_dtype_func = NULL
  * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,             # <<<<<<<<<<<<<<
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)
  */
   __Pyx_XDECREF(__pyx_r);
 
-  /* "View.MemoryView":1105
+  /* "View.MemoryView":1103
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 1103, __pyx_L1_error)
+  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 1101, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1089
+  /* "View.MemoryView":1087
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
@@ -14114,81 +14029,81 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1111
+/* "View.MemoryView":1109
  * 
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
 static Py_ssize_t abs_py_ssize_t(Py_ssize_t __pyx_v_arg) {
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
 
-  /* "View.MemoryView":1112
+  /* "View.MemoryView":1110
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_arg < 0) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1113
+    /* "View.MemoryView":1111
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:
  *         return -arg             # <<<<<<<<<<<<<<
  *     else:
  *         return arg
  */
     __pyx_r = (-__pyx_v_arg);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1112
+    /* "View.MemoryView":1110
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   }
 
-  /* "View.MemoryView":1115
+  /* "View.MemoryView":1113
  *         return -arg
  *     else:
  *         return arg             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_get_best_slice_order')
  */
   /*else*/ {
     __pyx_r = __pyx_v_arg;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1111
+  /* "View.MemoryView":1109
  * 
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1118
+/* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
@@ -14198,187 +14113,187 @@
   Py_ssize_t __pyx_v_f_stride;
   char __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1123
+  /* "View.MemoryView":1121
  *     """
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t f_stride = 0
  * 
  */
   __pyx_v_c_stride = 0;
 
-  /* "View.MemoryView":1124
+  /* "View.MemoryView":1122
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0
  *     cdef Py_ssize_t f_stride = 0             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_f_stride = 0;
 
-  /* "View.MemoryView":1126
+  /* "View.MemoryView":1124
  *     cdef Py_ssize_t f_stride = 0
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1127
+    /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1128
+      /* "View.MemoryView":1126
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_c_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1129
+      /* "View.MemoryView":1127
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
       goto __pyx_L4_break;
 
-      /* "View.MemoryView":1127
+      /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L4_break:;
 
-  /* "View.MemoryView":1131
+  /* "View.MemoryView":1129
  *             break
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  */
   __pyx_t_1 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_1;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1132
+    /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1133
+      /* "View.MemoryView":1131
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_f_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1134
+      /* "View.MemoryView":1132
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  */
       goto __pyx_L7_break;
 
-      /* "View.MemoryView":1132
+      /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L7_break:;
 
-  /* "View.MemoryView":1136
+  /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   __pyx_t_2 = ((abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1137
+    /* "View.MemoryView":1135
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  *         return 'C'             # <<<<<<<<<<<<<<
  *     else:
  *         return 'F'
  */
     __pyx_r = 'C';
     goto __pyx_L0;
 
-    /* "View.MemoryView":1136
+    /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   }
 
-  /* "View.MemoryView":1139
+  /* "View.MemoryView":1137
  *         return 'C'
  *     else:
  *         return 'F'             # <<<<<<<<<<<<<<
  * 
  * @cython.cdivision(True)
  */
   /*else*/ {
     __pyx_r = 'F';
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1118
+  /* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1142
+/* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
@@ -14391,61 +14306,61 @@
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   Py_ssize_t __pyx_t_6;
 
-  /* "View.MemoryView":1149
+  /* "View.MemoryView":1147
  * 
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  */
   __pyx_v_src_extent = (__pyx_v_src_shape[0]);
 
-  /* "View.MemoryView":1150
+  /* "View.MemoryView":1148
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  */
   __pyx_v_dst_extent = (__pyx_v_dst_shape[0]);
 
-  /* "View.MemoryView":1151
+  /* "View.MemoryView":1149
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  */
   __pyx_v_src_stride = (__pyx_v_src_strides[0]);
 
-  /* "View.MemoryView":1152
+  /* "View.MemoryView":1150
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_dst_stride = (__pyx_v_dst_strides[0]);
 
-  /* "View.MemoryView":1154
+  /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1155
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     __pyx_t_2 = ((__pyx_v_src_stride > 0) != 0);
@@ -14457,195 +14372,195 @@
     __pyx_t_2 = ((__pyx_v_dst_stride > 0) != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
       goto __pyx_L5_bool_binop_done;
     }
 
-    /* "View.MemoryView":1156
+    /* "View.MemoryView":1154
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):             # <<<<<<<<<<<<<<
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  *        else:
  */
     __pyx_t_2 = (((size_t)__pyx_v_src_stride) == __pyx_v_itemsize);
     if (__pyx_t_2) {
       __pyx_t_2 = (__pyx_v_itemsize == ((size_t)__pyx_v_dst_stride));
     }
     __pyx_t_3 = (__pyx_t_2 != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L5_bool_binop_done:;
 
-    /* "View.MemoryView":1155
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1157
+      /* "View.MemoryView":1155
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
  *        else:
  *            for i in range(dst_extent):
  */
       (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, (__pyx_v_itemsize * __pyx_v_dst_extent)));
 
-      /* "View.MemoryView":1155
+      /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
       goto __pyx_L4;
     }
 
-    /* "View.MemoryView":1159
+    /* "View.MemoryView":1157
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  *        else:
  *            for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride
  */
     /*else*/ {
       __pyx_t_4 = __pyx_v_dst_extent;
       __pyx_t_5 = __pyx_t_4;
       for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
         __pyx_v_i = __pyx_t_6;
 
-        /* "View.MemoryView":1160
+        /* "View.MemoryView":1158
  *        else:
  *            for i in range(dst_extent):
  *                memcpy(dst_data, src_data, itemsize)             # <<<<<<<<<<<<<<
  *                src_data += src_stride
  *                dst_data += dst_stride
  */
         (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, __pyx_v_itemsize));
 
-        /* "View.MemoryView":1161
+        /* "View.MemoryView":1159
  *            for i in range(dst_extent):
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride             # <<<<<<<<<<<<<<
  *                dst_data += dst_stride
  *     else:
  */
         __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-        /* "View.MemoryView":1162
+        /* "View.MemoryView":1160
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride
  *                dst_data += dst_stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(dst_extent):
  */
         __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
       }
     }
     __pyx_L4:;
 
-    /* "View.MemoryView":1154
+    /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1164
+  /* "View.MemoryView":1162
  *                dst_data += dst_stride
  *     else:
  *         for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *             _copy_strided_to_strided(src_data, src_strides + 1,
  *                                      dst_data, dst_strides + 1,
  */
   /*else*/ {
     __pyx_t_4 = __pyx_v_dst_extent;
     __pyx_t_5 = __pyx_t_4;
     for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
       __pyx_v_i = __pyx_t_6;
 
-      /* "View.MemoryView":1165
+      /* "View.MemoryView":1163
  *     else:
  *         for i in range(dst_extent):
  *             _copy_strided_to_strided(src_data, src_strides + 1,             # <<<<<<<<<<<<<<
  *                                      dst_data, dst_strides + 1,
  *                                      src_shape + 1, dst_shape + 1,
  */
       _copy_strided_to_strided(__pyx_v_src_data, (__pyx_v_src_strides + 1), __pyx_v_dst_data, (__pyx_v_dst_strides + 1), (__pyx_v_src_shape + 1), (__pyx_v_dst_shape + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize);
 
-      /* "View.MemoryView":1169
+      /* "View.MemoryView":1167
  *                                      src_shape + 1, dst_shape + 1,
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride             # <<<<<<<<<<<<<<
  *             dst_data += dst_stride
  * 
  */
       __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-      /* "View.MemoryView":1170
+      /* "View.MemoryView":1168
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride
  *             dst_data += dst_stride             # <<<<<<<<<<<<<<
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,
  */
       __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1142
+  /* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1172
+/* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
 static void copy_strided_to_strided(__Pyx_memviewslice *__pyx_v_src, __Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize) {
 
-  /* "View.MemoryView":1175
+  /* "View.MemoryView":1173
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  *     _copy_strided_to_strided(src.data, src.strides, dst.data, dst.strides,             # <<<<<<<<<<<<<<
  *                              src.shape, dst.shape, ndim, itemsize)
  * 
  */
   _copy_strided_to_strided(__pyx_v_src->data, __pyx_v_src->strides, __pyx_v_dst->data, __pyx_v_dst->strides, __pyx_v_src->shape, __pyx_v_dst->shape, __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1172
+  /* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1179
+/* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
@@ -14654,70 +14569,70 @@
   Py_ssize_t __pyx_v_size;
   Py_ssize_t __pyx_r;
   Py_ssize_t __pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
 
-  /* "View.MemoryView":1181
+  /* "View.MemoryView":1179
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     for shape in src.shape[:ndim]:
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_size = __pyx_t_1;
 
-  /* "View.MemoryView":1183
+  /* "View.MemoryView":1181
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  * 
  *     for shape in src.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         size *= shape
  * 
  */
   __pyx_t_3 = (__pyx_v_src->shape + __pyx_v_ndim);
   for (__pyx_t_4 = __pyx_v_src->shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_shape = (__pyx_t_2[0]);
 
-    /* "View.MemoryView":1184
+    /* "View.MemoryView":1182
  * 
  *     for shape in src.shape[:ndim]:
  *         size *= shape             # <<<<<<<<<<<<<<
  * 
  *     return size
  */
     __pyx_v_size = (__pyx_v_size * __pyx_v_shape);
   }
 
-  /* "View.MemoryView":1186
+  /* "View.MemoryView":1184
  *         size *= shape
  * 
  *     return size             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_fill_contig_strides_array')
  */
   __pyx_r = __pyx_v_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1179
+  /* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1189
+/* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
@@ -14725,121 +14640,121 @@
   int __pyx_v_idx;
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1198
+  /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
   __pyx_t_1 = ((__pyx_v_order == 'F') != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1199
+    /* "View.MemoryView":1197
  * 
  *     if order == 'F':
  *         for idx in range(ndim):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
     __pyx_t_2 = __pyx_v_ndim;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_idx = __pyx_t_4;
 
-      /* "View.MemoryView":1200
+      /* "View.MemoryView":1198
  *     if order == 'F':
  *         for idx in range(ndim):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  *     else:
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1201
+      /* "View.MemoryView":1199
  *         for idx in range(ndim):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
 
-    /* "View.MemoryView":1198
+    /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1203
+  /* "View.MemoryView":1201
  *             stride *= shape[idx]
  *     else:
  *         for idx in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
   /*else*/ {
     for (__pyx_t_2 = (__pyx_v_ndim - 1); __pyx_t_2 > -1; __pyx_t_2-=1) {
       __pyx_v_idx = __pyx_t_2;
 
-      /* "View.MemoryView":1204
+      /* "View.MemoryView":1202
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  * 
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1205
+      /* "View.MemoryView":1203
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  * 
  *     return stride
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1207
+  /* "View.MemoryView":1205
  *             stride *= shape[idx]
  * 
  *     return stride             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  */
   __pyx_r = __pyx_v_stride;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1189
+  /* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1210
+/* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -14855,222 +14770,222 @@
   struct __pyx_memoryview_obj *__pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":1221
+  /* "View.MemoryView":1219
  *     cdef void *result
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1222
+  /* "View.MemoryView":1220
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef size_t size = slice_get_size(src, ndim)             # <<<<<<<<<<<<<<
  * 
  *     result = malloc(size)
  */
   __pyx_v_size = __pyx_memoryview_slice_get_size(__pyx_v_src, __pyx_v_ndim);
 
-  /* "View.MemoryView":1224
+  /* "View.MemoryView":1222
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  *     result = malloc(size)             # <<<<<<<<<<<<<<
  *     if not result:
  *         _err(MemoryError, NULL)
  */
   __pyx_v_result = malloc(__pyx_v_size);
 
-  /* "View.MemoryView":1225
+  /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_result != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1226
+    /* "View.MemoryView":1224
  *     result = malloc(size)
  *     if not result:
  *         _err(MemoryError, NULL)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1226, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1224, __pyx_L1_error)
 
-    /* "View.MemoryView":1225
+    /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
  * 
  */
   }
 
-  /* "View.MemoryView":1229
+  /* "View.MemoryView":1227
  * 
  * 
  *     tmpslice.data = <char *> result             # <<<<<<<<<<<<<<
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  */
   __pyx_v_tmpslice->data = ((char *)__pyx_v_result);
 
-  /* "View.MemoryView":1230
+  /* "View.MemoryView":1228
  * 
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview             # <<<<<<<<<<<<<<
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  */
   __pyx_t_4 = __pyx_v_src->memview;
   __pyx_v_tmpslice->memview = __pyx_t_4;
 
-  /* "View.MemoryView":1231
+  /* "View.MemoryView":1229
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1232
+    /* "View.MemoryView":1230
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]             # <<<<<<<<<<<<<<
  *         tmpslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_tmpslice->shape[__pyx_v_i]) = (__pyx_v_src->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1233
+    /* "View.MemoryView":1231
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,
  */
     (__pyx_v_tmpslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1235
+  /* "View.MemoryView":1233
  *         tmpslice.suboffsets[i] = -1
  * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,             # <<<<<<<<<<<<<<
  *                               ndim, order)
  * 
  */
   (void)(__pyx_fill_contig_strides_array((&(__pyx_v_tmpslice->shape[0])), (&(__pyx_v_tmpslice->strides[0])), __pyx_v_itemsize, __pyx_v_ndim, __pyx_v_order));
 
-  /* "View.MemoryView":1239
+  /* "View.MemoryView":1237
  * 
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1240
+    /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     __pyx_t_2 = (((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1241
+      /* "View.MemoryView":1239
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0             # <<<<<<<<<<<<<<
  * 
  *     if slice_is_contig(src[0], order, ndim):
  */
       (__pyx_v_tmpslice->strides[__pyx_v_i]) = 0;
 
-      /* "View.MemoryView":1240
+      /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1243
+  /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
   __pyx_t_2 = (__pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1244
+    /* "View.MemoryView":1242
  * 
  *     if slice_is_contig(src[0], order, ndim):
  *         memcpy(result, src.data, size)             # <<<<<<<<<<<<<<
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  */
     (void)(memcpy(__pyx_v_result, __pyx_v_src->data, __pyx_v_size));
 
-    /* "View.MemoryView":1243
+    /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":1246
+  /* "View.MemoryView":1244
  *         memcpy(result, src.data, size)
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   /*else*/ {
     copy_strided_to_strided(__pyx_v_src, __pyx_v_tmpslice, __pyx_v_ndim, __pyx_v_itemsize);
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":1248
+  /* "View.MemoryView":1246
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1210
+  /* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -15086,15 +15001,15 @@
     #endif
   }
   __pyx_r = NULL;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1253
+/* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
@@ -15109,57 +15024,57 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_extents", 0);
 
-  /* "View.MemoryView":1256
+  /* "View.MemoryView":1254
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  *                                                         (i, extent1, extent2))             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err_dim')
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1256, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":1255
+  /* "View.MemoryView":1253
  * cdef int _err_extents(int i, Py_ssize_t extent1,
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %             # <<<<<<<<<<<<<<
  *                                                         (i, extent1, extent2))
  * 
  */
-  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1255, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1255, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_4, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __PYX_ERR(1, 1255, __pyx_L1_error)
+  __PYX_ERR(1, 1253, __pyx_L1_error)
 
-  /* "View.MemoryView":1253
+  /* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
@@ -15174,15 +15089,15 @@
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1259
+/* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
@@ -15198,26 +15113,26 @@
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_dim", 0);
   __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1260
+  /* "View.MemoryView":1258
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:
  *     raise error(msg.decode('ascii') % dim)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err')
  */
-  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_INCREF(__pyx_v_error);
   __pyx_t_3 = __pyx_v_error; __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
@@ -15227,22 +15142,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1260, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 1260, __pyx_L1_error)
+  __PYX_ERR(1, 1258, __pyx_L1_error)
 
-  /* "View.MemoryView":1259
+  /* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
@@ -15258,15 +15173,15 @@
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1263
+/* "View.MemoryView":1261
  * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
@@ -15283,32 +15198,32 @@
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err", 0);
   __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1264
+  /* "View.MemoryView":1262
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:             # <<<<<<<<<<<<<<
  *         raise error(msg.decode('ascii'))
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_msg != NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":1265
+    /* "View.MemoryView":1263
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))             # <<<<<<<<<<<<<<
  *     else:
  *         raise error
  */
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1265, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1263, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_error);
     __pyx_t_4 = __pyx_v_error; __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
@@ -15316,43 +15231,43 @@
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1265, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1263, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 1265, __pyx_L1_error)
+    __PYX_ERR(1, 1263, __pyx_L1_error)
 
-    /* "View.MemoryView":1264
+    /* "View.MemoryView":1262
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:             # <<<<<<<<<<<<<<
  *         raise error(msg.decode('ascii'))
  *     else:
  */
   }
 
-  /* "View.MemoryView":1267
+  /* "View.MemoryView":1265
  *         raise error(msg.decode('ascii'))
  *     else:
  *         raise error             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_contents')
  */
   /*else*/ {
     __Pyx_Raise(__pyx_v_error, 0, 0, 0);
-    __PYX_ERR(1, 1267, __pyx_L1_error)
+    __PYX_ERR(1, 1265, __pyx_L1_error)
   }
 
-  /* "View.MemoryView":1263
+  /* "View.MemoryView":1261
  * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
@@ -15368,15 +15283,15 @@
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1270
+/* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -15398,119 +15313,119 @@
   int __pyx_t_6;
   void *__pyx_t_7;
   int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "View.MemoryView":1278
+  /* "View.MemoryView":1276
  *     Check for overlapping memory and verify the shapes.
  *     """
  *     cdef void *tmpdata = NULL             # <<<<<<<<<<<<<<
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  */
   __pyx_v_tmpdata = NULL;
 
-  /* "View.MemoryView":1279
+  /* "View.MemoryView":1277
  *     """
  *     cdef void *tmpdata = NULL
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  */
   __pyx_t_1 = __pyx_v_src.memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1281
+  /* "View.MemoryView":1279
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)             # <<<<<<<<<<<<<<
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False
  */
   __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_src), __pyx_v_src_ndim);
 
-  /* "View.MemoryView":1282
+  /* "View.MemoryView":1280
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False             # <<<<<<<<<<<<<<
  *     cdef bint direct_copy = False
  *     cdef __Pyx_memviewslice tmp
  */
   __pyx_v_broadcasting = 0;
 
-  /* "View.MemoryView":1283
+  /* "View.MemoryView":1281
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False             # <<<<<<<<<<<<<<
  *     cdef __Pyx_memviewslice tmp
  * 
  */
   __pyx_v_direct_copy = 0;
 
-  /* "View.MemoryView":1286
+  /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
   __pyx_t_2 = ((__pyx_v_src_ndim < __pyx_v_dst_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1287
+    /* "View.MemoryView":1285
  * 
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_src), __pyx_v_src_ndim, __pyx_v_dst_ndim);
 
-    /* "View.MemoryView":1286
+    /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1288
+  /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   __pyx_t_2 = ((__pyx_v_dst_ndim < __pyx_v_src_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1289
+    /* "View.MemoryView":1287
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)             # <<<<<<<<<<<<<<
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_dst), __pyx_v_dst_ndim, __pyx_v_src_ndim);
 
-    /* "View.MemoryView":1288
+    /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1291
+  /* "View.MemoryView":1289
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
   __pyx_t_3 = __pyx_v_dst_ndim;
@@ -15518,420 +15433,420 @@
   if (((__pyx_t_3 > __pyx_t_4) != 0)) {
     __pyx_t_5 = __pyx_t_3;
   } else {
     __pyx_t_5 = __pyx_t_4;
   }
   __pyx_v_ndim = __pyx_t_5;
 
-  /* "View.MemoryView":1293
+  /* "View.MemoryView":1291
  *     cdef int ndim = max(src_ndim, dst_ndim)
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  */
   __pyx_t_5 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_5;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1294
+    /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i])) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1295
+      /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
       __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) == 1) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":1296
+        /* "View.MemoryView":1294
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  *                 broadcasting = True             # <<<<<<<<<<<<<<
  *                 src.strides[i] = 0
  *             else:
  */
         __pyx_v_broadcasting = 1;
 
-        /* "View.MemoryView":1297
+        /* "View.MemoryView":1295
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  *                 src.strides[i] = 0             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  */
         (__pyx_v_src.strides[__pyx_v_i]) = 0;
 
-        /* "View.MemoryView":1295
+        /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":1299
+      /* "View.MemoryView":1297
  *                 src.strides[i] = 0
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])             # <<<<<<<<<<<<<<
  * 
  *         if src.suboffsets[i] >= 0:
  */
       /*else*/ {
-        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1299, __pyx_L1_error)
+        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1297, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":1294
+      /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     }
 
-    /* "View.MemoryView":1301
+    /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     __pyx_t_2 = (((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1302
+      /* "View.MemoryView":1300
  * 
  *         if src.suboffsets[i] >= 0:
  *             _err_dim(ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  */
-      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1302, __pyx_L1_error)
+      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1300, __pyx_L1_error)
 
-      /* "View.MemoryView":1301
+      /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1304
+  /* "View.MemoryView":1302
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   __pyx_t_2 = (__pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1306
+    /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     __pyx_t_2 = ((!(__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim) != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1307
+      /* "View.MemoryView":1305
  * 
  *         if not slice_is_contig(src, order, ndim):
  *             order = get_best_order(&dst, ndim)             # <<<<<<<<<<<<<<
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  */
       __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim);
 
-      /* "View.MemoryView":1306
+      /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     }
 
-    /* "View.MemoryView":1309
+    /* "View.MemoryView":1307
  *             order = get_best_order(&dst, ndim)
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)             # <<<<<<<<<<<<<<
  *         src = tmp
  * 
  */
-    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1309, __pyx_L1_error)
+    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1307, __pyx_L1_error)
     __pyx_v_tmpdata = __pyx_t_7;
 
-    /* "View.MemoryView":1310
+    /* "View.MemoryView":1308
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  *         src = tmp             # <<<<<<<<<<<<<<
  * 
  *     if not broadcasting:
  */
     __pyx_v_src = __pyx_v_tmp;
 
-    /* "View.MemoryView":1304
+    /* "View.MemoryView":1302
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   }
 
-  /* "View.MemoryView":1312
+  /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_broadcasting != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1315
+    /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1316
+      /* "View.MemoryView":1314
  * 
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)             # <<<<<<<<<<<<<<
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'C', __pyx_v_ndim);
 
-      /* "View.MemoryView":1315
+      /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
       goto __pyx_L12;
     }
 
-    /* "View.MemoryView":1317
+    /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1318
+      /* "View.MemoryView":1316
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)             # <<<<<<<<<<<<<<
  * 
  *         if direct_copy:
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'F', __pyx_v_ndim);
 
-      /* "View.MemoryView":1317
+      /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     }
     __pyx_L12:;
 
-    /* "View.MemoryView":1320
+    /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     __pyx_t_2 = (__pyx_v_direct_copy != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1322
+      /* "View.MemoryView":1320
  *         if direct_copy:
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-      /* "View.MemoryView":1323
+      /* "View.MemoryView":1321
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))             # <<<<<<<<<<<<<<
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  */
       (void)(memcpy(__pyx_v_dst.data, __pyx_v_src.data, __pyx_memoryview_slice_get_size((&__pyx_v_src), __pyx_v_ndim)));
 
-      /* "View.MemoryView":1324
+      /* "View.MemoryView":1322
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  *             free(tmpdata)
  *             return 0
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-      /* "View.MemoryView":1325
+      /* "View.MemoryView":1323
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)             # <<<<<<<<<<<<<<
  *             return 0
  * 
  */
       free(__pyx_v_tmpdata);
 
-      /* "View.MemoryView":1326
+      /* "View.MemoryView":1324
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  *             return 0             # <<<<<<<<<<<<<<
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):
  */
       __pyx_r = 0;
       goto __pyx_L0;
 
-      /* "View.MemoryView":1320
+      /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     }
 
-    /* "View.MemoryView":1312
+    /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1328
+  /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = (__pyx_v_order == 'F');
   if (__pyx_t_2) {
     __pyx_t_2 = ('F' == __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim));
   }
   __pyx_t_8 = (__pyx_t_2 != 0);
   if (__pyx_t_8) {
 
-    /* "View.MemoryView":1331
+    /* "View.MemoryView":1329
  * 
  * 
  *         transpose_memslice(&src)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&dst)
  * 
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1331, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1329, __pyx_L1_error)
 
-    /* "View.MemoryView":1332
+    /* "View.MemoryView":1330
  * 
  *         transpose_memslice(&src)
  *         transpose_memslice(&dst)             # <<<<<<<<<<<<<<
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1332, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1330, __pyx_L1_error)
 
-    /* "View.MemoryView":1328
+    /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1334
+  /* "View.MemoryView":1332
  *         transpose_memslice(&dst)
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1335
+  /* "View.MemoryView":1333
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)             # <<<<<<<<<<<<<<
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  */
   copy_strided_to_strided((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1336
+  /* "View.MemoryView":1334
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  *     free(tmpdata)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1338
+  /* "View.MemoryView":1336
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  *     free(tmpdata)             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
   free(__pyx_v_tmpdata);
 
-  /* "View.MemoryView":1339
+  /* "View.MemoryView":1337
  * 
  *     free(tmpdata)
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1270
+  /* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -15947,217 +15862,217 @@
     #endif
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1342
+/* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim, int __pyx_v_ndim_other) {
   int __pyx_v_i;
   int __pyx_v_offset;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
 
-  /* "View.MemoryView":1346
+  /* "View.MemoryView":1344
  *                             int ndim_other) nogil:
  *     cdef int i
  *     cdef int offset = ndim_other - ndim             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_offset = (__pyx_v_ndim_other - __pyx_v_ndim);
 
-  /* "View.MemoryView":1348
+  /* "View.MemoryView":1346
  *     cdef int offset = ndim_other - ndim
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1349
+    /* "View.MemoryView":1347
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]             # <<<<<<<<<<<<<<
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  */
     (__pyx_v_mslice->shape[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1350
+    /* "View.MemoryView":1348
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  */
     (__pyx_v_mslice->strides[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-    /* "View.MemoryView":1351
+    /* "View.MemoryView":1349
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]             # <<<<<<<<<<<<<<
  * 
  *     for i in range(offset):
  */
     (__pyx_v_mslice->suboffsets[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->suboffsets[__pyx_v_i]);
   }
 
-  /* "View.MemoryView":1353
+  /* "View.MemoryView":1351
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  *     for i in range(offset):             # <<<<<<<<<<<<<<
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  */
   __pyx_t_1 = __pyx_v_offset;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1354
+    /* "View.MemoryView":1352
  * 
  *     for i in range(offset):
  *         mslice.shape[i] = 1             # <<<<<<<<<<<<<<
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1
  */
     (__pyx_v_mslice->shape[__pyx_v_i]) = 1;
 
-    /* "View.MemoryView":1355
+    /* "View.MemoryView":1353
  *     for i in range(offset):
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_mslice->strides[__pyx_v_i]) = (__pyx_v_mslice->strides[0]);
 
-    /* "View.MemoryView":1356
+    /* "View.MemoryView":1354
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_mslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1342
+  /* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1364
+/* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
  * 
  */
 
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_dtype_is_object, int __pyx_v_ndim, int __pyx_v_inc) {
   int __pyx_t_1;
 
-  /* "View.MemoryView":1368
+  /* "View.MemoryView":1366
  * 
  * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   __pyx_t_1 = (__pyx_v_dtype_is_object != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1369
+    /* "View.MemoryView":1367
  * 
  *     if dtype_is_object:
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,             # <<<<<<<<<<<<<<
  *                                            dst.strides, ndim, inc)
  * 
  */
     __pyx_memoryview_refcount_objects_in_slice_with_gil(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_inc);
 
-    /* "View.MemoryView":1368
+    /* "View.MemoryView":1366
  * 
  * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   }
 
-  /* "View.MemoryView":1364
+  /* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
  * 
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1373
+/* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   __Pyx_RefNannyDeclarations
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("refcount_objects_in_slice_with_gil", 0);
 
-  /* "View.MemoryView":1376
+  /* "View.MemoryView":1374
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  *     refcount_objects_in_slice(data, shape, strides, ndim, inc)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  */
   __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, __pyx_v_shape, __pyx_v_strides, __pyx_v_ndim, __pyx_v_inc);
 
-  /* "View.MemoryView":1373
+  /* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
 }
 
-/* "View.MemoryView":1379
+/* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
@@ -16166,178 +16081,178 @@
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   __Pyx_RefNannySetupContext("refcount_objects_in_slice", 0);
 
-  /* "View.MemoryView":1383
+  /* "View.MemoryView":1381
  *     cdef Py_ssize_t i
  * 
  *     for i in range(shape[0]):             # <<<<<<<<<<<<<<
  *         if ndim == 1:
  *             if inc:
  */
   __pyx_t_1 = (__pyx_v_shape[0]);
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1384
+    /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
     __pyx_t_4 = ((__pyx_v_ndim == 1) != 0);
     if (__pyx_t_4) {
 
-      /* "View.MemoryView":1385
+      /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
       __pyx_t_4 = (__pyx_v_inc != 0);
       if (__pyx_t_4) {
 
-        /* "View.MemoryView":1386
+        /* "View.MemoryView":1384
  *         if ndim == 1:
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])
  */
         Py_INCREF((((PyObject **)__pyx_v_data)[0]));
 
-        /* "View.MemoryView":1385
+        /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
         goto __pyx_L6;
       }
 
-      /* "View.MemoryView":1388
+      /* "View.MemoryView":1386
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  */
       /*else*/ {
         Py_DECREF((((PyObject **)__pyx_v_data)[0]));
       }
       __pyx_L6:;
 
-      /* "View.MemoryView":1384
+      /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":1390
+    /* "View.MemoryView":1388
  *                 Py_DECREF((<PyObject **> data)[0])
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
  *                                       ndim - 1, inc)
  * 
  */
     /*else*/ {
 
-      /* "View.MemoryView":1391
+      /* "View.MemoryView":1389
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  *                                       ndim - 1, inc)             # <<<<<<<<<<<<<<
  * 
  *         data += strides[0]
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_inc);
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":1393
+    /* "View.MemoryView":1391
  *                                       ndim - 1, inc)
  * 
  *         data += strides[0]             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_data = (__pyx_v_data + (__pyx_v_strides[0]));
   }
 
-  /* "View.MemoryView":1379
+  /* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1399
+/* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item, int __pyx_v_dtype_is_object) {
 
-  /* "View.MemoryView":1402
+  /* "View.MemoryView":1400
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  *     refcount_copying(dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
  *                          itemsize, item)
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1403
+  /* "View.MemoryView":1401
  *                               bint dtype_is_object) nogil:
  *     refcount_copying(dst, dtype_is_object, ndim, False)
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,             # <<<<<<<<<<<<<<
  *                          itemsize, item)
  *     refcount_copying(dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview__slice_assign_scalar(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_itemsize, __pyx_v_item);
 
-  /* "View.MemoryView":1405
+  /* "View.MemoryView":1403
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
  *                          itemsize, item)
  *     refcount_copying(dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1399
+  /* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1409
+/* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
@@ -16346,118 +16261,118 @@
   Py_ssize_t __pyx_v_stride;
   Py_ssize_t __pyx_v_extent;
   int __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   Py_ssize_t __pyx_t_4;
 
-  /* "View.MemoryView":1413
+  /* "View.MemoryView":1411
  *                               size_t itemsize, void *item) nogil:
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t extent = shape[0]
  * 
  */
   __pyx_v_stride = (__pyx_v_strides[0]);
 
-  /* "View.MemoryView":1414
+  /* "View.MemoryView":1412
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]
  *     cdef Py_ssize_t extent = shape[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_extent = (__pyx_v_shape[0]);
 
-  /* "View.MemoryView":1416
+  /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1417
+    /* "View.MemoryView":1415
  * 
  *     if ndim == 1:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             memcpy(data, item, itemsize)
  *             data += stride
  */
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1418
+      /* "View.MemoryView":1416
  *     if ndim == 1:
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)             # <<<<<<<<<<<<<<
  *             data += stride
  *     else:
  */
       (void)(memcpy(__pyx_v_data, __pyx_v_item, __pyx_v_itemsize));
 
-      /* "View.MemoryView":1419
+      /* "View.MemoryView":1417
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  *             data += stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(extent):
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
 
-    /* "View.MemoryView":1416
+    /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1421
+  /* "View.MemoryView":1419
  *             data += stride
  *     else:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             _slice_assign_scalar(data, shape + 1, strides + 1,
  *                                 ndim - 1, itemsize, item)
  */
   /*else*/ {
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1422
+      /* "View.MemoryView":1420
  *     else:
  *         for i in range(extent):
  *             _slice_assign_scalar(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
  *                                 ndim - 1, itemsize, item)
  *             data += stride
  */
       __pyx_memoryview__slice_assign_scalar(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize, __pyx_v_item);
 
-      /* "View.MemoryView":1424
+      /* "View.MemoryView":1422
  *             _slice_assign_scalar(data, shape + 1, strides + 1,
  *                                 ndim - 1, itemsize, item)
  *             data += stride             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1409
+  /* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
@@ -16547,155 +16462,151 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum", 0);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
-  __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__20, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (__pyx_t_2 != 0);
-  if (__pyx_t_3) {
+  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xb068931) != 0);
+  if (__pyx_t_1) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  */
-    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
-    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
-    __pyx_t_4 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_1, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_INCREF(__pyx_t_1);
-    __pyx_v___pyx_PickleError = __pyx_t_1;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);
+    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_INCREF(__pyx_t_2);
+    __pyx_v___pyx_PickleError = __pyx_t_2;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
-    __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_INCREF(__pyx_v___pyx_PickleError);
-    __pyx_t_1 = __pyx_v___pyx_PickleError; __pyx_t_6 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
-      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
-      if (likely(__pyx_t_6)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-        __Pyx_INCREF(__pyx_t_6);
+    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_1, function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
-    __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_1, function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
-  __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_5, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v___pyx_type);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result = __pyx_t_4;
-  __pyx_t_4 = 0;
+  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_v___pyx_result = __pyx_t_3;
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
-  __pyx_t_3 = (__pyx_v___pyx_state != Py_None);
-  __pyx_t_2 = (__pyx_t_3 != 0);
-  if (__pyx_t_2) {
+  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);
+  __pyx_t_6 = (__pyx_t_1 != 0);
+  if (__pyx_t_6) {
 
     /* "(tree fragment)":9
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  */
-    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
-    __pyx_t_4 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 9, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
+    __pyx_t_3 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
@@ -16715,18 +16626,18 @@
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
@@ -16983,15 +16894,15 @@
   #endif
   __pyx_array_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_array = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack.array", /*tp_name*/
+  "chython.containers._unpack.array", /*tp_name*/
   sizeof(struct __pyx_array_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_array, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -17042,23 +16953,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
@@ -17105,15 +17013,15 @@
   {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, METH_NOARGS, 0},
   {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type___pyx_MemviewEnum = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack.Enum", /*tp_name*/
+  "chython.containers._unpack.Enum", /*tp_name*/
   sizeof(struct __pyx_MemviewEnum_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_Enum, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -17164,23 +17072,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
@@ -17369,15 +17274,15 @@
   #endif
   __pyx_memoryview_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_memoryview = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack.memoryview", /*tp_name*/
+  "chython.containers._unpack.memoryview", /*tp_name*/
   sizeof(struct __pyx_memoryview_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_memoryview, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -17428,23 +17333,20 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
   PyObject *o = __pyx_tp_new_memoryview(t, a, k);
   if (unlikely(!o)) return 0;
@@ -17510,15 +17412,15 @@
 static struct PyGetSetDef __pyx_getsets__memoryviewslice[] = {
   {(char *)"base", __pyx_getprop___pyx_memoryviewslice_base, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type___pyx_memoryviewslice = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack._memoryviewslice", /*tp_name*/
+  "chython.containers._unpack._memoryviewslice", /*tp_name*/
   sizeof(struct __pyx_memoryviewslice_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc__memoryviewslice, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -17577,43 +17479,40 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec__cpack(PyObject* module); /*proto*/
+static int __pyx_pymod_exec__unpack(PyObject* module); /*proto*/
 static PyModuleDef_Slot __pyx_moduledef_slots[] = {
   {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec__cpack},
+  {Py_mod_exec, (void*)__pyx_pymod_exec__unpack},
   {0, NULL}
 };
 #endif
 
 static struct PyModuleDef __pyx_moduledef = {
     PyModuleDef_HEAD_INIT,
-    "_cpack",
+    "_unpack",
     0, /* m_doc */
   #if CYTHON_PEP489_MULTI_PHASE_INIT
     0, /* m_size */
   #else
     -1, /* m_size */
   #endif
     __pyx_methods /* m_methods */,
@@ -17636,25 +17535,23 @@
     #define CYTHON_SMALL_CODE
 #endif
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
   {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
   {&__pyx_n_s_Bond, __pyx_k_Bond, sizeof(__pyx_k_Bond), 0, 0, 1, 1},
-  {&__pyx_n_s_Bond__m, __pyx_k_Bond__m, sizeof(__pyx_k_Bond__m), 0, 0, 1, 1},
-  {&__pyx_n_s_Bond__n, __pyx_k_Bond__n, sizeof(__pyx_k_Bond__n), 0, 0, 1, 1},
   {&__pyx_n_s_Bond__order, __pyx_k_Bond__order, sizeof(__pyx_k_Bond__order), 0, 0, 1, 1},
   {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
   {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
   {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
   {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
-  {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
+  {&__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_k_Incompatible_checksums_s_vs_0xb0, sizeof(__pyx_k_Incompatible_checksums_s_vs_0xb0), 0, 0, 1, 0},
   {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
   {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_k_Invalid_shape_in_axis_d_d, sizeof(__pyx_k_Invalid_shape_in_axis_d_d), 0, 0, 1, 0},
   {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
   {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
   {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
@@ -17662,36 +17559,35 @@
   {&__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_k_Out_of_bounds_on_buffer_access_a, sizeof(__pyx_k_Out_of_bounds_on_buffer_access_a), 0, 0, 1, 0},
   {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
   {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
   {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
   {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
   {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
   {&__pyx_n_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 1},
+  {&__pyx_n_s_all_sign, __pyx_k_all_sign, sizeof(__pyx_k_all_sign), 0, 0, 1, 1},
   {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
-  {&__pyx_n_s_atoms, __pyx_k_atoms, sizeof(__pyx_k_atoms), 0, 0, 1, 1},
-  {&__pyx_n_s_atoms_count, __pyx_k_atoms_count, sizeof(__pyx_k_atoms_count), 0, 0, 1, 1},
+  {&__pyx_n_s_atom, __pyx_k_atom, sizeof(__pyx_k_atom), 0, 0, 1, 1},
   {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
   {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
   {&__pyx_n_s_bond, __pyx_k_bond, sizeof(__pyx_k_bond), 0, 0, 1, 1},
-  {&__pyx_n_s_bond_shift, __pyx_k_bond_shift, sizeof(__pyx_k_bond_shift), 0, 0, 1, 1},
   {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
   {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
   {&__pyx_n_s_charges, __pyx_k_charges, sizeof(__pyx_k_charges), 0, 0, 1, 1},
-  {&__pyx_n_s_chython_containers__cpack, __pyx_k_chython_containers__cpack, sizeof(__pyx_k_chython_containers__cpack), 0, 0, 1, 1},
-  {&__pyx_kp_s_chython_containers__cpack_pyx, __pyx_k_chython_containers__cpack_pyx, sizeof(__pyx_k_chython_containers__cpack_pyx), 0, 0, 1, 0},
+  {&__pyx_n_s_chython_containers__unpack, __pyx_k_chython_containers__unpack, sizeof(__pyx_k_chython_containers__unpack), 0, 0, 1, 1},
+  {&__pyx_kp_s_chython_containers__unpack_pyx, __pyx_k_chython_containers__unpack_pyx, sizeof(__pyx_k_chython_containers__unpack_pyx), 0, 0, 1, 0},
   {&__pyx_n_s_chython_containers_bonds, __pyx_k_chython_containers_bonds, sizeof(__pyx_k_chython_containers_bonds), 0, 0, 1, 1},
+  {&__pyx_n_s_cis_trans_1, __pyx_k_cis_trans_1, sizeof(__pyx_k_cis_trans_1), 0, 0, 1, 1},
+  {&__pyx_n_s_cis_trans_2, __pyx_k_cis_trans_2, sizeof(__pyx_k_cis_trans_2), 0, 0, 1, 1},
   {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
   {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
   {&__pyx_n_s_connections, __pyx_k_connections, sizeof(__pyx_k_connections), 0, 0, 1, 1},
   {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
   {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
-  {&__pyx_n_s_ct_count, __pyx_k_ct_count, sizeof(__pyx_k_ct_count), 0, 0, 1, 1},
-  {&__pyx_n_s_ct_shift, __pyx_k_ct_shift, sizeof(__pyx_k_ct_shift), 0, 0, 1, 1},
   {&__pyx_n_s_ct_sign, __pyx_k_ct_sign, sizeof(__pyx_k_ct_sign), 0, 0, 1, 1},
-  {&__pyx_n_s_ct_stereo, __pyx_k_ct_stereo, sizeof(__pyx_k_ct_stereo), 0, 0, 1, 1},
+  {&__pyx_n_s_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 0, 1, 1},
   {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
   {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
   {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
   {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
   {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
   {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
   {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
@@ -17700,49 +17596,54 @@
   {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
   {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
   {&__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 0, 1, 0},
   {&__pyx_n_s_hydrogens, __pyx_k_hydrogens, sizeof(__pyx_k_hydrogens), 0, 0, 1, 1},
   {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
   {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
   {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-  {&__pyx_n_s_is_chiral, __pyx_k_is_chiral, sizeof(__pyx_k_is_chiral), 0, 0, 1, 1},
+  {&__pyx_n_s_is_all, __pyx_k_is_all, sizeof(__pyx_k_is_all), 0, 0, 1, 1},
+  {&__pyx_n_s_is_tet, __pyx_k_is_tet, sizeof(__pyx_k_is_tet), 0, 0, 1, 1},
+  {&__pyx_n_s_isotope_shift, __pyx_k_isotope_shift, sizeof(__pyx_k_isotope_shift), 0, 0, 1, 1},
+  {&__pyx_n_s_isotopes, __pyx_k_isotopes, sizeof(__pyx_k_isotopes), 0, 0, 1, 1},
   {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
   {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
+  {&__pyx_n_s_j, __pyx_k_j, sizeof(__pyx_k_j), 0, 0, 1, 1},
   {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
+  {&__pyx_n_s_mapping, __pyx_k_mapping, sizeof(__pyx_k_mapping), 0, 0, 1, 1},
   {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
   {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
   {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
+  {&__pyx_n_s_na, __pyx_k_na, sizeof(__pyx_k_na), 0, 0, 1, 1},
   {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
   {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
+  {&__pyx_n_s_nb, __pyx_k_nb, sizeof(__pyx_k_nb), 0, 0, 1, 1},
+  {&__pyx_n_s_nct, __pyx_k_nct, sizeof(__pyx_k_nct), 0, 0, 1, 1},
   {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
   {&__pyx_n_s_neighbors, __pyx_k_neighbors, sizeof(__pyx_k_neighbors), 0, 0, 1, 1},
   {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
   {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
   {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
   {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
+  {&__pyx_n_s_order_shift, __pyx_k_order_shift, sizeof(__pyx_k_order_shift), 0, 0, 1, 1},
   {&__pyx_n_s_orders, __pyx_k_orders, sizeof(__pyx_k_orders), 0, 0, 1, 1},
   {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
+  {&__pyx_n_s_pack_length, __pyx_k_pack_length, sizeof(__pyx_k_pack_length), 0, 0, 1, 1},
   {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
   {&__pyx_n_s_py_allenes_stereo, __pyx_k_py_allenes_stereo, sizeof(__pyx_k_py_allenes_stereo), 0, 0, 1, 1},
   {&__pyx_n_s_py_atoms, __pyx_k_py_atoms, sizeof(__pyx_k_py_atoms), 0, 0, 1, 1},
   {&__pyx_n_s_py_atoms_stereo, __pyx_k_py_atoms_stereo, sizeof(__pyx_k_py_atoms_stereo), 0, 0, 1, 1},
   {&__pyx_n_s_py_bonds, __pyx_k_py_bonds, sizeof(__pyx_k_py_bonds), 0, 0, 1, 1},
-  {&__pyx_n_s_py_bonds_flat, __pyx_k_py_bonds_flat, sizeof(__pyx_k_py_bonds_flat), 0, 0, 1, 1},
   {&__pyx_n_s_py_charges, __pyx_k_py_charges, sizeof(__pyx_k_py_charges), 0, 0, 1, 1},
   {&__pyx_n_s_py_cis_trans_stereo, __pyx_k_py_cis_trans_stereo, sizeof(__pyx_k_py_cis_trans_stereo), 0, 0, 1, 1},
   {&__pyx_n_s_py_hydrogens, __pyx_k_py_hydrogens, sizeof(__pyx_k_py_hydrogens), 0, 0, 1, 1},
   {&__pyx_n_s_py_isotopes, __pyx_k_py_isotopes, sizeof(__pyx_k_py_isotopes), 0, 0, 1, 1},
-  {&__pyx_n_s_py_m, __pyx_k_py_m, sizeof(__pyx_k_py_m), 0, 0, 1, 1},
   {&__pyx_n_s_py_mapping, __pyx_k_py_mapping, sizeof(__pyx_k_py_mapping), 0, 0, 1, 1},
-  {&__pyx_n_s_py_n, __pyx_k_py_n, sizeof(__pyx_k_py_n), 0, 0, 1, 1},
-  {&__pyx_n_s_py_ngb, __pyx_k_py_ngb, sizeof(__pyx_k_py_ngb), 0, 0, 1, 1},
   {&__pyx_n_s_py_plane, __pyx_k_py_plane, sizeof(__pyx_k_py_plane), 0, 0, 1, 1},
   {&__pyx_n_s_py_radicals, __pyx_k_py_radicals, sizeof(__pyx_k_py_radicals), 0, 0, 1, 1},
-  {&__pyx_n_s_py_xy, __pyx_k_py_xy, sizeof(__pyx_k_py_xy), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_getbuffer, __pyx_k_pyx_getbuffer, sizeof(__pyx_k_pyx_getbuffer), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
@@ -17756,343 +17657,329 @@
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
   {&__pyx_n_s_shift, __pyx_k_shift, sizeof(__pyx_k_shift), 0, 0, 1, 1},
   {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
   {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
   {&__pyx_n_s_step, __pyx_k_step, sizeof(__pyx_k_step), 0, 0, 1, 1},
-  {&__pyx_n_s_stereo_sign, __pyx_k_stereo_sign, sizeof(__pyx_k_stereo_sign), 0, 0, 1, 1},
   {&__pyx_n_s_stop, __pyx_k_stop, sizeof(__pyx_k_stop), 0, 0, 1, 1},
   {&__pyx_kp_s_strided_and_direct, __pyx_k_strided_and_direct, sizeof(__pyx_k_strided_and_direct), 0, 0, 1, 0},
   {&__pyx_kp_s_strided_and_direct_or_indirect, __pyx_k_strided_and_direct_or_indirect, sizeof(__pyx_k_strided_and_direct_or_indirect), 0, 0, 1, 0},
   {&__pyx_kp_s_strided_and_indirect, __pyx_k_strided_and_indirect, sizeof(__pyx_k_strided_and_indirect), 0, 0, 1, 0},
   {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
   {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
   {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+  {&__pyx_n_s_tet_sign, __pyx_k_tet_sign, sizeof(__pyx_k_tet_sign), 0, 0, 1, 1},
+  {&__pyx_n_s_tmp, __pyx_k_tmp, sizeof(__pyx_k_tmp), 0, 0, 1, 1},
   {&__pyx_kp_s_unable_to_allocate_array_data, __pyx_k_unable_to_allocate_array_data, sizeof(__pyx_k_unable_to_allocate_array_data), 0, 0, 1, 0},
   {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
   {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
+  {&__pyx_n_s_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 0, 1, 1},
+  {&__pyx_n_s_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 81, __pyx_L1_error)
-  __pyx_builtin_object = __Pyx_GetBuiltinName(__pyx_n_s_object); if (!__pyx_builtin_object) __PYX_ERR(0, 181, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 134, __pyx_L1_error)
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 149, __pyx_L1_error)
-  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 152, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 47, __pyx_L1_error)
+  __pyx_builtin_object = __Pyx_GetBuiltinName(__pyx_n_s_object); if (!__pyx_builtin_object) __PYX_ERR(0, 152, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 133, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 148, __pyx_L1_error)
+  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 151, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 406, __pyx_L1_error)
-  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 615, __pyx_L1_error)
-  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 834, __pyx_L1_error)
+  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 404, __pyx_L1_error)
+  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 613, __pyx_L1_error)
+  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 832, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "chython/containers/_cpack.pyx":148
- *     py_bonds = {}
- *     py_bonds_flat = []
- *     py_xy = (0., 0.)             # <<<<<<<<<<<<<<
- * 
- *     for n in range(atoms_count):
- */
-  __pyx_tuple_ = PyTuple_Pack(2, __pyx_float_0_, __pyx_float_0_); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 148, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple_);
-  __Pyx_GIVEREF(__pyx_tuple_);
-
-  /* "View.MemoryView":134
+  /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 134, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 133, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple_);
+  __Pyx_GIVEREF(__pyx_tuple_);
 
-  /* "View.MemoryView":137
+  /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 136, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* "View.MemoryView":149
+  /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 149, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 148, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
 
-  /* "View.MemoryView":177
+  /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 177, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 176, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__4);
+  __Pyx_GIVEREF(__pyx_tuple__4);
 
-  /* "View.MemoryView":193
+  /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 193, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__7);
-  __Pyx_GIVEREF(__pyx_tuple__7);
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
 
-  /* "View.MemoryView":420
+  /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 420, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 418, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__8);
+  __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "View.MemoryView":497
+  /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 497, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 495, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "View.MemoryView":522
+  /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 522, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 520, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__10);
+  __Pyx_GIVEREF(__pyx_tuple__10);
 
-  /* "View.MemoryView":572
+  /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 572, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__12);
-  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 570, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__11);
+  __Pyx_GIVEREF(__pyx_tuple__11);
 
-  /* "View.MemoryView":579
+  /* "View.MemoryView":577
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
-  __pyx_tuple__13 = PyTuple_New(1); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 579, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
+  __pyx_tuple__12 = PyTuple_New(1); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 577, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_INCREF(__pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_int_neg_1);
-  PyTuple_SET_ITEM(__pyx_tuple__13, 0, __pyx_int_neg_1);
-  __Pyx_GIVEREF(__pyx_tuple__13);
+  PyTuple_SET_ITEM(__pyx_tuple__12, 0, __pyx_int_neg_1);
+  __Pyx_GIVEREF(__pyx_tuple__12);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__13);
+  __Pyx_GIVEREF(__pyx_tuple__13);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
+  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
 
-  /* "View.MemoryView":684
+  /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-  __pyx_slice__16 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__16)) __PYX_ERR(1, 684, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__16);
-  __Pyx_GIVEREF(__pyx_slice__16);
+  __pyx_slice__15 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__15)) __PYX_ERR(1, 682, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__15);
+  __Pyx_GIVEREF(__pyx_slice__15);
 
-  /* "View.MemoryView":705
+  /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 705, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
+  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 703, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
-  __pyx_tuple__20 = PyTuple_Pack(3, __pyx_int_184977713, __pyx_int_136983863, __pyx_int_112105877); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__20);
-  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
 
-  /* "chython/containers/_cpack.pyx":52
- * @cython.cdivision(True)
- * @cython.wraparound(False)
+  /* "chython/containers/_unpack.pyx":25
+ * 
+ * @cython.boundscheck(False)
  * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
- *     cdef char *charges
- *     cdef unsigned char *atoms, *hydrogens, *radicals, *is_chiral, *neighbors, **orders, *seen
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
  */
-  __pyx_tuple__21 = PyTuple_Pack(42, __pyx_n_s_data, __pyx_n_s_data, __pyx_n_s_charges, __pyx_n_s_atoms, __pyx_n_s_hydrogens, __pyx_n_s_radicals, __pyx_n_s_is_chiral, __pyx_n_s_neighbors, __pyx_n_s_orders, __pyx_n_s_seen, __pyx_n_s_connections, __pyx_n_s_ct_stereo, __pyx_n_s_stereo_sign, __pyx_n_s_ct_sign, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_i, __pyx_n_s_size, __pyx_n_s_shift, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_bond_shift, __pyx_n_s_atoms_count, __pyx_n_s_ct_count, __pyx_n_s_ct_shift, __pyx_n_s_py_xy, __pyx_n_s_bond, __pyx_n_s_py_n, __pyx_n_s_py_m, __pyx_n_s_py_mapping, __pyx_n_s_py_atoms, __pyx_n_s_py_isotopes, __pyx_n_s_py_bonds_flat, __pyx_n_s_py_charges, __pyx_n_s_py_radicals, __pyx_n_s_py_hydrogens, __pyx_n_s_py_plane, __pyx_n_s_py_bonds, __pyx_n_s_py_ngb, __pyx_n_s_py_atoms_stereo, __pyx_n_s_py_allenes_stereo, __pyx_n_s_py_cis_trans_stereo); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 52, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(1, 0, 42, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_containers__cpack_pyx, __pyx_n_s_unpack, 52, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) __PYX_ERR(0, 52, __pyx_L1_error)
+  __pyx_tuple__19 = PyTuple_Pack(49, __pyx_n_s_data, __pyx_n_s_data, __pyx_n_s_isotope_shift, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_c, __pyx_n_s_d, __pyx_n_s_na, __pyx_n_s_nct, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_pack_length, __pyx_n_s_shift, __pyx_n_s_order_shift, __pyx_n_s_nb, __pyx_n_s_mapping, __pyx_n_s_atom, __pyx_n_s_isotopes, __pyx_n_s_hydrogens, __pyx_n_s_neighbors, __pyx_n_s_orders, __pyx_n_s_cis_trans_1, __pyx_n_s_cis_trans_2, __pyx_n_s_connections, __pyx_n_s_charges, __pyx_n_s_radicals, __pyx_n_s_is_tet, __pyx_n_s_is_all, __pyx_n_s_tet_sign, __pyx_n_s_all_sign, __pyx_n_s_ct_sign, __pyx_n_s_x, __pyx_n_s_y, __pyx_n_s_seen, __pyx_n_s_bond, __pyx_n_s_py_charges, __pyx_n_s_py_radicals, __pyx_n_s_py_hydrogens, __pyx_n_s_py_plane, __pyx_n_s_py_bonds, __pyx_n_s_tmp, __pyx_n_s_py_atoms_stereo, __pyx_n_s_py_allenes_stereo, __pyx_n_s_py_cis_trans_stereo, __pyx_n_s_py_mapping, __pyx_n_s_py_atoms, __pyx_n_s_py_isotopes); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 25, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__19);
+  __Pyx_GIVEREF(__pyx_tuple__19);
+  __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(1, 0, 49, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_containers__unpack_pyx, __pyx_n_s_unpack, 25, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) __PYX_ERR(0, 25, __pyx_L1_error)
 
-  /* "View.MemoryView":287
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 287, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__23);
-  __Pyx_GIVEREF(__pyx_tuple__23);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
-  /* "View.MemoryView":288
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 288, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__24);
-  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
 
-  /* "View.MemoryView":289
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 289, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
 
-  /* "View.MemoryView":292
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 292, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
 
-  /* "View.MemoryView":293
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(1, 293, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__28 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__28);
-  __Pyx_GIVEREF(__pyx_tuple__28);
-  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__26 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_float_0_ = PyFloat_FromDouble(0.); if (unlikely(!__pyx_float_0_)) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
@@ -18138,62 +18025,62 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
-  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_array.tp_print = 0;
   #endif
-  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
   __pyx_array_type = &__pyx_type___pyx_array;
-  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 280, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_MemviewEnum.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_MemviewEnum.tp_dictoffset && __pyx_type___pyx_MemviewEnum.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_MemviewEnum.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 280, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
   __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
   __pyx_vtabptr_memoryview = &__pyx_vtable_memoryview;
   __pyx_vtable_memoryview.get_item_pointer = (char *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_get_item_pointer;
   __pyx_vtable_memoryview.is_slice = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_is_slice;
   __pyx_vtable_memoryview.setitem_slice_assignment = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_slice_assignment;
   __pyx_vtable_memoryview.setitem_slice_assign_scalar = (PyObject *(*)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_setitem_slice_assign_scalar;
   __pyx_vtable_memoryview.setitem_indexed = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_indexed;
   __pyx_vtable_memoryview.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryview_convert_item_to_object;
   __pyx_vtable_memoryview.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryview_assign_item_from_object;
-  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 331, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_memoryview.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryview.tp_dictoffset && __pyx_type___pyx_memoryview.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_memoryview.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 331, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 331, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
   __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
   __pyx_vtabptr__memoryviewslice = &__pyx_vtable__memoryviewslice;
   __pyx_vtable__memoryviewslice.__pyx_base = *__pyx_vtabptr_memoryview;
   __pyx_vtable__memoryviewslice.__pyx_base.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryviewslice_convert_item_to_object;
   __pyx_vtable__memoryviewslice.__pyx_base.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryviewslice_assign_item_from_object;
   __pyx_type___pyx_memoryviewslice.tp_base = __pyx_memoryview_type;
-  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 967, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_memoryviewslice.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryviewslice.tp_dictoffset && __pyx_type___pyx_memoryviewslice.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_memoryviewslice.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 967, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 967, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
   __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
@@ -18237,19 +18124,19 @@
 #else
 #define __Pyx_PyMODINIT_FUNC PyObject *
 #endif
 #endif
 
 
 #if PY_MAJOR_VERSION < 3
-__Pyx_PyMODINIT_FUNC init_cpack(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC init_cpack(void)
+__Pyx_PyMODINIT_FUNC init_unpack(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC init_unpack(void)
 #else
-__Pyx_PyMODINIT_FUNC PyInit__cpack(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC PyInit__cpack(void)
+__Pyx_PyMODINIT_FUNC PyInit__unpack(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit__unpack(void)
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 {
   return PyModuleDef_Init(&__pyx_moduledef);
 }
 static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
     #if PY_VERSION_HEX >= 0x030700A1
     static PY_INT64_T main_interpreter_id = -1;
@@ -18308,44 +18195,45 @@
     return module;
 bad:
     Py_XDECREF(module);
     return NULL;
 }
 
 
-static CYTHON_SMALL_CODE int __pyx_pymod_exec__cpack(PyObject *__pyx_pyinit_module)
+static CYTHON_SMALL_CODE int __pyx_pymod_exec__unpack(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
-  static PyThread_type_lock __pyx_t_3[8];
+  static int __pyx_t_3[119];
+  static PyThread_type_lock __pyx_t_4[8];
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   if (__pyx_m) {
     if (__pyx_m == __pyx_pyinit_module) return 0;
-    PyErr_SetString(PyExc_RuntimeError, "Module '_cpack' has already been imported. Re-initialisation is not supported.");
+    PyErr_SetString(PyExc_RuntimeError, "Module '_unpack' has already been imported. Re-initialisation is not supported.");
     return -1;
   }
   #elif PY_MAJOR_VERSION >= 3
   if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
   #if CYTHON_REFNANNY
 __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
 if (!__Pyx_RefNanny) {
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
-  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__cpack(void)", 0);
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__unpack(void)", 0);
   if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -18374,40 +18262,40 @@
   #endif
   /*--- Module creation code ---*/
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   __pyx_m = __pyx_pyinit_module;
   Py_INCREF(__pyx_m);
   #else
   #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("_cpack", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  __pyx_m = Py_InitModule4("_unpack", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
   #else
   __pyx_m = PyModule_Create(&__pyx_moduledef);
   #endif
   if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
   Py_INCREF(__pyx_d);
   __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
   Py_INCREF(__pyx_b);
   __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
   Py_INCREF(__pyx_cython_runtime);
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_chython__containers___cpack) {
+  if (__pyx_module_is_main_chython__containers___unpack) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "chython.containers._cpack")) {
-      if (unlikely(PyDict_SetItemString(modules, "chython.containers._cpack", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "chython.containers._unpack")) {
+      if (unlikely(PyDict_SetItemString(modules, "chython.containers._unpack", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -18420,189 +18308,321 @@
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
-  /* "chython/containers/_cpack.pyx":23
- * from cpython.mem cimport PyMem_Malloc, PyMem_Free
- * 
+  /* "chython/containers/_unpack.pyx":21
+ * cimport cython
+ * from libc.math cimport ldexp
  * from chython.containers.bonds import Bond             # <<<<<<<<<<<<<<
  * 
- * # Format specification::
+ * 
  */
-  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 23, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_Bond);
   __Pyx_GIVEREF(__pyx_n_s_Bond);
   PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Bond);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_chython_containers_bonds, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 23, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_chython_containers_bonds, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Bond); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 23, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Bond); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Bond, __pyx_t_1) < 0) __PYX_ERR(0, 23, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Bond, __pyx_t_1) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "chython/containers/_cpack.pyx":52
- * @cython.cdivision(True)
- * @cython.wraparound(False)
+  /* "chython/containers/_unpack.pyx":25
+ * 
+ * @cython.boundscheck(False)
  * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
- *     cdef char *charges
- *     cdef unsigned char *atoms, *hydrogens, *radicals, *is_chiral, *neighbors, **orders, *seen
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_7chython_10containers_6_cpack_1unpack, NULL, __pyx_n_s_chython_containers__cpack); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 52, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_7chython_10containers_7_unpack_1unpack, NULL, __pyx_n_s_chython_containers__unpack); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 25, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unpack, __pyx_t_2) < 0) __PYX_ERR(0, 52, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unpack, __pyx_t_2) < 0) __PYX_ERR(0, 25, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "chython/containers/_cpack.pyx":1
+  /* "chython/containers/_unpack.pyx":168
+ * 
+ * cdef int[119] common_isotopes
+ * common_isotopes[:] = [0, -15, -12, -9, -7, -5, -4, -2, 0, 3, 4, 7, 8, 11, 12, 15, 16, 19, 24, 23, 24, 29,             # <<<<<<<<<<<<<<
+ *                       32, 35, 36, 39, 40, 43, 43, 48, 49, 54, 57, 59, 63, 64, 68, 69, 72, 73, 75, 77,
+ *                       80, 82, 85, 87, 90, 92, 96, 99, 103, 106, 112, 111, 115, 117, 121, 123, 124, 125,
+ */
+  __pyx_t_3[0] = 0;
+  __pyx_t_3[1] = -15;
+  __pyx_t_3[2] = -12;
+  __pyx_t_3[3] = -9;
+  __pyx_t_3[4] = -7;
+  __pyx_t_3[5] = -5;
+  __pyx_t_3[6] = -4;
+  __pyx_t_3[7] = -2;
+  __pyx_t_3[8] = 0;
+  __pyx_t_3[9] = 3;
+  __pyx_t_3[10] = 4;
+  __pyx_t_3[11] = 7;
+  __pyx_t_3[12] = 8;
+  __pyx_t_3[13] = 11;
+  __pyx_t_3[14] = 12;
+  __pyx_t_3[15] = 15;
+  __pyx_t_3[16] = 16;
+  __pyx_t_3[17] = 19;
+  __pyx_t_3[18] = 24;
+  __pyx_t_3[19] = 23;
+  __pyx_t_3[20] = 24;
+  __pyx_t_3[21] = 29;
+  __pyx_t_3[22] = 32;
+  __pyx_t_3[23] = 35;
+  __pyx_t_3[24] = 36;
+  __pyx_t_3[25] = 39;
+  __pyx_t_3[26] = 40;
+  __pyx_t_3[27] = 43;
+  __pyx_t_3[28] = 43;
+  __pyx_t_3[29] = 48;
+  __pyx_t_3[30] = 49;
+  __pyx_t_3[31] = 54;
+  __pyx_t_3[32] = 57;
+  __pyx_t_3[33] = 59;
+  __pyx_t_3[34] = 63;
+  __pyx_t_3[35] = 64;
+  __pyx_t_3[36] = 68;
+  __pyx_t_3[37] = 69;
+  __pyx_t_3[38] = 72;
+  __pyx_t_3[39] = 73;
+  __pyx_t_3[40] = 75;
+  __pyx_t_3[41] = 77;
+  __pyx_t_3[42] = 80;
+  __pyx_t_3[43] = 82;
+  __pyx_t_3[44] = 85;
+  __pyx_t_3[45] = 87;
+  __pyx_t_3[46] = 90;
+  __pyx_t_3[47] = 92;
+  __pyx_t_3[48] = 96;
+  __pyx_t_3[49] = 99;
+  __pyx_t_3[50] = 0x67;
+  __pyx_t_3[51] = 0x6A;
+  __pyx_t_3[52] = 0x70;
+  __pyx_t_3[53] = 0x6F;
+  __pyx_t_3[54] = 0x73;
+  __pyx_t_3[55] = 0x75;
+  __pyx_t_3[56] = 0x79;
+  __pyx_t_3[57] = 0x7B;
+  __pyx_t_3[58] = 0x7C;
+  __pyx_t_3[59] = 0x7D;
+  __pyx_t_3[60] = 0x80;
+  __pyx_t_3[61] = 0x81;
+  __pyx_t_3[62] = 0x86;
+  __pyx_t_3[63] = 0x88;
+  __pyx_t_3[64] = 0x8D;
+  __pyx_t_3[65] = 0x8F;
+  __pyx_t_3[66] = 0x93;
+  __pyx_t_3[67] = 0x95;
+  __pyx_t_3[68] = 0x97;
+  __pyx_t_3[69] = 0x99;
+  __pyx_t_3[70] = 0x9D;
+  __pyx_t_3[71] = 0x9F;
+  __pyx_t_3[72] = 0xA2;
+  __pyx_t_3[73] = 0xA5;
+  __pyx_t_3[74] = 0xA8;
+  __pyx_t_3[75] = 0xAA;
+  __pyx_t_3[76] = 0xAE;
+  __pyx_t_3[77] = 0xB0;
+  __pyx_t_3[78] = 0xB3;
+  __pyx_t_3[79] = 0xB5;
+  __pyx_t_3[80] = 0xB9;
+  __pyx_t_3[81] = 0xBC;
+  __pyx_t_3[82] = 0xBF;
+  __pyx_t_3[83] = 0xC1;
+  __pyx_t_3[84] = 0xC1;
+  __pyx_t_3[85] = 0xC2;
+  __pyx_t_3[86] = 0xCE;
+  __pyx_t_3[87] = 0xCF;
+  __pyx_t_3[88] = 0xD2;
+  __pyx_t_3[89] = 0xD3;
+  __pyx_t_3[90] = 0xD8;
+  __pyx_t_3[91] = 0xD7;
+  __pyx_t_3[92] = 0xDE;
+  __pyx_t_3[93] = 0xDD;
+  __pyx_t_3[94] = 0xE4;
+  __pyx_t_3[95] = 0xE3;
+  __pyx_t_3[96] = 0xE7;
+  __pyx_t_3[97] = 0xE7;
+  __pyx_t_3[98] = 0xEB;
+  __pyx_t_3[99] = 0xEC;
+  __pyx_t_3[100] = 0xF1;
+  __pyx_t_3[101] = 0xF2;
+  __pyx_t_3[102] = 0xF3;
+  __pyx_t_3[103] = 0xF4;
+  __pyx_t_3[104] = 0xF5;
+  __pyx_t_3[105] = 0xFE;
+  __pyx_t_3[106] = 0xFD;
+  __pyx_t_3[107] = 0xFE;
+  __pyx_t_3[108] = 0xFE;
+  __pyx_t_3[109] = 0x106;
+  __pyx_t_3[110] = 0x109;
+  __pyx_t_3[111] = 0x109;
+  __pyx_t_3[112] = 0x10D;
+  __pyx_t_3[113] = 0x106;
+  __pyx_t_3[114] = 0x111;
+  __pyx_t_3[115] = 0x111;
+  __pyx_t_3[116] = 0x115;
+  __pyx_t_3[117] = 0x119;
+  __pyx_t_3[118] = 0x116;
+  if (unlikely((0x77) != (119))) {
+    PyErr_Format(PyExc_ValueError, "Assignment to slice of wrong length, expected %" CYTHON_FORMAT_SSIZE_T "d, got %" CYTHON_FORMAT_SSIZE_T "d", (Py_ssize_t)(119), (Py_ssize_t)(0x77));
+    __PYX_ERR(0, 168, __pyx_L1_error)
+  }
+  memcpy(&(__pyx_v_7chython_10containers_7_unpack_common_isotopes[0]), __pyx_t_3, sizeof(__pyx_v_7chython_10containers_7_unpack_common_isotopes[0]) * (119));
+
+  /* "chython/containers/_unpack.pyx":1
  * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
- * # cython: language_level=3
  * #
+ * #  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
  */
   __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":210
+  /* "View.MemoryView":209
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(array self):
  */
-  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 210, __pyx_L1_error)
+  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 209, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 210, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 209, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_array_type);
 
-  /* "View.MemoryView":287
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 286, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":288
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":289
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 289, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":292
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":293
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 293, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":317
+  /* "View.MemoryView":316
  * 
  * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0             # <<<<<<<<<<<<<<
  * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [
  *     PyThread_allocate_lock(),
  */
   __pyx_memoryview_thread_locks_used = 0;
 
-  /* "View.MemoryView":318
+  /* "View.MemoryView":317
  * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0
  * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [             # <<<<<<<<<<<<<<
  *     PyThread_allocate_lock(),
  *     PyThread_allocate_lock(),
  */
-  __pyx_t_3[0] = PyThread_allocate_lock();
-  __pyx_t_3[1] = PyThread_allocate_lock();
-  __pyx_t_3[2] = PyThread_allocate_lock();
-  __pyx_t_3[3] = PyThread_allocate_lock();
-  __pyx_t_3[4] = PyThread_allocate_lock();
-  __pyx_t_3[5] = PyThread_allocate_lock();
-  __pyx_t_3[6] = PyThread_allocate_lock();
-  __pyx_t_3[7] = PyThread_allocate_lock();
-  memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_3, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
+  __pyx_t_4[0] = PyThread_allocate_lock();
+  __pyx_t_4[1] = PyThread_allocate_lock();
+  __pyx_t_4[2] = PyThread_allocate_lock();
+  __pyx_t_4[3] = PyThread_allocate_lock();
+  __pyx_t_4[4] = PyThread_allocate_lock();
+  __pyx_t_4[5] = PyThread_allocate_lock();
+  __pyx_t_4[6] = PyThread_allocate_lock();
+  __pyx_t_4[7] = PyThread_allocate_lock();
+  memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_4, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
 
-  /* "View.MemoryView":551
+  /* "View.MemoryView":549
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 551, __pyx_L1_error)
+  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 549, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 551, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 549, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_memoryview_type);
 
-  /* "View.MemoryView":997
+  /* "View.MemoryView":995
  *         return self.from_object
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 997, __pyx_L1_error)
+  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 995, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 997, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 995, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_memoryviewslice_type);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
@@ -18624,19 +18644,19 @@
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   if (__pyx_m) {
     if (__pyx_d) {
-      __Pyx_AddTraceback("init chython.containers._cpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      __Pyx_AddTraceback("init chython.containers._unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
     Py_CLEAR(__pyx_m);
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init chython.containers._cpack");
+    PyErr_SetString(PyExc_ImportError, "init chython.containers._unpack");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
@@ -18687,14 +18707,29 @@
 #else
             "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
     }
     return result;
 }
 
+/* None */
+static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
+    long q = a / b;
+    long r = a - q*b;
+    q -= ((r != 0) & ((r ^ b) < 0));
+    return q;
+}
+
+/* None */
+static CYTHON_INLINE long __Pyx_mod_long(long a, long b) {
+    long r = a % b;
+    r += ((r != 0) & ((r ^ b) < 0)) * b;
+    return r;
+}
+
 /* DictGetItem */
 #if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
 static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
     PyObject *value;
     value = PyDict_GetItemWithError(d, key);
     if (unlikely(!value)) {
         if (!PyErr_Occurred()) {
@@ -18798,43 +18833,14 @@
     if (is_list || PySequence_Check(o)) {
         return PySequence_GetItem(o, i);
     }
 #endif
     return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
 }
 
-/* ObjectGetItem */
-#if CYTHON_USE_TYPE_SLOTS
-static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
-    PyObject *runerr = NULL;
-    Py_ssize_t key_value;
-    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
-    if (unlikely(!(m && m->sq_item))) {
-        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
-        return NULL;
-    }
-    key_value = __Pyx_PyIndex_AsSsize_t(index);
-    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
-        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
-    }
-    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
-        PyErr_Clear();
-        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
-    }
-    return NULL;
-}
-static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
-    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
-    if (likely(m && m->mp_subscript)) {
-        return m->mp_subscript(obj, key);
-    }
-    return __Pyx_PyObject_GetIndex(obj, key);
-}
-#endif
-
 /* PyDictVersioning */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
     PyObject *dict = Py_TYPE(obj)->tp_dict;
     return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
 }
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
@@ -19209,15 +19215,15 @@
 }
 #ifndef Py_NO_RETURN
 #define Py_NO_RETURN
 #endif
 static void __pyx_fatalerror(const char *fmt, ...) Py_NO_RETURN {
     va_list vargs;
     char msg[200];
-#if PY_VERSION_HEX >= 0x030A0000 || defined(HAVE_STDARG_PROTOTYPES)
+#ifdef HAVE_STDARG_PROTOTYPES
     va_start(vargs, fmt);
 #else
     va_start(vargs);
 #endif
     vsnprintf(msg, 200, fmt, vargs);
     va_end(vargs);
     Py_FatalError(msg);
@@ -19609,28 +19615,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_FAST_THREAD_STATE
+#if CYTHON_COMPILING_IN_PYPY
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
+#else
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
-#else
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -19651,15 +19657,15 @@
         ps2 = PyBytes_AS_STRING(s2);
         if (ps1[0] != ps2[0]) {
             return (equals == Py_NE);
         } else if (length == 1) {
             return (equals == Py_EQ);
         } else {
             int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
+#if CYTHON_USE_UNICODE_INTERNALS
             Py_hash_t hash1, hash2;
             hash1 = ((PyBytesObject*)s1)->ob_shash;
             hash2 = ((PyBytesObject*)s2)->ob_shash;
             if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                 return (equals == Py_NE);
             }
 #endif
@@ -19780,15 +19786,15 @@
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(owned_ref);
     #endif
     return (equals == Py_NE);
 #endif
 }
 
-/* DivInt[Py_ssize_t] */
+/* None */
 static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
     Py_ssize_t q = a / b;
     Py_ssize_t r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
@@ -19801,14 +19807,43 @@
     if (likely(PyString_Check(n)))
 #endif
         return __Pyx_PyObject_GetAttrStr(o, n);
 #endif
     return PyObject_GetAttr(o, n);
 }
 
+/* ObjectGetItem */
+#if CYTHON_USE_TYPE_SLOTS
+static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
+    PyObject *runerr;
+    Py_ssize_t key_value;
+    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
+    if (unlikely(!(m && m->sq_item))) {
+        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
+        return NULL;
+    }
+    key_value = __Pyx_PyIndex_AsSsize_t(index);
+    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
+        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
+    }
+    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
+        PyErr_Clear();
+        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
+    }
+    return NULL;
+}
+static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
+    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
+    if (likely(m && m->mp_subscript)) {
+        return m->mp_subscript(obj, key);
+    }
+    return __Pyx_PyObject_GetIndex(obj, key);
+}
+#endif
+
 /* decode_c_string */
 static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
          const char* cstring, Py_ssize_t start, Py_ssize_t stop,
          const char* encoding, const char* errors,
          PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
     Py_ssize_t length;
     if (unlikely((start < 0) | (stop < 0))) {
@@ -20364,22 +20399,14 @@
 #endif
 
 /* None */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
     PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
 }
 
-/* DivInt[long] */
-static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
-    long q = a / b;
-    long r = a - q*b;
-    q -= ((r != 0) & ((r ^ b) < 0));
-    return q;
-}
-
 /* ImportFrom */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
     PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
     if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
         PyErr_Format(PyExc_ImportError,
         #if PY_MAJOR_VERSION < 3
             "cannot import name %.230s", PyString_AS_STRING(name));
@@ -20514,43 +20541,25 @@
   }
   Py_XDECREF(name_attr);
   return ret;
 }
 static int __Pyx_setup_reduce(PyObject* type_obj) {
     int ret = 0;
     PyObject *object_reduce = NULL;
-    PyObject *object_getstate = NULL;
     PyObject *object_reduce_ex = NULL;
     PyObject *reduce = NULL;
     PyObject *reduce_ex = NULL;
     PyObject *reduce_cython = NULL;
     PyObject *setstate = NULL;
     PyObject *setstate_cython = NULL;
-    PyObject *getstate = NULL;
 #if CYTHON_USE_PYTYPE_LOOKUP
-    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
+    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #else
-    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
-    if (!getstate && PyErr_Occurred()) {
-        goto __PYX_BAD;
-    }
+    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #endif
-    if (getstate) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
-#else
-        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
-        if (!object_getstate && PyErr_Occurred()) {
-            goto __PYX_BAD;
-        }
-#endif
-        if (object_getstate != getstate) {
-            goto __PYX_GOOD;
-        }
-    }
 #if CYTHON_USE_PYTYPE_LOOKUP
     object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #else
     object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #endif
     reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
     if (reduce_ex == object_reduce_ex) {
@@ -20587,28 +20596,26 @@
     if (!PyErr_Occurred())
         PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
     ret = -1;
 __PYX_GOOD:
 #if !CYTHON_USE_PYTYPE_LOOKUP
     Py_XDECREF(object_reduce);
     Py_XDECREF(object_reduce_ex);
-    Py_XDECREF(object_getstate);
-    Py_XDECREF(getstate);
 #endif
     Py_XDECREF(reduce);
     Py_XDECREF(reduce_ex);
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
 /* CLineInTraceback */
 #ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(CYTHON_UNUSED PyThreadState *tstate, int c_line) {
+static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
     if (unlikely(!__pyx_cython_runtime)) {
         return c_line;
@@ -20630,15 +20637,15 @@
       } else {
         PyErr_Clear();
         use_cline = NULL;
       }
     }
     if (!use_cline) {
         c_line = 0;
-        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
+        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
     }
     else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
         c_line = 0;
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
@@ -20724,48 +20731,41 @@
     Py_INCREF(code_object);
 }
 
 /* AddTraceback */
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
-    PyCodeObject *py_code = NULL;
-    PyObject *py_funcname = NULL;
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
     #if PY_MAJOR_VERSION < 3
-    PyObject *py_srcfile = NULL;
     py_srcfile = PyString_FromString(filename);
-    if (!py_srcfile) goto bad;
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
     #endif
+    if (!py_srcfile) goto bad;
     if (c_line) {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
         #else
         py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
-        funcname = PyUnicode_AsUTF8(py_funcname);
-        if (!funcname) goto bad;
         #endif
     }
     else {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromString(funcname);
-        if (!py_funcname) goto bad;
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
         #endif
     }
-    #if PY_MAJOR_VERSION < 3
+    if (!py_funcname) goto bad;
     py_code = __Pyx_PyCode_New(
         0,
         0,
         0,
         0,
         0,
         __pyx_empty_bytes, /*PyObject *code,*/
@@ -20776,49 +20776,34 @@
         __pyx_empty_tuple, /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
         py_funcname,  /*PyObject *name,*/
         py_line,
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
     Py_DECREF(py_srcfile);
-    #else
-    py_code = PyCode_NewEmpty(filename, funcname, py_line);
-    #endif
-    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
+    Py_DECREF(py_funcname);
     return py_code;
 bad:
-    Py_XDECREF(py_funcname);
-    #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_srcfile);
-    #endif
+    Py_XDECREF(py_funcname);
     return NULL;
 }
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename) {
     PyCodeObject *py_code = 0;
     PyFrameObject *py_frame = 0;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject *ptype, *pvalue, *ptraceback;
     if (c_line) {
         c_line = __Pyx_CLineForTraceback(tstate, c_line);
     }
     py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
     if (!py_code) {
-        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
         py_code = __Pyx_CreateCodeObjectForTraceback(
             funcname, c_line, py_line, filename);
-        if (!py_code) {
-            /* If the code object creation fails, then we should clear the
-               fetched exception references and propagate the new exception */
-            Py_XDECREF(ptype);
-            Py_XDECREF(pvalue);
-            Py_XDECREF(ptraceback);
-            goto bad;
-        }
-        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
+        if (!py_code) goto bad;
         __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
     }
     py_frame = PyFrame_New(
         tstate,            /*PyThreadState *tstate,*/
         py_code,           /*PyCodeObject *code,*/
         __pyx_d,    /*PyObject *globals,*/
         0                  /*PyObject *locals*/
@@ -21678,19 +21663,14 @@
     return result;
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
-/* MemviewDtypeToObject */
-  static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_char__const__(const char *itemp) {
-    return (PyObject *) __Pyx_PyInt_From_unsigned_char(*(unsigned char const  *) itemp);
-}
-
 /* CIntFromPyVerify */
   #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
 #define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
 #define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
     {\
@@ -21773,246 +21753,208 @@
     __Pyx_XDECREF(temp_int);
     __Pyx_XDECREF(array_obj);
     __Pyx_RefNannyFinishContext();
     return new_mvs;
 }
 
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_char(unsigned char value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned char neg_one = (unsigned char) -1, const_zero = (unsigned char) 0;
+    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(unsigned char) < sizeof(long)) {
+        if (sizeof(unsigned int) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(unsigned char) <= sizeof(unsigned long)) {
+        } else if (sizeof(unsigned int) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned char) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(unsigned char) <= sizeof(long)) {
+        if (sizeof(unsigned int) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned char) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(unsigned char),
-                                     little, !is_unsigned);
-    }
-}
-
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
+        return _PyLong_FromByteArray(bytes, sizeof(unsigned int),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
-  static CYTHON_INLINE unsigned short __Pyx_PyInt_As_unsigned_short(PyObject *x) {
+  static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned short neg_one = (unsigned short) -1, const_zero = (unsigned short) 0;
+    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if (sizeof(unsigned short) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(unsigned short, long, PyInt_AS_LONG(x))
+        if (sizeof(unsigned int) < sizeof(long)) {
+            __PYX_VERIFY_RETURN_INT(unsigned int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
-            return (unsigned short) val;
+            return (unsigned int) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
             const digit* digits = ((PyLongObject*)x)->ob_digit;
             switch (Py_SIZE(x)) {
-                case  0: return (unsigned short) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(unsigned short, digit, digits[0])
+                case  0: return (unsigned int) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned int, digit, digits[0])
                 case 2:
-                    if (8 * sizeof(unsigned short) > 1 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) >= 2 * PyLong_SHIFT) {
-                            return (unsigned short) (((((unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0]));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 2 * PyLong_SHIFT) {
+                            return (unsigned int) (((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
                     }
                     break;
                 case 3:
-                    if (8 * sizeof(unsigned short) > 2 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) >= 3 * PyLong_SHIFT) {
-                            return (unsigned short) (((((((unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0]));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 3 * PyLong_SHIFT) {
+                            return (unsigned int) (((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
                     }
                     break;
                 case 4:
-                    if (8 * sizeof(unsigned short) > 3 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) >= 4 * PyLong_SHIFT) {
-                            return (unsigned short) (((((((((unsigned short)digits[3]) << PyLong_SHIFT) | (unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0]));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 4 * PyLong_SHIFT) {
+                            return (unsigned int) (((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
 #if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
-                    return (unsigned short) -1;
+                    return (unsigned int) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if (sizeof(unsigned short) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, unsigned long, PyLong_AsUnsignedLong(x))
+            if (sizeof(unsigned int) <= sizeof(unsigned long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(unsigned short) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+            } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
             const digit* digits = ((PyLongObject*)x)->ob_digit;
             switch (Py_SIZE(x)) {
-                case  0: return (unsigned short) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(unsigned short, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(unsigned short,  digit, +digits[0])
+                case  0: return (unsigned int) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(unsigned int, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned int,  digit, +digits[0])
                 case -2:
-                    if (8 * sizeof(unsigned short) - 1 > 1 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) - 1 > 1 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) - 1 > 2 * PyLong_SHIFT) {
-                            return (unsigned short) (((unsigned short)-1)*(((((unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
                     }
                     break;
                 case 2:
-                    if (8 * sizeof(unsigned short) > 1 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) - 1 > 2 * PyLong_SHIFT) {
-                            return (unsigned short) ((((((unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
                     }
                     break;
                 case -3:
-                    if (8 * sizeof(unsigned short) - 1 > 2 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) - 1 > 3 * PyLong_SHIFT) {
-                            return (unsigned short) (((unsigned short)-1)*(((((((unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
                     }
                     break;
                 case 3:
-                    if (8 * sizeof(unsigned short) > 2 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) - 1 > 3 * PyLong_SHIFT) {
-                            return (unsigned short) ((((((((unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
                     }
                     break;
                 case -4:
-                    if (8 * sizeof(unsigned short) - 1 > 3 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) - 1 > 4 * PyLong_SHIFT) {
-                            return (unsigned short) (((unsigned short)-1)*(((((((((unsigned short)digits[3]) << PyLong_SHIFT) | (unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
                     }
                     break;
                 case 4:
-                    if (8 * sizeof(unsigned short) > 3 * PyLong_SHIFT) {
+                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
                         if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned short) - 1 > 4 * PyLong_SHIFT) {
-                            return (unsigned short) ((((((((((unsigned short)digits[3]) << PyLong_SHIFT) | (unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
                     }
                     break;
             }
 #endif
-            if (sizeof(unsigned short) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, long, PyLong_AsLong(x))
+            if (sizeof(unsigned int) <= sizeof(long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(unsigned short) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, PY_LONG_LONG, PyLong_AsLongLong(x))
+            } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
 #if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
             PyErr_SetString(PyExc_RuntimeError,
                             "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
 #else
-            unsigned short val;
+            unsigned int val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
  #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
@@ -22024,302 +21966,106 @@
                                               bytes, sizeof(val),
                                               is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
 #endif
-            return (unsigned short) -1;
+            return (unsigned int) -1;
         }
     } else {
-        unsigned short val;
+        unsigned int val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (unsigned short) -1;
-        val = __Pyx_PyInt_As_unsigned_short(tmp);
+        if (!tmp) return (unsigned int) -1;
+        val = __Pyx_PyInt_As_unsigned_int(tmp);
         Py_DECREF(tmp);
         return val;
     }
 raise_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to unsigned short");
-    return (unsigned short) -1;
+        "value too large to convert to unsigned int");
+    return (unsigned int) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to unsigned short");
-    return (unsigned short) -1;
+        "can't convert negative value to unsigned int");
+    return (unsigned int) -1;
 }
 
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_short(unsigned short value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned short neg_one = (unsigned short) -1, const_zero = (unsigned short) 0;
+    const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(unsigned short) < sizeof(long)) {
+        if (sizeof(long) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(unsigned short) <= sizeof(unsigned long)) {
+        } else if (sizeof(long) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned short) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(unsigned short) <= sizeof(long)) {
+        if (sizeof(long) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned short) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(unsigned short),
+        return _PyLong_FromByteArray(bytes, sizeof(long),
                                      little, !is_unsigned);
     }
 }
 
-/* CIntFromPy */
-  static CYTHON_INLINE unsigned char __Pyx_PyInt_As_unsigned_char(PyObject *x) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const unsigned char neg_one = (unsigned char) -1, const_zero = (unsigned char) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(unsigned char) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(unsigned char, long, PyInt_AS_LONG(x))
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                goto raise_neg_overflow;
-            }
-            return (unsigned char) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (unsigned char) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(unsigned char, digit, digits[0])
-                case 2:
-                    if (8 * sizeof(unsigned char) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) >= 2 * PyLong_SHIFT) {
-                            return (unsigned char) (((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(unsigned char) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) >= 3 * PyLong_SHIFT) {
-                            return (unsigned char) (((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(unsigned char) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) >= 4 * PyLong_SHIFT) {
-                            return (unsigned char) (((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
-                        }
-                    }
-                    break;
-            }
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON
-            if (unlikely(Py_SIZE(x) < 0)) {
-                goto raise_neg_overflow;
-            }
-#else
-            {
-                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                if (unlikely(result < 0))
-                    return (unsigned char) -1;
-                if (unlikely(result == 1))
-                    goto raise_neg_overflow;
-            }
-#endif
-            if (sizeof(unsigned char) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, unsigned long, PyLong_AsUnsignedLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(unsigned char) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
-#endif
-            }
-        } else {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (unsigned char) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(unsigned char, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(unsigned char,  digit, +digits[0])
-                case -2:
-                    if (8 * sizeof(unsigned char) - 1 > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT) {
-                            return (unsigned char) (((unsigned char)-1)*(((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                        }
-                    }
-                    break;
-                case 2:
-                    if (8 * sizeof(unsigned char) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT) {
-                            return (unsigned char) ((((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                        }
-                    }
-                    break;
-                case -3:
-                    if (8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT) {
-                            return (unsigned char) (((unsigned char)-1)*(((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(unsigned char) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT) {
-                            return (unsigned char) ((((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                        }
-                    }
-                    break;
-                case -4:
-                    if (8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) - 1 > 4 * PyLong_SHIFT) {
-                            return (unsigned char) (((unsigned char)-1)*(((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(unsigned char) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(unsigned char) - 1 > 4 * PyLong_SHIFT) {
-                            return (unsigned char) ((((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                        }
-                    }
-                    break;
-            }
-#endif
-            if (sizeof(unsigned char) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, long, PyLong_AsLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(unsigned char) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, PY_LONG_LONG, PyLong_AsLongLong(x))
-#endif
-            }
-        }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            unsigned char val;
-            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (unsigned char) -1;
-        }
-    } else {
-        unsigned char val;
-        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (unsigned char) -1;
-        val = __Pyx_PyInt_As_unsigned_char(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-raise_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to unsigned char");
-    return (unsigned char) -1;
-raise_neg_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to unsigned char");
-    return (unsigned char) -1;
-}
-
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_char(char value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const char neg_one = (char) -1, const_zero = (char) 0;
+    const int neg_one = (int) -1, const_zero = (int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(char) < sizeof(long)) {
+        if (sizeof(int) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(char) <= sizeof(unsigned long)) {
+        } else if (sizeof(int) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(char) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(char) <= sizeof(long)) {
+        if (sizeof(int) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(char) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(char),
+        return _PyLong_FromByteArray(bytes, sizeof(int),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
   static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
@@ -22708,52 +22454,14 @@
     return (long) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to long");
     return (long) -1;
 }
 
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(int) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(int) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(int),
-                                     little, !is_unsigned);
-    }
-}
-
 /* CIntFromPy */
   static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const char neg_one = (char) -1, const_zero = (char) 0;
@@ -22944,41 +22652,19 @@
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to char");
     return (char) -1;
 }
 
 /* CheckBinaryVersion */
   static int __Pyx_check_binary_version(void) {
-    char ctversion[5];
-    int same=1, i, found_dot;
-    const char* rt_from_call = Py_GetVersion();
-    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
-    found_dot = 0;
-    for (i = 0; i < 4; i++) {
-        if (!ctversion[i]) {
-            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
-            break;
-        }
-        if (rt_from_call[i] != ctversion[i]) {
-            same = 0;
-            break;
-        }
-    }
-    if (!same) {
-        char rtversion[5] = {'\0'};
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
         char message[200];
-        for (i=0; i<4; ++i) {
-            if (rt_from_call[i] == '.') {
-                if (found_dot) break;
-                found_dot = 1;
-            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
-                break;
-            }
-            rtversion[i] = rt_from_call[i];
-        }
         PyOS_snprintf(message, sizeof(message),
                       "compiletime version %s of module '%.100s' "
                       "does not match runtime version %s",
                       ctversion, __Pyx_MODULE_NAME, rtversion);
         return PyErr_WarnEx(NULL, message, 1);
     }
     return 0;
@@ -23228,31 +22914,14 @@
   }
   x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
-  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
-    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
-#if PY_MAJOR_VERSION < 3
-  } else if (likely(PyInt_CheckExact(o))) {
-    return PyInt_AS_LONG(o);
-#endif
-  } else {
-    Py_ssize_t ival;
-    PyObject *x;
-    x = PyNumber_Index(o);
-    if (!x) return -1;
-    ival = PyInt_AsLong(x);
-    Py_DECREF(x);
-    return ival;
-  }
-}
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
   return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
 }
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
```

### Comparing `chython-1.64/chython/containers/cgr.py` & `chython-1.8/chython/containers/cgr.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,153 +1,193 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from functools import cached_property
-from typing import Dict, Iterator, Tuple, Optional, Collection
-from .bonds import DynamicBond
-from ..algorithms.isomorphism import Isomorphism
-from ..algorithms.morgan import Morgan
-from ..algorithms.rings import Rings
-from ..algorithms.smiles import CGRSmiles
-from ..periodictable import DynamicElement
-
-
-class CGRContainer(CGRSmiles, Morgan, Rings, Isomorphism):
-    __slots__ = ('_atoms', '_bonds', '_charges', '_radicals', '_p_charges', '_p_radicals', '__dict__', '__weakref__')
-    _atoms: Dict[int, DynamicElement]
-    _bonds: Dict[int, Dict[int, DynamicBond]]
-    _charges: Dict[int, int]
-    _radicals: Dict[int, bool]
-    _p_charges: Dict[int, int]
-    _p_radicals: Dict[int, bool]
-
-    def __init__(self):
-        self._atoms = {}
-        self._bonds = {}
-        self._charges = {}
-        self._radicals = {}
-        self._p_charges = {}
-        self._p_radicals = {}
-
-    def bonds(self) -> Iterator[Tuple[int, int, DynamicBond]]:
-        """
-        Iterate other all bonds
-        """
-        seen = set()
-        for n, m_bond in self._bonds.items():
-            seen.add(n)
-            for m, bond in m_bond.items():
-                if m not in seen:
-                    yield n, m, bond
-
-    @cached_property
-    def center_atoms(self) -> Tuple[int, ...]:
-        """ Get list of atoms of reaction center (atoms with dynamic: bonds, charges, radicals).
-        """
-        radicals = self._radicals
-        p_charges = self._p_charges
-        p_radicals = self._p_radicals
-
-        center = set()
-        for n, c in self._charges.items():
-            if c != p_charges[n] or radicals[n] != p_radicals[n]:
-                center.add(n)
-
-        for n, m_bond in self._bonds.items():
-            if any(bond.order != bond.p_order for bond in m_bond.values()):
-                center.add(n)
-
-        return tuple(center)
-
-    def substructure(self, atoms) -> 'CGRContainer':
-        """
-        Create substructure containing atoms from atoms list
-
-        :param atoms: list of atoms numbers of substructure
-        """
-        atoms = set(atoms)
-        sa = self._atoms
-        sc = self._charges
-        sr = self._radicals
-        sb = self._bonds
-        spc = self._p_charges
-        spr = self._p_radicals
-
-        sub = object.__new__(self.__class__)
-        sub._charges = {n: sc[n] for n in atoms}
-        sub._radicals = {n: sr[n] for n in atoms}
-        sub._p_charges = {n: spc[n] for n in atoms}
-        sub._p_radicals = {n: spr[n] for n in atoms}
-
-        sub._atoms = ca = {}
-        for n in atoms:
-            ca[n] = atom = sa[n].copy()
-            atom._attach_graph(sub, n)
-
-        sub._bonds = cb = {}
-        for n in atoms:
-            cb[n] = cbn = {}
-            for m, bond in sb[n].items():
-                if m in cb:  # bond partially exists. need back-connection.
-                    cbn[m] = cb[m][n]
-                elif m in atoms:
-                    cbn[m] = bond.copy()
-        return sub
-
-    def augmented_substructure(self, atoms, deep: int = 1):
-        atoms = set(atoms)
-        bonds = self._bonds
-
-        for _ in range(deep):
-            n = {y for x in atoms for y in bonds[x]} | atoms
-            if n == atoms:
-                break
-            atoms = n
-        return self.substructure(atoms)
-
-    def get_mapping(self, other: 'CGRContainer', /, *, automorphism_filter: bool = True,
-                    searching_scope: Optional[Collection[int]] = None):
-        """
-        Get self to other CGR substructure mapping generator.
-
-        :param other: CGR
-        :param automorphism_filter: skip matches to the same atoms.
-        :param searching_scope: substructure atoms list to localize isomorphism.
-        """
-        if isinstance(other, CGRContainer):
-            return self._get_mapping(other, automorphism_filter=automorphism_filter, searching_scope=searching_scope)
-        raise TypeError('CGRContainer expected')
-
-    def __iter__(self):
-        return iter(self._atoms)
-
-    def __getstate__(self):
-        return {'atoms': self._atoms, 'bonds': self._bonds, 'charges': self._charges, 'radicals': self._radicals,
-                'p_charges': self._p_charges, 'p_radicals': self._p_radicals}
-
-    def __setstate__(self, state):
-        self._atoms = state['atoms']
-        for n, a in state['atoms'].items():
-            a._attach_graph(self, n)
-        self._charges = state['charges']
-        self._radicals = state['radicals']
-        self._bonds = state['bonds']
-        self._p_charges = state['p_charges']
-        self._p_radicals = state['p_radicals']
-
-
-__all__ = ['CGRContainer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from functools import cached_property
+from typing import Dict, Iterator, List, Tuple
+from . import molecule  # cyclic imports resolve
+from .bonds import DynamicBond
+from ..algorithms.calculate2d import Calculate2DCGR
+from ..algorithms.depict import DepictCGR
+from ..algorithms.isomorphism import Isomorphism
+from ..algorithms.morgan import Morgan
+from ..algorithms.rings import Rings
+from ..algorithms.smiles import CGRSmiles
+from ..algorithms.x3dom import X3domCGR
+from ..periodictable import DynamicElement, Element
+
+
+class CGRContainer(CGRSmiles, Morgan, Rings, Isomorphism, DepictCGR, Calculate2DCGR, X3domCGR):
+    __slots__ = ('_atoms', '_bonds', '_charges', '_radicals', '_p_charges', '_p_radicals', '_plane', '_conformers',
+                 '__dict__', '__weakref__')
+    _atoms: Dict[int, DynamicElement]
+    _bonds: Dict[int, Dict[int, DynamicBond]]
+    _charges: Dict[int, int]
+    _radicals: Dict[int, bool]
+    _p_charges: Dict[int, int]
+    _p_radicals: Dict[int, bool]
+    _plane: Dict[int, Tuple[float, float]]
+    _conformers: List[Dict[int, Tuple[float, float, float]]]
+
+    def __init__(self):
+        self._atoms = {}
+        self._bonds = {}
+        self._charges = {}
+        self._radicals = {}
+        self._p_charges = {}
+        self._p_radicals = {}
+        self._plane = {}
+        self._conformers = []
+
+    def bonds(self) -> Iterator[Tuple[int, int, DynamicBond]]:
+        """
+        Iterate other all bonds
+        """
+        seen = set()
+        for n, m_bond in self._bonds.items():
+            seen.add(n)
+            for m, bond in m_bond.items():
+                if m not in seen:
+                    yield n, m, bond
+
+    @cached_property
+    def center_atoms(self) -> Tuple[int, ...]:
+        """ Get list of atoms of reaction center (atoms with dynamic: bonds, charges, radicals).
+        """
+        radicals = self._radicals
+        p_charges = self._p_charges
+        p_radicals = self._p_radicals
+
+        center = set()
+        for n, c in self._charges.items():
+            if c != p_charges[n] or radicals[n] != p_radicals[n]:
+                center.add(n)
+
+        for n, m_bond in self._bonds.items():
+            if any(bond.order != bond.p_order for bond in m_bond.values()):
+                center.add(n)
+
+        return tuple(center)
+
+    @cached_property
+    def aromatic_rings(self) -> Tuple[Tuple[int, ...], ...]:
+        """
+        existed or formed aromatic rings atoms numbers
+        """
+        adj = self._bonds
+        return tuple(ring for ring in self.sssr if
+                     adj[ring[0]][ring[-1]].order == 4 and all(adj[n][m].order == 4 for n, m in zip(ring, ring[1:])) or
+                     adj[ring[0]][ring[-1]].p_order == 4 and all(adj[n][m].p_order == 4 for n, m in zip(ring, ring[1:]))
+                     )
+
+    def substructure(self, atoms) -> 'CGRContainer':
+        """
+        Create substructure containing atoms from atoms list
+
+        :param atoms: list of atoms numbers of substructure
+        """
+        atoms = set(atoms)
+        sa = self._atoms
+        sc = self._charges
+        sr = self._radicals
+        sp = self._plane
+        sb = self._bonds
+        spc = self._p_charges
+        spr = self._p_radicals
+
+        sub = object.__new__(self.__class__)
+        sub._charges = {n: sc[n] for n in atoms}
+        sub._radicals = {n: sr[n] for n in atoms}
+        sub._p_charges = {n: spc[n] for n in atoms}
+        sub._p_radicals = {n: spr[n] for n in atoms}
+        sub._plane = {n: sp[n] for n in atoms}
+        sub._conformers = [{n: c[n] for n in atoms} for c in self._conformers]
+
+        sub._atoms = ca = {}
+        for n in atoms:
+            ca[n] = atom = sa[n].copy()
+            atom._attach_to_graph(sub, n)
+
+        sub._bonds = cb = {}
+        for n in atoms:
+            cb[n] = cbn = {}
+            for m, bond in sb[n].items():
+                if m in cb:  # bond partially exists. need back-connection.
+                    cbn[m] = cb[m][n]
+                elif m in atoms:
+                    cbn[m] = bond.copy()
+        return sub
+
+    def decompose(self) -> Tuple['molecule.MoleculeContainer', 'molecule.MoleculeContainer']:
+        """
+        decompose CGR to pair of Molecules, which represents reactants and products state of reaction
+
+        :return: tuple of two molecules
+        """
+        charges = self._charges
+        p_charges = self._p_charges
+        radicals = self._radicals
+        p_radicals = self._p_radicals
+        plane = self._plane
+
+        reactants = molecule.MoleculeContainer()
+        products = molecule.MoleculeContainer()
+
+        for n, atom in self._atoms.items():
+            atom = Element.from_atomic_number(atom.atomic_number)(atom.isotope)
+            reactants.add_atom(atom, n, charge=charges[n], is_radical=radicals[n], xy=plane[n])
+            products.add_atom(atom.copy(), n, charge=p_charges[n], is_radical=p_radicals[n], xy=plane[n])
+
+        for n, m, bond in self.bonds():
+            if bond.order:
+                reactants.add_bond(n, m, bond.order)
+            if bond.p_order:
+                products.add_bond(n, m, bond.p_order)
+        return reactants, products
+
+    def get_mapping(self, other: 'CGRContainer', /, **kwargs):
+        if isinstance(other, CGRContainer):
+            return super().get_mapping(other, **kwargs)
+        raise TypeError('CGRContainer expected')
+
+    def __iter__(self):
+        return iter(self._atoms)
+
+    def __invert__(self):
+        """
+        decompose CGR
+        """
+        return self.decompose()
+
+    def __getstate__(self):
+        return {'atoms': self._atoms, 'bonds': self._bonds, 'plane': self._plane, 'conformers': self._conformers,
+                'charges': self._charges, 'radicals': self._radicals,
+                'p_charges': self._p_charges, 'p_radicals': self._p_radicals}
+
+    def __setstate__(self, state):
+        self._atoms = state['atoms']
+        for n, a in state['atoms'].items():
+            a._attach_to_graph(self, n)
+        self._charges = state['charges']
+        self._radicals = state['radicals']
+        self._plane = state['plane']
+        self._bonds = state['bonds']
+        self._p_charges = state['p_charges']
+        self._p_radicals = state['p_radicals']
+        self._conformers = state['conformers']
+
+
+__all__ = ['CGRContainer']
```

### Comparing `chython-1.64/chython/containers/graph.py` & `chython-1.8/chython/containers/graph.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,300 +1,254 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABC, abstractmethod
-from functools import cached_property
-from typing import Dict, Generic, Iterator, Optional, Tuple, TypeVar
-from ..algorithms.morgan import Morgan
-from ..algorithms.rings import Rings
-from ..exceptions import AtomNotFound, MappingError, BondNotFound
-
-
-Atom = TypeVar('Atom')
-Bond = TypeVar('Bond')
-
-
-class Graph(Generic[Atom, Bond], Morgan, Rings, ABC):
-    __slots__ = ('_atoms', '_bonds', '_charges', '_radicals', '_atoms_stereo', '_cis_trans_stereo', '_allenes_stereo',
-                 '__dict__', '__weakref__')
-    __class_cache__ = {}
-
-    _atoms: Dict[int, Atom]
-    _bonds: Dict[int, Dict[int, Bond]]
-    _charges: Dict[int, int]
-    _radicals: Dict[int, bool]
-    _atoms_stereo: Dict[int, bool]
-    _allenes_stereo: Dict[int, bool]
-    _cis_trans_stereo: Dict[Tuple[int, int], bool]
-
-    def __init__(self):
-        self._atoms = {}
-        self._bonds = {}
-        self._charges = {}
-        self._radicals = {}
-        self._atoms_stereo = {}
-        self._allenes_stereo = {}
-        self._cis_trans_stereo = {}
-
-    def atom(self, n: int) -> Atom:
-        return self._atoms[n]
-
-    def has_atom(self, n: int) -> bool:
-        return n in self._atoms
-
-    def atoms(self) -> Iterator[Tuple[int, Atom]]:
-        """
-        iterate over all atoms
-        """
-        return iter(self._atoms.items())
-
-    @property
-    def atoms_count(self) -> int:
-        return len(self._atoms)
-
-    @property
-    def atoms_numbers(self) -> Iterator[int]:
-        return iter(self._atoms)
-
-    def bond(self, n: int, m: int) -> Bond:
-        try:
-            return self._bonds[n][m]
-        except KeyError as e:
-            raise BondNotFound from e
-
-    def has_bond(self, n: int, m: int) -> bool:
-        try:
-            self._bonds[n]  # check if atom exists
-            return n in self._bonds[m]
-        except KeyError:
-            raise AtomNotFound
-
-    def bonds(self) -> Iterator[Tuple[int, int, Bond]]:
-        """
-        iterate other all bonds
-        """
-        seen = set()
-        for n, m_bond in self._bonds.items():
-            seen.add(n)
-            for m, bond in m_bond.items():
-                if m not in seen:
-                    yield n, m, bond
-
-    @cached_property
-    def bonds_count(self) -> int:
-        return sum(len(x) for x in self._bonds.values()) // 2
-
-    @abstractmethod
-    def add_atom(self, atom: Atom, n: Optional[int] = None, *, charge: int = 0, is_radical: bool = False) -> int:
-        """
-        new atom addition
-        """
-        if n is None:
-            n = max(self._atoms, default=0) + 1
-        elif not isinstance(n, int):
-            raise TypeError('mapping should be integer')
-        elif n in self._atoms:
-            raise MappingError('atom with same number exists')
-        elif not isinstance(is_radical, bool):
-            raise TypeError('bool expected')
-        elif not isinstance(charge, int):
-            raise TypeError('formal charge should be int in range [-4, 4]')
-        elif charge > 4 or charge < -4:
-            raise ValueError('formal charge should be in range [-4, 4]')
-
-        atom._attach_graph(self, n)
-        self._atoms[n] = atom
-        self._charges[n] = charge
-        self._radicals[n] = is_radical
-        self._bonds[n] = {}
-        self.__dict__.clear()
-        return n
-
-    @abstractmethod
-    def add_bond(self, n: int, m: int, bond: Bond):
-        """
-        Add bond.
-        """
-        if n == m:
-            raise MappingError('atom loops impossible')
-        if n not in self._bonds or m not in self._bonds:
-            raise AtomNotFound('atoms not found')
-        if n in self._bonds[m]:
-            raise MappingError('atoms already bonded')
-
-        self._bonds[n][m] = self._bonds[m][n] = bond
-        self.__dict__.clear()
-
-    @abstractmethod
-    def copy(self):
-        """
-        copy of graph
-        """
-        copy = object.__new__(self.__class__)
-        copy._charges = self._charges.copy()
-        copy._radicals = self._radicals.copy()
-
-        copy._atoms = ca = {}
-        for n, atom in self._atoms.items():
-            atom = atom.copy()
-            ca[n] = atom
-            atom._attach_graph(copy, n)
-        return copy
-
-    @abstractmethod
-    def remap(self, mapping: Dict[int, int], *, copy=False):
-        """
-        Change atom numbers
-
-        :param mapping: mapping of old numbers to the new
-        :param copy: keep original graph
-        """
-        if len(mapping) != len(set(mapping.values())) or \
-                not (self._atoms.keys() - mapping.keys()).isdisjoint(mapping.values()):
-            raise ValueError('mapping overlap')
-
-        mg = mapping.get
-        sc = self._charges
-        sr = self._radicals
-
-        if copy:
-            h = self.__class__()
-            ha = h._atoms
-            hc = h._charges
-            hr = h._radicals
-            has = h._atoms_stereo
-            hal = h._allenes_stereo
-            hcs = h._cis_trans_stereo
-
-            for n, atom in self._atoms.items():
-                m = mg(n, n)
-                atom = atom.copy()
-                ha[m] = atom
-                atom._attach_graph(h, m)
-        else:
-            ha = {}
-            hc = {}
-            hr = {}
-            has = {}
-            hal = {}
-            hcs = {}
-
-            for n, atom in self._atoms.items():
-                m = mg(n, n)
-                ha[m] = atom
-                atom._change_map(m)  # change mapping number
-
-        for n in self._atoms:
-            m = mg(n, n)
-            hc[m] = sc[n]
-            hr[m] = sr[n]
-
-        for n, stereo in self._atoms_stereo.items():
-            has[mg(n, n)] = stereo
-        for n, stereo in self._allenes_stereo.items():
-            hal[mg(n, n)] = stereo
-        for (n, m), stereo in self._cis_trans_stereo.items():
-            hcs[(mg(n, n), mg(m, m))] = stereo
-
-        if copy:
-            return h  # noqa
-
-        self._atoms = ha
-        self._charges = hc
-        self._radicals = hr
-        self._atoms_stereo = has
-        self._allenes_stereo = hal
-        self._cis_trans_stereo = hcs
-        self.flush_cache()
-        return self
-
-    @abstractmethod
-    def union(self, other: 'Graph', *, remap: bool = False, copy: bool = True):
-        """
-        Merge Graphs into one.
-
-        :param remap: if atoms has collisions then remap other graph atoms else raise exception.
-        :param copy: keep original structure and return new object
-        """
-        if self._atoms.keys() & other._atoms.keys():
-            if remap:
-                other = other.remap({n: i for i, n in enumerate(other, start=max(self._atoms) + 1)}, copy=True)
-            else:
-                raise MappingError('mapping of graphs is not disjoint')
-
-        u = self.copy() if copy else self
-        u._charges.update(other._charges)
-        u._radicals.update(other._radicals)
-
-        ua = u._atoms
-        for n, atom in other._atoms.items():
-            ua[n] = atom = atom.copy()
-            atom._attach_graph(u, n)
-
-        u._atoms_stereo.update(other._atoms_stereo)
-        u._allenes_stereo.update(other._allenes_stereo)
-        u._cis_trans_stereo.update(other._cis_trans_stereo)
-        return u, other
-
-    def flush_cache(self):
-        self.__dict__.clear()
-
-    def __copy__(self):
-        return self.copy()
-
-    def __or__(self, other):
-        """
-        G | H is union of graphs
-        """
-        return self.union(other, remap=True)
-
-    def __ior__(self, other):
-        """
-        G =| H is union of graphs
-        """
-        return self.union(other, remap=True, copy=False)
-
-    def __len__(self):
-        return len(self._atoms)
-
-    def __iter__(self) -> Iterator[int]:
-        return iter(self._atoms)
-
-    def __bool__(self):
-        return bool(self._atoms)
-
-    def __getstate__(self):
-        state = {'atoms': self._atoms, 'bonds': self._bonds, 'charges': self._charges,
-                 'radicals': self._radicals}
-        from chython import pickle_cache
-
-        if pickle_cache:
-            state['cache'] = {k: v for k, v in self.__dict__.items() if k != '__cached_method___hash__'}
-        return state
-
-    def __setstate__(self, state):
-        self._atoms = state['atoms']
-        for n, a in state['atoms'].items():
-            a._attach_graph(self, n)
-        self._charges = state['charges']
-        self._radicals = state['radicals']
-        self._bonds = state['bonds']
-        if 'cache' in state:
-            self.__dict__.update(state['cache'])
-
-
-__all__ = ['Graph']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABC, abstractmethod
+from functools import cached_property
+from typing import Dict, Generic, Iterator, Optional, Tuple, TypeVar
+from ..algorithms.isomorphism import Isomorphism
+from ..algorithms.morgan import Morgan
+from ..algorithms.rings import Rings
+from ..exceptions import AtomNotFound, MappingError
+
+
+Atom = TypeVar('Atom')
+Bond = TypeVar('Bond')
+
+
+class Graph(Generic[Atom, Bond], Morgan, Rings, Isomorphism, ABC):
+    __slots__ = ('_atoms', '_bonds', '_plane', '_charges', '_radicals', '__dict__', '__weakref__')
+    __class_cache__ = {}
+
+    _atoms: Dict[int, Atom]
+    _bonds: Dict[int, Dict[int, Bond]]
+    _charges: Dict[int, int]
+    _radicals: Dict[int, bool]
+    _plane: Dict[int, Tuple[float, float]]
+
+    def __init__(self):
+        self._atoms = {}
+        self._bonds = {}
+        self._charges = {}
+        self._radicals = {}
+        self._plane = {}
+
+    def atom(self, n: int) -> Atom:
+        return self._atoms[n]
+
+    def has_atom(self, n: int) -> bool:
+        return n in self._atoms
+
+    def atoms(self) -> Iterator[Tuple[int, Atom]]:
+        """
+        iterate over all atoms
+        """
+        return iter(self._atoms.items())
+
+    @property
+    def atoms_count(self) -> int:
+        return len(self._atoms)
+
+    @property
+    def atoms_numbers(self) -> Iterator[int]:
+        return iter(self._atoms)
+
+    def bond(self, n: int, m: int) -> Bond:
+        return self._bonds[n][m]
+
+    def has_bond(self, n: int, m: int) -> bool:
+        try:
+            self._bonds[n]  # check if atom exists
+            return n in self._bonds[m]
+        except KeyError:
+            raise AtomNotFound
+
+    def bonds(self) -> Iterator[Tuple[int, int, Bond]]:
+        """
+        iterate other all bonds
+        """
+        seen = set()
+        for n, m_bond in self._bonds.items():
+            seen.add(n)
+            for m, bond in m_bond.items():
+                if m not in seen:
+                    yield n, m, bond
+
+    @cached_property
+    def bonds_count(self) -> int:
+        return sum(len(x) for x in self._bonds.values()) // 2
+
+    @abstractmethod
+    def add_atom(self, atom: Atom, _map: Optional[int] = None, *, charge: int = 0,
+                 is_radical: bool = False, xy: Tuple[float, float] = (0., 0.)) -> int:
+        """
+        new atom addition
+        """
+        if _map is None:
+            _map = max(self._atoms, default=0) + 1
+        elif not isinstance(_map, int):
+            raise TypeError('mapping should be integer')
+        elif _map in self._atoms:
+            raise MappingError('atom with same number exists')
+        elif not isinstance(xy, tuple) or len(xy) != 2 or not isinstance(xy[0], float) or not isinstance(xy[1], float):
+            raise TypeError('XY should be tuple with 2 float')
+        elif not isinstance(is_radical, bool):
+            raise TypeError('bool expected')
+        elif not isinstance(charge, int):
+            raise TypeError('formal charge should be int in range [-4, 4]')
+        elif charge > 4 or charge < -4:
+            raise ValueError('formal charge should be in range [-4, 4]')
+
+        self._atoms[_map] = atom
+        self._charges[_map] = charge
+        self._radicals[_map] = is_radical
+        self._plane[_map] = xy
+        self._bonds[_map] = {}
+        atom._attach_to_graph(self, _map)
+        self.__dict__.clear()
+        return _map
+
+    @abstractmethod
+    def add_bond(self, n: int, m: int, bond: Bond):
+        """
+        Add bond.
+        """
+        if n == m:
+            raise ValueError('atom loops impossible')
+        if n not in self._bonds or m not in self._bonds:
+            raise AtomNotFound('atoms not found')
+        if n in self._bonds[m]:
+            raise ValueError('atoms already bonded')
+
+        self._bonds[n][m] = self._bonds[m][n] = bond
+        self.__dict__.clear()
+
+    @abstractmethod
+    def delete_atom(self, n: int):
+        """
+        Remove atom.
+        """
+        del self._atoms[n]
+        del self._charges[n]
+        del self._radicals[n]
+        del self._plane[n]
+        sb = self._bonds
+        for m in sb.pop(n):
+            del sb[m][n]
+        self.__dict__.clear()
+
+    @abstractmethod
+    def delete_bond(self, n: int, m: int):
+        """
+        Remove bond.
+        """
+        del self._bonds[n][m]
+        del self._bonds[m][n]
+        self.__dict__.clear()
+
+    @abstractmethod
+    def copy(self):
+        """
+        copy of graph
+        """
+        copy = object.__new__(self.__class__)
+        copy._charges = self._charges.copy()
+        copy._radicals = self._radicals.copy()
+        copy._plane = self._plane.copy()
+
+        copy._bonds = cb = {}
+        for n, m_bond in self._bonds.items():
+            cb[n] = cbn = {}
+            for m, bond in m_bond.items():
+                if m in cb:  # bond partially exists. need back-connection.
+                    cbn[m] = cb[m][n]
+                else:
+                    cbn[m] = bond.copy()
+
+        copy._atoms = ca = {}
+        for n, atom in self._atoms.items():
+            atom = atom.copy()
+            ca[n] = atom
+            atom._attach_to_graph(copy, n)
+        return copy
+
+    @abstractmethod
+    def union(self, other: 'Graph'):
+        """
+        Merge Graphs into one.
+        """
+        u = self.copy()
+        u._charges.update(other._charges)
+        u._radicals.update(other._radicals)
+        u._plane.update(other._plane)
+
+        ua = u._atoms
+        for n, atom in other._atoms.items():
+            ua[n] = atom = atom.copy()
+            atom._attach_to_graph(u, n)
+
+        ub = u._bonds
+        for n, m_bond in other._bonds.items():
+            ub[n] = ubn = {}
+            for m, bond in m_bond.items():
+                if m in ub:  # bond partially exists. need back-connection.
+                    ubn[m] = ub[m][n]
+                else:
+                    ubn[m] = bond.copy()
+        return u
+
+    def flush_cache(self):
+        self.__dict__.clear()
+
+    def __copy__(self):
+        return self.copy()
+
+    def __or__(self, other):
+        """
+        G | H is union of graphs
+        """
+        return self.union(other)
+
+    def __len__(self):
+        return len(self._atoms)
+
+    def __iter__(self) -> Iterator[int]:
+        return iter(self._atoms)
+
+    def __bool__(self):
+        return bool(self._atoms)
+
+    def __getstate__(self):
+        state = {'atoms': self._atoms, 'bonds': self._bonds, 'plane': self._plane, 'charges': self._charges,
+                 'radicals': self._radicals}
+        import chython
+        if chython.pickle_cache:
+            state['cache'] = {k: v for k, v in self.__dict__.items() if k != '__cached_method___hash__'}
+        return state
+
+    def __setstate__(self, state):
+        self._atoms = state['atoms']
+        for n, a in state['atoms'].items():
+            a._attach_to_graph(self, n)
+        self._charges = state['charges']
+        self._radicals = state['radicals']
+        self._plane = state['plane']
+        self._bonds = state['bonds']
+        if 'cache' in state:
+            self.__dict__.update(state['cache'])
+
+
+__all__ = ['Graph']
```

### Comparing `chython-1.64/chython/containers/molecule.py` & `chython-1.8/chython/containers/molecule.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,1144 +1,1206 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from CachedMethods import cached_args_method
-from collections import Counter, defaultdict
-from functools import cached_property
-from numpy import uint, zeros
-from typing import Dict, Iterable, List, Optional, Tuple, Union
-from weakref import ref
-from zlib import compress, decompress
-from .bonds import Bond, DynamicBond, QueryBond
-from .cgr import CGRContainer
-from .graph import Graph
-from .query import QueryContainer
-from ..algorithms.aromatics import Aromatize
-from ..algorithms.calculate2d import Calculate2DMolecule
-from ..algorithms.depict import DepictMolecule
-from ..algorithms.isomorphism import MoleculeIsomorphism
-from ..algorithms.fingerprints import Fingerprints
-from ..algorithms.mcs import MCS
-from ..algorithms.smiles import MoleculeSmiles
-from ..algorithms.standardize import StandardizeMolecule
-from ..algorithms.stereo import MoleculeStereo
-from ..algorithms.tautomers import Tautomers
-from ..algorithms.x3dom import X3domMolecule
-from ..exceptions import MappingError, ValenceError
-from ..periodictable import DynamicElement, Element, QueryElement, H
-
-
-class MoleculeContainer(MoleculeStereo, Graph[Element, Bond], MoleculeIsomorphism, Aromatize, StandardizeMolecule,
-                        MoleculeSmiles, DepictMolecule, Calculate2DMolecule, Fingerprints, Tautomers, MCS,
-                        X3domMolecule):
-    __slots__ = ('_plane', '_conformers', '_hydrogens', '_parsed_mapping', '_backup', '__meta', '__name')
-
-    _conformers: List[Dict[int, Tuple[float, float, float]]]
-    _hydrogens: Dict[int, Optional[int]]
-    _parsed_mapping: Dict[int, int]
-    _plane: Dict[int, Tuple[float, float]]
-
-    def __init__(self):
-        super().__init__()
-        self._conformers = []
-        self._hydrogens = {}
-        self._parsed_mapping = {}
-        self._plane = {}
-        self.__meta = None
-        self.__name = None
-
-    @property
-    def meta(self) -> Dict:
-        if self.__meta is None:
-            self.__meta = {}  # lazy
-        return self.__meta
-
-    @property
-    def name(self) -> str:
-        return self.__name or ''
-
-    @name.setter
-    def name(self, name):
-        if not isinstance(name, str):
-            raise TypeError('name should be string up to 80 symbols')
-        self.__name = name
-
-    def environment(self, atom: int, include_bond: bool = True, include_atom: bool = True) -> \
-            Tuple[Union[Tuple[int, Bond, Element],
-                        Tuple[int, Element],
-                        Tuple[int, Bond],
-                        int], ...]:
-        """
-        groups of (atom_number, bond, atom) connected to atom or
-        groups of (atom_number, bond) connected to atom or
-        groups of (atom_number, atom) connected to atom or
-        neighbors atoms connected to atom
-
-        :param atom: number
-        :param include_atom: include atom object
-        :param include_bond: include bond object
-        """
-        if include_atom:
-            atoms = self._atoms
-            if include_bond:
-                return tuple((n, bond, atoms[n]) for n, bond in self._bonds[atom].items())
-            return tuple((n, atoms[n]) for n in self._bonds[atom])
-        elif include_bond:
-            return tuple(self._bonds[atom].items())
-        return tuple(self._bonds[atom])
-
-    @cached_args_method
-    def neighbors(self, n: int) -> int:
-        """number of neighbors atoms excluding any-bonded"""
-        return sum(b.order != 8 for b in self._bonds[n].values())
-
-    @cached_args_method
-    def hybridization(self, n: int) -> int:
-        """
-        Atom hybridization.
-
-        1 - if atom has zero or only single bonded neighbors, 2 - if has only one double bonded neighbor and any amount
-        of single bonded, 3 - if has one triple bonded and any amount of double and single bonded neighbors or
-        two and more double bonded and any amount of single bonded neighbors, 4 - if atom in aromatic ring.
-        """
-        hybridization = 1
-        for bond in self._bonds[n].values():
-            order = bond.order
-            if order == 4:
-                return 4
-            elif order == 3:
-                if hybridization != 3:
-                    hybridization = 3
-            elif order == 2:
-                if hybridization == 1:
-                    hybridization = 2
-                elif hybridization == 2:
-                    hybridization = 3
-        return hybridization
-
-    @cached_args_method
-    def heteroatoms(self, n: int) -> int:
-        """
-        Number of neighbored heteroatoms (not carbon or hydrogen) except any-bond connected.
-        """
-        atoms = self._atoms
-        return sum(atoms[m].atomic_number not in (1, 6) for m, b in self._bonds[n].items() if b.order != 8)
-
-    def implicit_hydrogens(self, n: int) -> Optional[int]:
-        """
-        Number of implicit hydrogen atoms connected to atom.
-
-        Returns None if count are ambiguous.
-        """
-        return self._hydrogens[n]
-
-    @cached_args_method
-    def explicit_hydrogens(self, n: int) -> int:
-        """
-        Number of explicit hydrogen atoms connected to atom.
-
-        Take into account any type of bonds with hydrogen atoms.
-        """
-        atoms = self._atoms
-        return sum(atoms[m].atomic_number == 1 for m in self._bonds[n])
-
-    @cached_args_method
-    def total_hydrogens(self, n: int) -> int:
-        """
-        Number of hydrogen atoms connected to atom.
-
-        Take into account any type of bonds with hydrogen atoms.
-        """
-        return self._hydrogens[n] + self.explicit_hydrogens(n)
-
-    @cached_args_method
-    def adjacency_matrix(self, set_bonds=False, /):
-        """
-        Adjacency matrix of Graph.
-
-        :param set_bonds: if True set bond orders instead of 1.
-        """
-        adj = zeros((len(self), len(self)), dtype=uint)
-        mapping = {n: x for x, n in enumerate(self._atoms)}
-        if set_bonds:
-            for n, ms in self._bonds.items():
-                n = mapping[n]
-                for m, b in ms.items():
-                    adj[n, mapping[m]] = int(b)
-        else:
-            for n, ms in self._bonds.items():
-                n = mapping[n]
-                for m, b in ms.items():
-                    adj[n, mapping[m]] = 1
-        return adj
-
-    @cached_property
-    def molecular_charge(self) -> int:
-        """
-        Total charge of molecule
-        """
-        return sum(self._charges.values())
-
-    @cached_property
-    def is_radical(self) -> bool:
-        """
-        True if at least one atom is radical
-        """
-        return any(self._radicals.values())
-
-    @cached_property
-    def molecular_mass(self) -> float:
-        return sum(x.atomic_mass for x in self._atoms.values()) + sum(self._hydrogens.values()) * H().atomic_mass
-
-    @cached_property
-    def brutto(self) -> Dict[str, int]:
-        """Counted atoms dict"""
-        c = Counter(x.atomic_symbol for x in self._atoms.values())
-        c['H'] += sum(self._hydrogens.values())
-        return dict(c)
-
-    @cached_property
-    def aromatic_rings(self) -> Tuple[Tuple[int, ...], ...]:
-        """
-        Aromatic rings atoms numbers
-        """
-        bonds = self._bonds
-        return tuple(ring for ring in self.sssr if bonds[ring[0]][ring[-1]] == 4
-                     and all(bonds[n][m] == 4 for n, m in zip(ring, ring[1:])))
-
-    def add_atom(self, atom: Union[Element, int, str], *args, charge=0, is_radical=False,
-                 xy: Tuple[float, float] = (0., 0.), _skip_hydrogen_calculation=False, **kwargs):
-        """
-        Add new atom.
-        """
-        if not isinstance(atom, Element):
-            if isinstance(atom, str):
-                atom = Element.from_symbol(atom)()
-            elif isinstance(atom, int):
-                atom = Element.from_atomic_number(atom)()
-            else:
-                raise TypeError('Element object expected')
-        if not isinstance(xy, tuple) or len(xy) != 2 or not isinstance(xy[0], float) or not isinstance(xy[1], float):
-            raise TypeError('XY should be tuple with 2 float')
-
-        n = super().add_atom(atom, *args, charge=charge, is_radical=is_radical, **kwargs)
-        self._plane[n] = xy
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-
-        if _skip_hydrogen_calculation:
-            self._hydrogens[n] = None
-        elif atom.atomic_number != 1:
-            try:
-                rules = atom.valence_rules(charge, is_radical, 0)
-            except ValenceError:
-                self._hydrogens[n] = None
-            else:
-                self._hydrogens[n] = rules[0][2]  # first rule without neighbors
-        else:
-            self._hydrogens[n] = 0
-        return n
-
-    def add_bond(self, n, m, bond: Union[Bond, int], *, _skip_hydrogen_calculation=False):
-        """
-        Connect atoms with bonds.
-
-        For Thiele forms of molecule causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-        """
-        if not isinstance(bond, Bond):
-            bond = Bond(bond)
-
-        bond._attach_graph(self, n, m)
-        super().add_bond(n, m, bond)
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-
-        if _skip_hydrogen_calculation:  # skip stereo fixing too
-            return
-
-        self._calc_implicit(n)
-        self._calc_implicit(m)
-
-        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:  # not hydrogen
-            # fix stereo if formed not to hydrogen bond
-            self.fix_stereo()
-
-    def delete_atom(self, n: int):
-        """
-        Remove atom.
-
-        For Thiele forms of molecule causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-        """
-        ngb = self._bonds.pop(n)
-        fix = self._atoms.pop(n).atomic_number != 1 and ngb
-
-        del self._charges[n]
-        del self._radicals[n]
-        del self._hydrogens[n]
-        del self._plane[n]
-
-        for m in ngb:
-            del self._bonds[m][n]
-            self._calc_implicit(m)
-
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-        try:
-            del self._parsed_mapping[n]
-        except KeyError:
-            pass
-
-        if fix:  # hydrogen atom not used for stereo coding
-            self.fix_stereo()
-        self.flush_cache()
-
-    def delete_bond(self, n: int, m: int):
-        """
-        Disconnect atoms.
-
-        For Thiele forms of molecule causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-        """
-        del self._bonds[n][m]
-        del self._bonds[m][n]
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-
-        self._calc_implicit(n)
-        self._calc_implicit(m)
-
-        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:
-            self.fix_stereo()
-        self.flush_cache()
-
-    def remap(self, mapping: Dict[int, int], *, copy: bool = False) -> 'MoleculeContainer':
-        atoms = self._atoms  # keep original atoms dict
-        h = super().remap(mapping, copy=copy)
-
-        mg = mapping.get
-        sp = self._plane
-        shg = self._hydrogens
-
-        if copy:
-            h._MoleculeContainer__name = self.__name
-            if self.__meta is not None:
-                h._MoleculeContainer__meta = self.__meta.copy()
-            hb = h._bonds
-            hp = h._plane
-            hhg = h._hydrogens
-            hcf = h._conformers
-            hm = h._parsed_mapping
-
-            # deep copy of bonds
-            for n, m_bond in self._bonds.items():
-                n = mg(n, n)
-                hb[n] = hbn = {}
-                for m, bond in m_bond.items():
-                    m = mg(m, m)
-                    if m in hb:  # bond partially exists. need back-connection.
-                        hbn[m] = hb[m][n]
-                    else:
-                        hbn[m] = bond = bond.copy()
-                        bond._attach_graph(h, n, m)
-        else:
-            hb = {}
-            hp = {}
-            hhg = {}
-            hcf = []
-            hm = {}
-
-            for n, m_bond in self._bonds.items():
-                n = mg(n, n)
-                hb[n] = hbn = {}
-                for m, bond in m_bond.items():
-                    m = mg(m, m)
-                    if m in hb:  # bond partially exists. need back-connection.
-                        hbn[m] = hb[m][n]
-                    else:
-                        hbn[m] = bond
-                        bond._change_map(n, m)
-
-        for n in atoms:
-            m = mg(n, n)
-            hp[m] = sp[n]
-            hhg[m] = shg[n]
-
-        hcf.extend({mg(n, n): x for n, x in c.items()} for c in self._conformers)
-        for n, m in self._parsed_mapping.items():
-            hm[mg(n, n)] = m
-
-        if copy:
-            return h
-
-        self._bonds = hb
-        self._plane = hp
-        self._hydrogens = hhg
-        self._conformers = hcf
-        self._parsed_mapping = hm
-        return self
-
-    def copy(self) -> 'MoleculeContainer':
-        copy = super().copy()
-
-        copy._bonds = cb = {}
-        for n, m_bond in self._bonds.items():
-            cb[n] = cbn = {}
-            for m, bond in m_bond.items():
-                if m in cb:  # bond partially exists. need back-connection.
-                    cbn[m] = cb[m][n]
-                else:
-                    cbn[m] = bond = bond.copy()
-                    bond._attach_graph(copy, n, m)
-
-        copy._MoleculeContainer__name = self.__name
-        if self.__meta is None:
-            copy._MoleculeContainer__meta = None
-        else:
-            copy._MoleculeContainer__meta = self.__meta.copy()
-        copy._plane = self._plane.copy()
-        copy._hydrogens = self._hydrogens.copy()
-        copy._parsed_mapping = self._parsed_mapping.copy()
-        copy._conformers = [c.copy() for c in self._conformers]
-        copy._atoms_stereo = self._atoms_stereo.copy()
-        copy._allenes_stereo = self._allenes_stereo.copy()
-        copy._cis_trans_stereo = self._cis_trans_stereo.copy()
-        return copy
-
-    def union(self, other: 'MoleculeContainer', *, remap: bool = False, copy: bool = True) -> 'MoleculeContainer':
-        if not isinstance(other, MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-        u, o = super().union(other, remap=remap, copy=copy)
-
-        ub = u._bonds
-        for n, m_bond in o._bonds.items():
-            ub[n] = ubn = {}
-            for m, bond in m_bond.items():
-                if m in ub:  # bond partially exists. need back-connection.
-                    ubn[m] = ub[m][n]
-                else:
-                    ubn[m] = bond = bond.copy()
-                    bond._attach_graph(u, n, m)
-
-        u._MoleculeContainer__name = u._MoleculeContainer__meta = None
-        u._conformers.clear()
-        u._plane.update(o._plane)
-        u._hydrogens.update(o._hydrogens)
-        u._parsed_mapping.update(o._parsed_mapping)
-        return u
-
-    def substructure(self, atoms: Iterable[int], *, as_query: bool = False, recalculate_hydrogens=True,
-                     skip_neighbors_marks=False, skip_hybridizations_marks=False, skip_hydrogens_marks=False,
-                     skip_rings_sizes_marks=False, skip_heteroatoms_marks=False) -> \
-            Union['MoleculeContainer', 'QueryContainer']:
-        """
-        Create substructure containing atoms from atoms list.
-
-        For Thiele forms of molecule In Molecule substructure causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-
-        :param atoms: list of atoms numbers of substructure
-        :param as_query: return Query object based on graph substructure
-        :param recalculate_hydrogens: calculate implicit H count in substructure
-        :param skip_neighbors_marks: Don't set neighbors count marks on substructured queries
-        :param skip_hybridizations_marks: Don't set hybridizations marks on substructured queries
-        :param skip_hydrogens_marks: Don't set hydrogens count marks on substructured queries
-        :param skip_rings_sizes_marks: Don't set rings_sizes marks on substructured queries
-        :param skip_heteroatoms_marks: Don't set heteroatoms count marks
-        """
-        if not atoms:
-            raise ValueError('empty atoms list not allowed')
-        if set(atoms) - self._atoms.keys():
-            raise ValueError('invalid atom numbers')
-        atoms = tuple(n for n in self._atoms if n in atoms)  # save original order
-        if as_query:
-            atom_type = QueryElement
-            bond_type = QueryBond
-            sub = object.__new__(QueryContainer)
-        else:
-            atom_type = Element
-            bond_type = Bond
-            sub = object.__new__(self.__class__)
-            sub._MoleculeContainer__name = sub._MoleculeContainer__meta = None
-
-        sa = self._atoms
-        sb = self._bonds
-        sc = self._charges
-        sr = self._radicals
-
-        sub._charges = {n: sc[n] for n in atoms}
-        sub._radicals = {n: sr[n] for n in atoms}
-
-        sub._atoms = ca = {}
-        for n in atoms:
-            ca[n] = atom = atom_type.from_atom(sa[n])
-            atom._attach_graph(sub, n)
-
-        sub._bonds = cb = {}
-        for n in atoms:
-            cb[n] = cbn = {}
-            for m, bond in sb[n].items():
-                if m in cb:  # bond partially exists. need back-connection.
-                    cbn[m] = cb[m][n]
-                elif m in atoms:
-                    cbn[m] = bond = bond_type.from_bond(bond)
-                    if not as_query:
-                        bond._attach_graph(sub, n, m)
-
-        if as_query:
-            lost = {n for n, a in sa.items() if a.atomic_number != 1} - set(atoms)  # atoms not in substructure
-            not_skin = {n for n in atoms if lost.isdisjoint(sb[n])}
-            sub._atoms_stereo = {n: s for n, s in self._atoms_stereo.items() if n in not_skin}
-            sub._allenes_stereo = {n: s for n, s in self._allenes_stereo.items()
-                                   if not_skin.issuperset(self._stereo_allenes_paths[n]) and
-                                      not_skin.issuperset(x for x in self._stereo_allenes[n] if x)}
-            sub._cis_trans_stereo = {nm: s for nm, s in self._cis_trans_stereo.items()
-                                     if not_skin.issuperset(self._stereo_cis_trans_paths[nm]) and
-                                        not_skin.issuperset(x for x in self._stereo_cis_trans[nm] if x)}
-
-            sub._masked = {n: False for n in atoms}
-            if skip_heteroatoms_marks:
-                sub._heteroatoms = {n: () for n in atoms}
-            else:
-                sha = self.heteroatoms
-                sub._heteroatoms = {n: (sha(n),) for n in atoms}
-
-            if skip_hybridizations_marks:
-                sub._hybridizations = {n: () for n in atoms}
-            else:
-                sh = self.hybridization
-                sub._hybridizations = {n: (sh(n),) for n in atoms}
-            if skip_neighbors_marks:
-                sub._neighbors = {n: () for n in atoms}
-            else:
-                sn = self.neighbors
-                sub._neighbors = {n: (sn(n),) for n in atoms}
-            if skip_hydrogens_marks:
-                sub._hydrogens = {n: () for n in atoms}
-            else:
-                shg = self._hydrogens
-                sub._hydrogens = {n: () if shg[n] is None else (shg[n],) for n in atoms}
-            if skip_rings_sizes_marks:
-                sub._rings_sizes = {n: () for n in atoms}
-            else:
-                rs = self.atoms_rings_sizes
-                sub._rings_sizes = {n: rs.get(n, ()) for n in atoms}
-        else:
-            sub._conformers = [{n: c[n] for n in atoms} for c in self._conformers]
-
-            if recalculate_hydrogens:
-                sub._hydrogens = {}
-                for n in atoms:
-                    sub._calc_implicit(n)
-            else:
-                hg = self._hydrogens
-                sub._hydrogens = {n: hg[n] for n in atoms}
-
-            sp = self._plane
-            sub._plane = {n: sp[n] for n in atoms}
-            sub._parsed_mapping = {n: m for n, m in self._parsed_mapping.items() if n in atoms}
-
-            # fix_stereo will repair data
-            sub._atoms_stereo = self._atoms_stereo.copy()
-            sub._allenes_stereo = self._allenes_stereo.copy()
-            sub._cis_trans_stereo = self._cis_trans_stereo.copy()
-            sub.fix_stereo()
-        return sub
-
-    def augmented_substructure(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> 'MoleculeContainer':
-        """
-        Create substructure containing atoms and their neighbors
-
-        :param atoms: list of core atoms in graph
-        :param deep: number of bonds between atoms and neighbors
-        """
-        return self.substructure(self._augmented_substructure(atoms, deep)[-1], **kwargs)
-
-    def augmented_substructures(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> List['MoleculeContainer']:
-        """
-        Create list of substructures containing atoms and their neighbors
-
-        :param atoms: list of core atoms in graph
-        :param deep: number of bonds between atoms and neighbors
-        :return: list of graphs containing atoms, atoms + first circle, atoms + 1st + 2nd,
-            etc up to deep or while new nodes available
-        """
-        return [self.substructure(a, **kwargs) for a in self._augmented_substructure(atoms, deep)]
-
-    def split(self) -> List['MoleculeContainer']:
-        """
-        Split disconnected structure to connected substructures
-        """
-        return [self.substructure(c, recalculate_hydrogens=False) for c in self.connected_components]
-
-    def compose(self, other: 'MoleculeContainer') -> 'CGRContainer':
-        """
-        Compose 2 graphs to CGR.
-        """
-        if not isinstance(other, MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-        sa = self._atoms
-        sc = self._charges
-        sr = self._radicals
-        sb = self._bonds
-
-        bonds = []
-        adj = defaultdict(lambda: defaultdict(lambda: [None, None]))
-
-        oa = other._atoms
-        oc = other._charges
-        or_ = other._radicals
-        ob = other._bonds
-
-        common = sa.keys() & oa.keys()
-
-        h = CGRContainer()
-        ha = h._atoms
-        hb = h._bonds
-        hc = h._charges
-        hpc = h._p_charges
-        hr = h._radicals
-        hpr = h._p_radicals
-
-        for n in sa.keys() - common:  # cleavage atoms
-            hc[n] = hpc[n] = sc[n]
-            hr[n] = hpr[n] = sr[n]
-            hb[n] = {}
-            ha[n] = a = DynamicElement.from_atom(sa[n])
-            a._attach_graph(h, n)
-
-            for m, bond in sb[n].items():
-                if m not in ha:
-                    if m in common:  # bond to common atoms is broken bond
-                        bond = DynamicBond(bond.order, None)
-                    else:
-                        bond = DynamicBond(bond.order, bond.order)
-                    bonds.append((n, m, bond))
-        for n in oa.keys() - common:  # coupling atoms
-            hc[n] = hpc[n] = oc[n]
-            hr[n] = hpr[n] = or_[n]
-            hb[n] = {}
-            ha[n] = a = DynamicElement.from_atom(oa[n])
-            a._attach_graph(h, n)
-
-            for m, bond in ob[n].items():
-                if m not in ha:
-                    if m in common:  # bond to common atoms is formed bond
-                        bond = DynamicBond(None, bond.order)
-                    else:
-                        bond = DynamicBond(bond.order, bond.order)
-                    bonds.append((n, m, bond))
-        for n in common:
-            an = adj[n]
-            for m, bond in sb[n].items():
-                if m in common:
-                    an[m][0] = bond.order
-            for m, bond in ob[n].items():
-                if m in common:
-                    an[m][1] = bond.order
-        for n in common:
-            san = sa[n]
-            if san.atomic_number != oa[n].atomic_number or san.isotope != oa[n].isotope:
-                raise MappingError(f'atoms with number {n} not equal')
-
-            hc[n] = sc[n]
-            hpc[n] = oc[n]
-            hr[n] = sr[n]
-            hpr[n] = or_[n]
-            hb[n] = {}
-            ha[n] = a = DynamicElement.from_atom(san)
-            a._attach_graph(h, n)
-
-            for m, (o1, o2) in adj[n].items():
-                if m not in ha:
-                    bonds.append((n, m, DynamicBond(o1, o2)))
-
-        for n, m, bond in bonds:
-            hb[n][m] = hb[m][n] = bond
-        return h
-
-    def get_fast_mapping(self, other: 'MoleculeContainer') -> Optional[Dict[int, int]]:
-        """
-        Get self to other fast (suboptimal) structure mapping.
-        Only one possible atoms mapping returned.
-        Effective only for big molecules.
-        """
-        if isinstance(other, MoleculeContainer):
-            if len(self) != len(other):
-                return
-            so = self.smiles_atoms_order
-            oo = other.smiles_atoms_order
-            if self != other:
-                return
-            return dict(zip(so, oo))
-        raise TypeError('MoleculeContainer expected')
-
-    def pack(self, *, compressed=True, check=True, version=2, order: List[int] = None) -> bytes:
-        """
-        Pack into compressed bytes.
-
-        Note:
-
-        * Less than 4096 atoms supported. Atoms mapping should be in range 1-4095.
-        * Implicit hydrogens count should be in range 0-6 or unspecified.
-        * Isotope shift should be in range -15 - 15 relatively chython.files._mdl.mol.common_isotopes
-        * Atoms neighbors should be in range 0-15
-
-        Format V2 specification::
-
-            Big endian bytes order
-            8 bit - 0x02 (format specification version)
-            12 bit - number of atoms
-            12 bit - cis/trans stereo block size
-            Atom block 9 bytes (repeated):
-            12 bit - atom number
-            4 bit - number of neighbors
-            2 bit tetrahedron sign (00 - not stereo, 10 or 11 - has stereo)
-            2 bit - allene sign
-            5 bit - isotope (00000 - not specified, over = isotope - common_isotope + 16)
-            7 bit - atomic number (<=118)
-            32 bit - XY float16 coordinates
-            3 bit - hydrogens (0-7). Note: 7 == None
-            4 bit - charge (charge + 4. possible range -4 - 4)
-            1 bit - radical state
-            Connection table: flatten list of neighbors. neighbors count stored in atom block.
-            For example CC(=O)O - {1: [2], 2: [1, 3, 4], 3: [2], 4: [2]} >> [2, 1, 3, 4, 2, 2].
-            Repeated block (equal to bonds count).
-            24 bit - paired 12 bit numbers.
-            Bonds order block 3 bit per bond zero-padded to full byte at the end.
-            Cis/trans data block (repeated):
-            24 bit - atoms pair
-            7 bit - zero padding. in future can be used for extra bond-level stereo, like atropoisomers.
-            1 bit - sign
-
-        Format V3 specification::
-
-            Big endian bytes order
-            8 bit - 0x03 (format specification version)
-            Atom block 3 bytes (repeated):
-            1 bit - atom entrance flag (always 1)
-            7 bit - atomic number (<=118)
-            3 bit - hydrogens (0-7). Note: 7 == None
-            4 bit - charge (charge + 4. possible range -4 - 4)
-            1 bit - radical state
-            1 bit padding
-            3 bit tetrahedron/allene sign
-                (000 - not stereo or unknown, 001 - pure-unknown-enantiomer, 010 or 011 - has stereo)
-            4 bit - number of following bonds and CT blocks (0-15)
-
-            Bond block 2 bytes (repeated 0-15 times)
-            12 bit - negative shift from current atom to connected (e.g. 0x001 = -1 - connected to previous atom)
-            4 bit - bond order: 0000 - single, 0001 - double, 0010 - triple, 0011 - aromatic, 0111 - special
-
-            Cis-Trans 2 bytes
-            12 bit - negative shift from current atom to connected (e.g. 0x001 = -1 - connected to previous atom)
-            4 bit - CT sign: 1000 or 1001 - to avoid overlap with bond
-
-        V2 format is faster than V3. V3 format doesn't include isotopes, atom numbers and XY coordinates.
-
-        :param compressed: return zlib-compressed pack.
-        :param check: check molecule for format restrictions.
-        :param version: format version
-        :param order: atom order in V3
-        """
-        from ._pack import pack
-
-        if check:
-            bonds = self._bonds
-            if not bonds:
-                raise ValueError('Empty molecules not supported')
-            if max(bonds) > 4095:
-                raise ValueError('Big molecules not supported')
-            if any(len(x) > 15 for x in bonds.values()):
-                raise ValueError('To many neighbors not supported')
-
-        if version == 2:
-            data = pack(self)
-        elif version == 3:
-            data = self._cpack(order, check)
-        else:
-            raise ValueError('invalid specification version')
-        if compressed:
-            return compress(data, 9)
-        return data
-
-    @classmethod
-    def pack_len(cls, data: bytes, /, *, compressed=True) -> int:
-        """
-        Returns atoms count in molecule pack.
-        """
-        if compressed:
-            data = decompress(data)
-        if data[0] not in (0, 2):
-            raise ValueError('invalid pack header')
-        return int.from_bytes(data[1:3], 'big') >> 4
-
-    @classmethod
-    def unpack(cls, data: Union[bytes, memoryview], /, *, compressed=True,
-               _return_pack_length=False) -> 'MoleculeContainer':
-        """
-        Unpack from compressed bytes.
-
-        :param compressed: decompress data before processing.
-        """
-        from ._unpack import unpack
-        from ._cpack import unpack as cpack
-
-        if compressed:
-            data = decompress(data)
-        if data[0] in (0, 2):
-            (mapping, atom_numbers, isotopes, charges, radicals, hydrogens, plane, bonds,
-             atoms_stereo, allenes_stereo, cis_trans_stereo, pack_length, bonds_flat) = unpack(data)
-        elif data[0] == 3:
-            (mapping, atom_numbers, isotopes, charges, radicals, hydrogens, plane, bonds,
-             atoms_stereo, allenes_stereo, cis_trans_stereo, pack_length, bonds_flat) = cpack(data)
-        else:
-            raise ValueError('invalid pack header')
-
-        mol = object.__new__(cls)
-        mol._bonds = bonds
-        mol._plane = plane
-        mol._charges = charges
-        mol._radicals = radicals
-        mol._hydrogens = hydrogens
-        mol._atoms_stereo = atoms_stereo
-        mol._allenes_stereo = allenes_stereo
-        mol._cis_trans_stereo = cis_trans_stereo
-
-        mol._conformers = []
-        mol._parsed_mapping = {}
-        mol._MoleculeContainer__meta = None
-        mol._MoleculeContainer__name = None
-        mol._atoms = atoms = {}
-
-        for n, a, i in zip(mapping, atom_numbers, isotopes):
-            atoms[n] = a = object.__new__(Element.from_atomic_number(a))
-            a._Core__isotope = i
-            a._graph = ref(mol)
-            a._n = n
-        for b in bonds_flat:
-            b._Bond__graph = ref(mol)
-
-        if _return_pack_length:
-            return mol, pack_length
-        return mol
-
-    def _cpack(self, order=None, check=True):
-        if order is None:
-            order = list(self._atoms)
-        elif check:
-            if not isinstance(order, (list, tuple)):
-                raise TypeError('invalid atoms order')
-            elif len(so := set(order)) != len(order) or not so.issubset(self._atoms):
-                raise ValueError('invalid atoms order')
-
-        atoms = self._atoms
-        bonds = self._bonds
-        charges = self._charges
-        radicals = self._radicals
-        hydrogens = self._hydrogens
-        atoms_stereo = self._atoms_stereo
-        allenes_stereo = self._allenes_stereo
-        allenes_terminals = self._stereo_allenes_terminals
-
-        cumulenes = {}
-        ct_map = {}
-        for n, m in self._cis_trans_stereo:
-            ct_map[n] = m
-            ct_map[m] = n
-            cumulenes[n] = [x for x, b in bonds[n].items() if b.order in (1, 4)]
-            cumulenes[m] = [x for x, b in bonds[m].items() if b.order in (1, 4)]
-
-        for c in self._allenes_stereo:
-            n, m = allenes_terminals[c]
-            cumulenes[n] = [x for x, b in bonds[n].items() if b.order in (1, 4)]
-            cumulenes[m] = [x for x, b in bonds[m].items() if b.order in (1, 4)]
-
-        seen = {}
-        data = [b'\x03']
-        for i, n in enumerate(order):
-            seen[n] = i
-            env = bonds[n]
-
-            data.append((0x80 | atoms[n].atomic_number).to_bytes(1, 'big'))
-
-            # 3 bit - hydrogens (0-6, None) | 4 bit - charge | 1 bit - radical
-            hcr = (charges[n] + 4) << 1 | radicals[n]
-            if (h := hydrogens[n]) is None:
-                hcr |= 0b11100000
-            else:
-                hcr |= h << 5
-            data.append(hcr.to_bytes(1, 'big'))
-
-            if n in atoms_stereo:
-                if self._translate_tetrahedron_sign(n, [x for x in order if x in env]):
-                    s = 0b0011_0000
-                else:
-                    s = 0b0010_0000
-            elif n in allenes_stereo:
-                t1, t2 = allenes_terminals[n]
-                nn = None
-                for x in order:
-                    if nn is None:
-                        if x in cumulenes[t1]:
-                            nn = x
-                            flag = True
-                        elif x in cumulenes[t2]:
-                            flag = False
-                            nn = x
-                    elif flag:  # noqa
-                        if x in cumulenes[t2]:
-                            nm = x
-                            break
-                    elif x in cumulenes[t1]:
-                        nm = x
-                        break
-                if self._translate_allene_sign(n, nn, nm):  # noqa
-                    s = 0b0011_0000
-                else:
-                    s = 0b0010_0000
-            else:
-                s = 0
-
-            tmp = []
-            for m in order[:i]:
-                if (b := env.get(m)) is not None:
-                    tmp.append(((i - seen[m]) << 4 | b.order - 1).to_bytes(2, 'big'))
-            if n in ct_map and (m := ct_map[n]) in seen:  # only right atom codes stereo sign
-                nm = None
-                for x in order:
-                    if nm is None:
-                        if x in cumulenes[n]:
-                            nm = x
-                            flag = True
-                        elif x in cumulenes[m]:
-                            nm = x
-                            flag = False
-                    elif flag:  # noqa
-                        if x in cumulenes[m]:
-                            nn = x
-                            break
-                    elif x in cumulenes[n]:
-                        nn = x
-                        break
-                if self._translate_cis_trans_sign(m, n, nm, nn):  # noqa
-                    cs = 0b1001
-                else:
-                    cs = 0b1000
-                tmp.append(((i - seen[m]) << 4 | cs).to_bytes(2, 'big'))
-
-            data.append((s | len(tmp)).to_bytes(1, 'big'))
-            data.extend(tmp)
-        return b''.join(data)
-
-    def _augmented_substructure(self, atoms: Iterable[int], deep: int):
-        atoms = set(atoms)
-        bonds = self._bonds
-        if atoms - self._atoms.keys():
-            raise ValueError('invalid atom numbers')
-        nodes = [atoms]
-        for _ in range(deep):
-            n = {y for x in nodes[-1] for y in bonds[x]} | nodes[-1]
-            if n in nodes:
-                break
-            nodes.append(n)
-        return nodes
-
-    def _calc_implicit(self, n: int):
-        """
-        Set firs possible hydrogens count based on rules
-        """
-        atoms = self._atoms
-        atom = atoms[n]
-        if (an := atom.atomic_number) == 1:  # hydrogen nether has implicit H
-            self._hydrogens[n] = 0
-            return
-
-        charge: int = self._charges[n]
-        is_radical = self._radicals[n]
-        explicit_sum = 0
-        explicit_dict = defaultdict(int)
-        aroma = 0
-        for m, bond in self._bonds[n].items():
-            order = bond.order
-            if order == 4:  # only neutral carbon aromatic rings supported
-                if not charge and not is_radical and an == 6:
-                    aroma += 1
-                else:  # use `kekule()` to calculate proper implicit hydrogens count
-                    self._hydrogens[n] = None
-                    return
-            elif order != 8:  # any bond used for complexes
-                explicit_sum += order
-                explicit_dict[(order, atoms[m].atomic_number)] += 1
-
-        if aroma == 2:
-            if explicit_sum == 0:  # H-Ar
-                self._hydrogens[n] = 1
-            elif explicit_sum == 1:  # R-Ar
-                self._hydrogens[n] = 0
-            else:  # invalid aromaticity
-                self._hydrogens[n] = None
-            return
-        elif aroma == 3:  # condensed rings
-            if explicit_sum:  # invalid aromaticity
-                self._hydrogens[n] = None
-            else:
-                self._hydrogens[n] = 0
-            return
-        elif aroma:
-            self._hydrogens[n] = None
-            return
-
-        try:
-            rules = atom.valence_rules(charge, is_radical, explicit_sum)
-        except ValenceError:
-            self._hydrogens[n] = None
-            return
-        for s, d, h in rules:
-            if s.issubset(explicit_dict) and all(explicit_dict[k] >= c for k, c in d.items()):
-                self._hydrogens[n] = h
-                return
-        self._hydrogens[n] = None  # rule not found
-
-    def _check_implicit(self, n: int, h: int) -> bool:
-        atoms = self._atoms
-        atom = atoms[n]
-        if atom.atomic_number == 1:  # hydrogen nether has implicit H
-            return h == 0
-
-        explicit_sum = 0
-        explicit_dict = defaultdict(int)
-
-        for m, bond in self._bonds[n].items():
-            order = bond.order
-            if order == 4:  # can't check aromatic rings
-                return False
-            elif order != 8:  # any bond used for complexes
-                explicit_sum += order
-                explicit_dict[(order, atoms[m].atomic_number)] += 1
-
-        try:
-            rules = atom.valence_rules(self._charges[n], self._radicals[n], explicit_sum)
-        except ValenceError:
-            return False
-        for s, d, _h in rules:
-            if h == _h and s.issubset(explicit_dict) and all(explicit_dict[k] >= c for k, c in d.items()):
-                return True
-        return False
-
-    def __int__(self):
-        """
-        Total charge of molecule
-        """
-        return self.molecular_charge
-
-    def __float__(self):
-        return self.molecular_mass
-
-    def __xor__(self, other):
-        """
-        G ^ H is CGR generation
-        """
-        return self.compose(other)
-
-    def __and__(self, other: Iterable[int]):
-        """
-        Substructure of graph with given nodes.
-        """
-        return self.substructure(other)
-
-    def __sub__(self, other: Iterable[int]):
-        """
-        Given nodes excluded substructure of graph.
-        """
-        atoms = set(other)
-        if atoms - self._atoms.keys():
-            raise ValueError('invalid atom numbers')
-        atoms = self._atoms.keys() - atoms
-        if atoms:
-            return self.substructure(atoms)
-        raise ValueError('full substitution not allowed')
-
-    def __enter__(self):
-        """
-        Transaction of changes. Keep current state for restoring on errors.
-        """
-        atoms = {}
-        for n, atom in self._atoms.items():
-            atom = atom.copy()
-            atoms[n] = atom
-            atom._attach_graph(self, n)
-
-        bonds = {}
-        for n, m_bond in self._bonds.items():
-            bonds[n] = cbn = {}
-            for m, bond in m_bond.items():
-                if m in bonds:  # bond partially exists. need back-connection.
-                    cbn[m] = bonds[m][n]
-                else:
-                    cbn[m] = bond = bond.copy()
-                    bond._attach_graph(self, n, m)
-
-        self._backup = {'atoms': atoms, 'bonds': bonds, 'parsed_mapping': self._parsed_mapping.copy(),
-                        'plane': self._plane.copy(), 'charges': self._charges.copy(), 'radicals': self._radicals.copy(),
-                        'hydrogens': self._hydrogens.copy(), 'conformers': [x.copy() for x in self._conformers],
-                        'atoms_stereo': self._atoms_stereo.copy(), 'allenes_stereo': self._allenes_stereo.copy(),
-                        'cis_trans_stereo': self._cis_trans_stereo.copy()}
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        if exc_type:  # restore state
-            backup = self._backup
-            self._atoms = backup['atoms']
-            self._bonds = backup['bonds']
-            self._parsed_mapping = backup['parsed_mapping']
-            self._plane = backup['plane']
-            self._charges = backup['charges']
-            self._radicals = backup['radicals']
-            self._hydrogens = backup['hydrogens']
-            self._conformers = backup['conformers']
-            self._atoms_stereo = backup['atoms_stereo']
-            self._allenes_stereo = backup['allenes_stereo']
-            self._cis_trans_stereo = backup['cis_trans_stereo']
-            self.flush_cache()
-        del self._backup
-
-    def __getstate__(self):
-        return {'conformers': self._conformers, 'hydrogens': self._hydrogens, 'atoms_stereo': self._atoms_stereo,
-                'allenes_stereo': self._allenes_stereo, 'cis_trans_stereo': self._cis_trans_stereo,
-                'parsed_mapping': self._parsed_mapping, 'meta': self.__meta, 'name': self.__name,
-                'plane': self._plane, **super().__getstate__()}
-
-    def __setstate__(self, state):
-        super().__setstate__(state)
-        self._conformers = state['conformers']
-        self._atoms_stereo = state['atoms_stereo']
-        self._allenes_stereo = state['allenes_stereo']
-        self._cis_trans_stereo = state['cis_trans_stereo']
-        self._hydrogens = state['hydrogens']
-        self._parsed_mapping = state['parsed_mapping']
-        self._plane = state['plane']
-        self.__meta = state['meta']
-        self.__name = state['name']
-
-        # attach bonds to graph
-        for n, m, b in self.bonds():
-            b._attach_graph(self, n, m)
-
-
-__all__ = ['MoleculeContainer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from array import array
+from CachedMethods import cached_args_method
+from collections import Counter, defaultdict
+from functools import cached_property
+from itertools import zip_longest
+from math import ceil
+from numpy import uint, zeros
+from struct import pack_into, unpack_from
+from typing import Dict, Iterable, List, Optional, Set, Tuple, Union
+from weakref import ref
+from zlib import compress, decompress
+from . import cgr, query  # cyclic imports resolve
+from .bonds import Bond, DynamicBond, QueryBond
+from .graph import Graph
+from ..algorithms.aromatics import Aromatize
+from ..algorithms.calculate2d import Calculate2DMolecule
+from ..algorithms.depict import DepictMolecule
+from ..algorithms.fingerprints import Fingerprints
+from ..algorithms.huckel import Huckel
+from ..algorithms.mcs import MCS
+from ..algorithms.smiles import MoleculeSmiles
+from ..algorithms.standardize import StandardizeMolecule
+from ..algorithms.stereo import MoleculeStereo
+from ..algorithms.tautomers import Tautomers
+from ..algorithms.x3dom import X3domMolecule
+from ..exceptions import MappingError, ValenceError
+from ..periodictable import DynamicElement, Element, QueryElement
+
+
+class MoleculeContainer(MoleculeStereo, Graph[Element, Bond], Aromatize, StandardizeMolecule, MoleculeSmiles,
+                        DepictMolecule, Calculate2DMolecule, Fingerprints, Tautomers, MCS, Huckel, X3domMolecule):
+    __slots__ = ('_conformers', '_atoms_stereo', '_hydrogens', '_cis_trans_stereo', '_allenes_stereo',
+                 '_parsed_mapping', '_backup', '__meta', '__name')
+
+    def __init__(self):
+        super().__init__()
+        self._conformers: List[Dict[int, Tuple[float, float, float]]] = []
+        self._hydrogens: Dict[int, Optional[int]] = {}
+        self._atoms_stereo: Dict[int, bool] = {}
+        self._allenes_stereo: Dict[int, bool] = {}
+        self._cis_trans_stereo: Dict[Tuple[int, int], bool] = {}
+        self._parsed_mapping: Dict[int, int] = {}
+        self.__meta = None
+        self.__name = None
+
+    @property
+    def meta(self) -> Dict:
+        if self.__meta is None:
+            self.__meta = {}  # lazy
+        return self.__meta
+
+    @property
+    def name(self) -> str:
+        return self.__name or ''
+
+    @name.setter
+    def name(self, name):
+        if not isinstance(name, str):
+            raise TypeError('name should be string up to 80 symbols')
+        self.__name = name
+
+    @cached_args_method
+    def environment(self, atom: int, include_bond: bool = True, include_atom: bool = True) -> \
+            Tuple[Union[Tuple[int, Bond, Element],
+                        Tuple[int, Element],
+                        Tuple[int, Bond],
+                        int], ...]:
+        """
+        groups of (atom_number, bond, atom) connected to atom or
+        groups of (atom_number, bond) connected to atom or
+        groups of (atom_number, atom) connected to atom or
+        neighbors atoms connected to atom
+
+        :param atom: number
+        :param include_atom: include atom object
+        :param include_bond: include bond object
+        """
+        if include_atom:
+            atoms = self._atoms
+            if include_bond:
+                return tuple((n, bond, atoms[n]) for n, bond in self._bonds[atom].items())
+            return tuple((n, atoms[n]) for n in self._bonds[atom])
+        elif include_bond:
+            return tuple(self._bonds[atom].items())
+        return tuple(self._bonds[atom])
+
+    @cached_args_method
+    def neighbors(self, n: int) -> int:
+        """number of neighbors atoms excluding any-bonded"""
+        return sum(b.order != 8 for b in self._bonds[n].values())
+
+    @cached_args_method
+    def hybridization(self, n: int) -> int:
+        """
+        Atom hybridization.
+
+        1 - if atom has zero or only single bonded neighbors, 2 - if has only one double bonded neighbor and any amount
+        of single bonded, 3 - if has one triple bonded and any amount of double and single bonded neighbors or
+        two and more double bonded and any amount of single bonded neighbors, 4 - if atom in aromatic ring.
+        """
+        hybridization = 1
+        for bond in self._bonds[n].values():
+            order = bond.order
+            if order == 4:
+                return 4
+            elif order == 3:
+                if hybridization != 3:
+                    hybridization = 3
+            elif order == 2:
+                if hybridization == 1:
+                    hybridization = 2
+                elif hybridization == 2:
+                    hybridization = 3
+        return hybridization
+
+    @cached_args_method
+    def heteroatoms(self, n: int) -> int:
+        """
+        Number of neighbored heteroatoms (not carbon or hydrogen)
+        """
+        atoms = self._atoms
+        return sum(atoms[m].atomic_number not in (1, 6) for m in self._bonds[n])
+
+    def implicit_hydrogens(self, n: int) -> Optional[int]:
+        """
+        Number of implicit hydrogen atoms connected to atom.
+
+        Returns None if count are ambiguous.
+        """
+        return self._hydrogens[n]
+
+    @cached_args_method
+    def explicit_hydrogens(self, n: int) -> int:
+        """
+        Number of explicit hydrogen atoms connected to atom.
+
+        Take into account any type of bonds with hydrogen atoms.
+        """
+        atoms = self._atoms
+        return sum(atoms[m].atomic_number == 1 for m in self._bonds[n])
+
+    @cached_args_method
+    def total_hydrogens(self, n: int) -> int:
+        """
+        Number of hydrogen atoms connected to atom.
+
+        Take into account any type of bonds with hydrogen atoms.
+        """
+        return self._hydrogens[n] + self.explicit_hydrogens(n)
+
+    def adjacency_matrix(self, set_bonds=False):
+        """
+        Adjacency matrix of Graph.
+
+        :param set_bonds: if True set bond orders instead of 1.
+        """
+        adj = zeros((len(self), len(self)), dtype=uint)
+        mapping = {n: x for x, n in enumerate(self._atoms)}
+        if set_bonds:
+            for n, ms in self._bonds.items():
+                n = mapping[n]
+                for m, b in ms.items():
+                    adj[n, mapping[m]] = int(b)
+        else:
+            for n, ms in self._bonds.items():
+                n = mapping[n]
+                for m, b in ms.items():
+                    adj[n, mapping[m]] = 1
+        return adj
+
+    @cached_property
+    def molecular_charge(self) -> int:
+        """
+        Total charge of molecule
+        """
+        return sum(self._charges.values())
+
+    @cached_property
+    def is_radical(self) -> bool:
+        """
+        True if at least one atom is radical
+        """
+        return any(self._radicals.values())
+
+    @cached_property
+    def molecular_mass(self) -> float:
+        return sum(x.atomic_mass for x in self._atoms.values())
+
+    @cached_property
+    def brutto(self) -> Dict[str, int]:
+        """Counted atoms dict"""
+        return Counter(x.atomic_symbol for x in self._atoms.values())
+
+    def add_atom(self, atom: Union[Element, int, str], *args, charge=0, is_radical=False, **kwargs):
+        """
+        Add new atom.
+        """
+        if not isinstance(atom, Element):
+            if isinstance(atom, str):
+                atom = Element.from_symbol(atom)()
+            elif isinstance(atom, int):
+                atom = Element.from_atomic_number(atom)()
+            else:
+                raise TypeError('Element object expected')
+
+        _map = super().add_atom(atom, *args, charge=charge, is_radical=is_radical, **kwargs)
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+
+        if atom.atomic_number != 1:
+            try:
+                rules = atom.valence_rules(charge, is_radical, 0)
+            except ValenceError:
+                self._hydrogens[_map] = None
+            else:
+                self._hydrogens[_map] = rules[0][2]  # first rule without neighbors
+        else:
+            self._hydrogens[_map] = 0
+        return _map
+
+    def add_bond(self, n, m, bond: Union[Bond, int]):
+        """
+        Connect atoms with bonds.
+
+        For Thiele forms of molecule causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+        """
+        if not isinstance(bond, Bond):
+            bond = Bond(bond)
+
+        super().add_bond(n, m, bond)
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+
+        self._calc_implicit(n)
+        self._calc_implicit(m)
+
+        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:  # not hydrogen
+            # fix stereo if formed not to hydrogen bond
+            self.fix_stereo()
+
+    def delete_atom(self, n):
+        """
+        Remove atom.
+
+        For Thiele forms of molecule causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+        """
+        old_bonds = self._bonds[n]  # save bonds
+        isnt_hydrogen = self._atoms[n].atomic_number != 1
+        super().delete_atom(n)
+
+        del self._hydrogens[n]
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+        try:
+            del self._parsed_mapping[n]
+        except KeyError:
+            pass
+
+        for m in old_bonds:
+            self._calc_implicit(m)
+
+        if isnt_hydrogen:  # hydrogen atom not used for stereo coding
+            self.fix_stereo()
+
+    def delete_bond(self, n, m):
+        """
+        Disconnect atoms.
+
+        For Thiele forms of molecule causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+        """
+        super().delete_bond(n, m)
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+
+        self._calc_implicit(n)
+        self._calc_implicit(m)
+
+        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:
+            self.fix_stereo()
+
+    def remap(self, mapping: Dict[int, int], *, copy: bool = False) -> 'MoleculeContainer':
+        if len(mapping) != len(set(mapping.values())) or \
+                not (self._atoms.keys() - mapping.keys()).isdisjoint(mapping.values()):
+            raise ValueError('mapping overlap')
+
+        mg = mapping.get
+        sp = self._plane
+        sc = self._charges
+        sr = self._radicals
+        shg = self._hydrogens
+
+        if copy:
+            h = self.__class__()
+            h._MoleculeContainer__name = self.__name
+            if self.__meta is not None:
+                h._MoleculeContainer__meta = self.__meta.copy()
+            hb = h._bonds
+            ha = h._atoms
+            hc = h._charges
+            hr = h._radicals
+            hp = h._plane
+            hhg = h._hydrogens
+            hcf = h._conformers
+            has = h._atoms_stereo
+            hal = h._allenes_stereo
+            hcs = h._cis_trans_stereo
+            hm = h._parsed_mapping
+
+            for n, atom in self._atoms.items():
+                m = mg(n, n)
+                atom = atom.copy()
+                ha[m] = atom
+                atom._attach_to_graph(h, m)
+
+            # deep copy of bonds
+            for n, m_bond in self._bonds.items():
+                n = mg(n, n)
+                hb[n] = hbn = {}
+                for m, bond in m_bond.items():
+                    m = mg(m, m)
+                    if m in hb:  # bond partially exists. need back-connection.
+                        hbn[m] = hb[m][n]
+                    else:
+                        hbn[m] = bond.copy()
+        else:
+            hb = {}
+            ha = {}
+            hc = {}
+            hr = {}
+            hp = {}
+            hhg = {}
+            hcf = []
+            has = {}
+            hal = {}
+            hcs = {}
+            hm = {}
+            for n, atom in self._atoms.items():
+                m = mg(n, n)
+                ha[m] = atom
+                atom._change_map(m)  # change mapping number
+
+            for n, m_bond in self._bonds.items():
+                hb[mg(n, n)] = {mg(m, m): b for m, b in m_bond.items()}
+
+        for n in self._atoms:
+            m = mg(n, n)
+            hc[m] = sc[n]
+            hr[m] = sr[n]
+            hp[m] = sp[n]
+            hhg[m] = shg[n]
+
+        hcf.extend({mg(n, n): x for n, x in c.items()} for c in self._conformers)
+        for n, m in self._parsed_mapping.items():
+            hm[mg(n, n)] = m
+        for n, stereo in self._atoms_stereo.items():
+            has[mg(n, n)] = stereo
+        for n, stereo in self._allenes_stereo.items():
+            hal[mg(n, n)] = stereo
+        for (n, m), stereo in self._cis_trans_stereo.items():
+            hcs[(mg(n, n), mg(m, m))] = stereo
+
+        if copy:
+            return h
+
+        self._atoms = ha
+        self._bonds = hb
+        self._charges = hc
+        self._radicals = hr
+        self._plane = hp
+        self._hydrogens = hhg
+        self._conformers = hcf
+        self._atoms_stereo = has
+        self._allenes_stereo = hal
+        self._cis_trans_stereo = hcs
+        self._parsed_mapping = hm
+        self.flush_cache()
+        return self
+
+    def copy(self) -> 'MoleculeContainer':
+        copy = super().copy()
+        copy._MoleculeContainer__name = self.__name
+        if self.__meta is None:
+            copy._MoleculeContainer__meta = None
+        else:
+            copy._MoleculeContainer__meta = self.__meta.copy()
+        copy._hydrogens = self._hydrogens.copy()
+        copy._parsed_mapping = self._parsed_mapping.copy()
+        copy._conformers = [c.copy() for c in self._conformers]
+        copy._atoms_stereo = self._atoms_stereo.copy()
+        copy._allenes_stereo = self._allenes_stereo.copy()
+        copy._cis_trans_stereo = self._cis_trans_stereo.copy()
+        return copy
+
+    def union(self, other: 'MoleculeContainer', *, remap=False) -> 'MoleculeContainer':
+        """
+        :param remap: if atoms has collisions then remap other graph atoms else raise exception.
+        """
+        if not isinstance(other, MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+        elif self._atoms.keys() & other._atoms.keys():
+            if remap:
+                other = other.remap({n: i for i, n in enumerate(other, start=max(self._atoms) + 1)}, copy=True)
+            else:
+                raise MappingError('mapping of graphs is not disjoint')
+        u = super().union(other)
+        u._MoleculeContainer__name = u._MoleculeContainer__meta = None
+        u._conformers.clear()
+        u._hydrogens.update(other._hydrogens)
+        u._parsed_mapping.update(other._parsed_mapping)
+        u._atoms_stereo.update(other._atoms_stereo)
+        u._allenes_stereo.update(other._allenes_stereo)
+        u._cis_trans_stereo.update(other._cis_trans_stereo)
+        return u
+
+    def substructure(self, atoms: Iterable[int], *, as_query: bool = False, recalculate_hydrogens=True,
+                     skip_neighbors_marks=False, skip_hybridizations_marks=False, skip_hydrogens_marks=False,
+                     skip_rings_sizes_marks=False,) -> Union['MoleculeContainer', 'query.QueryContainer']:
+        """
+        Create substructure containing atoms from atoms list.
+
+        For Thiele forms of molecule In Molecule substructure causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+
+        :param atoms: list of atoms numbers of substructure
+        :param as_query: return Query object based on graph substructure
+        :param recalculate_hydrogens: calculate implicit H count in substructure
+        :param skip_neighbors_marks: Don't set neighbors count marks on substructured queries
+        :param skip_hybridizations_marks: Don't set hybridizations marks on substructured queries
+        :param skip_hydrogens_marks: Don't set hydrogens count marks on substructured queries
+        :param skip_rings_sizes_marks: Don't set rings_sizes marks on substructured queries
+        """
+        if not atoms:
+            raise ValueError('empty atoms list not allowed')
+        if set(atoms) - self._atoms.keys():
+            raise ValueError('invalid atom numbers')
+        atoms = tuple(n for n in self._atoms if n in atoms)  # save original order
+        if as_query:
+            atom_type = QueryElement
+            bond_type = QueryBond
+            sub = object.__new__(query.QueryContainer)
+        else:
+            atom_type = Element
+            bond_type = Bond
+            sub = object.__new__(self.__class__)
+            sub._MoleculeContainer__name = sub._MoleculeContainer__meta = None
+
+        sa = self._atoms
+        sb = self._bonds
+        sc = self._charges
+        sr = self._radicals
+        sp = self._plane
+
+        sub._charges = {n: sc[n] for n in atoms}
+        sub._radicals = {n: sr[n] for n in atoms}
+        sub._plane = {n: sp[n] for n in atoms}
+
+        sub._atoms = ca = {}
+        for n in atoms:
+            ca[n] = atom = atom_type.from_atom(sa[n])
+            atom._attach_to_graph(sub, n)
+
+        sub._bonds = cb = {}
+        for n in atoms:
+            cb[n] = cbn = {}
+            for m, bond in sb[n].items():
+                if m in cb:  # bond partially exists. need back-connection.
+                    cbn[m] = cb[m][n]
+                elif m in atoms:
+                    cbn[m] = bond_type.from_bond(bond)
+
+        if as_query:
+            lost = {n for n, a in sa.items() if a.atomic_number != 1} - set(atoms)  # atoms not in substructure
+            not_skin = {n for n in atoms if lost.isdisjoint(sb[n])}
+            sub._atoms_stereo = {n: s for n, s in self._atoms_stereo.items() if n in not_skin}
+            sub._allenes_stereo = {n: s for n, s in self._allenes_stereo.items()
+                                   if not_skin.issuperset(self._stereo_allenes_paths[n]) and
+                                      not_skin.issuperset(x for x in self._stereo_allenes[n] if x)}
+            sub._cis_trans_stereo = {nm: s for nm, s in self._cis_trans_stereo.items()
+                                     if not_skin.issuperset(self._stereo_cis_trans_paths[nm]) and
+                                        not_skin.issuperset(x for x in self._stereo_cis_trans[nm] if x)}
+
+            sub._heteroatoms = {n: () for n in atoms}
+
+            if skip_hybridizations_marks:
+                sub._hybridizations = {n: () for n in atoms}
+            else:
+                sh = self.hybridization
+                sub._hybridizations = {n: (sh(n),) for n in atoms}
+            if skip_neighbors_marks:
+                sub._neighbors = {n: () for n in atoms}
+            else:
+                sn = self.neighbors
+                sub._neighbors = {n: (sn(n),) for n in atoms}
+            if skip_hydrogens_marks:
+                sub._hydrogens = {n: () for n in atoms}
+            else:
+                shg = self._hydrogens
+                sub._hydrogens = {n: () if shg[n] is None else (shg[n],) for n in atoms}
+            if skip_rings_sizes_marks:
+                sub._rings_sizes = {n: () for n in atoms}
+            else:
+                rs = self.atoms_rings_sizes
+                sub._rings_sizes = {n: rs.get(n, ()) for n in atoms}
+        else:
+            sub._conformers = [{n: c[n] for n in atoms} for c in self._conformers]
+
+            if recalculate_hydrogens:
+                sub._hydrogens = {}
+                for n in atoms:
+                    sub._calc_implicit(n)
+            else:
+                hg = self._hydrogens
+                sub._hydrogens = {n: hg[n] for n in atoms}
+
+            sub._parsed_mapping = {n: m for n, m in self._parsed_mapping.items() if n in atoms}
+
+            # fix_stereo will repair data
+            sub._atoms_stereo = self._atoms_stereo.copy()
+            sub._allenes_stereo = self._allenes_stereo.copy()
+            sub._cis_trans_stereo = self._cis_trans_stereo.copy()
+            sub.fix_stereo()
+        return sub
+
+    def augmented_substructure(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> 'MoleculeContainer':
+        """
+        Create substructure containing atoms and their neighbors
+
+        :param atoms: list of core atoms in graph
+        :param deep: number of bonds between atoms and neighbors
+        """
+        return self.substructure(self._augmented_substructure(atoms, deep)[-1], **kwargs)
+
+    def augmented_substructures(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> List['MoleculeContainer']:
+        """
+        Create list of substructures containing atoms and their neighbors
+
+        :param atoms: list of core atoms in graph
+        :param deep: number of bonds between atoms and neighbors
+        :return: list of graphs containing atoms, atoms + first circle, atoms + 1st + 2nd,
+            etc up to deep or while new nodes available
+        """
+        return [self.substructure(a, **kwargs) for a in self._augmented_substructure(atoms, deep)]
+
+    def split(self) -> List['MoleculeContainer']:
+        """
+        Split disconnected structure to connected substructures
+        """
+        return [self.substructure(c, recalculate_hydrogens=False) for c in self.connected_components]
+
+    def compose(self, other: 'MoleculeContainer') -> 'cgr.CGRContainer':
+        """
+        Compose 2 graphs to CGR.
+        """
+        if not isinstance(other, MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+        sa = self._atoms
+        sc = self._charges
+        sr = self._radicals
+        sp = self._plane
+        sb = self._bonds
+
+        bonds = []
+        adj = defaultdict(lambda: defaultdict(lambda: [None, None]))
+
+        oa = other._atoms
+        oc = other._charges
+        or_ = other._radicals
+        op = other._plane
+        ob = other._bonds
+
+        common = sa.keys() & oa.keys()
+
+        h = cgr.CGRContainer()
+        ha = h._atoms
+        hb = h._bonds
+        hc = h._charges
+        hpc = h._p_charges
+        hr = h._radicals
+        hpr = h._p_radicals
+        hp = h._plane
+
+        for n in sa.keys() - common:  # cleavage atoms
+            hc[n] = hpc[n] = sc[n]
+            hr[n] = hpr[n] = sr[n]
+            hp[n] = sp[n]
+            hb[n] = {}
+            ha[n] = a = DynamicElement.from_atom(sa[n])
+            a._attach_to_graph(h, n)
+
+            for m, bond in sb[n].items():
+                if m not in ha:
+                    if m in common:  # bond to common atoms is broken bond
+                        bond = DynamicBond(bond.order, None)
+                    else:
+                        bond = DynamicBond(bond.order, bond.order)
+                    bonds.append((n, m, bond))
+        for n in oa.keys() - common:  # coupling atoms
+            hc[n] = hpc[n] = oc[n]
+            hr[n] = hpr[n] = or_[n]
+            hp[n] = op[n]
+            hb[n] = {}
+            ha[n] = a = DynamicElement.from_atom(oa[n])
+            a._attach_to_graph(h, n)
+
+            for m, bond in ob[n].items():
+                if m not in ha:
+                    if m in common:  # bond to common atoms is formed bond
+                        bond = DynamicBond(None, bond.order)
+                    else:
+                        bond = DynamicBond(bond.order, bond.order)
+                    bonds.append((n, m, bond))
+        for n in common:
+            an = adj[n]
+            for m, bond in sb[n].items():
+                if m in common:
+                    an[m][0] = bond.order
+            for m, bond in ob[n].items():
+                if m in common:
+                    an[m][1] = bond.order
+        for n in common:
+            san = sa[n]
+            if san.atomic_number != oa[n].atomic_number or san.isotope != oa[n].isotope:
+                raise MappingError(f'atoms with number {{{n}}} not equal')
+
+            hc[n] = sc[n]
+            hpc[n] = oc[n]
+            hr[n] = sr[n]
+            hpr[n] = or_[n]
+            hp[n] = sp[n]
+            hb[n] = {}
+            ha[n] = a = DynamicElement.from_atom(san)
+            a._attach_to_graph(h, n)
+
+            for m, (o1, o2) in adj[n].items():
+                if m not in ha:
+                    bonds.append((n, m, DynamicBond(o1, o2)))
+
+        for n, m, bond in bonds:
+            hb[n][m] = hb[m][n] = bond
+        return h
+
+    def get_fast_mapping(self, other: 'MoleculeContainer') -> Optional[Dict[int, int]]:
+        """
+        Get self to other fast (suboptimal) structure mapping.
+        Only one possible atoms mapping returned.
+        Effective only for big molecules.
+        """
+        if isinstance(other, MoleculeContainer):
+            if len(self) != len(other):
+                return
+            so = self.smiles_atoms_order
+            oo = other.smiles_atoms_order
+            if self != other:
+                return
+            return dict(zip(so, oo))
+        raise TypeError('MoleculeContainer expected')
+
+    def get_mapping(self, other: 'MoleculeContainer', /, **kwargs):
+        if isinstance(other, MoleculeContainer):
+            return super().get_mapping(other, **kwargs)
+        raise TypeError('MoleculeContainer expected')
+
+    def pack(self, *, compressed=True) -> bytes:
+        """
+        Pack into compressed bytes.
+        Note:
+            * Less than 4096 atoms supported. Atoms mapping should be in range 1-4095.
+            * Implicit hydrogens count should be in range 0-6 or unspecified.
+            * Isotope shift should be in range -15 - 15 relatively mdl.common_isotopes
+            * Atoms neighbors should be in range 0-15
+
+        Format specification:
+        Big endian bytes order
+        8 bit - empty byte for future extending
+        12 bit - number of atoms
+        12 bit - cis/trans stereo block size
+        Atom block 9 bytes (repeated):
+        12 bit - atom number
+        4 bit - number of neighbors
+        2 bit tetrahedron sign (00 - not stereo, 10 or 11 - has stereo)
+        2 bit - allene sign
+        5 bit - isotope (00000 - not specified, over = isotope - common_isotope + 16)
+        7 bit - atomic number (<=118)
+        32 bit - XY float16 coordinates
+        3 bit - hydrogens (0-7). Note: 7 == None
+        4 bit - charge (charge + 4. possible range -4 - 4)
+        1 bit - radical state
+        Connection table: flatten list of neighbors. neighbors count stored in atom block.
+        For example CC(=O)O - {1: [2], 2: [1, 3, 4], 3: [2], 4: [2]} >> [2, 1, 3, 4, 2, 2].
+        Repeated block (equal to bonds count).
+        24 bit - paired 12 bit numbers.
+        Bonds order block (repeated):
+        16 bit - 5 bonds grouped (3 bit each). 1 bit unused. Zero padding used than bonds count not proportional to 5.
+        Cis/trans data block (repeated):
+        24 bit - atoms pair
+        7 bit - zero padding. in future can be used for extra bond-level stereo, like atropoisomers.
+        1 bit - sign
+
+        :param compressed: return zlib-compressed pack.
+        """
+        bonds = self._bonds
+        if max(bonds) > 4095:
+            raise ValueError('Big molecules not supported')
+        if any(len(x) > 15 for x in bonds.values()):
+            raise ValueError('To many neighbors not supported')
+        from ..files._mdl.mol import common_isotopes
+
+        plane = self._plane
+        charges = self._charges
+        radicals = self._radicals
+        hydrogens = self._hydrogens
+        atoms_stereo = self._atoms_stereo
+        allenes_stereo = self._allenes_stereo
+        cis_trans_stereo = self._cis_trans_stereo
+
+        data = bytearray(4 +  # extension byte + atoms count + cis/trans bit
+                         9 * self.atoms_count +  # atoms data
+                         3 * self.bonds_count +  # connection table
+                         2 * ceil(self.bonds_count / 5) +  # bonds order
+                         4 * len(cis_trans_stereo))
+        pack_into('>HB', data, 1, (self.atoms_count << 4) | (len(cis_trans_stereo) >> 8), len(cis_trans_stereo) & 0xff)
+        shift = 4
+
+        neighbors = []
+        bonds_pack = []
+        seen = set()
+        hold = []
+        for o, (n, a) in enumerate(self._atoms.items()):
+            bs = bonds[n]
+            neighbors.extend(bs)
+            seen.add(n)
+            for m, b in bs.items():
+                if m not in seen:
+                    bonds_pack.append(b.order - 1)  # 8 - 4 bit, but 7 - 3 bit
+
+            # 3 bit - hydrogens (0-7) | 4 bit - charge | 1 bit - radical
+            hcr = (charges[n] + 4) << 1
+            if radicals[n]:
+                hcr |= 1
+            if (h := hydrogens[n]) is None:
+                hcr |= 224
+            else:
+                hcr |= h << 5
+
+            # 2 bit tetrahedron sign | 2 bit - allene sign | 5 bit - isotope | 7 bit - atomic number (<=118)
+            sia = a.atomic_number
+            if a.isotope:
+                sia |= (a.isotope - common_isotopes[a.atomic_symbol] + 16) << 7
+
+            if n in atoms_stereo:
+                if atoms_stereo[n]:
+                    sia |= 0xc000
+                else:
+                    sia |= 0x8000
+            if n in allenes_stereo:
+                if allenes_stereo[n]:
+                    sia |= 0x3000
+                else:
+                    sia |= 0x2000
+
+            hold.append((shift + 9 * o, (n << 4) | len(bs), sia, *plane[n], hcr))
+
+        shift += 9 * self.atoms_count + 3 * self.bonds_count - 4
+        ngb = iter(reversed(neighbors))
+        for o, (n2, n1) in enumerate(zip_longest(ngb, ngb)):
+            # 12 bit + 12 bit
+            pack_into('>I', data, shift - 3 * o, (n1 << 12) | n2)
+
+        # pack after connection table for preventing override!
+        for x in hold:
+            pack_into('>2H2eB', data, *x)
+
+        # 16 bit - 5 bonds packing. 1 bit empty.
+        shift += 4
+        bp = iter(bonds_pack)
+        for o, (b1, b2, b3, b4, b5) in enumerate(zip_longest(bp, bp, bp, bp, bp, fillvalue=0)):
+            pack_into('>H', data, shift + 2 * o, (b1 << 12) | (b2 << 9) | (b3 << 6) | (b4 << 3) | b5)
+
+        shift += 2 * ceil(self.bonds_count / 5)
+        for o, ((n, m), s) in enumerate(cis_trans_stereo.items()):
+            pack_into('>I', data, shift + 4 * o, (n << 20) | (m << 8) | s)
+
+        if compressed:
+            return compress(bytes(data), 9)
+        return bytes(data)
+
+    @classmethod
+    def unpack(cls, data: bytes, /, *, compressed=True, _return_pack_length=False) -> 'MoleculeContainer':
+        """
+        Unpack from compressed bytes.
+
+        :param compressed: decompress data before processing.
+        """
+        try:  # windows? ;)
+            from ._unpack import unpack
+        except ImportError:
+            return cls.pure_unpack(data, compressed=compressed, _return_pack_length=_return_pack_length)
+        if compressed:
+            data = decompress(data)
+        if data[0] != 0:
+            raise ValueError('invalid pack header')
+
+        (mapping, atom_numbers, isotopes, charges, radicals, hydrogens, plane, bonds,
+         atoms_stereo, allenes_stereo, cis_trans_stereo, pack_length) = unpack(data)
+
+        mol = object.__new__(cls)
+        mol._bonds = bonds
+        mol._plane = plane
+        mol._charges = charges
+        mol._radicals = radicals
+        mol._hydrogens = hydrogens
+        mol._atoms_stereo = atoms_stereo
+        mol._allenes_stereo = allenes_stereo
+        mol._cis_trans_stereo = cis_trans_stereo
+
+        mol._conformers = []
+        mol._parsed_mapping = {}
+        mol._MoleculeContainer__meta = None
+        mol._MoleculeContainer__name = None
+        mol._atoms = atoms = {}
+
+        for n, a, i in zip(mapping, atom_numbers, isotopes):
+            atoms[n] = a = object.__new__(Element.from_atomic_number(a))
+            a._Core__isotope = i
+            a._graph = ref(mol)
+            a._map = n
+        if _return_pack_length:
+            return mol, pack_length
+        return mol
+
+    @classmethod
+    def pure_unpack(cls, data: bytes, /, *, compressed=True, _return_pack_length=False) -> 'MoleculeContainer':
+        """
+        Unpack from compressed bytes. Python implementation.
+        """
+        from ..files._mdl.mol import common_isotopes
+        if compressed:
+            data = memoryview(decompress(data))
+        elif not isinstance(data, memoryview):
+            data = memoryview(data)
+        if data[0] != 0:
+            raise ValueError('invalid pack header')
+
+        mol = cls()
+        atoms = mol._atoms
+        bonds = mol._bonds
+        plane = mol._plane
+        charges = mol._charges
+        radicals = mol._radicals
+        hydrogens = mol._hydrogens
+        atoms_stereo = mol._atoms_stereo
+        allenes_stereo = mol._allenes_stereo
+        cis_trans_stereo = mol._cis_trans_stereo
+
+        neighbors = {}
+        acs = int.from_bytes(data[1:4], 'big')
+        shift = 4
+        for o in range(acs >> 12):
+            nn, sia, x, y, hcr = unpack_from('>2H2eB', data, shift + 9 * o)
+            n = nn >> 4
+            neighbors[n] = nn & 0x0f
+            # stereo
+            s = sia >> 14
+            if s:
+                atoms_stereo[n] = s == 3
+            s = (sia >> 12) & 3
+            if s:
+                allenes_stereo[n] = s == 3
+
+            # atoms
+            a = Element.from_atomic_number(sia & 0x7f)
+            ai = (sia >> 7) & 0x1f
+            if ai:
+                ai += common_isotopes[a.__name__] - 16
+            else:
+                ai = None
+            atoms[n] = a = a(ai)
+            a._attach_to_graph(mol, n)
+
+            charges[n] = ((hcr >> 1) & 0x0f) - 4
+            radicals[n] = bool(hcr & 0x01)
+            hydrogens[n] = None if (h := hcr >> 5) == 7 else h
+            plane[n] = (x, y)
+
+        bc = sum(neighbors.values()) // 2
+        shift += 9 * len(neighbors) - 1
+        connections = []
+        for o in range(bc):
+            nn = unpack_from('>I', data, shift + 3 * o)[0]
+            connections.append((nn >> 12) & 0x0fff)
+            connections.append(nn & 0x0fff)
+
+        shift += 1 + 3 * bc
+        orders = []
+        for o in range(ceil(bc / 5)):
+            bb = unpack_from('>H', data, shift + 2 * o)[0]
+            orders.append(((bb >> 12) & 0x07) + 1)
+            orders.append(((bb >> 9) & 0x07) + 1)
+            orders.append(((bb >> 6) & 0x07) + 1)
+            orders.append(((bb >> 3) & 0x07) + 1)
+            orders.append((bb & 0x07) + 1)
+        orders = orders[:bc]  # skip padding
+
+        con = iter(connections)
+        ords = iter(orders)
+        for n, ms in neighbors.items():
+            bonds[n] = cbn = {}
+            for _ in range(ms):
+                m = next(con)
+                if m in bonds:  # bond partially exists. need back-connection.
+                    cbn[m] = bonds[m][n]
+                else:
+                    cbn[m] = Bond(next(ords))
+
+        shift += 2 * ceil(bc / 5)
+        for o in range(acs & 0x0fff):  # cis/trans
+            ct = unpack_from('>I', data, shift + 4 * o)[0]
+            cis_trans_stereo[(ct >> 20, (ct >> 8) & 0x0fff)] = ct & 0x01
+        if _return_pack_length:
+            return mol, shift + (acs & 0x0fff) * 4
+        return mol
+
+    def _augmented_substructure(self, atoms: Iterable[int], deep: int):
+        atoms = set(atoms)
+        bonds = self._bonds
+        if atoms - self._atoms.keys():
+            raise ValueError('invalid atom numbers')
+        nodes = [atoms]
+        for _ in range(deep):
+            n = {y for x in nodes[-1] for y in bonds[x]} | nodes[-1]
+            if n in nodes:
+                break
+            nodes.append(n)
+        return nodes
+
+    @cached_property
+    def _screen_fingerprint(self) -> Dict[int, Set[int]]:
+        """
+        Fingerprint of available linear fragments with set of mapped atoms.
+        Required for isomorphism tests filtering speedup.
+        Parameters can be modified globally in `MoleculeContainer._fingerprint_config`.
+        """
+        if self._fingerprint_config:
+            return {hash(k): {x for x in v for x in x} for k, v in self._fragments(**self._fingerprint_config).items()}
+        return {}
+
+    @cached_args_method
+    def _component_fingerprint(self, component):
+        """
+        Fingerprint of specific component.
+        """
+        scope = set(self.connected_components[component])
+        return {k: v & scope for k, v in self._screen_fingerprint.items() if not v.isdisjoint(scope)}
+
+    @cached_property
+    def _cython_compiled_structure(self):
+        # long I:
+        # bond: single, double, triple, aromatic, special = 5 bit
+        # atom: H-Ce: 58 bit
+        # transfer bit
+
+        # long II:
+        # atom Pr-Og: 60 bit
+        # hybridizations: 1-4 = 4 bit
+
+        # long III:
+        # isotope: not specified, isotope - common_isotope = -8 - +8 = 18 bit
+        # is_radical: 2 bit
+        # charge: -4 - +4: 9 bit
+        # implicit_hydrogens: 0-4 = 5 bit
+        # neighbors: 0-14 = 15 bit
+        # heteroatoms: 0-14 = 15 bit
+
+        # long IV:
+        # ring_sizes: not-in-ring bit, 3-atom ring, 4-...., 65-atom ring
+        from ..files._mdl.mol import common_isotopes
+
+        charges = self._charges
+        radicals = self._radicals
+        hydrogens = self._hydrogens
+        neighbors = self.neighbors
+        heteroatoms = self.heteroatoms
+        rings_sizes = self.atoms_rings_sizes
+        hybridization = self.hybridization
+
+        mapping = {}
+        numbers = []
+        bits1 = []
+        bits2 = []
+        bits3 = []
+        bits4 = []
+        for i, (n, a) in enumerate(self._atoms.items()):
+            mapping[n] = i
+            numbers.append(n)
+            v2 = 1 << (hybridization(n) - 1)
+            if (an := a.atomic_number) > 58:
+                v1 = 1  # transfer bit
+                v2 |= 1 << (122 - an)
+            else:
+                v1 = 1 << (59 - an)
+
+            if a.isotope:
+                v3 = 1 << (a.isotope - common_isotopes[a.atomic_symbol] + 54)
+                if radicals[n]:
+                    v3 |= 0x200000000000
+                else:
+                    v3 |= 0x100000000000
+            elif radicals[n]:
+                v3 = 0x8000200000000000
+            else:
+                v3 = 0x8000100000000000
+
+            v3 |= 1 << (charges[n] + 39)
+            v3 |= 1 << ((hydrogens[n] or 0) + 30)
+            v3 |= 1 << (neighbors(n) + 15)
+            v3 |= 1 << heteroatoms(n)
+
+            if n in rings_sizes:
+                v4 = 0
+                for r in rings_sizes[n]:
+                    if r > 65:  # big rings not supported
+                        continue
+                    v4 |= 1 << (65 - r)
+                if not v4:  # only 65+ rings. set as rings-free.
+                    v4 = 0x8000000000000000
+            else:  # not in rings
+                v4 = 0x8000000000000000
+
+            bits1.append(v1)
+            bits2.append(v2)
+            bits3.append(v3)
+            bits4.append(v4)
+
+        o_from = [0] * len(mapping)
+        o_to = [0] * len(mapping)
+        indices = [0] * self.bonds_count * 2
+        bonds = [0] * self.bonds_count * 2
+        start = 0
+        for n, ms in self._bonds.items():
+            i = mapping[n]
+            o_from[i] = start
+            for j, (m, b) in enumerate(ms.items(), start):
+                indices[j] = x = mapping[m]
+                v = bits1[x]
+                o = b.order
+                if o == 1:
+                    v |= 0x0800000000000000
+                elif o == 4:
+                    v |= 0x4000000000000000
+                elif o == 2:
+                    v |= 0x1000000000000000
+                elif o == 3:
+                    v |= 0x2000000000000000
+                else:
+                    v |= 0x8000000000000000
+                bonds[j] = v
+            start += len(ms)
+            o_to[i] = start
+
+        return (array('L', numbers), array('Q', bits1), array('Q', bits2), array('Q', bits3), array('Q', bits4),
+                array('Q', bonds), array('I', o_from), array('I', o_to), array('I', indices))
+
+    def _calc_implicit(self, n: int):
+        atoms = self._atoms
+        atom = atoms[n]
+        if atom.atomic_number != 1:
+            charge: int = self._charges[n]
+            is_radical = self._radicals[n]
+            explicit_sum = 0
+            explicit_dict = defaultdict(int)
+            for m, bond in self._bonds[n].items():
+                order = bond.order
+                if order == 4:  # aromatic rings not supported
+                    self._hydrogens[n] = None
+                    return
+                elif order != 8:  # any bond used for complexes
+                    explicit_sum += order
+                    explicit_dict[(order, atoms[m].atomic_number)] += 1
+            try:
+                rules = atom.valence_rules(charge, is_radical, explicit_sum)
+            except ValenceError:
+                self._hydrogens[n] = None
+                return
+            for s, d, h in rules:
+                if s.issubset(explicit_dict) and all(explicit_dict[k] >= c for k, c in d.items()):
+                    self._hydrogens[n] = h
+                    return
+        self._hydrogens[n] = 0
+
+    def __int__(self):
+        """
+        Total charge of molecule
+        """
+        return self.molecular_charge
+
+    def __float__(self):
+        return self.molecular_mass
+
+    def __xor__(self, other):
+        """
+        G ^ H is CGR generation
+        """
+        return self.compose(other)
+
+    def __and__(self, other: Iterable[int]):
+        """
+        Substructure of graph with given nodes.
+        """
+        return self.substructure(other)
+
+    def __sub__(self, other: Iterable[int]):
+        """
+        Given nodes excluded substructure of graph.
+        """
+        atoms = set(other)
+        if atoms - self._atoms.keys():
+            raise ValueError('invalid atom numbers')
+        atoms = self._atoms.keys() - atoms
+        if atoms:
+            return self.substructure(atoms)
+        raise ValueError('full substitution not allowed')
+
+    def __enter__(self):
+        """
+        Transaction of changes. Keep current state for restoring on errors.
+        """
+        atoms = {}
+        for n, atom in self._atoms.items():
+            atom = atom.copy()
+            atoms[n] = atom
+            atom._attach_to_graph(self, n)
+
+        bonds = {}
+        for n, m_bond in self._bonds.items():
+            bonds[n] = cbn = {}
+            for m, bond in m_bond.items():
+                if m in bonds:  # bond partially exists. need back-connection.
+                    cbn[m] = bonds[m][n]
+                else:
+                    cbn[m] = bond.copy()
+        self._backup = {'atoms': atoms, 'bonds': bonds, 'parsed_mapping': self._parsed_mapping.copy(),
+                        'plane': self._plane.copy(), 'charges': self._charges.copy(), 'radicals': self._radicals.copy(),
+                        'hydrogens': self._hydrogens.copy(), 'conformers': [x.copy() for x in self._conformers],
+                        'atoms_stereo': self._atoms_stereo.copy(), 'allenes_stereo': self._allenes_stereo.copy(),
+                        'cis_trans_stereo': self._cis_trans_stereo.copy()}
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        if exc_type:  # restore state
+            backup = self._backup
+            self._atoms = backup['atoms']
+            self._bonds = backup['bonds']
+            self._parsed_mapping = backup['parsed_mapping']
+            self._plane = backup['plane']
+            self._charges = backup['charges']
+            self._radicals = backup['radicals']
+            self._hydrogens = backup['hydrogens']
+            self._conformers = backup['conformers']
+            self._atoms_stereo = backup['atoms_stereo']
+            self._allenes_stereo = backup['allenes_stereo']
+            self._cis_trans_stereo = backup['cis_trans_stereo']
+            self.flush_cache()
+        del self._backup
+
+    def __getstate__(self):
+        return {'conformers': self._conformers, 'hydrogens': self._hydrogens, 'atoms_stereo': self._atoms_stereo,
+                'allenes_stereo': self._allenes_stereo, 'cis_trans_stereo': self._cis_trans_stereo,
+                'parsed_mapping': self._parsed_mapping, 'meta': self.__meta, 'name': self.__name,
+                **super().__getstate__()}
+
+    def __setstate__(self, state):
+        super().__setstate__(state)
+        self._conformers = state['conformers']
+        self._atoms_stereo = state['atoms_stereo']
+        self._allenes_stereo = state['allenes_stereo']
+        self._cis_trans_stereo = state['cis_trans_stereo']
+        self._hydrogens = state['hydrogens']
+        self._parsed_mapping = state['parsed_mapping']
+        self.__meta = state['meta']
+        self.__name = state['name']
+
+    _fingerprint_config = {'min_radius': 2, 'max_radius': 4}  # set empty for disable screening
+
+
+__all__ = ['MoleculeContainer']
```

### Comparing `chython-1.64/chython/containers/reaction.py` & `chython-1.8/chython/containers/reaction.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,334 +1,285 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from CachedMethods import cached_method
-from functools import reduce
-from hashlib import sha512
-from itertools import chain
-from math import ceil
-from operator import itemgetter, or_
-from typing import Dict, Iterable, Iterator, Optional, Tuple, List
-from zlib import compress, decompress
-from .cgr import CGRContainer
-from .molecule import MoleculeContainer
-from ..algorithms.calculate2d import Calculate2DReaction
-from ..algorithms.depict import DepictReaction
-from ..algorithms.mapping import Mapping
-from ..algorithms.standardize import StandardizeReaction
-
-
-class ReactionContainer(StandardizeReaction, Mapping, Calculate2DReaction, DepictReaction):
-    """
-    Reaction storage. Contains reactants, products and reagents lists.
-
-    Reaction storage hashable and comparable. based on reaction unique signature (SMILES).
-    """
-    __slots__ = ('__reactants', '__products', '__reagents', '__meta', '__name', '_arrow', '_signs', '__dict__')
-    __class_cache__ = {}
-
-    def __init__(self, reactants: Iterable[MoleculeContainer] = (), products: Iterable[MoleculeContainer] = (),
-                 reagents: Iterable[MoleculeContainer] = (), meta: Optional[Dict] = None, name: Optional[str] = None):
-        """
-        New reaction object creation
-
-        :param reactants: list of MoleculeContainers in left side of reaction
-        :param products: right side of reaction. see reactants
-        :param reagents: middle side of reaction: solvents, catalysts, etc. see reactants
-        :param meta: dictionary of metadata. like DTYPE-DATUM in RDF
-
-        """
-        reactants = tuple(reactants)
-        products = tuple(products)
-        reagents = tuple(reagents)
-        if not reactants and not products and not reagents:
-            raise ValueError('At least one graph object required')
-        elif not all(isinstance(x, MoleculeContainer) for x in chain(reactants, products, reagents)):
-            raise TypeError(f'MoleculeContainers expected')
-
-        self.__reactants = reactants
-        self.__products = products
-        self.__reagents = reagents
-        if meta is None:
-            self.__meta = None
-        else:
-            self.__meta = dict(meta)
-        if name is None:
-            self.__name = None
-        else:
-            self.name = name
-        self._arrow = None
-        self._signs = None
-
-    @property
-    def reactants(self) -> Tuple[MoleculeContainer, ...]:
-        return self.__reactants
-
-    @property
-    def reagents(self) -> Tuple[MoleculeContainer, ...]:
-        return self.__reagents
-
-    @property
-    def products(self) -> Tuple[MoleculeContainer, ...]:
-        return self.__products
-
-    def molecules(self) -> Iterator[MoleculeContainer]:
-        """
-        Iterator of all reaction molecules
-        """
-        return chain(self.__reactants, self.__reagents, self.__products)
-
-    @property
-    def meta(self) -> Dict:
-        """
-        Dictionary of metadata.
-        Like DTYPE-DATUM in RDF
-        """
-        if self.__meta is None:
-            self.__meta = {}  # lazy
-        return self.__meta
-
-    @property
-    def name(self) -> str:
-        return self.__name or ''
-
-    @name.setter
-    def name(self, name: str):
-        if not isinstance(name, str):
-            raise TypeError('name should be string up to 80 symbols')
-        self.__name = name
-
-    def copy(self) -> 'ReactionContainer':
-        """
-        Get copy of object
-        """
-        copy = object.__new__(self.__class__)
-        copy._ReactionContainer__reactants = tuple(x.copy() for x in self.__reactants)
-        copy._ReactionContainer__products = tuple(x.copy() for x in self.__products)
-        copy._ReactionContainer__reagents = tuple(x.copy() for x in self.__reagents)
-        copy._ReactionContainer__name = self.__name
-        if self.__meta is None:
-            copy._ReactionContainer__meta = None
-        else:
-            copy._ReactionContainer__meta = self.__meta.copy()
-        copy._arrow = self._arrow
-        copy._signs = self._signs
-        return copy
-
-    @cached_method
-    def compose(self) -> CGRContainer:
-        """
-        Get CGR of reaction
-
-        Reagents will be presented as unchanged molecules
-        :return: CGRContainer
-        """
-        rr = self.__reagents + self.__reactants
-        if rr:
-            r = reduce(or_, rr)
-        else:
-            r = MoleculeContainer()
-        if self.__products:
-            p = reduce(or_, self.__products)
-        else:
-            p = MoleculeContainer()
-        return r ^ p
-
-    def flush_cache(self):
-        self.__dict__.clear()
-        for m in self.molecules():
-            m.flush_cache()
-
-    def pack(self, *, compressed=True, check=True):
-        """
-        Pack into compressed bytes.
-
-        Note:
-            * Same restrictions as in molecules pack.
-            * reactants, reagents nad products should contain less than 256 molecules.
-
-        Format specification:
-        Big endian bytes order
-        8 bit - header byte = 0x01 (current format specification)
-        8 bit - reactants count
-        8 bit - reagents count
-        8 bit - products count
-        x bit - concatenated molecules packs
-
-        :param compressed: return zlib-compressed pack.
-        :param check: check molecules for format restrictions.
-        """
-        data = b''.join((bytearray((1, len(self.__reactants), len(self.__reagents), len(self.__products))),
-                         *(m.pack(compressed=False, check=check) for m in self.molecules())))
-        if compressed:
-            return compress(data, 9)
-        return data
-
-    @classmethod
-    def pack_len(cls, data: bytes, /, *, compressed=True) -> Tuple[List[int], List[int], List[int]]:
-        """
-        Returns reactants, reagents, products molecules atoms count in reaction pack.
-        """
-        if compressed:
-            data = decompress(data)
-        data = memoryview(data)
-        if data[0] != 1:
-            raise ValueError('invalid pack header')
-        reactants, reagents, products = data[1], data[2], data[3]
-
-        v = data[4]  # mol pack version
-        shift = 5  # RH+RC+RC+PC+MH
-        molecules = []
-        for _ in range(reactants + reagents + products - 1):
-            acs = int.from_bytes(data[shift: shift + 3], 'big')
-            neighbors = 0
-            ac = acs >> 12
-            shift += 4  # AC+CC+AN
-            for _ in range(ac):
-                neighbors += data[shift] & 0x0f
-                shift += 9
-            neighbors //= 2
-            if v == 2:
-                shift += 3 * neighbors + ceil(neighbors * 3 / 8) + (acs & 0x0fff) * 4
-            elif v == 0:
-                shift += 3 * neighbors + ceil(neighbors / 5) * 2 + (acs & 0x0fff) * 4
-            molecules.append(ac)
-        if reactants or reagents or products:
-            molecules.append(int.from_bytes(data[shift: shift + 3], 'big') >> 12)
-        return molecules[:reactants], molecules[reactants: -products], molecules[-products:]
-
-    @classmethod
-    def unpack(cls, data: bytes, /, *, compressed=True) -> 'ReactionContainer':
-        """
-        Unpack from compressed bytes.
-
-        :param compressed: decompress data before processing.
-        """
-        if compressed:
-            data = decompress(data)
-        data = memoryview(data)
-        if data[0] != 1:
-            raise ValueError('invalid pack header')
-
-        reactants, reagents, products = data[1], data[2], data[3]
-        molecules = []
-        shift = 4
-        for _ in range(reactants + reagents + products):
-            m, pl = MoleculeContainer.unpack(data[shift:], compressed=False, _return_pack_length=True)
-            molecules.append(m)
-            shift += pl
-        return cls(molecules[:reactants], molecules[-products:], molecules[reactants: -products])
-
-    def __invert__(self) -> CGRContainer:
-        """
-        Get CGR of reaction
-        """
-        return self.compose()
-
-    def __eq__(self, other):
-        return isinstance(other, ReactionContainer) and str(self) == str(other)
-
-    @cached_method
-    def __hash__(self):
-        return hash(str(self))
-
-    @cached_method
-    def __bytes__(self):
-        return sha512(str(self).encode()).digest()
-
-    def __bool__(self):
-        """
-        Exists both reactants and products
-        """
-        return bool(self.__reactants and self.__products)
-
-    @cached_method
-    def __str__(self):
-        return format(self)
-
-    def __format__(self, format_spec):
-        """
-        :param format_spec:
-            !c - Keep nested containers order.
-            a - Generate asymmetric closures.
-            !s - Disable stereo marks.
-            A - Use aromatic bonds instead aromatic atoms.
-            m - Set atom mapping.
-            r - Generate random-ordered smiles.
-            h - Show implicit hydrogens.
-            !b - Disable bonds tokens.
-            !x - Disable CXSMILES extension.
-            !z - Disable charge representation.
-        """
-        sig = []
-        count = 0
-        contract = []
-        orders = []
-
-        for ml in (self.__reactants, self.__reagents, self.__products):
-            mso = [(m, *m.__format__(format_spec, _return_order=True)) for m in ml]
-            if not format_spec or '!c' not in format_spec:
-                mso.sort(key=itemgetter(1))
-
-            ss = []
-            for m, s, o in mso:
-                if m.connected_components_count > 1:
-                    contract.append([str(x + count) for x in range(m.connected_components_count)])
-                    count += m.connected_components_count
-                else:
-                    count += 1
-
-                orders.append((m, o))
-                ss.append(s)
-            sig.append('.'.join(ss))
-
-        if not format_spec or '!x' not in format_spec:
-            cx = []
-            if r := ','.join(str(n) for n, (m, a) in enumerate((m, a) for m, o in orders for a in o) if m._radicals[a]):
-                cx.append(f'^1:{r}')
-            if contract:
-                cx.append(f"f:{','.join('.'.join(x) for x in contract)}")
-            if cx:
-                return f"{'>'.join(sig)} |{','.join(cx)}|"
-        return '>'.join(sig)
-
-    @cached_method
-    def __len__(self):
-        return len(self.__reactants) + len(self.__products) + len(self.__reagents)
-
-    def __getstate__(self):
-        state = {'reactants': self.__reactants, 'products': self.__products, 'reagents': self.__reagents,
-                 'meta': self.__meta, 'name': self.__name, 'arrow': self._arrow, 'signs': self._signs}
-        from chython import pickle_cache
-
-        if pickle_cache:
-            state['cache'] = self.__dict__
-        return state
-
-    def __setstate__(self, state):
-        self.__reactants = state['reactants']
-        self.__products = state['products']
-        self.__reagents = state['reagents']
-        self.__meta = state['meta']
-        self.__name = state['name']
-        self._arrow = state['arrow']
-        self._signs = state['signs']
-        if 'cache' in state:
-            self.__dict__.update(state['cache'])
-
-
-__all__ = ['ReactionContainer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from CachedMethods import cached_method
+from functools import reduce
+from hashlib import sha512
+from itertools import chain
+from math import ceil
+from operator import or_
+from typing import Dict, Iterable, Iterator, Optional, Tuple
+from zlib import compress, decompress
+from .cgr import CGRContainer
+from .molecule import MoleculeContainer
+from ..algorithms.calculate2d import Calculate2DReaction
+from ..algorithms.depict import DepictReaction
+from ..algorithms.standardize import StandardizeReaction
+
+
+class ReactionContainer(StandardizeReaction, Calculate2DReaction, DepictReaction):
+    """
+    Reaction storage. Contains reactants, products and reagents lists.
+
+    Reaction storage hashable and comparable. based on reaction unique signature (SMILES).
+    """
+    __slots__ = ('__reactants', '__products', '__reagents', '__meta', '__name', '_arrow', '_signs', '__dict__')
+    __class_cache__ = {}
+
+    def __init__(self, reactants: Iterable[MoleculeContainer] = (), products: Iterable[MoleculeContainer] = (),
+                 reagents: Iterable[MoleculeContainer] = (), meta: Optional[Dict] = None, name: Optional[str] = None):
+        """
+        New reaction object creation
+
+        :param reactants: list of MoleculeContainers in left side of reaction
+        :param products: right side of reaction. see reactants
+        :param reagents: middle side of reaction: solvents, catalysts, etc. see reactants
+        :param meta: dictionary of metadata. like DTYPE-DATUM in RDF
+
+        """
+        reactants = tuple(reactants)
+        products = tuple(products)
+        reagents = tuple(reagents)
+        if not reactants and not products and not reagents:
+            raise ValueError('At least one graph object required')
+        elif not all(isinstance(x, MoleculeContainer) for x in chain(reactants, products, reagents)):
+            raise TypeError(f'MoleculeContainers expected')
+
+        self.__reactants = reactants
+        self.__products = products
+        self.__reagents = reagents
+        if meta is None:
+            self.__meta = None
+        else:
+            self.__meta = dict(meta)
+        if name is None:
+            self.__name = None
+        else:
+            self.name = name
+        self._arrow = None
+        self._signs = None
+
+    @property
+    def reactants(self) -> Tuple[MoleculeContainer, ...]:
+        return self.__reactants
+
+    @property
+    def reagents(self) -> Tuple[MoleculeContainer, ...]:
+        return self.__reagents
+
+    @property
+    def products(self) -> Tuple[MoleculeContainer, ...]:
+        return self.__products
+
+    def molecules(self) -> Iterator[MoleculeContainer]:
+        """
+        Iterator of all reaction molecules
+        """
+        return chain(self.__reactants, self.__reagents, self.__products)
+
+    @property
+    def meta(self) -> Dict:
+        """
+        Dictionary of metadata.
+        Like DTYPE-DATUM in RDF
+        """
+        if self.__meta is None:
+            self.__meta = {}  # lazy
+        return self.__meta
+
+    @property
+    def name(self) -> str:
+        return self.__name or ''
+
+    @name.setter
+    def name(self, name: str):
+        if not isinstance(name, str):
+            raise TypeError('name should be string up to 80 symbols')
+        self.__name = name
+
+    def copy(self) -> 'ReactionContainer':
+        """
+        Get copy of object
+        """
+        copy = object.__new__(self.__class__)
+        copy._ReactionContainer__reactants = tuple(x.copy() for x in self.__reactants)
+        copy._ReactionContainer__products = tuple(x.copy() for x in self.__products)
+        copy._ReactionContainer__reagents = tuple(x.copy() for x in self.__reagents)
+        copy._ReactionContainer__meta = self.__meta.copy()
+        copy._ReactionContainer__name = self.__name
+        copy._arrow = self._arrow
+        copy._signs = self._signs
+        return copy
+
+    @cached_method
+    def compose(self) -> CGRContainer:
+        """
+        Get CGR of reaction
+
+        Reagents will be presented as unchanged molecules
+        :return: CGRContainer
+        """
+        rr = self.__reagents + self.__reactants
+        if rr:
+            r = reduce(or_, rr)
+        else:
+            r = MoleculeContainer()
+        if self.__products:
+            p = reduce(or_, self.__products)
+        else:
+            p = MoleculeContainer()
+        return r ^ p
+
+    @classmethod
+    def from_cgr(cls, cgr: CGRContainer) -> 'ReactionContainer':
+        """
+        Decompose CGR into reaction
+        """
+        if not isinstance(cgr, CGRContainer):
+            raise TypeError('CGR expected')
+        r, p = ~cgr
+        return ReactionContainer(r, p)
+
+    def flush_cache(self):
+        self.__dict__.clear()
+        for m in self.molecules():
+            m.flush_cache()
+
+    def pack(self, *, compressed=True):
+        """
+        Pack into compressed bytes.
+
+        Note:
+            * Same restrictions as in molecules pack.
+            * reactants, reagents nad products should contain less than 257 molecules.
+
+        Format specification:
+        Big endian bytes order
+        8 bit - header byte = 0x01. Extending possible
+        8 bit - reactants count
+        8 bit - reagents count
+        8 bit - products count
+        x bit - concatenated molecules packs
+
+        :param compressed: return zlib-compressed pack.
+        """
+        data = b''.join((bytearray((1, len(self.__reactants), len(self.__reagents), len(self.__products))),
+                         *(m.pack(compressed=False) for m in self.molecules())))
+        if compressed:
+            return compress(data, 9)
+        return data
+
+    @classmethod
+    def unpack(cls, data: bytes, /, *, compressed=True) -> 'ReactionContainer':
+        """
+        Unpack from compressed bytes.
+
+        :param compressed: decompress data before processing.
+        """
+        if compressed:
+            data = decompress(data)
+        data = memoryview(data)
+        if data[0] != 1:
+            raise ValueError('invalid pack header')
+
+        reactants, reagents, products = data[1], data[2], data[3]
+        molecules = []
+        shift = 4
+        for i in range(reactants + reagents + products):
+            m, pl = MoleculeContainer.unpack(data[shift:], compressed=False, _return_pack_length=True)
+            molecules.append(m)
+            shift += pl
+        return cls(molecules[:reactants], molecules[-products:], molecules[reactants: -products])
+
+    def __invert__(self) -> CGRContainer:
+        """
+        Get CGR of reaction
+        """
+        return self.compose()
+
+    def __eq__(self, other):
+        return isinstance(other, ReactionContainer) and str(self) == str(other)
+
+    @cached_method
+    def __hash__(self):
+        return hash(str(self))
+
+    @cached_method
+    def __bytes__(self):
+        return sha512(str(self).encode()).digest()
+
+    def __bool__(self):
+        """
+        Exists both reactants and products
+        """
+        return bool(self.__reactants and self.__products)
+
+    @cached_method
+    def __str__(self):
+        return format(self)
+
+    def __format__(self, format_spec):
+        """
+        :param format_spec: see specification of nested containers.
+            !c - Keep nested containers order
+            !C - skip cxsmiles fragments contract
+        """
+        sig = []
+        count = 0
+        contract = []
+        for ml in (self.__reactants, self.__reagents, self.__products):
+            if not format_spec or '!c' not in format_spec:
+                ml = sorted(ml, key=str)
+            for m in ml:
+                if m.connected_components_count > 1:
+                    contract.append([str(x + count) for x in range(m.connected_components_count)])
+                    count += m.connected_components_count
+                else:
+                    count += 1
+            if format_spec:
+                sig.append('.'.join(format(x, format_spec) for x in ml))
+            else:
+                sig.append('.'.join(str(x) for x in ml))
+        if (not format_spec or '!C' not in format_spec) and contract:
+            return f"{'>'.join(sig)} |f:{','.join('.'.join(x) for x in contract)}|"
+        return '>'.join(sig)
+
+    @cached_method
+    def __len__(self):
+        return len(self.__reactants) + len(self.__products) + len(self.__reagents)
+
+    def __getstate__(self):
+        state = {'reactants': self.__reactants, 'products': self.__products, 'reagents': self.__reagents,
+                 'meta': self.__meta, 'name': self.__name, 'arrow': self._arrow, 'signs': self._signs}
+        import chython
+        if chython.pickle_cache:
+            state['cache'] = self.__dict__
+        return state
+
+    def __setstate__(self, state):
+        self.__reactants = state['reactants']
+        self.__products = state['products']
+        self.__reagents = state['reagents']
+        self.__meta = state['meta']
+        self.__name = state['name']
+        self._arrow = state['arrow']
+        self._signs = state['signs']
+        if 'cache' in state:
+            self.__dict__.update(state['cache'])
+
+
+__all__ = ['ReactionContainer']
```

### Comparing `chython-1.64/chython/files/MRVrw.py` & `chython-1.8/chython/files/MRVrw.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,507 +1,463 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from io import StringIO, BytesIO, TextIOWrapper, BufferedIOBase, BufferedReader
-from itertools import count, islice, chain
-from lxml.etree import iterparse, QName, tostring
-from pathlib import Path
-from typing import Union, List, Iterator, Dict, Optional
-from ._convert import create_molecule, create_reaction
-from ._mapping import postprocess_parsed_molecule, postprocess_parsed_reaction
-from ._mdl import postprocess_molecule
-from ..containers import MoleculeContainer, ReactionContainer
-from ..exceptions import EmptyMolecule, EmptyReaction
-
-
-organic_set = {'B', 'C', 'N', 'O', 'P', 'S', 'Se', 'F', 'Cl', 'Br', 'I'}
-bond_map = {8: '1" queryType="Any', 4: 'A', 1: '1', 2: '2', 3: '3',
-            'Any': 8, 'any': 8, 'A': 4, 'a': 4, '1': 1, '2': 2, '3': 3}
-
-
-def xml_dict(parent_element, stop_list=None):
-    stop_list = set() if stop_list is None else set(stop_list)
-    out = {}
-    for x, y in parent_element.items():
-        y = y.strip()
-        if y:
-            x = '@%s' % x.strip()
-            out[x] = y
-
-    text = []
-    if len(parent_element):
-        elements_grouped = defaultdict(list)
-        for element in parent_element:
-            name = QName(element).localname
-            if name in stop_list:
-                text.append(tostring(element, encoding=str, with_tail=False))
-            else:
-                elements_grouped[name].append(element)
-
-            if element.tail:
-                t = element.tail.strip()
-                if t:
-                    text.append(t)
-
-        for element_tag, element_group in elements_grouped.items():
-            if len(element_group) == 1:
-                out[element_tag] = xml_dict(element_group[0], stop_list)
-            else:
-                out[element_tag] = [xml_dict(x, stop_list) for x in element_group]
-
-    if parent_element.text:
-        t = parent_element.text.strip()
-        if t:
-            text.insert(0, t)
-    if text:
-        out['$'] = ''.join(text)
-
-    return out
-
-
-class MRVRead:
-    """
-    ChemAxon MRV files reader. works similar to opened file object. support `with` context manager.
-    on initialization accept opened in binary mode file, string path to file,
-    pathlib.Path object or another binary buffered reader object
-    """
-    molecule_cls = MoleculeContainer
-    reaction_cls = ReactionContainer
-
-    def __init__(self, file, *, ignore: bool = True, remap: bool = False,
-                 calc_cis_trans: bool = False, ignore_stereo: bool = False, ignore_bad_isotopes: bool = False):
-        """
-        :param ignore: Skip some checks of data or try to fix some errors.
-        :param remap: Remap atom numbers started from one.
-        :param calc_cis_trans: Calculate cis/trans marks from 2d coordinates.
-        :param ignore_stereo: Ignore stereo data.
-        :param ignore_bad_isotopes: reset invalid isotope mark to non-isotopic.
-        """
-        if isinstance(file, str):
-            self.__file = open(file, 'rb')
-            self.__is_buffer = False
-        elif isinstance(file, Path):
-            self.__file = file.open('rb')
-            self.__is_buffer = False
-        elif isinstance(file, (BytesIO, BufferedReader, BufferedIOBase)):
-            self.__file = file
-            self.__is_buffer = True
-        else:
-            raise TypeError('invalid file. BytesIO, BufferedReader and BufferedIOBase subclasses expected')
-        self.__ignore = ignore
-        self.__remap = remap
-        self.__calc_cis_trans = calc_cis_trans
-        self.__ignore_stereo = ignore_stereo
-        self.__ignore_bad_isotopes = ignore_bad_isotopes
-        self.__tell = 0
-        self.__xml = iterparse(self.__file, tag='{*}MChemicalStruct')
-        self.__buffer = None
-
-    def read(self, amount: Optional[int] = None) -> List[Union[ReactionContainer, MoleculeContainer]]:
-        """
-        Parse whole file
-
-        :param amount: number of records to read
-        """
-        if amount:
-            return list(islice(iter(self), amount))
-        return list(iter(self))
-
-    def read_structure(self, *, current: bool = True):
-        """
-        Read Reaction or Molecule container.
-
-        :param current: return current structure if already parsed, otherwise read next
-        """
-        data = self._read_block(current=current)
-        meta = self.read_metadata()
-        log = []
-
-        if 'molecule' in data and isinstance(data['molecule'], dict):
-            data = data['molecule']
-            tmp = parse_molecule(data)
-            postprocess_parsed_molecule(tmp, remap=self.__remap, ignore=self.__ignore)
-            mol = create_molecule(tmp, ignore_bad_isotopes=self.__ignore_bad_isotopes, _cls=self.molecule_cls)
-            postprocess_molecule(mol, tmp, ignore=self.__ignore, ignore_stereo=self.__ignore_stereo,
-                                 calc_cis_trans=self.__calc_cis_trans)
-            if meta:
-                mol.meta.update(meta)
-            return mol
-        elif 'reaction' in data and isinstance(data['reaction'], dict):
-            data = data['reaction']
-            tmp = {'reactants': [], 'products': [], 'reagents': [],
-                   'meta': None, 'log': log, 'title': data.get('@title')}
-
-            n = 0
-            for tag, group in (('reactantList', 'reactants'), ('productList', 'products'), ('agentList', 'reagents')):
-                if tag in data and 'molecule' in data[tag]:
-                    molecule = data[tag]['molecule']
-                    if isinstance(molecule, dict):
-                        molecule = (molecule,)
-                    for m in molecule:
-                        n += 1
-                        try:
-                            tmp[group].append(parse_molecule(m))
-                        except ValueError as e:
-                            if isinstance(e, EmptyMolecule):
-                                log.append(f'ignored empty molecule {n}')
-                            elif self.__ignore:
-                                log.append(f'ignored molecule {n} with {e}')
-                            else:
-                                raise
-
-            if not tmp['reactants'] and not tmp['products'] and not tmp['reagents']:
-                raise EmptyReaction
-
-            postprocess_parsed_reaction(tmp, remap=self.__remap, ignore=self.__ignore)
-            rxn = create_reaction(tmp, ignore_bad_isotopes=self.__ignore_bad_isotopes, _m_cls=self.molecule_cls,
-                                  _r_cls=self.reaction_cls)
-            for mol, tmp in zip(rxn.molecules(), chain(tmp['reactants'], tmp['reagents'], tmp['products'])):
-                postprocess_molecule(mol, tmp, ignore=self.__ignore, ignore_stereo=self.__ignore_stereo,
-                                     calc_cis_trans=self.__calc_cis_trans)
-            if meta:
-                rxn.meta.update(meta)
-            return rxn
-        else:
-            raise ValueError('reaction or molecule expected')
-
-    def read_metadata(self, *, current: bool = True) -> Dict[str, str]:
-        """
-        Read metadata block
-        """
-        data = self._read_block(current=current)
-        if 'molecule' in data and isinstance(data['molecule'], dict):
-            data = data['molecule']
-        elif 'reaction' in data and isinstance(data['reaction'], dict):
-            data = data['reaction']
-        else:
-            raise ValueError('reaction or molecule expected')
-
-        if 'propertyList' in data and 'property' in data['propertyList']:
-            data = data['propertyList']['property']
-            meta = {}
-            if isinstance(data, dict):
-                key = data['@title']
-                val = data['scalar']['$'].strip()
-                if key and val:
-                    meta[key] = val
-                else:
-                    meta['chython_unparsed_metadata'] = [data]
-            else:
-                for x in data:
-                    key = x['@title']
-                    val = x['scalar']['$'].strip()
-                    if key and val:
-                        meta[key] = val
-                    else:
-                        if 'chython_unparsed_metadata' not in meta:
-                            meta['chython_unparsed_metadata'] = []
-                        meta['chython_unparsed_metadata'].append(x)
-        else:
-            return {}
-
-    def close(self, force: bool = False):
-        """
-        Close opened file
-
-        :param force: force closing of externally opened file or buffer
-        """
-        if not self.__is_buffer or force:
-            self.__file.close()
-
-    def tell(self):
-        """
-        Number of records processed from the original file
-        """
-        return self.__tell
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, _type, value, traceback):
-        self.close()
-
-    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
-        while True:
-            try:
-                yield self.read_structure(current=False)
-            except ValueError:
-                pass
-            except EOFError:
-                return
-
-    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
-        return next(iter(self))
-
-    def _read_block(self, *, current: bool = True) -> dict:
-        if not current or not self.__buffer:
-            self.__buffer = None
-            try:
-                e = next(self.__xml)[1]
-            except StopIteration:
-                raise EOFError
-            self.__buffer = xml_dict(e)
-            self.__tell += 1
-            e.clear()
-        return self.__buffer
-
-
-def parse_molecule(data):
-    atoms, bonds, stereo = [], [], []
-    log = []
-    hydrogens = {}
-    atom_map = {}
-    if 'atom' in data['atomArray']:
-        da = data['atomArray']['atom']
-        if isinstance(da, dict):
-            da = (da,)
-        for n, atom in enumerate(da):
-            atom_map[atom['@id']] = n
-            atoms.append({'element': atom['@elementType'],
-                          'isotope': int(atom['@isotope']) if '@isotope' in atom else None,
-                          'charge': int(atom.get('@formalCharge', 0)),
-                          'is_radical': '@radical' in atom,
-                          'mapping': int(atom.get('@mrvMap', 0))})
-            if '@z3' in atom:
-                atoms[-1].update(x=float(atom['@x3']), y=float(atom['@y3']), z=float(atom['@z3']))
-            else:
-                atoms[-1].update(x=float(atom['@x2']) / 2, y=float(atom['@y2']) / 2, z=0.)
-            if '@mrvQueryProps' in atom:
-                raise ValueError('queries unsupported')
-            if '@hydrogenCount' in atom:
-                hydrogens[n] = int(atom['@hydrogenCount'])
-    else:
-        atom = data['atomArray']
-        for n, (_id, e) in enumerate(zip(atom['@atomID'].split(), atom['@elementType'].split())):
-            atom_map[_id] = n
-            atoms.append({'element': e, 'charge': 0, 'mapping': 0, 'isotope': None, 'is_radical': False})
-        if '@z3' in atom:
-            for a, x, y, z in zip(atoms, atom['@x3'].split(), atom['@y3'].split(), atom['@z3'].split()):
-                a['x'] = float(x)
-                a['y'] = float(y)
-                a['z'] = float(z)
-        else:
-            for a, x, y in zip(atoms, atom['@x2'].split(), atom['@y2'].split()):
-                a['x'] = float(x) / 2
-                a['y'] = float(y) / 2
-                a['z'] = 0.
-        if '@isotope' in atom:
-            for a, x in zip(atoms, atom['@isotope'].split()):
-                if x != '0':
-                    a['isotope'] = int(x)
-        if '@formalCharge' in atom:
-            for a, x in zip(atoms, atom['@formalCharge'].split()):
-                if x != '0':
-                    a['charge'] = int(x)
-        if '@mrvMap' in atom:
-            for a, x in zip(atoms, atom['@mrvMap'].split()):
-                if x != '0':
-                    a['mapping'] = int(x)
-        if '@radical' in atom:
-            for a, x in zip(atoms, atom['@radical'].split()):
-                if x != '0':
-                    a['is_radical'] = True
-        if '@mrvQueryProps' in atom:
-            raise ValueError('queries unsupported')
-    if not atoms:
-        raise EmptyMolecule
-
-    if 'bond' in data['bondArray']:
-        db = data['bondArray']['bond']
-        if isinstance(db, dict):
-            db = (db,)
-        for bond in db:
-            order = bond_map[bond['@queryType' if '@queryType' in bond else '@order']]
-            a1, a2 = bond['@atomRefs2'].split()
-            if 'bondStereo' in bond:
-                if '$' in bond['bondStereo']:
-                    s = bond['bondStereo']['$']
-                    if s == 'H':
-                        stereo.append((atom_map[a1], atom_map[a2], -1))
-                    elif s == 'W':
-                        stereo.append((atom_map[a1], atom_map[a2], 1))
-                    else:
-                        log.append('invalid or unsupported stereo')
-                else:
-                    log.append('incorrect bondStereo tag')
-            bonds.append((atom_map[a1], atom_map[a2], order))
-
-    return {'atoms': atoms, 'bonds': bonds, 'stereo': stereo, 'hydrogens': hydrogens,
-            'meta': None, 'title': data.get('@title'), 'log': log}
-
-
-class MRVWrite:
-    """
-    ChemAxon MRV files writer. works similar to opened for writing file object. support `with` context manager.
-    on initialization accept opened for writing in text mode file, string path to file,
-    pathlib.Path object or another buffered writer object
-    """
-    def __init__(self, file, mapping: bool = True):
-        """
-        :param mapping: write atom mapping.
-        """
-        if isinstance(file, str):
-            self.__file = open(file, 'w')
-            self.__is_buffer = False
-        elif isinstance(file, Path):
-            self.__file = file.open('w')
-            self.__is_buffer = False
-        elif isinstance(file, (TextIOWrapper, StringIO)):
-            self.__file = file
-            self.__is_buffer = True
-        else:
-            raise TypeError('invalid file. '
-                            'TextIOWrapper, StringIO, BytesIO, BufferedReader and BufferedIOBase subclasses possible')
-        self.__writable = True
-        self.__finalized = False
-        self.__mapping = mapping
-
-    def close(self, force=False):
-        """
-        Write close tag of MRV file and close opened file
-
-        :param force: force closing of externally opened file or buffer
-        """
-        if not self.__finalized:
-            self.__file.write('</cml>\n')
-            self.__finalized = True
-        if self.__writable:
-            self.write = self.__write_closed
-            self.__writable = False
-
-        if not self.__is_buffer or force:
-            self.__file.close()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, _type, value, traceback):
-        self.close()
-
-    @staticmethod
-    def __write_closed(_):
-        raise ValueError('I/O operation on closed writer')
-
-    def write(self, data: Union[ReactionContainer, MoleculeContainer]):
-        """
-        Write single molecule or reaction into file
-        """
-        self.__file.write('<cml>\n')
-        self.__write(data)
-        self.write = self.__write
-
-    def __write(self, data):
-        file = self.__file
-        file.write('<MDocument><MChemicalStruct>')
-        if isinstance(data, ReactionContainer):
-            if not data._arrow:
-                data.fix_positions()
-            if data.name:
-                file.write(f'<reaction title="{data.name}">')
-            else:
-                file.write('<reaction>')
-
-            if data.meta:
-                file.write('<propertyList>')
-                for k, v in data.meta.items():
-                    if isinstance(v, str):
-                        v = f'<![CDATA[{v}]]>'
-                    file.write(f'<property title="{k}"><scalar>{v}</scalar></property>')
-                file.write('</propertyList>')
-
-            c = count(1)
-            for i, j in ((data.reactants, 'reactantList'), (data.reagents, 'agentList'),
-                         (data.products, 'productList')):
-                if not i:
-                    continue
-                file.write(f'<{j}>')
-                for n, m in zip(c, i):
-                    if m.name:
-                        file.write(f'<molecule title="{m.name}" molID="m{n}">')
-                    else:
-                        file.write(f'<molecule molID="m{n}">')
-
-                    self.__write_molecule(m)
-                    file.write('</molecule>')
-                file.write(f'</{j}>')
-
-            file.write(f'<arrow type="DEFAULT" x1="{data._arrow[0] * 2:.4f}" y1="0" '
-                       f'x2="{data._arrow[1] * 2:.4f}" y2="0"/></reaction>')
-        elif not isinstance(data, MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-        else:
-            if data.name:
-                file.write(f'<molecule title="{data.name}">')
-            else:
-                file.write('<molecule>')
-            if data.meta:
-                file.write('<propertyList>')
-                for k, v in data.meta.items():
-                    if isinstance(v, str):
-                        v = f'<![CDATA[{v}]]>'
-                    file.write(f'<property title="{k}"><scalar>{v}</scalar></property>')
-                file.write('</propertyList>')
-
-            self.__write_molecule(data)
-            file.write('</molecule>')
-        file.write('</MChemicalStruct></MDocument>\n')
-
-    def __write_molecule(self, g):
-        gp = g._plane
-        gc = g._charges
-        gr = g._radicals
-        bg = g._bonds
-        hg = g._hydrogens
-        hb = g.hybridization
-        mapping = self.__mapping
-
-        file = self.__file
-        file.write('<atomArray>')
-        for n, atom in g._atoms.items():
-            x, y = gp[n]
-            ih = hg[n]
-            file.write(f'<atom id="a{n}" elementType="{atom.atomic_symbol}" x2="{x * 2:.4f}" y2="{y * 2:.4f}"')
-            if mapping:
-                file.write(f' mrvMap="{n}"')
-            if gc[n]:
-                file.write(f' formalCharge="{gc[n]}"')
-            if gr[n]:
-                file.write(' radical="monovalent"')
-            if atom.isotope:
-                file.write(f' isotope="{atom.isotope}"')
-            if ih and (atom.atomic_symbol not in organic_set or hb(n) == 4 and atom.atomic_number in (5, 7, 15)):
-                file.write(f' hydrogenCount="{ih}"')
-            file.write('/>')
-        file.write('</atomArray>')
-
-        file.write('<bondArray>')
-        wedge = defaultdict(set)
-        n = 0  # empty wedge trick
-        for n, (i, j, s) in enumerate(g._wedge_map, start=1):
-            file.write(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bg[i][j].order]}">'
-                       f'<bondStereo>{s == 1 and "W" or "H"}</bondStereo></bond>')
-            wedge[i].add(j)
-            wedge[j].add(i)
-        for i, j, bond in g.bonds():
-            if j not in wedge[i]:
-                n += 1
-                file.write(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bond.order]}"/>')
-        file.write('</bondArray>')
-
-
-__all__ = ['MRVRead', 'MRVWrite']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict, namedtuple
+from io import StringIO, BytesIO, TextIOWrapper, BufferedIOBase, BufferedReader
+from itertools import count
+from lxml.etree import iterparse, QName, tostring
+from pathlib import Path
+from traceback import format_exc
+from typing import Union, List, Iterator
+from ._mdl import MDLStereo
+from ..containers import MoleculeContainer, ReactionContainer
+from ..exceptions import EmptyMolecule
+
+
+parse_error = namedtuple('MRVParseError', ('number', 'json', 'log', 'meta'))
+organic_set = {'B', 'C', 'N', 'O', 'P', 'S', 'Se', 'F', 'Cl', 'Br', 'I'}
+bond_map = {8: '1" queryType="Any', 4: 'A', 1: '1', 2: '2', 3: '3',
+            'Any': 8, 'any': 8, 'A': 4, 'a': 4, '1': 1, '2': 2, '3': 3}
+
+
+def xml_dict(parent_element, stop_list=None):
+    stop_list = set() if stop_list is None else set(stop_list)
+    out = {}
+    for x, y in parent_element.items():
+        y = y.strip()
+        if y:
+            x = '@%s' % x.strip()
+            out[x] = y
+
+    text = []
+    if len(parent_element):
+        elements_grouped = defaultdict(list)
+        for element in parent_element:
+            name = QName(element).localname
+            if name in stop_list:
+                text.append(tostring(element, encoding=str, with_tail=False))
+            else:
+                elements_grouped[name].append(element)
+
+            if element.tail:
+                t = element.tail.strip()
+                if t:
+                    text.append(t)
+
+        for element_tag, element_group in elements_grouped.items():
+            if len(element_group) == 1:
+                out[element_tag] = xml_dict(element_group[0], stop_list)
+            else:
+                out[element_tag] = [xml_dict(x, stop_list) for x in element_group]
+
+    if parent_element.text:
+        t = parent_element.text.strip()
+        if t:
+            text.insert(0, t)
+    if text:
+        out['$'] = ''.join(text)
+
+    return out
+
+
+class MRVRead(MDLStereo):
+    """
+    ChemAxon MRV files reader. works similar to opened file object. support `with` context manager.
+    on initialization accept opened in binary mode file, string path to file,
+    pathlib.Path object or another binary buffered reader object
+    """
+    def __init__(self, file, **kwargs):
+        """
+        :param ignore: Skip some checks of data or try to fix some errors.
+        :param remap: Remap atom numbers started from one.
+        :param store_log: Store parser log if exists messages to `.meta` by key `ParserLog`.
+        :param calc_cis_trans: Calculate cis/trans marks from 2d coordinates.
+        :param ignore_stereo: Ignore stereo data.
+        """
+        if isinstance(file, str):
+            self.__file = open(file, 'rb')
+            self.__is_buffer = False
+        elif isinstance(file, Path):
+            self.__file = file.open('rb')
+            self.__is_buffer = False
+        elif isinstance(file, (BytesIO, BufferedReader, BufferedIOBase)):
+            self.__file = file
+            self.__is_buffer = True
+        else:
+            raise TypeError('invalid file. BytesIO, BufferedReader and BufferedIOBase subclasses possible')
+        super().__init__(**kwargs)
+        self._data = self.__reader()
+
+    def close(self, force=False):
+        """
+        close opened file
+
+        :param force: force closing of externally opened file or buffer
+        """
+        if not self.__is_buffer or force:
+            self.__file.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, _type, value, traceback):
+        self.close()
+
+    def read(self) -> List[Union[ReactionContainer, MoleculeContainer]]:
+        """
+        parse whole file
+
+        :return: list of parsed molecules or reactions
+        """
+        return list(iter(self))
+
+    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
+        return (x for x in self._data if not isinstance(x, parse_error))
+
+    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
+        return next(iter(self))
+
+    def __reader(self) -> Iterator[Union[ReactionContainer, MoleculeContainer, parse_error]]:
+        for n, (_, element) in enumerate(iterparse(self.__file, tag='{*}MChemicalStruct')):
+            parsed = xml_dict(element)
+            element.clear()
+            if 'molecule' in parsed and isinstance(parsed['molecule'], dict):
+                parsed = parsed['molecule']
+                if 'propertyList' in parsed and 'property' in parsed['propertyList']:
+                    meta = self.__parse_property(parsed['propertyList']['property'])
+                else:
+                    meta = {}
+
+                try:
+                    record = self.__parse_molecule(parsed)
+                except (KeyError, ValueError):
+                    self._info(f'record consist errors:\n{format_exc()}')
+                    yield parse_error(n, parsed, self._format_log(), meta)
+                else:
+                    record['meta'].update(meta)
+                    try:
+                        container = self._convert_molecule(record)
+                    except ValueError:
+                        self._info(f'record consist errors:\n{format_exc()}')
+                        yield parse_error(n, parsed, self._format_log(), meta)
+                    else:
+                        yield container
+            elif 'reaction' in parsed and isinstance(parsed['reaction'], dict):
+                parsed = parsed['reaction']
+                if 'propertyList' in parsed and 'property' in parsed['propertyList']:
+                    meta = self.__parse_property(parsed['propertyList']['property'])
+                else:
+                    meta = {}
+
+                try:
+                    record = self.__parse_reaction(parsed)
+                except (KeyError, ValueError):
+                    self._info(f'record consist errors:\n{format_exc()}')
+                    yield parse_error(n, parsed, self._format_log(), meta)
+                else:
+                    record['meta'] = meta
+                    try:
+                        container = self._convert_reaction(record)
+                    except ValueError:
+                        self._info(f'record consist errors:\n{format_exc()}')
+                        yield parse_error(n, parsed, self._format_log(), meta)
+                    else:
+                        yield container
+            else:
+                self._info('invalid MDocument')
+                yield parse_error(n, parsed, self._format_log(), {})
+
+    def __parse_reaction(self, data):
+        reaction = {'reactants': [], 'products': [], 'reagents': []}
+        title = data.get('@title')
+        if title:
+            reaction['title'] = title
+        for tag, group in (('reactantList', 'reactants'), ('productList', 'products'), ('agentList', 'reagents')):
+            if tag in data and 'molecule' in data[tag]:
+                molecule = data[tag]['molecule']
+                if isinstance(molecule, dict):
+                    molecule = (molecule,)
+                for m in molecule:
+                    try:
+                        reaction[group].append(self.__parse_molecule(m))
+                    except EmptyMolecule:
+                        if not self._ignore:
+                            raise
+                        self._info('empty molecule ignored')
+        return reaction
+
+    def __parse_property(self, data):
+        meta = {}
+        if isinstance(data, dict):
+            key = data['@title']
+            val = data['scalar']['$'].strip()
+            if key and val:
+                meta[key] = val
+            else:
+                self._info(f'invalid metadata entry: {data}')
+        else:
+            for x in data:
+                key = x['@title']
+                val = x['scalar']['$'].strip()
+                if key and val:
+                    meta[key] = val
+                else:
+                    self._info(f'invalid metadata entry: {x}')
+        return meta
+
+    def __parse_molecule(self, data):
+        atoms, bonds, stereo = [], [], []
+        hydrogens = {}
+        atom_map = {}
+        if 'atom' in data['atomArray']:
+            da = data['atomArray']['atom']
+            if isinstance(da, dict):
+                da = (da,)
+            for n, atom in enumerate(da):
+                atom_map[atom['@id']] = n
+                atoms.append({'element': atom['@elementType'],
+                              'isotope': int(atom['@isotope']) if '@isotope' in atom else None,
+                              'charge': int(atom.get('@formalCharge', 0)),
+                              'is_radical': '@radical' in atom,
+                              'mapping': int(atom.get('@mrvMap', 0))})
+                if '@z3' in atom:
+                    atoms[-1].update(x=float(atom['@x3']), y=float(atom['@y3']), z=float(atom['@z3']))
+                else:
+                    atoms[-1].update(x=float(atom['@x2']) / 2, y=float(atom['@y2']) / 2, z=0.)
+                if '@mrvQueryProps' in atom:
+                    raise ValueError('queries unsupported')
+                if '@hydrogenCount' in atom:
+                    hydrogens[n] = int(atom['@hydrogenCount'])
+        else:
+            atom = data['atomArray']
+            for n, (_id, e) in enumerate(zip(atom['@atomID'].split(), atom['@elementType'].split())):
+                atom_map[_id] = n
+                atoms.append({'element': e, 'charge': 0, 'mapping': 0, 'isotope': None, 'is_radical': False})
+            if '@z3' in atom:
+                for a, x, y, z in zip(atoms, atom['@x3'].split(), atom['@y3'].split(), atom['@z3'].split()):
+                    a['x'] = float(x)
+                    a['y'] = float(y)
+                    a['z'] = float(z)
+            else:
+                for a, x, y in zip(atoms, atom['@x2'].split(), atom['@y2'].split()):
+                    a['x'] = float(x) / 2
+                    a['y'] = float(y) / 2
+                    a['z'] = 0.
+            if '@isotope' in atom:
+                for a, x in zip(atoms, atom['@isotope'].split()):
+                    if x != '0':
+                        a['isotope'] = int(x)
+            if '@formalCharge' in atom:
+                for a, x in zip(atoms, atom['@formalCharge'].split()):
+                    if x != '0':
+                        a['charge'] = int(x)
+            if '@mrvMap' in atom:
+                for a, x in zip(atoms, atom['@mrvMap'].split()):
+                    if x != '0':
+                        a['mapping'] = int(x)
+            if '@radical' in atom:
+                for a, x in zip(atoms, atom['@radical'].split()):
+                    if x != '0':
+                        a['is_radical'] = True
+            if '@mrvQueryProps' in atom:
+                raise ValueError('queries unsupported')
+        if not atoms:
+            raise EmptyMolecule
+
+        if 'bond' in data['bondArray']:
+            db = data['bondArray']['bond']
+            if isinstance(db, dict):
+                db = (db,)
+            for bond in db:
+                order = bond_map[bond['@queryType' if '@queryType' in bond else '@order']]
+                a1, a2 = bond['@atomRefs2'].split()
+                if 'bondStereo' in bond:
+                    if '$' in bond['bondStereo']:
+                        s = bond['bondStereo']['$']
+                        if s == 'H':
+                            stereo.append((atom_map[a1], atom_map[a2], -1))
+                        elif s == 'W':
+                            stereo.append((atom_map[a1], atom_map[a2], 1))
+                        else:
+                            self._info('invalid or unsupported stereo')
+                    else:
+                        self._info('incorrect bondStereo tag')
+                bonds.append((atom_map[a1], atom_map[a2], order))
+
+        mol = {'atoms': atoms, 'bonds': bonds, 'stereo': stereo, 'meta': {}, 'hydrogens': hydrogens}
+        if '@title' in data:
+            mol['title'] = data['@title']
+        return mol
+
+
+class MRVWrite:
+    """
+    ChemAxon MRV files writer. works similar to opened for writing file object. support `with` context manager.
+    on initialization accept opened for writing in text mode file, string path to file,
+    pathlib.Path object or another buffered writer object
+    """
+    def __init__(self, file):
+        if isinstance(file, str):
+            self._file = open(file, 'w')
+            self._is_buffer = False
+        elif isinstance(file, Path):
+            self._file = file.open('w')
+            self._is_buffer = False
+        elif isinstance(file, (TextIOWrapper, StringIO)):
+            self._file = file
+            self._is_buffer = True
+        else:
+            raise TypeError('invalid file. '
+                            'TextIOWrapper, StringIO, BytesIO, BufferedReader and BufferedIOBase subclasses possible')
+        self.__writable = True
+
+    def close(self, force=False):
+        """
+        write close tag of MRV file and close opened file
+
+        :param force: force closing of externally opened file or buffer
+        """
+        if not self.__finalized:
+            self._file.write('</cml>\n')
+            self.__finalized = True
+        if self.__writable:
+            self.write = self.__write_closed
+            self.__writable = False
+
+        if not self._is_buffer or force:
+            self._file.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, _type, value, traceback):
+        self.close()
+
+    @staticmethod
+    def __write_closed(_):
+        raise ValueError('I/O operation on closed writer')
+
+    def write(self, data: Union[ReactionContainer, MoleculeContainer]):
+        """
+        write single molecule or reaction into file
+        """
+        self._file.write('<cml>\n')
+        self.__write(data)
+        self.write = self.__write
+
+    def __write(self, data):
+        if isinstance(data, ReactionContainer):
+            buffer = ['<MDocument><MChemicalStruct>']
+            if not data._arrow:
+                data.fix_positions()
+
+            if data.name:
+                buffer.append(f'<reaction title="{data.name}">')
+            else:
+                buffer.append('<reaction>')
+
+            if data.meta:
+                buffer.append('<propertyList>')
+                for k, v in data.meta.items():
+                    if isinstance(v, str):
+                        v = f'<![CDATA[{v}]]>'
+                    buffer.append(f'<property title="{k}"><scalar>{v}</scalar></property>')
+                buffer.append('</propertyList>')
+            c = count(1)
+            for i, j in ((data.reactants, 'reactantList'), (data.products, 'productList'),
+                         (data.reagents, 'agentList')):
+                if not i:
+                    continue
+                buffer.append(f'<{j}>')
+                for n, m in zip(c, i):
+                    if m.name:
+                        buffer.append(f'<molecule title="{m.name}" molID="m{n}">')
+                    else:
+                        buffer.append(f'<molecule molID="m{n}">')
+                    buffer.append(self.__convert_structure(m))
+                    buffer.append('</molecule>')
+                buffer.append(f'</{j}>')
+
+            buffer.append(f'<arrow type="DEFAULT" x1="{data._arrow[0] * 2:.4f}" y1="0" '
+                          f'x2="{data._arrow[1] * 2:.4f}" y2="0"/>')
+            buffer.append('</reaction>')
+            self._file.writelines(buffer)
+        elif not isinstance(data, MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+        else:
+            m = self.__convert_structure(data)
+            self._file.write('<MDocument><MChemicalStruct>')
+
+            if data.name:
+                self._file.write(f'<molecule title="{data.name}">')
+            else:
+                self._file.write('<molecule>')
+
+            if data.meta:
+                self._file.write('<propertyList>')
+                for k, v in data.meta.items():
+                    if isinstance(v, str):
+                        v = f'<![CDATA[{v}]]>'
+                    self._file.write(f'<property title="{k}"><scalar>{v}</scalar></property>')
+                self._file.write('</propertyList>')
+            self._file.write(m)
+            self._file.write('</molecule>')
+        self._file.write('</MChemicalStruct></MDocument>\n')
+
+    @staticmethod
+    def __convert_structure(g):
+        gp = g._plane
+        gc = g._charges
+        gr = g._radicals
+        bg = g._bonds
+        hg = g._hydrogens
+        hb = g.hybridization
+
+        out = ['<atomArray>']
+        for n, atom in g._atoms.items():
+            x, y = gp[n]
+            ih = hg[n]
+            out.append(f'<atom id="a{n}" elementType="{atom.atomic_symbol}" '
+                       f'x2="{x * 2:.4f}" y2="{y * 2:.4f}" mrvMap="{n}"')
+            if gc[n]:
+                out.append(f' formalCharge="{gc[n]}"')
+            if gr[n]:
+                out.append(' radical="monovalent"')
+            if atom.isotope:
+                out.append(f' isotope="{atom.isotope}"')
+            if ih and (atom.atomic_symbol not in organic_set or hb(n) == 4 and atom.atomic_number in (5, 7, 15)):
+                out.append(f' hydrogenCount="{ih}"')
+            out.append('/>')
+        out.append('</atomArray>')
+
+        out.append('<bondArray>')
+        wedge = defaultdict(set)
+        for n, (i, j, s) in enumerate(g._wedge_map, start=1):
+            out.append(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bg[i][j].order]}">'
+                       f'<bondStereo>{s == 1 and "W" or "H"}</bondStereo></bond>')
+            wedge[i].add(j)
+            wedge[j].add(i)
+        for n, (i, j, bond) in enumerate(g.bonds(), start=len(out)):
+            if j not in wedge[i]:
+                out.append(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bond.order]}"/>')
+        out.append('</bondArray>')
+        return ''.join(out)
+
+    __finalized = False
+
+
+__all__ = ['MRVRead', 'MRVWrite']
```

### Comparing `chython-1.64/chython/files/__init__.py` & `chython-1.8/chython/files/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,29 +1,30 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .daylight import *
-from .inchi import *
-from .MRVrw import *
-from .PDBrw import *
-from .RDFrw import *
-from .SDFrw import *
-from .xyz import *
-
-
-__all__ = ['smiles', 'smarts', 'mdl_mol', 'mdl_rxn', 'xyz', 'xyz_file', 'inchi']
-__all__.extend(x for x in locals() if x.endswith(('Read', 'Write')))
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .INCHIrw import *
+from .MRVrw import *
+from .PDBrw import *
+from .RDFrw import *
+from .SDFrw import *
+from .SMILESrw import *
+from .XYZrw import *
+from ._mdl import parse_error
+
+
+__all__ = [x for x in locals() if x.endswith(('Read', 'Write'))]
+__all__.append('mdl_mol')
```

### Comparing `chython-1.64/chython/files/_mdl/read.py` & `chython-1.8/chython/files/_mdl/read.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,225 +1,190 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABCMeta, abstractmethod
-from base64 import urlsafe_b64encode
-from fileinput import FileInput
-from io import StringIO, TextIOWrapper
-from itertools import islice
-from os.path import abspath, join
-from pathlib import Path
-from pickle import load, UnpicklingError
-from sys import platform
-from tempfile import gettempdir
-from typing import Union, Iterator, List, Dict, Optional
-from ...containers import ReactionContainer, MoleculeContainer
-
-
-class MDLReadMeta(ABCMeta):
-    def __call__(cls, *args, **kwargs):
-        if kwargs.get('indexable'):
-            _cls = type(cls.__name__, (cls,), {'__len__': lambda x: len(x._shifts), '__module__': cls.__module__})
-            obj = object.__new__(_cls)  # noqa
-        else:
-            obj = object.__new__(cls)  # noqa
-        obj.__init__(*args, **kwargs)
-        return obj
-
-
-class MDLRead(metaclass=MDLReadMeta):
-    def __init__(self, file, buffer_size=1000, indexable=False, ignore=True, remap=False, ignore_bad_isotopes=False,
-                 ignore_stereo=False, calc_cis_trans=False):
-        if isinstance(file, str):
-            self._file = open(file)
-            self._is_buffer = False
-        elif isinstance(file, Path):
-            self._file = file.open()
-            self._is_buffer = False
-        elif isinstance(file, (TextIOWrapper, StringIO, FileInput)):
-            self._file = file
-            self._is_buffer = True
-        else:
-            raise TypeError('invalid file. TextIOWrapper, StringIO or FileInput subclasses or path to file expected')
-        self._shifts = None
-        self._tell = 0
-        self._buffer_size = buffer_size
-        self._buffer = None
-        self._ignore = ignore
-        self._remap = remap
-        self._ignore_bad_isotopes = ignore_bad_isotopes
-        self._ignore_stereo = ignore_stereo
-        self._calc_cis_trans = calc_cis_trans
-        if indexable:
-            self._load_cache()
-
-    def read(self, amount: Optional[int] = None) -> List[Union[ReactionContainer, MoleculeContainer]]:
-        """
-        Parse whole file
-
-        :param amount: number of records to read
-        """
-        if amount:
-            return list(islice(iter(self), amount))
-        return list(iter(self))
-
-    @abstractmethod
-    def read_structure(self, *, current: bool = True):
-        """
-        Read Reaction or Molecule container.
-
-        :param current: return current structure if already parsed, otherwise read next
-        """
-
-    @abstractmethod
-    def read_metadata(self, *, current: bool = True) -> Dict[str, str]:
-        """
-        Read metadata block
-        """
-
-    def close(self, force: bool = False):
-        """
-        Close opened file
-
-        :param force: force closing of externally opened file or buffer
-        """
-        if not self._is_buffer or force:
-            self._file.close()
-
-    def tell(self):
-        """
-        Number of records processed from the original file
-        """
-        return self._tell
-
-    def seek(self, offset):
-        """
-        Shift to a given record number
-        """
-        if self._shifts:
-            if 0 <= offset < len(self._shifts):
-                self._tell = offset
-                self._buffer = None
-                self._file.seek(self._shifts[offset])
-            else:
-                raise IndexError('invalid offset')
-        else:
-            raise NotImplementedError('Indexable supported in unix-like o.s. and for files stored on disk')
-
-    @abstractmethod
-    def reset_index(self):
-        """
-        Create (rewrite) indexation table. Implemented only for object that
-        is a real file (the path to the file is specified) because the external grep utility is used.
-        """
-
-    def read_block(self, *, current: bool = True) -> str:
-        """
-        Read full record block with metadata
-        """
-        return ''.join(self._read_block(current=current))
-
-    @abstractmethod
-    def _read_block(self, *, current: bool = True) -> List[str]:
-        """
-        Read full record block with metadata
-        """
-
-    def _load_cache(self):
-        """
-        Load existing cache or create new. Working only for UNIX-like systems and local files (not buffers).
-        """
-        if platform == 'win32' or self._is_buffer:
-            return
-        try:
-            with open(self._cache_path, 'rb') as f:
-                self._shifts = load(f)
-        except FileNotFoundError:  # cache not found
-            self.reset_index()
-        except IsADirectoryError as e:
-            raise IsADirectoryError(f'Please delete {self._cache_path} directory') from e
-        except (UnpicklingError, EOFError) as e:  # invalid file. ask user to check it.
-            raise UnpicklingError(f'Invalid cache file {self._cache_path}. Please delete it') from e
-
-    @property
-    def _cache_path(self):
-        return abspath(join(gettempdir(), 'chython_' + urlsafe_b64encode(abspath(self._file.name).encode()).decode()))
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, _type, value, traceback):
-        self.close()
-
-    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
-        while True:
-            try:
-                yield self.read_structure(current=False)
-            except ValueError:
-                pass
-            except EOFError:
-                return
-
-    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
-        return next(iter(self))
-
-    def __getitem__(self, item) -> Union[ReactionContainer, MoleculeContainer,
-                                         List[Union[ReactionContainer, MoleculeContainer]]]:
-        """
-        Getting the item by index from the original file,
-        For slices records with errors skipped.
-        """
-        if self._shifts:
-            _len = len(self._shifts)
-            if isinstance(item, int):
-                if item >= _len or item < -_len:
-                    raise IndexError('List index out of range')
-                if item < 0:
-                    item += _len
-                self.seek(item)
-                return self.read_structure()
-            elif isinstance(item, slice):
-                start, stop, step = item.indices(_len)
-                if start == stop:
-                    return []
-                if step == 1:
-                    self.seek(start)
-                    records = []
-                    for _ in range(start, stop):
-                        try:
-                            records.append(self.read_structure(current=False))
-                        except EOFError:
-                            break
-                        except ValueError:
-                            pass
-                else:
-                    records = []
-                    for index in range(start, stop, step):
-                        self.seek(index)
-                        try:
-                            records.append(self.read_structure())
-                        except EOFError:
-                            break
-                        except ValueError:
-                            pass
-                return records
-            else:
-                raise TypeError('Indices must be integers or slices')
-        raise NotImplementedError('Indexable supported in unix-like o.s. and for files stored on disk')
-
-
-__all__ = ['MDLRead']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from base64 import urlsafe_b64encode
+from fileinput import FileInput
+from io import StringIO, TextIOWrapper
+from itertools import islice
+from os.path import abspath, join
+from pathlib import Path
+from pickle import dump, load, UnpicklingError
+from sys import platform
+from tempfile import gettempdir
+from typing import Union, Iterator, List
+from .parser import parse_error
+from .stereo import MDLStereo
+from ...containers import ReactionContainer, MoleculeContainer
+
+
+class MDLReadMeta(type):
+    def __call__(cls, *args, **kwargs):
+        if kwargs.get('indexable'):
+            _cls = type(cls.__name__, (cls,), {'__len__': lambda x: len(x._shifts) - 1, '__module__': cls.__module__})
+            obj = object.__new__(_cls)
+        else:
+            obj = object.__new__(cls)
+        obj.__init__(*args, **kwargs)
+        return obj
+
+
+class MDLRead(MDLStereo, metaclass=MDLReadMeta):
+    def __init__(self, file, **kwargs):
+        if isinstance(file, str):
+            self._file = open(file)
+            self._is_buffer = False
+        elif isinstance(file, Path):
+            self._file = file.open()
+            self._is_buffer = False
+        elif isinstance(file, (TextIOWrapper, StringIO, FileInput)):
+            self._file = file
+            self._is_buffer = True
+        else:
+            raise TypeError('invalid file. TextIOWrapper, StringIO subclasses possible')
+        super().__init__(**kwargs)
+
+    def close(self, force=False):
+        """
+        Close opened file
+
+        :param force: force closing of externally opened file or buffer
+        """
+        if not self._is_buffer or force:
+            self._file.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, _type, value, traceback):
+        self.close()
+
+    def _load_cache(self):
+        """
+        Load existing cache or create new. Working only for UNIX-like systems and local files (not buffers).
+        """
+        if platform == 'win32' or self._is_buffer:
+            return
+        try:
+            with open(self.__cache_path, 'rb') as f:
+                self._shifts = load(f)
+        except FileNotFoundError:  # cache not found
+            self.reset_index()
+        except IsADirectoryError as e:
+            raise IsADirectoryError(f'Please delete {self.__cache_path} directory') from e
+        except (UnpicklingError, EOFError) as e:  # invalid file. ask user to check it.
+            raise UnpicklingError(f'Invalid cache file {self.__cache_path}. Please delete it') from e
+
+    def reset_index(self):
+        """
+        Create (rewrite) indexation table. Implemented only for object that
+        is a real file (the path to the file is specified) because the external grep utility is used.
+        """
+        if platform != 'win32' and not self._is_buffer:
+            self._shifts = self._get_shifts(self._file.name)
+            with open(self.__cache_path, 'wb') as f:
+                dump(self._shifts, f)
+        else:
+            raise self._implement_error
+
+    @property
+    def __cache_path(self):
+        return abspath(join(gettempdir(), 'chython_' + urlsafe_b64encode(abspath(self._file.name).encode()).decode()))
+
+    def read(self) -> List[Union[ReactionContainer, MoleculeContainer]]:
+        """
+        Parse whole file
+
+        :return: list of parsed molecules
+        """
+        return list(iter(self))
+
+    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
+        return (x for x in self._data if not isinstance(x, parse_error))
+
+    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
+        return next(iter(self))
+
+    def __getitem__(self, item) -> Union[ReactionContainer, MoleculeContainer, parse_error]:
+        """
+        Getting the item by index from the original file,
+        For slices records with errors skipped.
+        For indexed access records with errors returned as error container.
+        :return: [Molecule, Reaction]Container or list of [Molecule, Reaction]Containers
+        """
+        if self._shifts:
+            _len = len(self._shifts) - 1
+            if isinstance(item, int):
+                if item >= _len or item < -_len:
+                    raise IndexError('List index out of range')
+                if item < 0:
+                    item += _len
+                self.seek(item)
+                return next(self._data)
+            elif isinstance(item, slice):
+                start, stop, step = item.indices(_len)
+                if start == stop:
+                    return []
+                if step == 1:
+                    self.seek(start)
+                    records = [x for x in islice(self._data, stop - start) if not isinstance(x, parse_error)]
+                else:
+                    records = []
+                    for index in range(start, stop, step):
+                        self.seek(index)
+                        record = next(self._data)
+                        if not isinstance(record, parse_error):
+                            records.append(record)
+                return records
+            else:
+                raise TypeError('Indices must be integers or slices')
+        raise self._implement_error
+
+    def read_text(self, item):
+        """
+        Read record block as text
+        """
+        if self._shifts:
+            if not isinstance(item, int):
+                raise TypeError('int required')
+            _len = len(self._shifts) - 1
+            if item >= _len or item < -_len:
+                raise IndexError('List index out of range')
+            if item < 0:
+                item += _len
+            start = self._shifts[item]
+            end = self._shifts[item + 1]
+            current = self._file.tell()
+            self._file.seek(start)
+            data = self._file.read(end - start)
+            self._file.seek(current)
+            return data
+        raise self._implement_error
+
+    def _prepare_meta(self, meta):
+        new_meta = {}
+        for k, v in meta.items():
+            if v:
+                new_meta[k] = '\n'.join(v)
+            else:
+                self._info(f'invalid metadata entry: {k}: {v}')
+        return new_meta
+
+    _shifts = None
+    _implement_error = NotImplementedError('Indexable supported in unix-like o.s. and for files stored on disk')
+
+
+__all__ = ['MDLRead']
```

### Comparing `chython-1.64/chython/files/_mdl/stereo.py` & `chython-1.8/chython/files/_mdl/stereo.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,95 +1,79 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from ...exceptions import NotChiral, IsChiral, ValenceError
-
-
-def postprocess_molecule(molecule, data, *, ignore=True, ignore_stereo=False, calc_cis_trans=False,
-                         keep_implicit=False):
-    mapping = data['mapping']
-    hydrogens = molecule._hydrogens
-    hyb = molecule.hybridization
-
-    implicit_mismatch = {}
-    if 'chython_parsing_log' in molecule.meta:
-        log = molecule.meta['chython_parsing_log']
-    else:
-        log = []
-
-    for n, h in data['hydrogens'].items():
-        n = mapping[n]
-        if keep_implicit:  # override any calculated hydrogens count.
-            hydrogens[n] = h
-        if (hc := hydrogens[n]) is None:  # aromatic rings or valence errors
-            if hyb(n) == 4:  # this is aromatic rings. just store given H count.
-                hydrogens[n] = h
-        elif hc != h:
-            if hyb(n) == 4:
-                if ignore:
-                    implicit_mismatch[n] = h
-                    log.append(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-                else:
-                    raise ValueError(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-            elif molecule._check_implicit(n, h):  # set another possible implicit state. probably Al, P
-                hydrogens[n] = h
-            elif ignore:  # just ignore it
-                implicit_mismatch[n] = h
-                log.append(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-            else:
-                raise ValueError(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-
-    if implicit_mismatch:
-        molecule.meta['chython_implicit_mismatch'] = implicit_mismatch
-    if log and 'chython_parsing_log' not in molecule.meta:
-        molecule.meta['chython_parsing_log'] = log
-    if ignore_stereo:
-        return
-
-    if calc_cis_trans:
-        molecule.calculate_cis_trans_from_2d()
-
-    stereo = [(mapping[n], mapping[m], s) for n, m, s in data['stereo']]
-    while stereo:
-        fail_stereo = []
-        old_stereo = len(stereo)
-        for n, m, s in stereo:
-            try:
-                molecule.add_wedge(n, m, s, clean_cache=False)
-            except NotChiral:
-                fail_stereo.append((n, m, s))
-            except IsChiral:
-                pass
-            except ValenceError:
-                log.append('structure has errors, stereo data skipped')
-                molecule.flush_cache()
-                break
-        else:
-            stereo = fail_stereo
-            if len(stereo) == old_stereo:
-                break
-            molecule.flush_stereo_cache()
-            if calc_cis_trans:
-                molecule.calculate_cis_trans_from_2d(clean_cache=False)
-            continue
-        break
-
-    if log and 'chython_parsing_log' not in molecule.meta:
-        molecule.meta['chython_parsing_log'] = log
-
-
-__all__ = ['postprocess_molecule']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .parser import Parser
+from ...exceptions import NotChiral, IsChiral, ValenceError
+
+
+class MDLStereo(Parser):
+    def __init__(self, calc_cis_trans=False, ignore_stereo=False, **kwargs):
+        super().__init__(**kwargs)
+        self.__calc_cis_trans = calc_cis_trans
+        self.__ignore_stereo = ignore_stereo
+
+    def _create_molecule(self, data, mapping):
+        mol = super()._create_molecule(data, mapping)
+        hydrogens = mol._hydrogens
+        for n, h in data['hydrogens'].items():
+            n = mapping[n]
+            hc = hydrogens[n]
+            if hc is None:  # aromatic rings or valence errors. just store given H count.
+                hydrogens[n] = h
+            elif hc != h:  # H count mismatch. try radical state of atom.
+                if self._ignore:
+                    hydrogens[n] = h  # set parsed hydrogens count
+                    self._info(f'implicit hydrogen count ({h}) mismatch with '
+                               f'calculated ({hc}) on atom {n}. calculated count replaced.')
+                else:
+                    raise ValueError(f'implicit hydrogen count ({h}) mismatch with '
+                                     f'calculated ({hc}) on atom {n}.')
+
+        if self.__ignore_stereo:
+            return mol
+
+        if self.__calc_cis_trans:
+            mol.calculate_cis_trans_from_2d()
+
+        stereo = [(mapping[n], mapping[m], s) for n, m, s in data['stereo']]
+        while stereo:
+            fail_stereo = []
+            old_stereo = len(stereo)
+            for n, m, s in stereo:
+                try:
+                    mol.add_wedge(n, m, s, clean_cache=False)
+                except NotChiral:
+                    fail_stereo.append((n, m, s))
+                except IsChiral:
+                    pass
+                except ValenceError:
+                    self._info('structure has errors, stereo data skipped')
+                    mol.flush_cache()
+                    break
+            else:
+                stereo = fail_stereo
+                if len(stereo) == old_stereo:
+                    break
+                mol.flush_stereo_cache()
+                if self.__calc_cis_trans:
+                    mol.calculate_cis_trans_from_2d(clean_cache=False)
+                continue
+            break
+        return mol
+
+
+__all__ = ['MDLStereo']
```

### Comparing `chython-1.64/chython/periodictable/__init__.py` & `chython-1.8/chython/periodictable/__init__.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABCMeta
-from .element import *
-from .groups import *
-from .periods import *
-from .groupI import *
-from .groupII import *
-from .groupIII import *
-from .groupIV import *
-from .groupV import *
-from .groupVI import *
-from .groupVII import *
-from .groupVIII import *
-from .groupIX import *
-from .groupX import *
-from .groupXI import *
-from .groupXII import *
-from .groupXIII import *
-from .groupXIV import *
-from .groupXV import *
-from .groupXVI import *
-from .groupXVII import *
-from .groupXVIII import *
-
-modules = {v.__name__: v for k, v in globals().items() if k.startswith('group') and k != 'groups'}
-elements = {k: v for k, v in globals().items() if isinstance(v, ABCMeta) and k != 'Element' and issubclass(v, Element)}
-
-__all__ = ['Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'ListElement', 'AnyMetal']
-__all__.extend(k for k in globals() if k.startswith('Group'))
-__all__.extend(k for k in globals() if k.startswith('Period'))
-__all__.extend(elements)
-
-
-for _class in (DynamicElement, QueryElement):
-    for k, v in elements.items():
-        name = f'{_class.__name__[:-7]}{k}'
-        globals()[name] = cls = type(name, (_class, *v.__mro__[-3:-1]),
-                                     {'__module__': v.__module__, '__slots__': (), 'atomic_number': v.atomic_number,
-                                      'atomic_radius': v.atomic_radius})
-        setattr(modules[v.__module__], name, cls)
-        modules[v.__module__].__all__.append(name)
-        __all__.append(name)
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABCMeta
+from .element import *
+from .groups import *
+from .periods import *
+from .groupI import *
+from .groupII import *
+from .groupIII import *
+from .groupIV import *
+from .groupV import *
+from .groupVI import *
+from .groupVII import *
+from .groupVIII import *
+from .groupIX import *
+from .groupX import *
+from .groupXI import *
+from .groupXII import *
+from .groupXIII import *
+from .groupXIV import *
+from .groupXV import *
+from .groupXVI import *
+from .groupXVII import *
+from .groupXVIII import *
+
+modules = {v.__name__: v for k, v in globals().items() if k.startswith('group') and k != 'groups'}
+elements = {k: v for k, v in globals().items() if isinstance(v, ABCMeta) and k != 'Element' and issubclass(v, Element)}
+
+__all__ = ['Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'ListElement', 'AnyMetal']
+__all__.extend(k for k in globals() if k.startswith('Group'))
+__all__.extend(k for k in globals() if k.startswith('Period'))
+__all__.extend(elements)
+
+
+for _class in (DynamicElement, QueryElement):
+    for k, v in elements.items():
+        name = f'{_class.__name__[:-7]}{k}'
+        globals()[name] = cls = type(name, (_class, *v.__mro__[-3:-1]),
+                                     {'__module__': v.__module__, '__slots__': (), 'atomic_number': v.atomic_number,
+                                      'atomic_radius': v.atomic_radius})
+        setattr(modules[v.__module__], name, cls)
+        modules[v.__module__].__all__.append(name)
+        __all__.append(name)
```

### Comparing `chython-1.64/chython/periodictable/element/__init__.py` & `chython-1.8/chython/periodictable/element/__init__.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .core import *
-from .element import *
-from .query import *
-from .dynamic import *
-
-
-__all__ = ['Core', 'Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .core import *
+from .element import *
+from .query import *
+from .dynamic import *
+
+
+__all__ = ['Core', 'Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
```

### Comparing `chython-1.64/chython/periodictable/element/dynamic.py` & `chython-1.8/chython/periodictable/element/dynamic.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,100 +1,100 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABC
-from typing import Type, Union
-from .core import Core
-from .element import Element
-from ...exceptions import IsNotConnectedAtom
-
-
-class DynamicElement(Core, ABC):
-    __slots__ = ('__p_charge', '__p_is_radical')
-
-    @property
-    def atomic_symbol(self) -> str:
-        return self.__class__.__name__[7:]
-
-    @classmethod
-    def from_symbol(cls, symbol: str) -> Type['DynamicElement']:
-        """
-        get DynamicElement class by its symbol
-        """
-        try:
-            element = next(x for x in DynamicElement.__subclasses__() if x.__name__ == f'Dynamic{symbol}')
-        except StopIteration:
-            raise ValueError(f'DynamicElement with symbol "{symbol}" not found')
-        return element
-
-    @classmethod
-    def from_atomic_number(cls, number: int) -> Type['DynamicElement']:
-        """
-        get DynamicElement class by its number
-        """
-        try:
-            element = next(x for x in DynamicElement.__subclasses__() if x.atomic_number.fget(None) == number)
-        except StopIteration:
-            raise ValueError(f'DynamicElement with number "{number}" not found')
-        return element
-
-    @classmethod
-    def from_atom(cls, atom: Union['Element', 'DynamicElement']) -> 'DynamicElement':
-        """
-        get DynamicElement object from Element object or copy of DynamicElement object
-        """
-        if isinstance(atom, Element):
-            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
-        elif not isinstance(atom, DynamicElement):
-            raise TypeError('Element or DynamicElement expected')
-        return atom.copy()
-
-    @property
-    def p_charge(self) -> int:
-        try:
-            return self._graph()._p_charges[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def p_is_radical(self) -> bool:
-        try:
-            return self._graph()._p_radicals[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    def __eq__(self, other):
-        """
-        compare attached to molecules dynamic elements
-        """
-        return isinstance(other, DynamicElement) and self.atomic_number == other.atomic_number and \
-            self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical and \
-            self.p_charge == other.p_charge and self.p_is_radical == other.p_is_radical
-
-    def __hash__(self):
-        return hash((self.isotope or 0, self.atomic_number, self.charge, self.p_charge,
-                     self.is_radical, self.p_is_radical))
-
-    @property
-    def is_dynamic(self) -> bool:
-        """
-        Atom has dynamic features
-        """
-        return self.charge != self.p_charge or self.is_radical != self.p_is_radical
-
-
-__all__ = ['DynamicElement']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABC
+from typing import Type, Union
+from .core import Core
+from .element import Element
+from ...exceptions import IsNotConnectedAtom
+
+
+class DynamicElement(Core, ABC):
+    __slots__ = ('__p_charge', '__p_is_radical')
+
+    @property
+    def atomic_symbol(self) -> str:
+        return self.__class__.__name__[7:]
+
+    @classmethod
+    def from_symbol(cls, symbol: str) -> Type['DynamicElement']:
+        """
+        get DynamicElement class by its symbol
+        """
+        try:
+            element = next(x for x in DynamicElement.__subclasses__() if x.__name__ == f'Dynamic{symbol}')
+        except StopIteration:
+            raise ValueError(f'DynamicElement with symbol "{symbol}" not found')
+        return element
+
+    @classmethod
+    def from_atomic_number(cls, number: int) -> Type['DynamicElement']:
+        """
+        get DynamicElement class by its number
+        """
+        try:
+            element = next(x for x in DynamicElement.__subclasses__() if x.atomic_number.fget(None) == number)
+        except StopIteration:
+            raise ValueError(f'DynamicElement with number "{number}" not found')
+        return element
+
+    @classmethod
+    def from_atom(cls, atom: Union['Element', 'DynamicElement']) -> 'DynamicElement':
+        """
+        get DynamicElement object from Element object or copy of DynamicElement object
+        """
+        if isinstance(atom, Element):
+            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
+        elif not isinstance(atom, DynamicElement):
+            raise TypeError('Element or DynamicElement expected')
+        return atom.copy()
+
+    @property
+    def p_charge(self) -> int:
+        try:
+            return self._graph()._p_charges[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @property
+    def p_is_radical(self) -> bool:
+        try:
+            return self._graph()._p_radicals[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    def __eq__(self, other):
+        """
+        compare attached to molecules dynamic elements
+        """
+        return isinstance(other, DynamicElement) and self.atomic_number == other.atomic_number and \
+            self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical and \
+            self.p_charge == other.p_charge and self.p_is_radical == other.p_is_radical
+
+    def __hash__(self):
+        return hash((self.isotope or 0, self.atomic_number, self.charge, self.p_charge,
+                     self.is_radical, self.p_is_radical))
+
+    @property
+    def is_dynamic(self) -> bool:
+        """
+        Atom has dynamic features
+        """
+        return self.charge != self.p_charge or self.is_radical != self.p_is_radical
+
+
+__all__ = ['DynamicElement']
```

### Comparing `chython-1.64/chython/periodictable/element/query.py` & `chython-1.8/chython/periodictable/element/query.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,318 +1,394 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2021 Dmitrij Zanadvornykh <zandmitrij@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABC
-from typing import Tuple, Type, List, Union
-from .core import Core
-from .element import Element
-from ...exceptions import IsNotConnectedAtom
-
-
-_inorganic = {'He', 'Ne', 'Ar', 'Kr', 'Xe', 'F', 'Cl', 'Br', 'I', 'B', 'C', 'N', 'O',
-              'H', 'Si', 'P', 'S', 'Se', 'Ge', 'As', 'Sb', 'Te'}
-
-
-class Query(Core, ABC):
-    __slots__ = ()
-
-    @property
-    def neighbors(self) -> Tuple[int, ...]:
-        try:
-            return self._graph()._neighbors[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def hybridization(self):
-        try:
-            return self._graph()._hybridizations[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def heteroatoms(self) -> Tuple[int, ...]:
-        try:
-            return self._graph()._heteroatoms[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def ring_sizes(self) -> Tuple[int, ...]:
-        """
-        Atom rings sizes.
-        """
-        try:
-            return self._graph()._rings_sizes[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-        except KeyError:
-            return ()
-
-    @property
-    def implicit_hydrogens(self) -> Tuple[int, ...]:
-        try:
-            return self._graph()._hydrogens[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-
-class QueryElement(Query, ABC):
-    __slots__ = ()
-
-    @property
-    def atomic_symbol(self) -> str:
-        return self.__class__.__name__[5:]
-
-    @classmethod
-    def from_symbol(cls, symbol: str) -> Type[Union['QueryElement', 'AnyElement', 'AnyMetal']]:
-        """
-        get Element class by its symbol
-        """
-        if symbol == 'A':
-            return AnyElement
-        elif symbol == 'M':
-            return AnyMetal
-        try:
-            element = next(x for x in QueryElement.__subclasses__() if x.__name__ == f'Query{symbol}')
-        except StopIteration:
-            raise ValueError(f'QueryElement with symbol "{symbol}" not found')
-        return element
-
-    @classmethod
-    def from_atomic_number(cls, number: int) -> Type['QueryElement']:
-        """
-        get Element class by its number
-        """
-        try:
-            element = next(x for x in QueryElement.__subclasses__() if x.atomic_number.fget(None) == number)
-        except StopIteration:
-            raise ValueError(f'QueryElement with number "{number}" not found')
-        return element
-
-    @classmethod
-    def from_atom(cls, atom: Union['Element', 'Query']) -> 'Query':
-        """
-        get QueryElement or AnyElement object from Element object or copy of QueryElement or AnyElement
-        """
-        if isinstance(atom, Element):
-            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
-        elif not isinstance(atom, Query):
-            raise TypeError('Element or Query expected')
-        return atom.copy()
-
-    def __eq__(self, other):
-        """
-        compare attached to molecules elements and query elements
-        """
-        if isinstance(other, Element):
-            if self.atomic_number == other.atomic_number and self.charge == other.charge and \
-                    self.is_radical == other.is_radical:
-                if self.isotope and self.isotope != other.isotope:
-                    return False
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                if self.ring_sizes:
-                    if self.ring_sizes[0]:
-                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
-                            return False
-                    elif other.ring_sizes:  # not in ring expected
-                        return False
-                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
-                    return False
-                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
-                    return False
-                return True
-        elif isinstance(other, QueryElement) and self.atomic_number == other.atomic_number and \
-                self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical \
-                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
-                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
-                and self.heteroatoms == other.heteroatoms:
-            # equal query element has equal query marks
-            return True
-        return False
-
-    def __hash__(self):
-        return hash((self.isotope or 0, self.atomic_number, self.charge, self.is_radical, self.neighbors,
-                     self.hybridization, self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
-
-
-class AnyElement(Query):
-    __slots__ = ()
-
-    def __init__(self, *args, **kwargs):
-        super().__init__()
-
-    @property
-    def atomic_symbol(self) -> str:
-        return 'A'
-
-    @property
-    def atomic_number(self) -> int:
-        return 0
-
-    def __eq__(self, other):
-        """
-        Compare attached to molecules elements and query elements
-        """
-        if isinstance(other, Element):
-            if self.charge == other.charge and self.is_radical == other.is_radical:
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                if self.ring_sizes:
-                    if self.ring_sizes[0]:
-                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
-                            return False
-                    elif other.ring_sizes:  # not in ring expected
-                        return False
-                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
-                    return False
-                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
-                    return False
-                return True
-        elif isinstance(other, AnyMetal):
-            return False
-        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
-                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
-                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
-                and self.heteroatoms == other.heteroatoms:
-            return True
-        return False
-
-    def __hash__(self):
-        return hash((self.charge, self.is_radical, self.neighbors, self.hybridization, self.ring_sizes,
-                     self.implicit_hydrogens, self.heteroatoms))
-
-
-class AnyMetal(Query):
-    """
-    Charge and radical ignored any metal. Rings, hydrogens and heteroatoms count also ignored.
-
-    Class designed for d-elements matching in standardization.
-    """
-    def __init__(self, *args, **kwargs):
-        super().__init__()
-
-    @property
-    def atomic_symbol(self) -> str:
-        return 'M'
-
-    @property
-    def atomic_number(self) -> int:
-        return 0
-
-    def __eq__(self, other):
-        if isinstance(other, Element):
-            if other.atomic_symbol not in _inorganic:
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                return True
-        elif isinstance(other, AnyMetal) and self.neighbors == other.neighbors \
-                and self.hybridization == other.hybridization:
-            return True
-        return False
-
-    def __hash__(self):
-        return hash((self.neighbors, self.hybridization))
-
-
-class ListElement(Query):
-    __slots__ = ('_elements', '_numbers')
-
-    def __init__(self, elements: List[str], *args, **kwargs):
-        """
-        Elements list
-        """
-        super().__init__()
-        self._elements = tuple(elements)
-        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__() if x.__name__ in elements)
-
-    @property
-    def atomic_symbol(self) -> str:
-        return ','.join(self._elements)
-
-    @property
-    def atomic_number(self) -> int:
-        return 0
-
-    def copy(self):
-        copy = super().copy()
-        copy._elements = self._elements
-        copy._numbers = self._numbers
-        return copy
-
-    def __eq__(self, other):
-        """
-        Compare attached to molecules elements and query elements
-        """
-        if isinstance(other, Element):
-            if other.atomic_number in self._numbers:
-                if self.charge != other.charge or self.is_radical != other.is_radical:
-                    return False
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                if self.ring_sizes:
-                    if self.ring_sizes[0]:
-                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
-                            return False
-                    elif other.ring_sizes:  # not in ring expected
-                        return False
-                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
-                    return False
-                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
-                    return False
-                return True
-        elif isinstance(other, (AnyElement, AnyMetal)):
-            return False
-        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
-                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
-                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
-                and self.heteroatoms == other.heteroatoms:
-            if isinstance(other, ListElement):
-                return self._numbers == other._numbers
-            return other.atomic_number in self._numbers
-        return False
-
-    def __hash__(self):
-        return hash((self._numbers, self.charge, self.is_radical, self.neighbors, self.hybridization,
-                     self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
-
-    def __getstate__(self):
-        state = super().__getstate__()
-        state['elements'] = self._elements
-        return state
-
-    def __setstate__(self, state):
-        self._elements = state['elements']
-        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__()
-                              if x.__name__ in state['elements'])
-        super().__setstate__(state)
-
-    def __repr__(self):
-        return f'{self.__class__.__name__}([{",".join(self._elements)}])'
-
-
-__all__ = ['Query', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2021 Dmitrij Zanadvornykh <zandmitrij@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABC
+from typing import Tuple, Type, List, Union
+from .core import Core
+from .element import Element
+from ...exceptions import IsNotConnectedAtom
+
+
+_inorganic = {'He', 'Ne', 'Ar', 'Kr', 'Xe', 'F', 'Cl', 'Br', 'I', 'B', 'C', 'N', 'O',
+              'H', 'Si', 'P', 'S', 'Se', 'Ge', 'As', 'Sb', 'Te'}
+
+
+class Query(Core, ABC):
+    __slots__ = ()
+
+    @Core.charge.setter
+    def charge(self, charge):
+        if not isinstance(charge, int):
+            raise TypeError('formal charge should be int in range [-4, 4]')
+        elif charge > 4 or charge < -4:
+            raise ValueError('formal charge should be in range [-4, 4]')
+        try:
+            g = self._graph()
+            g._charges[self._map] = charge
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @Core.is_radical.setter
+    def is_radical(self, is_radical):
+        if not isinstance(is_radical, bool):
+            raise TypeError('bool expected')
+        try:
+            g = self._graph()
+            g._radicals[self._map] = is_radical
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def neighbors(self) -> Tuple[int, ...]:
+        try:
+            return self._graph()._neighbors[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @property
+    def hybridization(self):
+        try:
+            return self._graph()._hybridizations[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @neighbors.setter
+    def neighbors(self, neighbors):
+        try:
+            g = self._graph()
+            g._neighbors[self._map] = g._validate_neighbors(neighbors)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @hybridization.setter
+    def hybridization(self, hybridization):
+        try:
+            g = self._graph()
+            g._hybridizations[self._map] = g._validate_hybridization(hybridization)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def heteroatoms(self) -> Tuple[int, ...]:
+        try:
+            return self._graph()._heteroatoms[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @heteroatoms.setter
+    def heteroatoms(self, heteroatoms):
+        try:
+            g = self._graph()
+            g._heteroatoms[self._map] = g._validate_neighbors(heteroatoms)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def ring_sizes(self) -> Tuple[int, ...]:
+        """
+        Atom rings sizes.
+        """
+        try:
+            return self._graph()._rings_sizes[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+        except KeyError:
+            return ()
+
+    @ring_sizes.setter
+    def ring_sizes(self, ring_sizes):
+        try:
+            g = self._graph()
+            g._rings_sizes[self._map] = g._validate_rings(ring_sizes)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def implicit_hydrogens(self) -> Tuple[int, ...]:
+        try:
+            return self._graph()._hydrogens[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @implicit_hydrogens.setter
+    def implicit_hydrogens(self, implicit_hydrogens):
+        try:
+            g = self._graph()
+            g._hydrogens[self._map] = g._validate_neighbors(implicit_hydrogens)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+
+class QueryElement(Query, ABC):
+    __slots__ = ()
+
+    @property
+    def atomic_symbol(self) -> str:
+        return self.__class__.__name__[5:]
+
+    @classmethod
+    def from_symbol(cls, symbol: str) -> Type[Union['QueryElement', 'AnyElement', 'AnyMetal']]:
+        """
+        get Element class by its symbol
+        """
+        if symbol == 'A':
+            return AnyElement
+        elif symbol == 'M':
+            return AnyMetal
+        try:
+            element = next(x for x in QueryElement.__subclasses__() if x.__name__ == f'Query{symbol}')
+        except StopIteration:
+            raise ValueError(f'QueryElement with symbol "{symbol}" not found')
+        return element
+
+    @classmethod
+    def from_atomic_number(cls, number: int) -> Type['QueryElement']:
+        """
+        get Element class by its number
+        """
+        try:
+            element = next(x for x in QueryElement.__subclasses__() if x.atomic_number.fget(None) == number)
+        except StopIteration:
+            raise ValueError(f'QueryElement with number "{number}" not found')
+        return element
+
+    @classmethod
+    def from_atom(cls, atom: Union['Element', 'Query']) -> 'Query':
+        """
+        get QueryElement or AnyElement object from Element object or copy of QueryElement or AnyElement
+        """
+        if isinstance(atom, Element):
+            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
+        elif not isinstance(atom, Query):
+            raise TypeError('Element or Query expected')
+        return atom.copy()
+
+    def __eq__(self, other):
+        """
+        compare attached to molecules elements and query elements
+        """
+        if isinstance(other, Element):
+            if self.atomic_number == other.atomic_number and self.charge == other.charge and \
+                    self.is_radical == other.is_radical:
+                if self.isotope and self.isotope != other.isotope:
+                    return False
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                if self.ring_sizes:
+                    if self.ring_sizes[0]:
+                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
+                            return False
+                    elif other.ring_sizes:  # not in ring expected
+                        return False
+                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
+                    return False
+                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
+                    return False
+                return True
+        elif isinstance(other, QueryElement) and self.atomic_number == other.atomic_number and \
+                self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical \
+                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
+                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
+                and self.heteroatoms == other.heteroatoms:
+            # equal query element has equal query marks
+            return True
+        return False
+
+    def __hash__(self):
+        return hash((self.isotope or 0, self.atomic_number, self.charge, self.is_radical, self.neighbors,
+                     self.hybridization, self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
+
+
+class AnyElement(Query):
+    __slots__ = ()
+
+    def __init__(self, *args, **kwargs):
+        super().__init__()
+
+    @property
+    def atomic_symbol(self) -> str:
+        return 'A'
+
+    @property
+    def atomic_number(self) -> int:
+        return 0
+
+    def __eq__(self, other):
+        """
+        Compare attached to molecules elements and query elements
+        """
+        if isinstance(other, Element):
+            if self.charge == other.charge and self.is_radical == other.is_radical:
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                if self.ring_sizes:
+                    if self.ring_sizes[0]:
+                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
+                            return False
+                    elif other.ring_sizes:  # not in ring expected
+                        return False
+                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
+                    return False
+                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
+                    return False
+                return True
+        elif isinstance(other, AnyMetal):
+            return False
+        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
+                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
+                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
+                and self.heteroatoms == other.heteroatoms:
+            return True
+        return False
+
+    def __hash__(self):
+        return hash((self.charge, self.is_radical, self.neighbors, self.hybridization, self.ring_sizes,
+                     self.implicit_hydrogens, self.heteroatoms))
+
+
+class AnyMetal(Query):
+    """
+    Charge and radical ignored any metal. Rings, hydrogens and heteroatoms count also ignored.
+
+    Class designed for d-elements matching in standardization.
+    """
+    def __init__(self, *args, **kwargs):
+        super().__init__()
+
+    @property
+    def atomic_symbol(self) -> str:
+        return 'M'
+
+    @property
+    def atomic_number(self) -> int:
+        return 0
+
+    def __eq__(self, other):
+        if isinstance(other, Element):
+            if other.atomic_symbol not in _inorganic:
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                return True
+        elif isinstance(other, AnyMetal) and self.neighbors == other.neighbors \
+                and self.hybridization == other.hybridization:
+            return True
+        return False
+
+    def __hash__(self):
+        return hash((self.neighbors, self.hybridization))
+
+
+class ListElement(Query):
+    __slots__ = ('_elements', '_numbers')
+
+    def __init__(self, elements: List[str], *args, **kwargs):
+        """
+        Elements list
+        """
+        super().__init__()
+        self._elements = tuple(elements)
+        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__() if x.__name__ in elements)
+
+    @property
+    def atomic_symbol(self) -> str:
+        return ','.join(self._elements)
+
+    @property
+    def atomic_number(self) -> int:
+        return 0
+
+    def copy(self):
+        copy = super().copy()
+        copy._elements = self._elements
+        copy._numbers = self._numbers
+        return copy
+
+    def __eq__(self, other):
+        """
+        Compare attached to molecules elements and query elements
+        """
+        if isinstance(other, Element):
+            if other.atomic_number in self._numbers:
+                if self.charge != other.charge or self.is_radical != other.is_radical:
+                    return False
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                if self.ring_sizes:
+                    if self.ring_sizes[0]:
+                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
+                            return False
+                    elif other.ring_sizes:  # not in ring expected
+                        return False
+                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
+                    return False
+                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
+                    return False
+                return True
+        elif isinstance(other, (AnyElement, AnyMetal)):
+            return False
+        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
+                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
+                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
+                and self.heteroatoms == other.heteroatoms:
+            if isinstance(other, ListElement):
+                return self._numbers == other._numbers
+            return other.atomic_number in self._numbers
+        return False
+
+    def __hash__(self):
+        return hash((self._numbers, self.charge, self.is_radical, self.neighbors, self.hybridization,
+                     self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
+
+    def __getstate__(self):
+        state = super().__getstate__()
+        state['elements'] = self._elements
+        return state
+
+    def __setstate__(self, state):
+        self._elements = state['elements']
+        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__()
+                              if x.__name__ in state['elements'])
+        super().__setstate__(state)
+
+    def __repr__(self):
+        return f'{self.__class__.__name__}([{",".join(self._elements)}])'
+
+
+__all__ = ['Query', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
```

### Comparing `chython-1.64/chython/periodictable/groupI.py` & `chython-1.8/chython/periodictable/groupXIII.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,220 +1,205 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupI
-from .periods import *
-
-
-class H(Element, PeriodI, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 1
-
-    @property
-    def isotopes_distribution(self):
-        return {1: 0.999885, 2: 0.000115, 3: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {1: 1.007825, 2: 2.014102, 3: 3.016049}
-
-    @property
-    def _common_valences(self):
-        return 1,
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()), (0, True, 0, ()), (-1, False, 0, ())
-
-    @property
-    def atomic_radius(self):
-        return 0.53
-
-
-class Li(Element, PeriodII, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 3
-
-    @property
-    def isotopes_distribution(self):
-        return {6: 0.0759, 7: 0.9241}
-
-    @property
-    def isotopes_masses(self):
-        return {6: 6.015122, 7: 7.016004}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 167
-
-
-class Na(Element, PeriodIII, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 11
-
-    @property
-    def isotopes_distribution(self):
-        return {22: 0., 23: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {22: 21.994437, 23: 22.98977}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 1.9
-
-
-class K(Element, PeriodIV, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 19
-
-    @property
-    def isotopes_distribution(self):
-        return {39: 0.932581, 40: 0.000117, 41: 0.067302, 42: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {39: 38.963707, 40: 39.963999, 41: 40.961826, 42: 41.962402}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.43
-
-
-class Rb(Element, PeriodV, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 37
-
-    @property
-    def isotopes_distribution(self):
-        return {82: 0., 85: 0.7217, 87: 0.2783}
-
-    @property
-    def isotopes_masses(self):
-        return {82: 81.918209, 85: 84.911789, 87: 86.909183}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.65
-
-
-class Cs(Element, PeriodVI, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 55
-
-    @property
-    def isotopes_distribution(self):
-        return {131: 0., 133: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {131: 130.905464, 133: 132.905447}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.98
-
-
-class Fr(Element, PeriodVII, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 87
-
-    @property
-    def isotopes_distribution(self):
-        return {223: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {223: 223.019736}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.98  # unknown, taken radius of previous element in group
-
-
-__all__ = ['H', 'Li', 'Na', 'K', 'Rb', 'Cs', 'Fr']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXIII
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class B(Element, PeriodII, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 5
+
+    @property
+    def isotopes_distribution(self):
+        return {10: 0.199, 11: 0.801}
+
+    @property
+    def isotopes_masses(self):
+        return {10: 10.012937, 11: 11.009305}
+
+    @property
+    def _common_valences(self):
+        return 3,
+
+    @property
+    def _valences_exceptions(self):
+        return (-1, False, 4, ()),
+
+    @property
+    def atomic_radius(self):
+        return .87
+
+
+class Al(Element, PeriodIII, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 13
+
+    @property
+    def isotopes_distribution(self):
+        return {27: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {27: 26.981538}
+
+    @property
+    def _common_valences(self):
+        return 0,  # 3 omitted. added to exceptions
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (2, False, 1, ()), (1, False, 2, ()), (0, False, 3, ()), (-1, False, 4, ()),
+                (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.18
+
+
+class Ga(Element, PeriodIV, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 31
+
+    @property
+    def isotopes_distribution(self):
+        return {67: 0., 69: 0.60108, 71: 0.39892}
+
+    @property
+    def isotopes_masses(self):
+        return {67: 66.928202, 69: 68.925581, 71: 70.924705}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
+                (-1, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'), (1, 'H'))),
+                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (-1, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (-1, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.36
+
+
+class In(Element, PeriodV, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 49
+
+    @property
+    def isotopes_distribution(self):
+        return {111: 0., 113: 0.0429, 115: 0.9571}
+
+    @property
+    def isotopes_masses(self):
+        return {111: 110.905103, 113: 112.904061, 115: 114.903878}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
+                (0, False, 0, ((1, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 1.56
+
+
+class Tl(Element, PeriodVI, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 81
+
+    @property
+    def isotopes_distribution(self):
+        return {203: 0.29524, 205: 0.70476}
+
+    @property
+    def isotopes_masses(self):
+        return {203: 202.972329, 205: 204.974412}
+
+    @property
+    def _common_valences(self):
+        return 0, 1
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 0, ()), (3, False, 0, ()),
+                (-3, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (1, False, 0, ((1, 'C'), (1, 'C'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.56
+
+
+class Nh(Element, PeriodVII, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 113
+
+    @property
+    def isotopes_distribution(self):
+        return {286: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {286: 286.182555}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.56  # unknown, taken radius of previous element in group
+
+
+__all__ = ['B', 'Al', 'Ga', 'In', 'Tl', 'Nh']
```

### Comparing `chython-1.64/chython/periodictable/groupII.py` & `chython-1.8/chython/periodictable/groupXV.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,199 +1,214 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupII
-from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Be(Element, PeriodII, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 4
-
-    @property
-    def isotopes_distribution(self):
-        return {9: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {9: 9.012182}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 1.12
-
-
-class Mg(Element, PeriodIII, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 12
-
-    @property
-    def isotopes_distribution(self):
-        return {24: 0.7899, 25: 0.1, 26: 0.1101}
-
-    @property
-    def isotopes_masses(self):
-        return {24: 23.985042, 25: 24.985837, 26: 25.982593}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return ((2, False, 0, ()),
-                (1, False, 0, ((1, 'C'),)),
-                (1, False, 0, ((1, 'O'),)),
-                (1, False, 0, ((1, 'Br'),)),
-                (1, False, 0, ((1, 'Cl'),)))
-
-    @property
-    def atomic_radius(self):
-        return 1.45
-
-
-class Ca(Element, PeriodIV, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 20
-
-    @property
-    def isotopes_distribution(self):
-        return {40: 0.96941, 42: 0.00647, 43: 0.00135, 44: 0.02086, 45: 0., 46: 4e-05, 47: 0., 48: 0.00187}
-
-    @property
-    def isotopes_masses(self):
-        return {40: 39.962591, 42: 41.958618, 43: 42.958767, 44: 43.955481, 45: 44.956186, 46: 45.953693, 47: 46.954541,
-                48: 47.952534}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 1.94
-
-
-class Sr(Element, PeriodV, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 38
-
-    @property
-    def isotopes_distribution(self):
-        return {84: 0.0056, 85: 0., 86: 0.0986, 87: 0.07, 88: 0.8258, 89: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {84: 83.913425, 85: 84.912933, 86: 85.909262, 87: 86.908879, 88: 87.905614, 89: 88.907451}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.19
-
-
-class Ba(Element, PeriodVI, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 56
-
-    @property
-    def isotopes_distribution(self):
-        return {130: 0.00106, 132: 0.00101, 134: 0.02417, 135: 0.06592, 136: 0.07854, 137: 0.11232, 138: 0.71698}
-
-    @property
-    def isotopes_masses(self):
-        return {130: 129.90631, 132: 131.905056, 134: 133.904503, 135: 134.905683, 136: 135.90457, 137: 136.905821,
-                138: 137.905241}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.53
-
-
-class Ra(Element, PeriodVII, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 88
-
-    @property
-    def isotopes_distribution(self):
-        return {223: 0., 226: 1.0, 228: 0., 233: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {223: 223.018502, 226: 226.025410, 228: 228.031070, 233: 233.048065}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.53  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Be', 'Mg', 'Ca', 'Sr', 'Ba', 'Ra']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXV
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class N(Element, PeriodII, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 7
+
+    @property
+    def isotopes_distribution(self):
+        return {14: 0.99632, 15: 0.00368}
+
+    @property
+    def isotopes_masses(self):
+        return {14: 14.003074, 15: 15.000109}
+
+    @property
+    def _common_valences(self):
+        return 3,
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 2, ()), (1, False, 4, ()),
+                (0, True, 2, ()))  # *NO, etc
+
+    @property
+    def atomic_radius(self):
+        return .56
+
+
+class P(Element, PeriodIII, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 15
+
+    @property
+    def isotopes_distribution(self):
+        return {31: 1.0, 32: 0., 33: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {31: 30.973762, 32: 31.973908, 33: 32.971726}
+
+    @property
+    def _common_valences(self):
+        return 3, 5
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 2, ()), (1, False, 4, ()),
+                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return .98
+
+
+class As(Element, PeriodIV, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 33
+
+    @property
+    def isotopes_distribution(self):
+        return {75: 1.0, 76: 0., 77: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {75: 74.921596, 76: 75.922394, 77: 76.920647}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 5
+
+    @property
+    def _valences_exceptions(self):
+        return (1, False, 4, ()),
+
+    @property
+    def atomic_radius(self):
+        return 1.14
+
+
+class Sb(Element, PeriodV, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 51
+
+    @property
+    def isotopes_distribution(self):
+        return {121: 0.5721, 123: 0.4279}
+
+    @property
+    def isotopes_masses(self):
+        return {121: 120.903818, 123: 122.904216}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 5
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 4, ()),
+                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.33
+
+
+class Bi(Element, PeriodVI, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 83
+
+    @property
+    def isotopes_distribution(self):
+        return {207: 0., 209: 1.0, 210: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {207: 206.978471, 209: 208.980383, 210: 209.984120}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'),)),
+                (0, False, 0, ((1, 'Br'),)),
+
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'S'), (1, 'S'))),
+                (0, False, 0, ((2, 'S'),)),
+                (0, False, 0, ((1, 'Se'), (1, 'Se'))),
+                (0, False, 0, ((2, 'Se'),)),
+
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.43
+
+
+class Mc(Element, PeriodVII, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 115
+
+    @property
+    def isotopes_distribution(self):
+        return {289: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {289: 289.0}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.43  # unknown, taken radius of previous element in group
+
+
+__all__ = ['N', 'P', 'As', 'Sb', 'Bi', 'Mc']
```

### Comparing `chython-1.64/chython/periodictable/groupIII.py` & `chython-1.8/chython/periodictable/groupIII.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,1026 +1,1026 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupIII
-from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Sc(Element, PeriodIV, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 21
-
-    @property
-    def isotopes_distribution(self):
-        return {44: 0., 45: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {44: 43.959403, 45: 44.955910}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()), (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F')))
-
-    @property
-    def atomic_radius(self):
-        return 1.84
-
-
-class Y(Element, PeriodV, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 39
-
-    @property
-    def isotopes_distribution(self):
-        return {86: 0., 89: 1.0, 90: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {86: 85.914886, 89: 88.905848, 90: 89.907152}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.12
-
-
-class La(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 57
-
-    @property
-    def isotopes_distribution(self):
-        return {138: 0.0009, 139: 0.9991}
-
-    @property
-    def isotopes_masses(self):
-        return {138: 137.907107, 139: 138.906348}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.12  # unknown, taken radius of previous element in group
-
-
-class Ce(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 58
-
-    @property
-    def isotopes_distribution(self):
-        return {136: 0.00185, 138: 0.00251, 140: 0.8845, 142: 0.11114}
-
-    @property
-    def isotopes_masses(self):
-        return {136: 135.90714, 138: 137.905986, 140: 139.905434, 142: 141.90924}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.12  # unknown, taken radius of previous element in group
-
-
-class Pr(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 59
-
-    @property
-    def isotopes_distribution(self):
-        return {141: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {141: 140.907648}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.47
-
-
-class Nd(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 60
-
-    @property
-    def isotopes_distribution(self):
-        return {142: 0.272, 143: 0.122, 144: 0.238, 145: 0.083, 146: 0.172, 148: 0.057, 150: 0.056}
-
-    @property
-    def isotopes_masses(self):
-        return {142: 141.907719, 143: 142.90981, 144: 143.910083, 145: 144.912569, 146: 145.913112, 148: 147.916889,
-                150: 149.920887}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'),)),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.06
-
-
-class Pm(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 61
-
-    @property
-    def isotopes_distribution(self):
-        return {145: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {145: 144.912749}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.05
-
-
-class Sm(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 62
-
-    @property
-    def isotopes_distribution(self):
-        return {144: 0.0307, 145: 0., 147: 0.1499, 148: 0.1124, 149: 0.1382, 150: 0.0738, 152: 0.2675, 153: 0.,
-                154: 0.2275}
-
-    @property
-    def isotopes_masses(self):
-        return {144: 143.911995, 145: 144.913410, 147: 146.914893, 148: 147.914818, 149: 148.917180, 150: 149.917271,
-                152: 151.919728, 153: 152.922097, 154: 153.922205}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.38
-
-
-class Eu(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 63
-
-    @property
-    def isotopes_distribution(self):
-        return {151: 0.4781, 152: 0., 153: 0.5219}
-
-    @property
-    def isotopes_masses(self):
-        return {151: 150.919846, 152: 151.921744, 153: 152.921226}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.31
-
-
-class Gd(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 64
-
-    @property
-    def isotopes_distribution(self):
-        return {152: 0.002, 153: 0., 154: 0.0218, 155: 0.148, 156: 0.2047, 157: 0.1565, 158: 0.2484, 160: 0.2186}
-
-    @property
-    def isotopes_masses(self):
-        return {152: 151.919788, 153: 152.921750, 154: 153.920862, 155: 154.922619, 156: 155.922120, 157: 156.923957,
-                158: 157.924101, 160: 159.927051}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.33
-
-
-class Tb(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 65
-
-    @property
-    def isotopes_distribution(self):
-        return {159: 1.0, 160: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {159: 158.925343, 160: 159.927168}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.25
-
-
-class Dy(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 66
-
-    @property
-    def isotopes_distribution(self):
-        return {156: 0.0006, 158: 0.001, 160: 0.0234, 161: 0.1891, 162: 0.2551, 163: 0.249, 164: 0.2818}
-
-    @property
-    def isotopes_masses(self):
-        return {156: 155.924278, 158: 157.924405, 160: 159.925194, 161: 160.92693, 162: 161.926795, 163: 162.928728,
-                164: 163.929171}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.28
-
-
-class Ho(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 67
-
-    @property
-    def isotopes_distribution(self):
-        return {165: 1.0, 166: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {165: 164.930319, 166: 165.932284}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.26
-
-
-class Er(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 68
-
-    @property
-    def isotopes_distribution(self):
-        return {162: 0.0014, 164: 0.0161, 166: 0.3361, 167: 0.2293, 168: 0.2678, 170: 0.1493}
-
-    @property
-    def isotopes_masses(self):
-        return {162: 161.928775, 164: 163.929197, 166: 165.93029, 167: 166.932045, 168: 167.932368, 170: 169.93546}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.26
-
-
-class Tm(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 69
-
-    @property
-    def isotopes_distribution(self):
-        return {169: 1.0, 170: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {169: 168.934211, 170: 169.935801}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.22
-
-
-class Yb(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 70
-
-    @property
-    def isotopes_distribution(self):
-        return {168: 0.0013, 169: 0., 170: 0.0304, 171: 0.1428, 172: 0.2183, 173: 0.1613, 174: 0.3183, 176: 0.1276}
-
-    @property
-    def isotopes_masses(self):
-        return {168: 167.933894, 169: 168.935190, 170: 169.934759, 171: 170.936322, 172: 171.936378, 173: 172.938207,
-                174: 173.938858, 176: 175.942568}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.22
-
-
-class Lu(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 71
-
-    @property
-    def isotopes_distribution(self):
-        return {175: 0.9741, 176: 0.0259, 177: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {175: 174.940768, 176: 175.942682, 177: 176.943758}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17
-
-
-class Ac(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 89
-
-    @property
-    def isotopes_distribution(self):
-        return {225: 0., 227: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {225: 225.023230, 227: 227.027752}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Th(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 90
-
-    @property
-    def isotopes_distribution(self):
-        return {227: 0., 232: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {227: 227.027704, 232: 232.038050}
-
-    @property
-    def _common_valences(self):
-        return 0, 4
-
-    @property
-    def _valences_exceptions(self):
-        return ((4, False, 0, ()),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Pa(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 91
-
-    @property
-    def isotopes_distribution(self):
-        return {231: 1.0, 233: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {231: 231.035879, 233: 233.040247}
-
-    @property
-    def _common_valences(self):
-        return 0, 4, 5
-
-    @property
-    def _valences_exceptions(self):
-        return ((4, False, 0, ()),
-                (0, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class U(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 92
-
-    @property
-    def isotopes_distribution(self):
-        return {234: 5.5e-05, 235: 0.0072, 238: 0.992745}
-
-    @property
-    def isotopes_masses(self):
-        return {234: 234.040946, 235: 235.043923, 238: 238.050783}
-
-    @property
-    def _common_valences(self):
-        return 0, 3, 4, 5, 6
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()), (4, False, 0, ()),
-                (2, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Np(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 93
-
-    @property
-    def isotopes_distribution(self):
-        return {237: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {237: 237.048173}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4, 5, 6, 7
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()), (4, False, 0, ()),
-                (1, False, 0, ((2, 'O'), (2, 'O'))),
-                (2, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Pu(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 94
-
-    @property
-    def isotopes_distribution(self):
-        return {239: 1.0, 242: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {239: 239.052163, 242: 242.058743}
-
-    @property
-    def _common_valences(self):
-        return 0, 3, 4, 5, 6
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()), (4, False, 0, ()),
-                (1, False, 0, ((2, 'O'), (2, 'O'))),
-                (2, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'Se'), )),
-                (0, False, 0, ((2, 'S'),)),
-                (0, False, 0, ((2, 'Te'),)),
-                (0, False, 0, ((2, 'O'),)),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Am(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 95
-
-    @property
-    def isotopes_distribution(self):
-        return {241: 1.0, 243: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {241: 241.056829, 243: 243.061380}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Cm(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 96
-
-    @property
-    def isotopes_distribution(self):
-        return {243: 0., 244: 1.0, 248: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {243: 243.061389, 244: 244.062753, 248: 248.072349}
-
-    @property
-    def _common_valences(self):
-        return 0, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (0, False, 0, ((2, 'O'),)), (0, False, 0, ((1, 'H'), (1, 'H')))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Bk(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 97
-
-    @property
-    def isotopes_distribution(self):
-        return {249: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {249: 249.074987}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()), (4, False, 0, ())
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Cf(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 98
-
-    @property
-    def isotopes_distribution(self):
-        return {249: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {249: 249.074854}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Es(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 99
-
-    @property
-    def isotopes_distribution(self):
-        return {252: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {252: 252.08298}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Fm(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 100
-
-    @property
-    def isotopes_distribution(self):
-        return {257: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {257: 257.095106}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Md(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 101
-
-    @property
-    def isotopes_distribution(self):
-        return {258: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {258: 258.098431}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class No(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 102
-
-    @property
-    def isotopes_distribution(self):
-        return {259: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {259: 259.10103}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Lr(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 103
-
-    @property
-    def isotopes_distribution(self):
-        return {266: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {266: 266.11983}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Sc', 'Y',
-           'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu',
-           'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupIII
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Sc(Element, PeriodIV, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 21
+
+    @property
+    def isotopes_distribution(self):
+        return {44: 0., 45: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {44: 43.959403, 45: 44.955910}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()), (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F')))
+
+    @property
+    def atomic_radius(self):
+        return 1.84
+
+
+class Y(Element, PeriodV, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 39
+
+    @property
+    def isotopes_distribution(self):
+        return {86: 0., 89: 1.0, 90: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {86: 85.914886, 89: 88.905848, 90: 89.907152}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.12
+
+
+class La(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 57
+
+    @property
+    def isotopes_distribution(self):
+        return {138: 0.0009, 139: 0.9991}
+
+    @property
+    def isotopes_masses(self):
+        return {138: 137.907107, 139: 138.906348}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.12  # unknown, taken radius of previous element in group
+
+
+class Ce(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 58
+
+    @property
+    def isotopes_distribution(self):
+        return {136: 0.00185, 138: 0.00251, 140: 0.8845, 142: 0.11114}
+
+    @property
+    def isotopes_masses(self):
+        return {136: 135.90714, 138: 137.905986, 140: 139.905434, 142: 141.90924}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.12  # unknown, taken radius of previous element in group
+
+
+class Pr(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 59
+
+    @property
+    def isotopes_distribution(self):
+        return {141: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {141: 140.907648}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.47
+
+
+class Nd(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 60
+
+    @property
+    def isotopes_distribution(self):
+        return {142: 0.272, 143: 0.122, 144: 0.238, 145: 0.083, 146: 0.172, 148: 0.057, 150: 0.056}
+
+    @property
+    def isotopes_masses(self):
+        return {142: 141.907719, 143: 142.90981, 144: 143.910083, 145: 144.912569, 146: 145.913112, 148: 147.916889,
+                150: 149.920887}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'),)),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.06
+
+
+class Pm(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 61
+
+    @property
+    def isotopes_distribution(self):
+        return {145: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {145: 144.912749}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.05
+
+
+class Sm(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 62
+
+    @property
+    def isotopes_distribution(self):
+        return {144: 0.0307, 145: 0., 147: 0.1499, 148: 0.1124, 149: 0.1382, 150: 0.0738, 152: 0.2675, 153: 0.,
+                154: 0.2275}
+
+    @property
+    def isotopes_masses(self):
+        return {144: 143.911995, 145: 144.913410, 147: 146.914893, 148: 147.914818, 149: 148.917180, 150: 149.917271,
+                152: 151.919728, 153: 152.922097, 154: 153.922205}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.38
+
+
+class Eu(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 63
+
+    @property
+    def isotopes_distribution(self):
+        return {151: 0.4781, 152: 0., 153: 0.5219}
+
+    @property
+    def isotopes_masses(self):
+        return {151: 150.919846, 152: 151.921744, 153: 152.921226}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.31
+
+
+class Gd(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 64
+
+    @property
+    def isotopes_distribution(self):
+        return {152: 0.002, 153: 0., 154: 0.0218, 155: 0.148, 156: 0.2047, 157: 0.1565, 158: 0.2484, 160: 0.2186}
+
+    @property
+    def isotopes_masses(self):
+        return {152: 151.919788, 153: 152.921750, 154: 153.920862, 155: 154.922619, 156: 155.922120, 157: 156.923957,
+                158: 157.924101, 160: 159.927051}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.33
+
+
+class Tb(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 65
+
+    @property
+    def isotopes_distribution(self):
+        return {159: 1.0, 160: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {159: 158.925343, 160: 159.927168}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.25
+
+
+class Dy(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 66
+
+    @property
+    def isotopes_distribution(self):
+        return {156: 0.0006, 158: 0.001, 160: 0.0234, 161: 0.1891, 162: 0.2551, 163: 0.249, 164: 0.2818}
+
+    @property
+    def isotopes_masses(self):
+        return {156: 155.924278, 158: 157.924405, 160: 159.925194, 161: 160.92693, 162: 161.926795, 163: 162.928728,
+                164: 163.929171}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.28
+
+
+class Ho(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 67
+
+    @property
+    def isotopes_distribution(self):
+        return {165: 1.0, 166: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {165: 164.930319, 166: 165.932284}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.26
+
+
+class Er(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 68
+
+    @property
+    def isotopes_distribution(self):
+        return {162: 0.0014, 164: 0.0161, 166: 0.3361, 167: 0.2293, 168: 0.2678, 170: 0.1493}
+
+    @property
+    def isotopes_masses(self):
+        return {162: 161.928775, 164: 163.929197, 166: 165.93029, 167: 166.932045, 168: 167.932368, 170: 169.93546}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.26
+
+
+class Tm(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 69
+
+    @property
+    def isotopes_distribution(self):
+        return {169: 1.0, 170: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {169: 168.934211, 170: 169.935801}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.22
+
+
+class Yb(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 70
+
+    @property
+    def isotopes_distribution(self):
+        return {168: 0.0013, 169: 0., 170: 0.0304, 171: 0.1428, 172: 0.2183, 173: 0.1613, 174: 0.3183, 176: 0.1276}
+
+    @property
+    def isotopes_masses(self):
+        return {168: 167.933894, 169: 168.935190, 170: 169.934759, 171: 170.936322, 172: 171.936378, 173: 172.938207,
+                174: 173.938858, 176: 175.942568}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.22
+
+
+class Lu(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 71
+
+    @property
+    def isotopes_distribution(self):
+        return {175: 0.9741, 176: 0.0259, 177: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {175: 174.940768, 176: 175.942682, 177: 176.943758}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17
+
+
+class Ac(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 89
+
+    @property
+    def isotopes_distribution(self):
+        return {225: 0., 227: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {225: 225.023230, 227: 227.027752}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Th(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 90
+
+    @property
+    def isotopes_distribution(self):
+        return {227: 0., 232: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {227: 227.027704, 232: 232.038050}
+
+    @property
+    def _common_valences(self):
+        return 0, 4
+
+    @property
+    def _valences_exceptions(self):
+        return ((4, False, 0, ()),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Pa(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 91
+
+    @property
+    def isotopes_distribution(self):
+        return {231: 1.0, 233: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {231: 231.035879, 233: 233.040247}
+
+    @property
+    def _common_valences(self):
+        return 0, 4, 5
+
+    @property
+    def _valences_exceptions(self):
+        return ((4, False, 0, ()),
+                (0, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class U(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 92
+
+    @property
+    def isotopes_distribution(self):
+        return {234: 5.5e-05, 235: 0.0072, 238: 0.992745}
+
+    @property
+    def isotopes_masses(self):
+        return {234: 234.040946, 235: 235.043923, 238: 238.050783}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 4, 5, 6
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (4, False, 0, ()),
+                (2, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Np(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 93
+
+    @property
+    def isotopes_distribution(self):
+        return {237: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {237: 237.048173}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4, 5, 6, 7
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (4, False, 0, ()),
+                (1, False, 0, ((2, 'O'), (2, 'O'))),
+                (2, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Pu(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 94
+
+    @property
+    def isotopes_distribution(self):
+        return {239: 1.0, 242: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {239: 239.052163, 242: 242.058743}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 4, 5, 6
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (4, False, 0, ()),
+                (1, False, 0, ((2, 'O'), (2, 'O'))),
+                (2, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'Se'), )),
+                (0, False, 0, ((2, 'S'),)),
+                (0, False, 0, ((2, 'Te'),)),
+                (0, False, 0, ((2, 'O'),)),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Am(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 95
+
+    @property
+    def isotopes_distribution(self):
+        return {241: 1.0, 243: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {241: 241.056829, 243: 243.061380}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Cm(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 96
+
+    @property
+    def isotopes_distribution(self):
+        return {243: 0., 244: 1.0, 248: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {243: 243.061389, 244: 244.062753, 248: 248.072349}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (0, False, 0, ((2, 'O'),)), (0, False, 0, ((1, 'H'), (1, 'H')))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Bk(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 97
+
+    @property
+    def isotopes_distribution(self):
+        return {249: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {249: 249.074987}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()), (4, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Cf(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 98
+
+    @property
+    def isotopes_distribution(self):
+        return {249: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {249: 249.074854}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Es(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 99
+
+    @property
+    def isotopes_distribution(self):
+        return {252: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {252: 252.08298}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Fm(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 100
+
+    @property
+    def isotopes_distribution(self):
+        return {257: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {257: 257.095106}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Md(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 101
+
+    @property
+    def isotopes_distribution(self):
+        return {258: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {258: 258.098431}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class No(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 102
+
+    @property
+    def isotopes_distribution(self):
+        return {259: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {259: 259.10103}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (2, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Lr(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 103
+
+    @property
+    def isotopes_distribution(self):
+        return {266: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {266: 266.11983}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Sc', 'Y',
+           'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu',
+           'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr']
```

### Comparing `chython-1.64/chython/periodictable/groupVII.py` & `chython-1.8/chython/periodictable/groupXI.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,146 +1,146 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupVII
-from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Mn(Element, PeriodIV, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 25
-
-    @property
-    def isotopes_distribution(self):
-        return {52: 0., 55: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {52: 51.945566, 55: 54.938050}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return ((2, False, 0, ()), (3, False, 0, ()),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'),)),  # MnO
-                (0, False, 0, ((2, 'O'), (1, 'O'))),  # Mn2O3
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),  # MnO2
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),  # [MnO4]2-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'O'))))  # [MnO4]-
-
-    @property
-    def atomic_radius(self):
-        return 1.61
-
-
-class Tc(Element, PeriodV, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 43
-
-    @property
-    def isotopes_distribution(self):
-        return {98: 0., 99: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {98: 97.907216, 99: 98.906255}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'))),  # TcO2
-                (0, False, 0, ((2, 'S'), (2, 'S'))))  # TcS2
-
-    @property
-    def atomic_radius(self):
-        return 1.83
-
-
-class Re(Element, PeriodVI, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 75
-
-    @property
-    def isotopes_distribution(self):
-        return {185: 0.374, 186: 0., 187: 0.626, 188: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {185: 184.952956, 186: 185.954986, 187: 186.955751, 188: 187.958114}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.88
-
-
-class Bh(Element, PeriodVII, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 107
-
-    @property
-    def isotopes_distribution(self):
-        return {270: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {270: 270.133363}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.88  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Mn', 'Tc', 'Re', 'Bh']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXI
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Cu(Element, PeriodIV, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 29
+
+    @property
+    def isotopes_distribution(self):
+        return {63: 0.6917, 64: 0., 65: 0.3083, 67: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {63: 62.929601, 64: 63.929764, 65: 64.927794, 67: 66.927730}
+
+    @property
+    def _common_valences(self):
+        return 0, 1, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()),
+                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'))),  # CuCl2^-
+                (-3, False, 0, ((1, 'S'), (1, 'S'))))  # CuS2^3- - это характерный комплекс для одновалентной меди
+
+    @property
+    def atomic_radius(self):
+        return 1.45
+
+
+class Ag(Element, PeriodV, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 47
+
+    @property
+    def isotopes_distribution(self):
+        return {107: 0.51839, 109: 0.48161, 110: 0., 111: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {107: 106.905093, 109: 108.904756, 110: 109.906107, 111: 110.905291}
+
+    @property
+    def _common_valences(self):
+        return 0, 1
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 0, ((1, 'Cl'), (1, 'Cl'))),  # AgCl2^1-
+                (-1, False, 0, ((1, 'O'), (1, 'O'))),  # Ag(OH)2^1-
+                (-1, False, 0, ((1, 'S'), (1, 'S'))),  # AgS2^1-
+                (-1, False, 0, ((1, 'C'), (1, 'C'))),  # Ag(CN)2^1-
+                (1, False, 0, ()))
+
+    @property
+    def atomic_radius(self):
+        return 1.65
+
+
+class Au(Element, PeriodVI, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 79
+
+    @property
+    def isotopes_distribution(self):
+        return {195: 0., 197: 1.0, 198: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {195: 194.965035, 197: 196.966552, 198: 197.968244}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 0, ()), (3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.74
+
+
+class Rg(Element, PeriodVII, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 111
+
+    @property
+    def isotopes_distribution(self):
+        return {282: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {282: 282.169127}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.74  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Cu', 'Ag', 'Au', 'Rg']
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `chython-1.64/chython/periodictable/groupVIII.py` & `chython-1.8/chython/periodictable/groupVII.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,145 +1,146 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupVIII
-from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Fe(Element, PeriodIV, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 26
-
-    @property
-    def isotopes_distribution(self):
-        return {54: 0.05845, 55: 0., 56: 0.91754, 57: 0.02119, 58: 0.00282, 59: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {54: 53.939615, 55: 54.938293, 56: 55.934942, 57: 56.935399, 58: 57.933281, 59: 58.934876}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()), (3, False, 0, ())
-
-    @property
-    def atomic_radius(self):
-        return 1.56
-
-
-class Ru(Element, PeriodV, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 44
-
-    @property
-    def isotopes_distribution(self):
-        return {96: 0.0554, 98: 0.0187, 99: 0.1276, 100: 0.126, 101: 0.1706, 102: 0.3155, 104: 0.1862, 106: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {96: 95.907598, 98: 97.905287, 99: 98.905939, 100: 99.90422, 101: 100.905582, 102: 101.904349,
-                104: 103.90543, 106: 105.907329}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),  # RuO4
-                (0, False, 0, ((1, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),  # [RuO4]-
-                (0, False, 0, ((2, 'C'), (1, 'Cl'), (1, 'Cl'))),  # Grubbs
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))))  # Hoveyda–Grubbs
-
-    @property
-    def atomic_radius(self):
-        return 1.78
-
-
-class Os(Element, PeriodVI, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 76
-
-    @property
-    def isotopes_distribution(self):
-        return {184: 0.0002, 186: 0.0159, 187: 0.0196, 188: 0.1324, 189: 0.1615, 190: 0.2626, 191: 0., 192: 0.4078}
-
-    @property
-    def isotopes_masses(self):
-        return {184: 183.952491, 186: 185.953838, 187: 186.955748, 188: 187.955836, 189: 188.958145, 190: 189.958445,
-                191: 190.960930, 192: 191.961479}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.85
-
-
-class Hs(Element, PeriodVII, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 108
-
-    @property
-    def isotopes_distribution(self):
-        return {240: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {270: 270.134293}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.85  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Fe', 'Ru', 'Os', 'Hs']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupVII
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Mn(Element, PeriodIV, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 25
+
+    @property
+    def isotopes_distribution(self):
+        return {52: 0., 55: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {52: 51.945566, 55: 54.938050}
+
+    @property
+    def _common_valences(self):
+        return 0, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()), (3, False, 0, ()),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'),)),  # MnO
+                (0, False, 0, ((2, 'O'), (1, 'O'))),  # Mn2O3
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),  # MnO2
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),  # [MnO4]2-
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'O'))))  # [MnO4]-
+
+    @property
+    def atomic_radius(self):
+        return 1.61
+
+
+class Tc(Element, PeriodV, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 43
+
+    @property
+    def isotopes_distribution(self):
+        return {98: 0., 99: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {98: 97.907216, 99: 98.906255}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((2, 'O'), (2, 'O'))),  # TcO2
+                (0, False, 0, ((2, 'S'), (2, 'S'))))  # TcS2
+
+    @property
+    def atomic_radius(self):
+        return 1.83
+
+
+class Re(Element, PeriodVI, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 75
+
+    @property
+    def isotopes_distribution(self):
+        return {185: 0.374, 186: 0., 187: 0.626, 188: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {185: 184.952956, 186: 185.954986, 187: 186.955751, 188: 187.958114}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.88
+
+
+class Bh(Element, PeriodVII, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 107
+
+    @property
+    def isotopes_distribution(self):
+        return {270: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {270: 270.133363}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.88  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Mn', 'Tc', 'Re', 'Bh']
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `chython-1.64/chython/periodictable/groupXIII.py` & `chython-1.8/chython/periodictable/groupVI.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,207 +1,167 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupXIII
-from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class B(Element, PeriodII, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 5
-
-    @property
-    def isotopes_distribution(self):
-        return {10: 0.199, 11: 0.801}
-
-    @property
-    def isotopes_masses(self):
-        return {10: 10.012937, 11: 11.009305}
-
-    @property
-    def _common_valences(self):
-        return 3,
-
-    @property
-    def _valences_exceptions(self):
-        return ((-1, False, 4, ()), (0, False, 0, ()),
-                (0, True, 2, ()))  # radical OGB-dataset
-
-    @property
-    def atomic_radius(self):
-        return .87
-
-
-class Al(Element, PeriodIII, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 13
-
-    @property
-    def isotopes_distribution(self):
-        return {27: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {27: 26.981538}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (2, False, 1, ()), (1, False, 2, ()), (0, False, 3, ()), (-1, False, 4, ()),  # accept [AlHx]
-                (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.18
-
-
-class Ga(Element, PeriodIV, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 31
-
-    @property
-    def isotopes_distribution(self):
-        return {67: 0., 68: 0., 69: 0.60108, 71: 0.39892}
-
-    @property
-    def isotopes_masses(self):
-        return {67: 66.928202, 68: 67.927980, 69: 68.925581, 71: 70.924705}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
-                (-1, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'), (1, 'H'))),
-                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (-1, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
-                (-1, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.36
-
-
-class In(Element, PeriodV, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 49
-
-    @property
-    def isotopes_distribution(self):
-        return {111: 0., 113: 0.0429, 115: 0.9571}
-
-    @property
-    def isotopes_masses(self):
-        return {111: 110.905103, 113: 112.904061, 115: 114.903878}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
-                (0, False, 0, ((1, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 1.56
-
-
-class Tl(Element, PeriodVI, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 81
-
-    @property
-    def isotopes_distribution(self):
-        return {203: 0.29524, 205: 0.70476}
-
-    @property
-    def isotopes_masses(self):
-        return {203: 202.972329, 205: 204.974412}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return ((1, False, 0, ()), (3, False, 0, ()),
-                (-3, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.56
-
-
-class Nh(Element, PeriodVII, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 113
-
-    @property
-    def isotopes_distribution(self):
-        return {286: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {286: 286.182555}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.56  # unknown, taken radius of previous element in group
-
-
-__all__ = ['B', 'Al', 'Ga', 'In', 'Tl', 'Nh']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupVI
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Cr(Element, PeriodIV, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 24
+
+    @property
+    def isotopes_distribution(self):
+        return {50: 0.04345, 51: 0., 52: 0.83789, 53: 0.09501, 54: 0.02365}
+
+    @property
+    def isotopes_masses(self):
+        return {50: 49.946050, 51: 50.944767, 52: 51.940512, 53: 52.940654, 54: 53.938885}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()), (3, False, 0, ()),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),  # CrO2
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),  # CrF4
+                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))),  # CrC4
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.66
+
+
+class Mo(Element, PeriodV, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 42
+
+    @property
+    def isotopes_distribution(self):
+        return {92: 0.1484, 94: 0.0925, 95: 0.1592, 96: 0.1668, 97: 0.0955, 98: 0.2413, 99: 0., 100: 0.0963}
+
+    @property
+    def isotopes_masses(self):
+        return {92: 91.906810, 94: 93.905088, 95: 94.905841, 96: 95.904679, 97: 96.906021, 98: 97.905408, 99: 98.907712,
+                100: 99.907477}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'S'), (2, 'S'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.90
+
+
+class W(Element, PeriodVI, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 74
+
+    @property
+    def isotopes_distribution(self):
+        return {180: 0.0012, 182: 0.265, 183: 0.1431, 184: 0.3064, 186: 0.2843}
+
+    @property
+    def isotopes_masses(self):
+        return {180: 179.946706, 182: 181.948206, 183: 182.950224, 184: 183.950933, 186: 185.954362}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.93
+
+
+class Sg(Element, PeriodVII, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 106
+
+    @property
+    def isotopes_distribution(self):
+        return {269: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {269: 269.128634}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.93  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Cr', 'Mo', 'W', 'Sg']
```

### Comparing `chython-1.64/chython/periodictable/groupXVI.py` & `chython-1.8/chython/periodictable/groupXVI.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,400 +1,358 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupXVI
-from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class O(Element, PeriodII, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 8
-
-    @property
-    def isotopes_distribution(self):
-        return {15: 0., 16: 0.99757, 17: 0.00038, 18: 0.00205}
-
-    @property
-    def isotopes_masses(self):
-        return {15: 15.003065, 16: 15.994915, 17: 16.999132, 18: 17.99916}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return (-1, False, 1, ()), (-2, False, 0, ()), (0, True, 1, ()), (1, False, 3, ())
-
-    @property
-    def atomic_radius(self):
-        return .48
-
-
-class S(Element, PeriodIII, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 16
-
-    @property
-    def isotopes_distribution(self):
-        return {32: 0.9493, 33: 0.0076, 34: 0.0429, 35: 0., 36: 0.0002}
-
-    @property
-    def isotopes_masses(self):
-        return {32: 31.972071, 33: 32.971458, 34: 33.967867, 35: 34.969032, 36: 35.967081}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return ((-1, False, 1, ()), (-2, False, 0, ()),  # anions
-                (0, True, 1, ()), (0, True, 3, ()),  # radical OGB-dataset
-                (0, False, 0, ()),  # elemental
-
-                (1, False, 0, ((2, 'C'), (1, 'C'))),
-                (1, False, 0, ((2, 'C'), (1, 'S'))),
-                (1, False, 0, ((2, 'N'), (1, 'C'))),
-
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'B'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'O'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'N'))),
-
-                (1, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (1, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'), (1, 'N'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'))),
-                (0, False, 0, ((2, 'N'), (2, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'))),
-                (0, False, 0, ((2, 'C'), (2, 'C'))),
-                (0, False, 0, ((2, 'C'), (2, 'N'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'S'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'Br'), (1, 'Br'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'S'), (1, 'S'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'P'))),
-
-                (0, False, 0, ((2, 'N'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'O'))),
-                (0, False, 0, ((2, 'N'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'F'))),
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'N'))),
-                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'S'))),
-                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'N'))),
-                (0, False, 0, ((2, 'C'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'C'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((2, 'S'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'N'))),
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'S'))),
-
-                (0, False, 0, ((1, 'N'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-
-                (0, False, 0, ((1, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'N'), (1, 'C'), (1, 'C'))),
-
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'N'), (1, 'N'))),
-
-                (0, False, 0, ((1, 'S'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'C'))),
-
-                # sulfat derivatives
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'I'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'I'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'F'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'F'))),
-
-                (0, False, 0, ((2, 'N'), (2, 'N'), (1, 'C'), (1, 'C'))),
-
-                # aci forms of tautomers
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'N'))),
-
-                (0, False, 0, ((2, 'N'), (2, 'C'), (1, 'C'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'O'))),  # [S2O3]2-
-                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'C'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'S'), (2, 'S'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))))
-
-    @property
-    def atomic_radius(self):
-        return .87
-
-
-class Se(Element, PeriodIV, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 34
-
-    @property
-    def isotopes_distribution(self):
-        return {73: 0., 74: 0.0089, 75: 0., 76: 0.0937, 77: 0.0763, 78: 0.2377, 80: 0.4961, 82: 0.0873}
-
-    @property
-    def isotopes_masses(self):
-        return {73: 72.926765, 74: 73.922477, 75: 74.922523, 76: 75.919214, 77: 76.919915, 78: 77.917310, 80: 79.916522,
-                82: 81.916700}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return ((-1, False, 1, ()), (-2, False, 0, ()),
-                (0, False, 0, ()),  # elemental
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
-                (1, False, 0, ((1, 'C'), (2, 'C'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'S'), (2, 'S'))),
-                (0, False, 0, ((2, 'N'), (2, 'N'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'C'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'O'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Br'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.03
-
-
-class Te(Element, PeriodV, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 52
-
-    @property
-    def isotopes_distribution(self):
-        return {120: 0.0009, 122: 0.0255, 123: 0.0089, 124: 0.0474, 125: 0.0707, 126: 0.1884, 128: 0.3174, 130: 0.3408}
-
-    @property
-    def isotopes_masses(self):
-        return {120: 119.90402, 122: 121.903047, 123: 122.904273, 124: 123.90282, 125: 124.904425, 126: 125.903306,
-                128: 127.904461, 130: 129.906223}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ()),  # elemental,
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
-                (-1, False, 0, ((1, 'C'), (1, 'O'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (1, False, 0, ((1, 'C'), (2, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'C'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'O'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'C'), (1, 'O'), (1, 'Cl'), (1, 'Cl'))),
-
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'Cl'), (1, 'Cl'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.23
-
-
-class Po(Element, PeriodVI, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 84
-
-    @property
-    def isotopes_distribution(self):
-        return {210: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {210: 209.982874}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.35
-
-
-class Lv(Element, PeriodVII, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 116
-
-    @property
-    def isotopes_distribution(self):
-        return {293: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {293: 293.204555}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.35  # unknown, taken radius of previous element in group
-
-
-__all__ = ['O', 'S', 'Se', 'Te', 'Po', 'Lv']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXVI
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class O(Element, PeriodII, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 8
+
+    @property
+    def isotopes_distribution(self):
+        return {16: 0.99757, 17: 0.00038, 18: 0.00205}
+
+    @property
+    def isotopes_masses(self):
+        return {16: 15.994915, 17: 16.999132, 18: 17.99916}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return (-1, False, 1, ()), (-2, False, 0, ()), (0, True, 1, ()), (1, False, 3, ())
+
+    @property
+    def atomic_radius(self):
+        return .48
+
+
+class S(Element, PeriodIII, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 16
+
+    @property
+    def isotopes_distribution(self):
+        return {32: 0.9493, 33: 0.0076, 34: 0.0429, 35: 0., 36: 0.0002}
+
+    @property
+    def isotopes_masses(self):
+        return {32: 31.972071, 33: 32.971458, 34: 33.967867, 35: 34.969032, 36: 35.967081}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 1, ()), (-2, False, 0, ()),
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'B'))),
+                (1, False, 0, ((1, 'C'), (2, 'C'))),
+                (1, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'))),
+                (0, False, 0, ((2, 'N'), (2, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'))),
+                (0, False, 0, ((2, 'C'), (2, 'C'))),
+                (0, False, 0, ((2, 'C'), (2, 'N'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'S'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'Br'), (1, 'Br'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'P'))),
+
+                (0, False, 0, ((2, 'N'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'O'))),
+                (0, False, 0, ((2, 'N'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'F'))),
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'N'))),
+                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'S'))),
+                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'N'))),
+                (0, False, 0, ((2, 'C'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'C'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'O'))),
+                (0, False, 0, ((2, 'S'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'N'))),
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'S'))),
+
+                (0, False, 0, ((1, 'N'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'F'), (1, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+
+                (0, False, 0, ((1, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'N'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
+
+                (0, False, 0, ((1, 'S'), (1, 'C'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'C'))),
+
+                # sulfat derivatives
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'I'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'I'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'F'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'F'))),
+
+                (0, False, 0, ((2, 'N'), (2, 'N'), (1, 'C'), (1, 'C'))),
+
+                # aci forms of tautomers
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'N'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'O'))),  # [S2O3]2-
+                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'C'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))))
+
+    @property
+    def atomic_radius(self):
+        return .87
+
+
+class Se(Element, PeriodIV, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 34
+
+    @property
+    def isotopes_distribution(self):
+        return {73: 0., 74: 0.0089, 75: 0., 76: 0.0937, 77: 0.0763, 78: 0.2377, 80: 0.4961, 82: 0.0873}
+
+    @property
+    def isotopes_masses(self):
+        return {73: 72.926765, 74: 73.922477, 75: 74.922523, 76: 75.919214, 77: 76.919915, 78: 77.917310, 80: 79.916522,
+                82: 81.916700}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 1, ()),
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (1, False, 0, ((1, 'C'), (2, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'S'), (2, 'S'))),
+                (0, False, 0, ((2, 'N'), (2, 'N'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.03
+
+
+class Te(Element, PeriodV, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 52
+
+    @property
+    def isotopes_distribution(self):
+        return {120: 0.0009, 122: 0.0255, 123: 0.0089, 124: 0.0474, 125: 0.0707, 126: 0.1884, 128: 0.3174, 130: 0.3408}
+
+    @property
+    def isotopes_masses(self):
+        return {120: 119.90402, 122: 121.903047, 123: 122.904273, 124: 123.90282, 125: 124.904425, 126: 125.903306,
+                128: 127.904461, 130: 129.906223}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (1, False, 0, ((1, 'C'), (2, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'C'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.23
+
+
+class Po(Element, PeriodVI, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 84
+
+    @property
+    def isotopes_distribution(self):
+        return {210: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {210: 209.982874}
+
+    @property
+    def _common_valences(self):
+        return 0, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.35
+
+
+class Lv(Element, PeriodVII, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 116
+
+    @property
+    def isotopes_distribution(self):
+        return {293: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {293: 293.204555}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.35  # unknown, taken radius of previous element in group
+
+
+__all__ = ['O', 'S', 'Se', 'Te', 'Po', 'Lv']
```

### Comparing `chython-1.64/chython/periodictable/groupXVIII.py` & `chython-1.8/chython/periodictable/groupXIV.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,232 +1,213 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupXVIII
-from .periods import *
-
-
-class He(Element, PeriodI, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 2
-
-    @property
-    def isotopes_distribution(self):
-        return {3: 1e-06, 4: 0.999999}
-
-    @property
-    def isotopes_masses(self):
-        return {3: 3.016029, 4: 4.002603}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .31
-
-
-class Ne(Element, PeriodII, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 10
-
-    @property
-    def isotopes_distribution(self):
-        return {20: 0.9048, 21: 0.0027, 22: 0.0925}
-
-    @property
-    def isotopes_masses(self):
-        return {20: 19.99244, 21: 20.993847, 22: 21.991386}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .38
-
-
-class Ar(Element, PeriodIII, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 18
-
-    @property
-    def isotopes_distribution(self):
-        return {36: 0.003365, 38: 0.000632, 40: 0.996003}
-
-    @property
-    def isotopes_masses(self):
-        return {36: 35.967546, 38: 37.962732, 40: 39.962383}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .71
-
-
-class Kr(Element, PeriodIV, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 36
-
-    @property
-    def isotopes_distribution(self):
-        return {78: 0.0035, 80: 0.0228, 81: 0., 82: 0.1158, 83: 0.1149, 84: 0.57, 86: 0.173}
-
-    @property
-    def isotopes_masses(self):
-        return {78: 77.920386, 80: 79.916378, 81: 80.916592, 82: 81.913485, 83: 82.914136, 84: 83.911507, 86: 85.91061}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .87
-
-
-class Xe(Element, PeriodV, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 54
-
-    @property
-    def isotopes_distribution(self):
-        return {124: 0.0009, 126: 0.0009, 127: 0., 128: 0.0192, 129: 0.2644, 130: 0.0408, 131: 0.2118, 132: 0.2689,
-                133: 0., 134: 0.1044, 136: 0.0887}
-
-    @property
-    def isotopes_masses(self):
-        return {124: 123.905896, 126: 125.904269, 127: 126.905184, 128: 127.90353, 129: 128.904779, 130: 129.903508,
-                131: 130.905082, 132: 131.904155, 133: 132.905911, 134: 133.905394, 136: 135.90722}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        # XeF2, XeF4, XeF6, XeO3, XeO4, XeO2F2, XeOF4, XeO3F2, [XeO6]4-
-        return ((0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.08
-
-
-class Rn(Element, PeriodVI, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 86
-
-    @property
-    def isotopes_distribution(self):
-        return {222: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {222: 222.017578}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return (0, False, 0, ((1, 'F'), (1, 'F'))), (1, False, 0, ((1, 'F'),))
-
-    @property
-    def atomic_radius(self):
-        return 1.2
-
-
-class Og(Element, PeriodVII, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 118
-
-    @property
-    def isotopes_distribution(self):
-        return {294: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {294: 294.0}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.2  # unknown, taken radius of previous element in group
-
-
-__all__ = ['He', 'Ne', 'Ar', 'Kr', 'Xe', 'Rn', 'Og']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXIV
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class C(Element, PeriodII, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 6
+
+    @property
+    def isotopes_distribution(self):
+        return {12: 0.9893, 13: 0.0107, 14: 0.0}
+
+    @property
+    def isotopes_masses(self):
+        return {12: 12.0, 13: 13.003355, 14: 14.003242}
+
+    @property
+    def _common_valences(self):
+        return 4,
+
+    @property
+    def _valences_exceptions(self):
+        return (0, True, 3, ()), (1, False, 3, ()), (-1, False, 3, ())
+
+    @property
+    def atomic_radius(self):
+        return .67
+
+
+class Si(Element, PeriodIII, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 14
+
+    @property
+    def isotopes_distribution(self):
+        return {28: 0.922297, 29: 0.046832, 30: 0.030872}
+
+    @property
+    def isotopes_masses(self):
+        return {28: 27.976927, 29: 28.976495, 30: 29.97377}
+
+    @property
+    def _common_valences(self):
+        return 4,
+
+    @property
+    def _valences_exceptions(self):
+        return (-2, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+
+    @property
+    def atomic_radius(self):
+        return 1.11
+
+
+class Ge(Element, PeriodIV, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 32
+
+    @property
+    def isotopes_distribution(self):
+        return {70: 0.2084, 72: 0.2754, 73: 0.0773, 74: 0.3628, 76: 0.0761}
+
+    @property
+    def isotopes_masses(self):
+        return {70: 69.92425, 72: 71.922076, 73: 72.923459, 74: 73.921178, 76: 75.921403}
+
+    @property
+    def _common_valences(self):
+        return 4,
+
+    @property
+    def _valences_exceptions(self):
+        return (-2, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+
+    @property
+    def atomic_radius(self):
+        return 1.25
+
+
+class Sn(Element, PeriodV, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 50
+
+    @property
+    def isotopes_distribution(self):
+        return {112: 0.0097, 113: 0., 114: 0.0066, 115: 0.0034, 116: 0.1454, 117: 0.0768, 118: 0.2422, 119: 0.0859,
+                120: 0.3258, 122: 0.0463, 124: 0.0579}
+
+    @property
+    def isotopes_masses(self):
+        return {112: 111.904821, 113: 112.905171, 114: 113.902782, 115: 114.903346, 116: 115.901744, 117: 116.902954,
+                118: 117.901606, 119: 118.903309, 120: 119.902197, 122: 121.903440, 124: 123.905275}
+
+    @property
+    def _common_valences(self):
+        return 0, 4
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()),
+                (0, False, 0, ((2, 'O'),)), (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'S'),)),
+
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 1, ((1, 'C'), (1, 'C'), (1, 'C'))),
+
+                (-2, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.45
+
+
+class Pb(Element, PeriodVI, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 82
+
+    @property
+    def isotopes_distribution(self):
+        return {204: 0.014, 206: 0.241, 207: 0.221, 208: 0.524, 210: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {204: 203.973029, 206: 205.974449, 207: 206.975881, 208: 207.976636, 210: 209.984189}
+
+    @property
+    def _common_valences(self):
+        return 0, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()),
+                (-2, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (-2, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.54
+
+
+class Fl(Element, PeriodVII, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 114
+
+    @property
+    def isotopes_distribution(self):
+        return {289: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {289: 289.190444}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.54  # unknown, taken radius of previous element in group
+
+
+__all__ = ['C', 'Si', 'Ge', 'Sn', 'Pb', 'Fl']
```

### Comparing `chython-1.64/chython/reactor/transformer.py` & `chython-1.8/chython/reactor/transformer.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Adelia Fatykhova <adelik21979@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from typing import Union
-from .base import BaseReactor
-from ..containers import QueryContainer, MoleculeContainer
-
-
-class Transformer(BaseReactor):
-    """
-    Editor for molecules.
-    generates modified molecules from input molecule using template.
-    Transformer calling returns generator of all possible replacements.
-    """
-    def __init__(self, pattern: QueryContainer, replacement: Union[MoleculeContainer, QueryContainer],
-                 delete_atoms: bool = True, automorphism_filter: bool = True, fix_aromatic_rings: bool = True,
-                 fix_tautomers: bool = True):
-        """
-        :param pattern: Search pattern.
-        :param replacement: Resulted structure.
-        :param delete_atoms: If True atoms exists in reactants but not exists in products will be removed.
-        :param fix_aromatic_rings: Proceed kekule and thiele on products.
-        :param fix_tautomers: See `thiele()` docs.
-        :param automorphism_filter: Skip matches to same atoms.
-        """
-        if not isinstance(pattern, QueryContainer) or not isinstance(replacement, (MoleculeContainer, QueryContainer)):
-            raise TypeError('invalid params')
-
-        self.pattern = pattern
-        self.replacement = replacement
-        self.__automorphism_filter = automorphism_filter
-        super().__init__({n for n, h in pattern._masked.items() if not h}, replacement, delete_atoms,
-                         fix_aromatic_rings, fix_tautomers)
-
-    def __call__(self, structure: MoleculeContainer):
-        if not isinstance(structure, MoleculeContainer):
-            raise TypeError('only Molecules possible')
-
-        for mapping in self.pattern.get_mapping(structure, automorphism_filter=self.__automorphism_filter):
-            yield from self._patcher(structure, mapping)
-
-
-__all__ = ['Transformer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Adelia Fatykhova <adelik21979@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from typing import Union
+from .base import BaseReactor
+from ..containers import QueryContainer, MoleculeContainer
+
+
+class Transformer(BaseReactor):
+    """
+    Editor for molecules.
+    generates modified molecules from input molecule using template.
+    Transformer calling returns generator of all possible replacements.
+    """
+    def __init__(self, pattern: QueryContainer, replacement: Union[MoleculeContainer, QueryContainer],
+                 delete_atoms: bool = True):
+        """
+        :param pattern: search pattern
+        :param replacement: atoms and bonds replacement
+        :param delete_atoms: if True atoms exists in pattern but not exists in replacement will be removed
+        """
+        if not isinstance(pattern, QueryContainer) or not isinstance(replacement, (MoleculeContainer, QueryContainer)):
+            raise TypeError('invalid params')
+
+        self.__pattern = pattern
+        super().__init__(pattern, replacement, delete_atoms)
+
+    def __call__(self, structure: MoleculeContainer, automorphism_filter: bool = True):
+        if not isinstance(structure, MoleculeContainer):
+            raise TypeError('only Molecules possible')
+
+        for mapping in self.__pattern.get_mapping(structure, automorphism_filter=automorphism_filter):
+            yield self._patcher(structure, mapping)
+
+    def __getstate__(self):
+        return {'pattern': self.__pattern, **super().__getstate__()}
+
+    def __setstate__(self, state):
+        self.__pattern = state['pattern']
+        super().__setstate__(state)
+
+
+__all__ = ['Transformer']
```

### Comparing `chython-1.64/chython/utils/functional_groups.py` & `chython-1.8/chython/utils/functional_groups.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2020 Dinar Batyrshin <batyrshin-dinar@mail.ru>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-
-
-def functional_groups(molecule, limit):
-    """
-    Generate all connected atom groups up to limit atoms.
-
-    :param molecule: MoleculeContainer
-    :param limit: chain length
-    :return: list of molecule functional groups
-    """
-    bonds = molecule._bonds
-
-    if limit < 1:
-        raise ValueError('limit should be >= 1')
-
-    response = []
-    groups = set()
-    stack = [([a], list(n)) for a, n in bonds.items()]
-    while stack:
-        aug, nei = stack.pop(0)
-        for x in nei:
-            augx = (*aug, x)
-            if augx not in groups:
-                groups.add(augx)
-                response.append(molecule.substructure(augx, as_query=True))
-                nt = nei.copy()
-                nt.remove(x)
-                nt.extend(list(bonds[x]))
-                if len(augx) < limit:
-                    stack.append((augx, nt))
-    return response
-
-
-__all__ = ['functional_groups']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2020 Dinar Batyrshin <batyrshin-dinar@mail.ru>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+
+
+def functional_groups(molecule, limit):
+    """
+    Generate all connected atom groups up to limit atoms.
+
+    :param molecule: MoleculeContainer
+    :param limit: chain length
+    :return: list of molecule functional groups
+    """
+    bonds = molecule._bonds
+
+    if limit < 1:
+        raise ValueError('limit should be >= 1')
+
+    response = []
+    groups = set()
+    stack = [([a], list(n)) for a, n in bonds.items()]
+    while stack:
+        aug, nei = stack.pop(0)
+        for x in nei:
+            augx = (*aug, x)
+            if augx not in groups:
+                groups.add(augx)
+                response.append(molecule.substructure(augx, as_query=True))
+                nt = nei.copy()
+                nt.remove(x)
+                nt.extend(list(bonds[x]))
+                if len(augx) < limit:
+                    stack.append((augx, nt))
+    return response
+
+
+__all__ = ['functional_groups']
```

### Comparing `chython-1.64/chython/utils/rdkit.py` & `chython-1.8/chython/utils/rdkit.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,189 +1,179 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from rdkit.Chem import AssignStereochemistry, Atom, BondStereo, BondType, ChiralType, Conformer, RWMol, SanitizeMol
-from ..containers import MoleculeContainer
-from ..exceptions import IsChiral, NotChiral, ValenceError
-from ..periodictable import Element
-
-
-def from_rdkit_molecule(data):
-    """
-    RDKit molecule object to MoleculeContainer converter
-    """
-    mol = MoleculeContainer()
-    parsed_mapping = mol._parsed_mapping
-    mol_conformers = mol._conformers
-    bonds = mol._bonds
-
-    atoms, mapping = [], []
-    tetrahedron_stereo = []
-    for a in data.GetAtoms():
-        e = Element.from_symbol(a.GetSymbol())
-        isotope = a.GetIsotope()
-        if isotope:
-            e = e(isotope)
-        else:
-            e = e()
-        atom = {'atom': e, 'charge': a.GetFormalCharge()}
-
-        radical = a.GetNumRadicalElectrons()
-        if radical:
-            atom['is_radical'] = True
-
-        atoms.append(atom)
-        mapping.append(a.GetAtomMapNum())
-        tetrahedron_stereo.append(a.GetChiralTag())
-
-    conformers = []
-    c = data.GetConformers()
-    if c:
-        for atom, (x, y, _) in zip(atoms, c[0].GetPositions()):
-            atom['xy'] = (x, y)
-        for c in c:
-            if c.Is3D():
-                conformers.append(c.GetPositions())
-
-    new_map = []
-    for a, n in zip(atoms, mapping):
-        a = mol.add_atom(**a)
-        new_map.append(a)
-        parsed_mapping[a] = n
-
-    stereo = []
-    for b in data.GetBonds():
-        n, m = new_map[b.GetBeginAtomIdx()], new_map[b.GetEndAtomIdx()]
-        mol.add_bond(n, m, _rdkit_bond_map[b.GetBondType()])
-        s = b.GetStereo()
-        if s == _cis:
-            nn, nm = b.GetStereoAtoms()
-            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], True))
-        elif s == _trans:
-            nn, nm = b.GetStereoAtoms()
-            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], False))
-
-    for n, s in zip(new_map, tetrahedron_stereo):
-        if s == _chiral_cw:
-            env = bonds[n]
-            env = [x for x in new_map if x in env]
-            stereo.append((mol.add_atom_stereo, n, env, False))
-        elif s == _chiral_ccw:
-            env = bonds[n]
-            env = [x for x in new_map if x in env]
-            stereo.append((mol.add_atom_stereo, n, env, True))
-
-    while stereo:
-        fail_stereo = []
-        old_stereo = len(stereo)
-        for f, *args in stereo:
-            try:
-                f(*args, clean_cache=False)
-            except NotChiral:
-                fail_stereo.append((f, *args))
-            except IsChiral:
-                pass
-            except ValenceError:
-                mol.flush_cache()
-                break
-        else:
-            stereo = fail_stereo
-            if len(stereo) == old_stereo:
-                break
-            mol.flush_stereo_cache()
-            continue
-        break
-
-    for c in conformers:
-        mol_conformers.append({k: tuple(v) for k, v in zip(new_map, c)})
-    return mol
-
-
-def to_rdkit_molecule(data: MoleculeContainer, *, keep_mapping=True):
-    """
-    MoleculeContainer to RDKit molecule object converter.
-
-    :param keep_mapping: set atom numbers.
-
-    Note: implicit hydrogens data omitted.
-    """
-    mol = RWMol()
-    mapping = {}
-    atoms = data._atoms
-    bonds = data._bonds
-
-    for n, a in data.atoms():
-        ra = Atom(a.atomic_number)
-        if keep_mapping:
-            ra.SetAtomMapNum(n)
-        if a.charge:
-            ra.SetFormalCharge(a.charge)
-        if a.isotope:
-            ra.SetIsotope(a.isotope)
-        if a.is_radical:
-            ra.SetNumRadicalElectrons(1)
-        mapping[n] = mol.AddAtom(ra)
-
-    for n, m, b in data.bonds():
-        if atoms[n].atomic_symbol not in _inorganic:
-            n, m = m, n  # fix direction of dative bond
-        mol.AddBond(mapping[n], mapping[m], _bond_map[b.order])
-
-    for n in data._atoms_stereo:
-        ra = mol.GetAtomWithIdx(mapping[n])
-        env = bonds[n]
-        s = data._translate_tetrahedron_sign(n, [x for x in mapping if x in env])
-        ra.SetChiralTag(_chiral_ccw if s else _chiral_cw)
-
-    for nm, s in data._cis_trans_stereo.items():
-        n, m = nm
-        if m in bonds[n]:  # cumulenes unsupported
-            nn, nm, *_ = data._stereo_cis_trans[nm]
-            b = mol.GetBondBetweenAtoms(mapping[n], mapping[m])
-            b.SetStereoAtoms(mapping[nn], mapping[nm])
-            b.SetStereo(_cis if s else _trans)
-
-    conf = Conformer()
-    for n, a in data.atoms():
-        conf.SetAtomPosition(mapping[n], (a.x, a.y, 0))
-    conf.Set3D(False)
-    mol.AddConformer(conf, assignId=True)
-
-    for c in data._conformers:
-        conf = Conformer()
-        for n, xyz in c.items():
-            conf.SetAtomPosition(mapping[n], xyz)
-        mol.AddConformer(conf, assignId=True)
-
-    SanitizeMol(mol)
-    AssignStereochemistry(mol, flagPossibleStereoCenters=True, force=True)
-    return mol
-
-
-_rdkit_bond_map = {BondType.SINGLE: 1, BondType.DOUBLE: 2, BondType.TRIPLE: 3, BondType.AROMATIC: 4, BondType.ZERO: 8,
-                   BondType.UNSPECIFIED: 8, BondType.DATIVE: 8}
-_bond_map = {1: BondType.SINGLE, 2: BondType.DOUBLE, 3: BondType.TRIPLE, 4: BondType.AROMATIC, 8: BondType.DATIVE}
-
-_chiral_cw = ChiralType.CHI_TETRAHEDRAL_CW
-_chiral_ccw = ChiralType.CHI_TETRAHEDRAL_CCW
-_trans = BondStereo.STEREOE
-_cis = BondStereo.STEREOZ
-_inorganic = {'He', 'Ne', 'Ar', 'Kr', 'Xe', 'F', 'Cl', 'Br', 'I', 'C', 'N', 'O',
-              'H', 'Si', 'P', 'S', 'Se', 'Ge', 'As', 'Sb', 'Te'}
-
-
-__all__ = ['from_rdkit_molecule', 'to_rdkit_molecule']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from rdkit.Chem import AssignStereochemistry, Atom, BondStereo, BondType, ChiralType, Conformer, RWMol, SanitizeMol
+from ..containers import MoleculeContainer
+from ..exceptions import IsChiral, NotChiral, ValenceError
+from ..periodictable import Element
+
+
+def from_rdkit_molecule(data):
+    """
+    RDKit molecule object to MoleculeContainer converter
+    """
+    mol = MoleculeContainer()
+    parsed_mapping = mol._parsed_mapping
+    mol_conformers = mol._conformers
+    bonds = mol._bonds
+
+    atoms, mapping = [], []
+    tetrahedron_stereo = []
+    for a in data.GetAtoms():
+        e = Element.from_symbol(a.GetSymbol())
+        isotope = a.GetIsotope()
+        if isotope:
+            e = e(isotope)
+        else:
+            e = e()
+        atom = {'atom': e, 'charge': a.GetFormalCharge()}
+
+        radical = a.GetNumRadicalElectrons()
+        if radical:
+            atom['is_radical'] = True
+
+        atoms.append(atom)
+        mapping.append(a.GetAtomMapNum())
+        tetrahedron_stereo.append(a.GetChiralTag())
+
+    conformers = []
+    c = data.GetConformers()
+    if c:
+        for atom, (x, y, _) in zip(atoms, c[0].GetPositions()):
+            atom['xy'] = (x, y)
+        for c in c:
+            if c.Is3D():
+                conformers.append(c.GetPositions())
+
+    new_map = []
+    for a, n in zip(atoms, mapping):
+        a = mol.add_atom(**a)
+        new_map.append(a)
+        parsed_mapping[a] = n
+
+    stereo = []
+    for b in data.GetBonds():
+        n, m = new_map[b.GetBeginAtomIdx()], new_map[b.GetEndAtomIdx()]
+        mol.add_bond(n, m, _rdkit_bond_map[b.GetBondType()])
+        s = b.GetStereo()
+        if s == _cis:
+            nn, nm = b.GetStereoAtoms()
+            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], True))
+        elif s == _trans:
+            nn, nm = b.GetStereoAtoms()
+            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], False))
+
+    for n, s in zip(new_map, tetrahedron_stereo):
+        if s == _chiral_cw:
+            env = bonds[n]
+            env = [x for x in new_map if x in env]
+            stereo.append((mol.add_atom_stereo, n, env, False))
+        elif s == _chiral_ccw:
+            env = bonds[n]
+            env = [x for x in new_map if x in env]
+            stereo.append((mol.add_atom_stereo, n, env, True))
+
+    while stereo:
+        fail_stereo = []
+        old_stereo = len(stereo)
+        for f, *args in stereo:
+            try:
+                f(*args, clean_cache=False)
+            except NotChiral:
+                fail_stereo.append((f, *args))
+            except IsChiral:
+                pass
+            except ValenceError:
+                mol.flush_cache()
+                break
+        else:
+            stereo = fail_stereo
+            if len(stereo) == old_stereo:
+                break
+            mol.flush_stereo_cache()
+            continue
+        break
+
+    for c in conformers:
+        mol_conformers.append({k: tuple(v) for k, v in zip(new_map, c)})
+    return mol
+
+
+def to_rdkit_molecule(data: MoleculeContainer):
+    """
+    MoleculeContainer to RDKit molecule object converter.
+
+    Note: implicit hydrogens data omitted.
+    """
+    mol = RWMol()
+    mapping = {}
+    bonds = data._bonds
+
+    for n, a in data.atoms():
+        ra = Atom(a.atomic_number)
+        ra.SetAtomMapNum(n)
+        if a.charge:
+            ra.SetFormalCharge(a.charge)
+        if a.isotope:
+            ra.SetIsotope(a.isotope)
+        if a.is_radical:
+            ra.SetNumRadicalElectrons(1)
+        mapping[n] = mol.AddAtom(ra)
+
+    for n, m, b in data.bonds():
+        mol.AddBond(mapping[n], mapping[m], _bond_map[b.order])
+
+    for n in data._atoms_stereo:
+        ra = mol.GetAtomWithIdx(mapping[n])
+        env = bonds[n]
+        s = data._translate_tetrahedron_sign(n, [x for x in mapping if x in env])
+        ra.SetChiralTag(_chiral_ccw if s else _chiral_cw)
+
+    for nm, s in data._cis_trans_stereo.items():
+        n, m = nm
+        if m in bonds[n]:  # cumulenes unsupported
+            nn, nm, *_ = data._stereo_cis_trans[nm]
+            b = mol.GetBondBetweenAtoms(mapping[n], mapping[m])
+            b.SetStereoAtoms(mapping[nn], mapping[nm])
+            b.SetStereo(_cis if s else _trans)
+
+    conf = Conformer()
+    for n, a in data.atoms():
+        conf.SetAtomPosition(mapping[n], (a.x, a.y, 0))
+    conf.Set3D(False)
+    mol.AddConformer(conf, assignId=True)
+
+    for c in data._conformers:
+        conf = Conformer()
+        for n, xyz in c.items():
+            conf.SetAtomPosition(mapping[n], xyz)
+        mol.AddConformer(conf, assignId=True)
+
+    SanitizeMol(mol)
+    AssignStereochemistry(mol, flagPossibleStereoCenters=True, force=True)
+    return mol
+
+
+_rdkit_bond_map = {BondType.SINGLE: 1, BondType.DOUBLE: 2, BondType.TRIPLE: 3, BondType.AROMATIC: 4}
+_bond_map = {1: BondType.SINGLE, 2: BondType.DOUBLE, 3: BondType.TRIPLE, 4: BondType.AROMATIC}
+
+_chiral_cw = ChiralType.CHI_TETRAHEDRAL_CW
+_chiral_ccw = ChiralType.CHI_TETRAHEDRAL_CCW
+_trans = BondStereo.STEREOE
+_cis = BondStereo.STEREOZ
+
+__all__ = ['from_rdkit_molecule', 'to_rdkit_molecule']
```

### Comparing `chython-1.64/setup.py` & `chython-1.8/setup.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from distutils.command.sdist import sdist
-from distutils.command.build import build
-from distutils.util import get_platform
-from importlib.util import find_spec
-from pathlib import Path
-from setuptools import setup, Extension, find_packages
-
-
-class _sdist(sdist):
-    def finalize_options(self):
-        super().finalize_options()
-        self.distribution.data_files.append(('lib', ['INCHI/libinchi.so',
-                                                     'INCHI/libinchi.dll', 'INCHI/libinchi.dynlib']))
-
-
-cmd_class = {'sdist': _sdist}
-
-
-if find_spec('wheel'):
-    from wheel.bdist_wheel import bdist_wheel
-
-    class _bdist_wheel(bdist_wheel):
-        def finalize_options(self):
-            super().finalize_options()
-            self.root_is_pure = False
-            platform = get_platform()
-            if platform == 'win-amd64':
-                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dll']))
-            elif platform == 'linux-x86_64':
-                self.distribution.data_files.append(('lib', ['INCHI/libinchi.so']))
-            elif platform == 'macosx-11-x86_64':
-                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dynlib']))
-
-    cmd_class['bdist_wheel'] = _bdist_wheel
-
-
-if find_spec('cython'):
-    class _build(build):
-        def finalize_options(self):
-            super().finalize_options()
-            from Cython.Build import cythonize
-            self.distribution.ext_modules = cythonize(self.distribution.ext_modules, language_level=3)
-
-    cmd_class['build'] = _build
-
-
-setup(
-    name='chython',
-    version='1.64',
-    packages=find_packages(),
-    url='https://github.com/chython/chython',
-    license='LGPLv3',
-    author='Dr. Ramil Nugmanov',
-    author_email='nougmanoff@protonmail.com',
-    python_requires='>=3.8',
-    cmdclass=cmd_class,
-    ext_modules=[Extension('chython.algorithms._isomorphism', ['chython/algorithms/_isomorphism.pyx'],
-                           extra_compile_args=['-O3']),
-                 Extension('chython.containers._unpack', ['chython/containers/_unpack.pyx'],
-                           extra_compile_args=['-O3']),
-                 Extension('chython.containers._pack', ['chython/containers/_pack.pyx'], extra_compile_args=['-O3']),
-                 Extension('chython.containers._cpack', ['chython/containers/_cpack.pyx'], extra_compile_args=['-O3']),
-                 Extension('chython.files._xyz', ['chython/files/_xyz.pyx'], extra_compile_args=['-O3'])],
-    setup_requires=['wheel', 'cython'],
-    install_requires=['CachedMethods>=0.1.4,<0.2', 'lazy-object-proxy>=1.6', 'lxml>=4.1', 'py-mini-racer>=0.4.0',
-                      'numpy>=1.18'],
-    extras_require={'pytest': ['pytest'], 'mapping': ['chytorch-rxnmap>=1.4']},
-    package_data={'chython.algorithms': ['_isomorphism.pyx'], 'chython.algorithms.calculate2d': ['clean2d.js'],
-                  'chython.containers': ['_pack.pyx', '_unpack.pyx'], 'chython.files': ['_xyz.pyx']},
-    data_files=[],
-    zip_safe=False,
-    long_description=(Path(__file__).parent / 'README.rst').read_text('utf8'),
-    classifiers=['Environment :: Plugins',
-                 'Intended Audience :: Science/Research',
-                 'License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)',
-                 'Operating System :: OS Independent',
-                 'Programming Language :: Python',
-                 'Programming Language :: Python :: 3 :: Only',
-                 'Programming Language :: Python :: 3.8',
-                 'Topic :: Scientific/Engineering',
-                 'Topic :: Scientific/Engineering :: Chemistry',
-                 'Topic :: Scientific/Engineering :: Information Analysis',
-                 'Topic :: Software Development',
-                 'Topic :: Software Development :: Libraries',
-                 'Topic :: Software Development :: Libraries :: Python Modules']
-)
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from distutils.command.sdist import sdist
+from distutils.command.build import build
+from distutils.util import get_platform
+from importlib.util import find_spec
+from pathlib import Path
+from setuptools import setup, Extension, find_packages
+
+
+class _sdist(sdist):
+    def finalize_options(self):
+        super().finalize_options()
+        self.distribution.data_files.append(('lib', ['INCHI/libinchi.so',
+                                                     'INCHI/libinchi.dll', 'INCHI/libinchi.dynlib']))
+
+
+cmd_class = {'sdist': _sdist}
+
+
+if find_spec('wheel'):
+    from wheel.bdist_wheel import bdist_wheel
+
+    class _bdist_wheel(bdist_wheel):
+        def finalize_options(self):
+            super().finalize_options()
+            self.root_is_pure = False
+            platform = get_platform()
+            if platform == 'win-amd64':
+                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dll']))
+            elif platform == 'linux-x86_64':
+                self.distribution.data_files.append(('lib', ['INCHI/libinchi.so']))
+            elif platform == 'macosx-11-x86_64':
+                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dynlib']))
+
+    cmd_class['bdist_wheel'] = _bdist_wheel
+
+
+if find_spec('cython'):
+    class _build(build):
+        def finalize_options(self):
+            super().finalize_options()
+            from Cython.Build import cythonize
+            self.distribution.ext_modules = cythonize(self.distribution.ext_modules, language_level=3)
+
+    cmd_class['build'] = _build
+
+
+setup(
+    name='chython',
+    version='1.8',
+    packages=find_packages(),
+    url='https://github.com/chython/chython',
+    license='LGPLv3',
+    author='Dr. Ramil Nugmanov',
+    author_email='nougmanoff@protonmail.com',
+    python_requires='>=3.8',
+    cmdclass=cmd_class,
+    ext_modules=[Extension('chython.containers._unpack', ['chython/containers/_unpack.pyx'],
+                           extra_compile_args=['-O3']),
+                 Extension('chython.algorithms._isomorphism', ['chython/algorithms/_isomorphism.pyx'],
+                           extra_compile_args=['-O3'])],
+    setup_requires=['wheel', 'cython'],
+    install_requires=['CachedMethods>=0.1.4,<0.2', 'lazy_object_proxy>=1.6', 'lxml>=4.1', 'py-mini-racer>=0.4.0',
+                      'numpy>=1.18', 'numba>=0.50'],
+    extras_require={'pytest': ['pytest']},
+    package_data={'chython.algorithms': ['_isomorphism.pyx'], 'chython.algorithms.calculate2d': ['clean2d.js'],
+                  'chython.containers': ['_unpack.pyx']},
+    data_files=[],
+    zip_safe=False,
+    long_description=(Path(__file__).parent / 'README.rst').read_text('utf8'),
+    classifiers=['Environment :: Plugins',
+                 'Intended Audience :: Science/Research',
+                 'License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)',
+                 'Operating System :: OS Independent',
+                 'Programming Language :: Python',
+                 'Programming Language :: Python :: 3 :: Only',
+                 'Programming Language :: Python :: 3.8',
+                 'Topic :: Scientific/Engineering',
+                 'Topic :: Scientific/Engineering :: Chemistry',
+                 'Topic :: Scientific/Engineering :: Information Analysis',
+                 'Topic :: Software Development',
+                 'Topic :: Software Development :: Libraries',
+                 'Topic :: Software Development :: Libraries :: Python Modules'],
+    command_options={'build_sphinx': {'source_dir': ('setup.py', 'doc'),
+                                      'build_dir':  ('setup.py', 'build/doc'),
+                                      'all_files': ('setup.py', True)}}
+)
```

