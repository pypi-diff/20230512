# Comparing `tmp/odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4-py3-none-any.whl.zip` & `tmp/odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,34 @@
-Zip file size: 33954 bytes, number of entries: 23
--rw-r--r--  2.0 unx     4413 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/README.rst
--rw-r--r--  2.0 unx       21 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/__init__.py
--rw-r--r--  2.0 unx      514 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/__manifest__.py
--rw-r--r--  2.0 unx     3392 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/registry.py
--rw-r--r--  2.0 unx     4525 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/i18n/endpoint_route_handler.pot
--rw-r--r--  2.0 unx       59 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/models/__init__.py
--rw-r--r--  2.0 unx    10394 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/models/endpoint_route_handler.py
--rw-r--r--  2.0 unx     3523 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/models/ir_http.py
--rw-r--r--  2.0 unx       43 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/readme/CONTRIBUTORS.rst
--rw-r--r--  2.0 unx      138 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/readme/DESCRIPTION.rst
--rw-r--r--  2.0 unx      372 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/readme/ROADMAP.rst
--rw-r--r--  2.0 unx     1214 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/readme/USAGE.rst
--rw-r--r--  2.0 unx      306 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/security/ir.model.access.csv
--rw-r--r--  2.0 unx     9455 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/static/description/icon.png
--rw-r--r--  2.0 unx    14468 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/static/description/index.html
--rw-r--r--  2.0 unx       67 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/tests/__init__.py
--rw-r--r--  2.0 unx     1630 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/tests/common.py
--rw-r--r--  2.0 unx     3176 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/tests/test_endpoint.py
--rw-r--r--  2.0 unx     2584 b- defN 22-Jul-16 07:25 odoo/addons/endpoint_route_handler/tests/test_endpoint_controller.py
--rw-r--r--  2.0 unx     5048 b- defN 22-Jul-16 07:25 odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Jul-16 07:25 odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 22-Jul-16 07:25 odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2582 b- defN 22-Jul-16 07:25 odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/RECORD
-23 files, 68021 bytes uncompressed, 29504 bytes compressed:  56.6%
+Zip file size: 45208 bytes, number of entries: 32
+-rw-r--r--  2.0 unx     5240 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/README.rst
+-rw-r--r--  2.0 unx       64 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/__init__.py
+-rw-r--r--  2.0 unx      556 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/__manifest__.py
+-rw-r--r--  2.0 unx      246 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/exceptions.py
+-rw-r--r--  2.0 unx      362 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/post_init_hook.py
+-rw-r--r--  2.0 unx    11835 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/registry.py
+-rw-r--r--  2.0 unx       19 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/controllers/__init__.py
+-rw-r--r--  2.0 unx      474 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/controllers/main.py
+-rw-r--r--  2.0 unx     8735 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/i18n/endpoint_route_handler.pot
+-rw-r--r--  2.0 unx      429 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/migrations/14.0.2.0.0/pre-migrate.py
+-rw-r--r--  2.0 unx      141 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/models/__init__.py
+-rw-r--r--  2.0 unx     8887 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/models/endpoint_route_handler.py
+-rw-r--r--  2.0 unx     1536 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/models/endpoint_route_handler_tool.py
+-rw-r--r--  2.0 unx     4121 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/models/endpoint_route_sync_mixin.py
+-rw-r--r--  2.0 unx     2829 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/models/ir_http.py
+-rw-r--r--  2.0 unx       43 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/readme/CONTRIBUTORS.rst
+-rw-r--r--  2.0 unx      138 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/readme/DESCRIPTION.rst
+-rw-r--r--  2.0 unx      372 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/readme/ROADMAP.rst
+-rw-r--r--  2.0 unx     2035 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/readme/USAGE.rst
+-rw-r--r--  2.0 unx      565 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/security/ir.model.access.csv
+-rw-r--r--  2.0 unx     9455 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/static/description/icon.png
+-rw-r--r--  2.0 unx    15448 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/static/description/index.html
+-rw-r--r--  2.0 unx       95 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/tests/__init__.py
+-rw-r--r--  2.0 unx     1647 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/tests/common.py
+-rw-r--r--  2.0 unx      821 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/tests/fake_controllers.py
+-rw-r--r--  2.0 unx     6641 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/tests/test_endpoint.py
+-rw-r--r--  2.0 unx     2353 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/tests/test_endpoint_controller.py
+-rw-r--r--  2.0 unx     8001 b- defN 23-May-11 16:30 odoo/addons/endpoint_route_handler/tests/test_registry.py
+-rw-r--r--  2.0 unx     5875 b- defN 23-May-11 16:30 odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-11 16:30 odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-May-11 16:30 odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3631 b- defN 23-May-11 16:30 odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/RECORD
+32 files, 102691 bytes uncompressed, 38990 bytes compressed:  62.0%
```

## zipnote {}

```diff
@@ -3,26 +3,47 @@
 
 Filename: odoo/addons/endpoint_route_handler/__init__.py
 Comment: 
 
 Filename: odoo/addons/endpoint_route_handler/__manifest__.py
 Comment: 
 
+Filename: odoo/addons/endpoint_route_handler/exceptions.py
+Comment: 
+
+Filename: odoo/addons/endpoint_route_handler/post_init_hook.py
+Comment: 
+
 Filename: odoo/addons/endpoint_route_handler/registry.py
 Comment: 
 
+Filename: odoo/addons/endpoint_route_handler/controllers/__init__.py
+Comment: 
+
+Filename: odoo/addons/endpoint_route_handler/controllers/main.py
+Comment: 
+
 Filename: odoo/addons/endpoint_route_handler/i18n/endpoint_route_handler.pot
 Comment: 
 
+Filename: odoo/addons/endpoint_route_handler/migrations/14.0.2.0.0/pre-migrate.py
+Comment: 
+
 Filename: odoo/addons/endpoint_route_handler/models/__init__.py
 Comment: 
 
 Filename: odoo/addons/endpoint_route_handler/models/endpoint_route_handler.py
 Comment: 
 
+Filename: odoo/addons/endpoint_route_handler/models/endpoint_route_handler_tool.py
+Comment: 
+
+Filename: odoo/addons/endpoint_route_handler/models/endpoint_route_sync_mixin.py
+Comment: 
+
 Filename: odoo/addons/endpoint_route_handler/models/ir_http.py
 Comment: 
 
 Filename: odoo/addons/endpoint_route_handler/readme/CONTRIBUTORS.rst
 Comment: 
 
 Filename: odoo/addons/endpoint_route_handler/readme/DESCRIPTION.rst
@@ -45,26 +66,32 @@
 
 Filename: odoo/addons/endpoint_route_handler/tests/__init__.py
 Comment: 
 
 Filename: odoo/addons/endpoint_route_handler/tests/common.py
 Comment: 
 
+Filename: odoo/addons/endpoint_route_handler/tests/fake_controllers.py
+Comment: 
+
 Filename: odoo/addons/endpoint_route_handler/tests/test_endpoint.py
 Comment: 
 
 Filename: odoo/addons/endpoint_route_handler/tests/test_endpoint_controller.py
 Comment: 
 
-Filename: odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/METADATA
+Filename: odoo/addons/endpoint_route_handler/tests/test_registry.py
+Comment: 
+
+Filename: odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/METADATA
 Comment: 
 
-Filename: odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/WHEEL
+Filename: odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/WHEEL
 Comment: 
 
-Filename: odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/top_level.txt
+Filename: odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/top_level.txt
 Comment: 
 
-Filename: odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/RECORD
+Filename: odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odoo/addons/endpoint_route_handler/README.rst

```diff
@@ -1,10 +1,10 @@
-====================
- Route route handler
-====================
+======================
+Endpoint route handler
+======================
 
 .. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !! This file is generated by oca-gen-addon-readme !!
    !! changes will be overwritten.                   !!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 .. |badge1| image:: https://img.shields.io/badge/maturity-Beta-yellow.png
@@ -43,32 +43,55 @@
     class MyModel(models.Model):
         _name = "my.model"
         _inherit = "endpoint.route.handler"
 
 Once you have this, each `my.model` record will generate a route.
 You can have a look at the `endpoint` module to see a real life example.
 
+The options of the routing rules are defined by the method `_default_endpoint_options`.
+Here's an example from the `endpoint` module::
+
+    def _default_endpoint_options_handler(self):
+        return {
+            "klass_dotted_path": "odoo.addons.endpoint.controllers.main.EndpointController",
+            "method_name": "auto_endpoint",
+            "default_pargs": (self.route,),
+        }
+
+As you can see, you have to pass the references to the controller class and the method to use
+when the endpoint is called. And you can prepare some default arguments to pass.
+In this case, the route of the current record.
+
 
 As a tool
 ~~~~~~~~~
 
 Initialize non stored route handlers and generate routes from them.
 For instance::
 
-    route_handler = self.env["endpoint.route.handler"]
+    route_handler = self.env["endpoint.route.handler.tool"]
     endpoint_handler = MyController()._my_handler
     vals = {
         "name": "My custom route",
         "route": "/my/custom/route",
         "request_method": "GET",
         "auth_type": "public",
     }
     new_route = route_handler.new(vals)
-    new_route._refresh_endpoint_data()  # required only for NewId records
-    new_route._register_controller(endpoint_handler=endpoint_handler, key="my-custom-route")
+    new_route._register_controller()
+
+You can override options and define - for instance - a different controller method::
+
+    options = {
+        "handler": {
+            "klass_dotted_path": "odoo.addons.my_module.controllers.SpecialController",
+            "method_name": "my_special_handler",
+        }
+    }
+    new_route._register_controller(options=options)
 
 Of course, what happens when the endpoint gets called
 depends on the logic defined on the controller method.
 
 In both cases (mixin and tool) when a new route is generated or an existing one is updated,
 the `ir.http.routing_map` (which holds all Odoo controllers) will be updated.
```

## odoo/addons/endpoint_route_handler/__init__.py

```diff
@@ -1 +1,2 @@
 from . import models
+from .post_init_hook import post_init_hook
```

## odoo/addons/endpoint_route_handler/__manifest__.py

```diff
@@ -1,16 +1,17 @@
 # Copyright 2021 Camptocamp SA
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
 
 {
-    "name": " Route route handler",
+    "name": "Endpoint route handler",
     "summary": """Provide mixin and tool to generate custom endpoints on the fly.""",
-    "version": "14.0.1.1.0",
+    "version": "14.0.2.0.0",
     "license": "LGPL-3",
     "development_status": "Beta",
     "author": "Camptocamp,Odoo Community Association (OCA)",
     "maintainers": ["simahawk"],
     "website": "https://github.com/OCA/web-api",
     "data": [
         "security/ir.model.access.csv",
     ],
+    "post_init_hook": "post_init_hook",
 }
```

## odoo/addons/endpoint_route_handler/registry.py

```diff
@@ -1,113 +1,395 @@
 # Copyright 2021 Camptocamp SA
 # @author: Simone Orsi <simone.orsi@camptocamp.com>
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
 
-_REGISTRY_BY_DB = {}
+import importlib
+import json
+import logging
+from functools import partial
+
+from psycopg2 import sql
+from psycopg2.extensions import AsIs
+from psycopg2.extras import execute_values
+
+from odoo import http, tools
+from odoo.tools import DotDict
+
+from odoo.addons.base.models.ir_model import query_insert
+
+from .exceptions import EndpointHandlerNotFound
+
+_logger = logging.getLogger(__name__)
+
+
+def query_multi_update(cr, table_name, rows, cols):
+    """Update multiple rows at once.
+
+    :param `cr`: active db cursor
+    :param `table_name`: sql table to update
+    :param `rows`: list of dictionaries with write-ready values
+    :param `cols`: list of keys representing columns' names
+    """
+    # eg: key=c.key, route=c.route
+    keys = sql.SQL(",").join([sql.SQL("{0}=c.{0}".format(col)) for col in cols])
+    col_names = sql.SQL(",").join([sql.Identifier(col) for col in cols])
+    template = (
+        sql.SQL("(")
+        + sql.SQL(",").join([sql.SQL("%({})s".format(col)) for col in cols])
+        + sql.SQL(")")
+    )
+    query = sql.SQL(
+        """
+    UPDATE {table} AS t SET
+        {keys}
+    FROM (VALUES {values})
+        AS c({col_names})
+    WHERE c.key = t.key
+    RETURNING t.key
+    """
+    ).format(
+        table=sql.Identifier(table_name),
+        keys=keys,
+        col_names=col_names,
+        values=sql.Placeholder(),
+    )
+    execute_values(
+        cr,
+        query.as_string(cr._cnx),
+        rows,
+        template=template.as_string(cr._cnx),
+    )
 
 
 class EndpointRegistry:
     """Registry for endpoints.
 
     Used to:
 
     * track registered endpoints
-    * track routes to be updated for specific ir.http instances
     * retrieve routing rules to load in ir.http routing map
     """
 
-    __slots__ = ("_mapping", "_http_ids", "_http_ids_to_update")
+    __slots__ = "cr"
+    _table = "endpoint_route"
+    _columns = (
+        # name, type, comment
+        ("key", "VARCHAR", ""),
+        ("route", "VARCHAR", ""),
+        ("opts", "text", ""),
+        ("routing", "text", ""),
+        ("endpoint_hash", "VARCHAR(32)", ""),
+        ("route_group", "VARCHAR(32)", ""),
+        ("updated_at", "TIMESTAMP NOT NULL DEFAULT NOW()", ""),
+    )
 
-    def __init__(self):
-        # collect EndpointRule objects
-        self._mapping = {}
-        # collect ids of ir.http instances
-        self._http_ids = set()
-        # collect ids of ir.http instances that need update
-        self._http_ids_to_update = set()
+    @classmethod
+    def registry_for(cls, cr):
+        return cls(cr)
 
-    def get_rules(self):
-        return self._mapping.values()
+    @classmethod
+    def wipe_registry_for(cls, cr):
+        cr.execute("TRUNCATE endpoint_route")
+        _logger.info("endpoint_route wiped")
 
-    # TODO: add test
-    def get_rules_by_group(self, group):
-        for key, rule in self._mapping.items():
-            if rule.route_group == group:
-                yield (key, rule)
+    @classmethod
+    def _setup_db(cls, cr):
+        if not tools.sql.table_exists(cr, cls._table):
+            cls._setup_db_table(cr)
+            cls._setup_db_timestamp(cr)
+            cls._setup_db_version(cr)
+            _logger.info("endpoint_route table set up")
 
-    def add_or_update_rule(self, rule, force=False, init=False):
-        """Add or update an existing rule.
+    @classmethod
+    def _setup_db_table(cls, cr):
+        """Create routing table and indexes"""
+        tools.sql.create_model_table(cr, cls._table, columns=cls._columns)
+        tools.sql.create_unique_index(
+            cr,
+            "endpoint_route__key_uniq",
+            cls._table,
+            [
+                "key",
+            ],
+        )
+        tools.sql.add_constraint(
+            cr,
+            cls._table,
+            "endpoint_route__endpoint_hash_uniq",
+            "unique(endpoint_hash)",
+        )
 
-        :param rule: instance of EndpointRule
-        :param force: replace a rule forcedly
-        :param init: given when adding rules for the first time
+    @classmethod
+    def _setup_db_timestamp(cls, cr):
+        """Create trigger to update rows timestamp on updates"""
+        cr.execute(
+            """
+            CREATE OR REPLACE FUNCTION endpoint_route_set_timestamp()
+                RETURNS TRIGGER AS $$
+            BEGIN
+                NEW.updated_at = NOW();
+                RETURN NEW;
+            END;
+            $$ LANGUAGE plpgsql;
         """
-        key = rule.key
-        existing = self._mapping.get(key)
-        if not existing or force:
-            self._mapping[key] = rule
-            if not init:
-                self._refresh_update_required()
-            return True
-        if existing.endpoint_hash != rule.endpoint_hash:
-            # Override and set as to be updated
-            self._mapping[key] = rule
-            if not init:
-                self._refresh_update_required()
-            return True
-
-    def drop_rule(self, key):
-        existing = self._mapping.pop(key, None)
-        if not existing:
-            return False
-        self._refresh_update_required()
-        return True
+        )
+        cr.execute(
+            """
+            CREATE TRIGGER trigger_endpoint_route_set_timestamp
+            BEFORE UPDATE ON %(table)s
+            FOR EACH ROW
+            EXECUTE PROCEDURE endpoint_route_set_timestamp();
+        """,
+            {"table": AsIs(cls._table)},
+        )
 
-    def routing_update_required(self, http_id):
-        return http_id in self._http_ids_to_update
+    @classmethod
+    def _setup_db_version(cls, cr):
+        """Create sequence and triggers to keep track of routes' version"""
+        cr.execute(
+            """
+            SELECT 1  FROM pg_class WHERE RELNAME = 'endpoint_route_version'
+        """
+        )
+        if not cr.fetchone():
+            sql = """
+                CREATE SEQUENCE endpoint_route_version INCREMENT BY 1 START WITH 1;
+                CREATE OR REPLACE FUNCTION increment_endpoint_route_version()
+                    RETURNS TRIGGER AS $$
+                BEGIN
+                  PERFORM nextval('endpoint_route_version');
+                  RETURN NEW;
+                END;
+                $$ language plpgsql;
+                CREATE TRIGGER  update_endpoint_route_version_trigger
+                    BEFORE INSERT ON %(table)s
+                   for each row execute procedure increment_endpoint_route_version();
+                CREATE TRIGGER  insert_endpoint_route_version_trigger
+                    BEFORE UPDATE ON %(table)s
+                   for each row execute procedure increment_endpoint_route_version();
+            """
+            cr.execute(sql, {"table": AsIs(cls._table)})
+
+    def __init__(self, cr):
+        self.cr = cr
+
+    def get_rules(self, keys=None, where=None):
+        for row in self._get_rules(keys=keys, where=where):
+            yield EndpointRule.from_row(self.cr.dbname, row)
+
+    def _get_rules(self, keys=None, where=None, one=False):
+        query = "SELECT * FROM endpoint_route"
+        pargs = ()
+        if keys and not where:
+            query += " WHERE key IN %s"
+            pargs = (tuple(keys),)
+        elif where:
+            query += " " + where
+        self.cr.execute(query, pargs)
+        return self.cr.fetchone() if one else self.cr.fetchall()
+
+    def _get_rule(self, key):
+        row = self._get_rules(keys=(key,), one=True)
+        if row:
+            return EndpointRule.from_row(self.cr.dbname, row)
+
+    def _lock_rows(self, keys):
+        sql = "SELECT id FROM endpoint_route WHERE key IN %s FOR UPDATE"
+        self.cr.execute(sql, (tuple(keys),), log_exceptions=False)
+
+    def _update(self, rows_mapping):
+        self._lock_rows(tuple(rows_mapping.keys()))
+        return query_multi_update(
+            self.cr,
+            self._table,
+            tuple(rows_mapping.values()),
+            EndpointRule._ordered_columns(),
+        )
 
-    def _refresh_update_required(self):
-        for http_id in self._http_ids:
-            self._http_ids_to_update.add(http_id)
+    def _create(self, rows_mapping):
+        return query_insert(self.cr, self._table, list(rows_mapping.values()))
 
-    def reset_update_required(self, http_id):
-        self._http_ids_to_update.discard(http_id)
+    def get_rules_by_group(self, group):
+        rules = self.get_rules(where=f"WHERE route_group='{group}'")
+        return rules
 
-    @classmethod
-    def registry_for(cls, dbname):
-        if dbname not in _REGISTRY_BY_DB:
-            _REGISTRY_BY_DB[dbname] = cls()
-        return _REGISTRY_BY_DB[dbname]
+    def update_rules(self, rules, init=False):
+        """Add or update rules.
 
-    @classmethod
-    def wipe_registry_for(cls, dbname):
-        if dbname in _REGISTRY_BY_DB:
-            del _REGISTRY_BY_DB[dbname]
+        :param rule: list of instances of EndpointRule
+        :param force: replace rules forcedly
+        :param init: given when adding rules for the first time
+        """
+        keys = [x.key for x in rules]
+        existing = {x.key: x for x in self.get_rules(keys=keys)}
+        to_create = {}
+        to_update = {}
+        for rule in rules:
+            if rule.key in existing:
+                to_update[rule.key] = rule.to_row()
+            else:
+                to_create[rule.key] = rule.to_row()
+        res = False
+        if to_create:
+            self._create(to_create)
+            res = True
+        if to_update:
+            self._update(to_update)
+            res = True
+        return res
 
-    def ir_http_track(self, _id):
-        self._http_ids.add(_id)
+    def drop_rules(self, keys):
+        self.cr.execute("DELETE FROM endpoint_route WHERE key IN %s", (tuple(keys),))
+        return True
 
-    def ir_http_seen(self, _id):
-        return _id in self._http_ids
+    def make_rule(self, *a, **kw):
+        return EndpointRule(self.cr.dbname, *a, **kw)
 
-    @staticmethod
-    def make_rule(*a, **kw):
-        return EndpointRule(*a, **kw)
+    def last_update(self):
+        self.cr.execute(
+            """
+            SELECT updated_at
+            FROM endpoint_route
+            ORDER BY updated_at DESC
+            LIMIT 1
+        """
+        )
+        res = self.cr.fetchone()
+        if res:
+            return res[0].timestamp()
+        return 0.0
+
+    def last_version(self):
+        self.cr.execute(
+            """
+            SELECT last_value FROM endpoint_route_version
+        """
+        )
+        res = self.cr.fetchone()
+        if res:
+            return res[0]
+        return -1
 
 
 class EndpointRule:
     """Hold information for a custom endpoint rule."""
 
-    __slots__ = ("key", "route", "endpoint", "routing", "endpoint_hash", "route_group")
-
-    def __init__(self, key, route, endpoint, routing, endpoint_hash, route_group=None):
+    __slots__ = (
+        "_dbname",
+        "key",
+        "route",
+        "opts",
+        "endpoint_hash",
+        "routing",
+        "route_group",
+    )
+
+    def __init__(
+        self, dbname, key, route, options, routing, endpoint_hash, route_group=None
+    ):
+        self._dbname = dbname
         self.key = key
         self.route = route
-        self.endpoint = endpoint
+        self.options = options
         self.routing = routing
         self.endpoint_hash = endpoint_hash
         self.route_group = route_group
 
     def __repr__(self):
-        return f"{self.key}: {self.route}" + (
-            f"[{self.route_group}]" if self.route_group else ""
+        # FIXME: use class name, remove key
+        return (
+            f"<{self.__class__.__name__}: {self.key}"
+            + (f" #{self.route_group}" if self.route_group else "nogroup")
+            + ">"
         )
+
+    @classmethod
+    def _ordered_columns(cls):
+        return [k for k in cls.__slots__ if not k.startswith("_")]
+
+    @property
+    def options(self):
+        return DotDict(self.opts)
+
+    @options.setter
+    def options(self, value):
+        """Validate options.
+
+        See `_get_handler` for more info.
+        """
+        assert "klass_dotted_path" in value["handler"]
+        assert "method_name" in value["handler"]
+        self.opts = value
+
+    @classmethod
+    def from_row(cls, dbname, row):
+        key, route, options, routing, endpoint_hash, route_group = row[1:-1]
+        # TODO: #jsonb-ref
+        options = json.loads(options)
+        routing = json.loads(routing)
+        init_args = (
+            dbname,
+            key,
+            route,
+            options,
+            routing,
+            endpoint_hash,
+            route_group,
+        )
+        return cls(*init_args)
+
+    def to_dict(self):
+        return {k: getattr(self, k) for k in self._ordered_columns()}
+
+    def to_row(self):
+        row = self.to_dict()
+        for k, v in row.items():
+            if isinstance(v, (dict, list)):
+                row[k] = json.dumps(v)
+        return row
+
+    @property
+    def endpoint(self):
+        """Lookup http.Endpoint to be used for the routing map."""
+        handler = self._get_handler()
+        pargs = self.handler_options.get("default_pargs", ())
+        kwargs = self.handler_options.get("default_kwargs", {})
+        method = partial(handler, *pargs, **kwargs)
+        return http.EndPoint(method, self.routing)
+
+    @property
+    def handler_options(self):
+        return self.options.handler
+
+    def _get_handler(self):
+        """Resolve endpoint handler lookup.
+
+        `options` must contain `handler` key to provide:
+
+            * the controller's klass via `klass_dotted_path`
+            * the controller's method to use via `method_name`
+
+        Lookup happens by:
+
+            1. importing the controller klass module
+            2. loading the klass
+            3. accessing the method via its name
+
+        If any of them is not found, a specific exception is raised.
+        """
+        mod_path, klass_name = self.handler_options.klass_dotted_path.rsplit(".", 1)
+        try:
+            mod = importlib.import_module(mod_path)
+        except ImportError as exc:
+            raise EndpointHandlerNotFound(f"Module `{mod_path}` not found") from exc
+        try:
+            klass = getattr(mod, klass_name)
+        except AttributeError as exc:
+            raise EndpointHandlerNotFound(f"Class `{klass_name}` not found") from exc
+        method_name = self.handler_options.method_name
+        try:
+            method = getattr(klass(), method_name)
+        except AttributeError as exc:
+            raise EndpointHandlerNotFound(
+                f"Method name `{method_name}` not found"
+            ) from exc
+        return method
```

## odoo/addons/endpoint_route_handler/i18n/endpoint_route_handler.pot

```diff
@@ -11,118 +11,186 @@
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: \n"
 "Plural-Forms: \n"
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__active
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__active
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_sync_mixin__active
 msgid "Active"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__auth_type
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__auth_type
 msgid "Auth Type"
 msgstr ""
 
 #. module: endpoint_route_handler
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__create_uid
+msgid "Created by"
+msgstr ""
+
+#. module: endpoint_route_handler
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__create_date
+msgid "Created on"
+msgstr ""
+
+#. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__csrf
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__csrf
 msgid "Csrf"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__display_name
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__display_name
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_sync_mixin__display_name
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_ir_http__display_name
 msgid "Display Name"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__endpoint_hash
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__endpoint_hash
 msgid "Endpoint Hash"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model,name:endpoint_route_handler.model_endpoint_route_handler
 msgid "Endpoint Route handler"
 msgstr ""
 
 #. module: endpoint_route_handler
+#: model:ir.model,name:endpoint_route_handler.model_endpoint_route_handler_tool
+msgid "Endpoint Route handler tool"
+msgstr ""
+
+#. module: endpoint_route_handler
+#: model:ir.model,name:endpoint_route_handler.model_endpoint_route_sync_mixin
+msgid "Endpoint Route sync mixin"
+msgstr ""
+
+#. module: endpoint_route_handler
 #: model:ir.model,name:endpoint_route_handler.model_ir_http
 msgid "HTTP Routing"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__id
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__id
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_sync_mixin__id
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_ir_http__id
 msgid "ID"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,help:endpoint_route_handler.field_endpoint_route_handler__endpoint_hash
+#: model:ir.model.fields,help:endpoint_route_handler.field_endpoint_route_handler_tool__endpoint_hash
 msgid "Identify the route with its main params"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler____last_update
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool____last_update
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_sync_mixin____last_update
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_ir_http____last_update
 msgid "Last Modified on"
 msgstr ""
 
 #. module: endpoint_route_handler
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__write_uid
+msgid "Last Updated by"
+msgstr ""
+
+#. module: endpoint_route_handler
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__write_date
+msgid "Last Updated on"
+msgstr ""
+
+#. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__name
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__name
 msgid "Name"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: code:addons/endpoint_route_handler/models/endpoint_route_handler.py:0
 #, python-format
 msgid ""
 "Non unique route(s): %(routes)s.\n"
 "Found in model(s): %(models)s.\n"
 msgstr ""
 
 #. module: endpoint_route_handler
+#: model:ir.model.fields,help:endpoint_route_handler.field_endpoint_route_handler__registry_sync
+#: model:ir.model.fields,help:endpoint_route_handler.field_endpoint_route_handler_tool__registry_sync
+#: model:ir.model.fields,help:endpoint_route_handler.field_endpoint_route_sync_mixin__registry_sync
+msgid ""
+"ON: the record has been modified and registry was not notified.\n"
+"No change will be active until this flag is set to false via proper action.\n"
+"\n"
+"OFF: record in line with the registry, nothing to do."
+msgstr ""
+
+#. module: endpoint_route_handler
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__registry_sync
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__registry_sync
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_sync_mixin__registry_sync
+msgid "Registry Sync"
+msgstr ""
+
+#. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__request_content_type
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__request_content_type
 msgid "Request Content Type"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__request_method
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__request_method
 msgid "Request Method"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: code:addons/endpoint_route_handler/models/endpoint_route_handler.py:0
 #, python-format
-msgid "Request method is required for POST and PUT."
+msgid "Request content type is required for POST and PUT."
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__route
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__route
 msgid "Route"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__route_group
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__route_group
 msgid "Route Group"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler__route_type
+#: model:ir.model.fields,field_description:endpoint_route_handler.field_endpoint_route_handler_tool__route_type
 msgid "Route Type"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.fields,help:endpoint_route_handler.field_endpoint_route_handler__route_group
+#: model:ir.model.fields,help:endpoint_route_handler.field_endpoint_route_handler_tool__route_group
 msgid "Use this to classify routes together"
 msgstr ""
 
 #. module: endpoint_route_handler
 #: model:ir.model.constraint,message:endpoint_route_handler.constraint_endpoint_endpoint_endpoint_route_unique
 #: model:ir.model.constraint,message:endpoint_route_handler.constraint_endpoint_mixin_endpoint_route_unique
 #: model:ir.model.constraint,message:endpoint_route_handler.constraint_endpoint_route_handler_endpoint_route_unique
+#: model:ir.model.constraint,message:endpoint_route_handler.constraint_endpoint_route_handler_tool_endpoint_route_unique
 msgid "You can register an endpoint route only once."
 msgstr ""
 
 #. module: endpoint_route_handler
 #: code:addons/endpoint_route_handler/models/endpoint_route_handler.py:0
 #, python-format
 msgid "`%s` uses a blacklisted routed = `%s`"
```

## odoo/addons/endpoint_route_handler/models/__init__.py

```diff
@@ -1,2 +1,4 @@
+from . import endpoint_route_sync_mixin
 from . import endpoint_route_handler
+from . import endpoint_route_handler_tool
 from . import ir_http
```

## odoo/addons/endpoint_route_handler/models/endpoint_route_handler.py

```diff
@@ -1,29 +1,26 @@
 # Copyright 2021 Camptocamp SA
 # @author: Simone Orsi <simone.orsi@camptocamp.com>
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
 
 import logging
 
-from odoo import _, api, exceptions, fields, http, models
-
-# from odoo.addons.base_sparse_field.models.fields import Serialized
-from ..registry import EndpointRegistry
+from odoo import _, api, exceptions, fields, models
 
 ENDPOINT_ROUTE_CONSUMER_MODELS = {
     # by db
 }
 
 
 class EndpointRouteHandler(models.AbstractModel):
 
     _name = "endpoint.route.handler"
+    _inherit = "endpoint.route.sync.mixin"
     _description = "Endpoint Route handler"
 
-    active = fields.Boolean(default=True)
     name = fields.Char(required=True)
     route = fields.Char(
         required=True,
         index=True,
         compute="_compute_route",
         inverse="_inverse_route",
         readonly=False,
@@ -43,17 +40,19 @@
     # # TODO: validate params? Just for doc? Maybe use Cerberus?
     # # -> For now let the implementer validate the params in the snippet.
     # request_params = Serialized(help="TODO")
 
     endpoint_hash = fields.Char(
         compute="_compute_endpoint_hash", help="Identify the route with its main params"
     )
-
     csrf = fields.Boolean(default=False)
 
+    # TODO: add flag to prevent route updates on save ->
+    # should be handled by specific actions + filter in a tree view + btn on form
+
     _sql_constraints = [
         (
             "endpoint_route_unique",
             "unique(route)",
             "You can register an endpoint route only once.",
         )
     ]
@@ -128,28 +127,29 @@
             ("text/plain", "Text"),
             ("text/csv", "CSV"),
             ("application/json", "JSON"),
             ("application/xml", "XML"),
             ("application/x-www-form-urlencoded", "Form"),
         ]
 
-    @api.depends(lambda self: self._controller_fields())
+    @api.depends(lambda self: self._routing_impacting_fields())
     def _compute_endpoint_hash(self):
         # Do not use read to be able to play this on NewId records too
         # (NewId records are classified as missing in ACL check).
-        # values = self.read(self._controller_fields())
+        # values = self.read(self._routing_impacting_fields())
         values = [
-            {fname: rec[fname] for fname in self._controller_fields()} for rec in self
+            {fname: rec[fname] for fname in self._routing_impacting_fields()}
+            for rec in self
         ]
         for rec, vals in zip(self, values):
             vals.pop("id", None)
             rec.endpoint_hash = hash(tuple(vals.values()))
 
-    def _controller_fields(self):
-        return ["route", "auth_type", "request_method"]
+    def _routing_impacting_fields(self):
+        return ("route", "auth_type", "request_method")
 
     @api.depends("route")
     def _compute_route(self):
         for rec in self:
             rec.route = rec._clean_route()
 
     def _inverse_route(self):
@@ -180,122 +180,69 @@
                 )
 
     @api.constrains("request_method", "request_content_type")
     def _check_request_method(self):
         for rec in self:
             if rec.request_method in ("POST", "PUT") and not rec.request_content_type:
                 raise exceptions.UserError(
-                    _("Request method is required for POST and PUT.")
+                    _("Request content type is required for POST and PUT.")
                 )
 
-    # Handle automatic route registration
-
-    @api.model_create_multi
-    def create(self, vals_list):
-        rec = super().create(vals_list)
-        if not self._abstract and rec.active:
-            rec._register_controllers()
-        return rec
-
-    def write(self, vals):
-        res = super().write(vals)
-        self._handle_route_updates(vals)
-        return res
-
-    def _handle_route_updates(self, vals):
-        if "active" in vals:
-            if vals["active"]:
-                self._register_controllers()
-            else:
-                self._unregister_controllers()
-            return True
-        if any([x in vals for x in self._controller_fields()]):
-            self._register_controllers()
-            return True
-        return False
-
-    def unlink(self):
-        if not self._abstract:
-            self._unregister_controllers()
-        return super().unlink()
-
-    def _register_hook(self):
-        super()._register_hook()
-        if not self._abstract:
-            # Look explicitly for active records.
-            # Pass `init` to not set the registry as updated
-            # since this piece of code runs only when the model is loaded.
-            self.search([("active", "=", True)])._register_controllers(init=True)
-
-    def _register_controllers(self, init=False):
-        if self._abstract:
-            self._refresh_endpoint_data()
-        for rec in self:
-            rec._register_controller(init=init)
-
-    def _unregister_controllers(self):
-        if self._abstract:
-            self._refresh_endpoint_data()
-        for rec in self:
-            rec._unregister_controller()
+    def _prepare_endpoint_rules(self, options=None):
+        return [rec._make_controller_rule(options=options) for rec in self]
 
-    def _refresh_endpoint_data(self):
-        """Enforce refresh of route computed fields.
+    def _registered_endpoint_rule_keys(self):
+        return tuple([rec._endpoint_registry_unique_key() for rec in self])
 
-        Required for NewId records when using this model as a tool.
-        """
-        self._compute_endpoint_hash()
-        self._compute_route()
-
-    @property
-    def _endpoint_registry(self):
-        return EndpointRegistry.registry_for(self.env.cr.dbname)
+    def _endpoint_registry_unique_key(self):
+        return "{0._name}:{0.id}".format(self)
 
-    def _register_controller(self, endpoint_handler=None, key=None, init=False):
-        rule = self._make_controller_rule(endpoint_handler=endpoint_handler, key=key)
-        self._endpoint_registry.add_or_update_rule(rule, init=init)
+    # TODO: consider if useful or not for single records
+    def _register_single_controller(self, options=None, key=None, init=False):
+        """Shortcut to register one single controller."""
+        rule = self._make_controller_rule(options=options, key=key)
+        self._endpoint_registry.update_rules([rule], init=init)
         self._logger.debug(
             "Registered controller %s (auth: %s)", self.route, self.auth_type
         )
 
-    def _make_controller_rule(self, endpoint_handler=None, key=None):
+    def _make_controller_rule(self, options=None, key=None):
         key = key or self._endpoint_registry_unique_key()
         route, routing, endpoint_hash = self._get_routing_info()
-        endpoint_handler = endpoint_handler or self._default_endpoint_handler()
-        assert callable(endpoint_handler)
-        endpoint = http.EndPoint(endpoint_handler, routing)
-        rule = self._endpoint_registry.make_rule(
+        options = options or self._default_endpoint_options()
+        return self._endpoint_registry.make_rule(
             # fmt: off
             key,
             route,
-            endpoint,
+            options,
             routing,
             endpoint_hash,
             route_group=self.route_group
             # fmt: on
         )
-        return rule
-
-    def _default_endpoint_handler(self):
-        """Provide default endpoint handler.
 
-        :return: bound method of a controller (eg: MyController()._my_handler)
-        """
-        raise NotImplementedError("No default endpoint handler defined.")
+    def _default_endpoint_options(self):
+        options = {"handler": self._default_endpoint_options_handler()}
+        return options
+
+    def _default_endpoint_options_handler(self):
+        self._logger.warning(
+            "No specific endpoint handler options defined for: %s, falling back to default",
+            self._name,
+        )
+        base_path = "odoo.addons.endpoint_route_handler.controllers.main"
+        return {
+            "klass_dotted_path": f"{base_path}.EndpointNotFoundController",
+            "method_name": "auto_not_found",
+            "default_pargs": (self.route,),
+        }
 
     def _get_routing_info(self):
         route = self.route
         routing = dict(
             type=self.route_type,
             auth=self.auth_type,
             methods=[self.request_method],
             routes=[route],
             csrf=self.csrf,
         )
         return route, routing, self.endpoint_hash
-
-    def _endpoint_registry_unique_key(self):
-        return "{0._name}:{0.id}".format(self)
-
-    def _unregister_controller(self, key=None):
-        key = key or self._endpoint_registry_unique_key()
-        self._endpoint_registry.drop_rule(key)
```

## odoo/addons/endpoint_route_handler/models/ir_http.py

```diff
@@ -14,70 +14,57 @@
 _logger = logging.getLogger(__name__)
 
 
 class IrHttp(models.AbstractModel):
     _inherit = "ir.http"
 
     @classmethod
+    def _endpoint_route_registry(cls, env):
+        return EndpointRegistry.registry_for(env.cr)
+
+    @classmethod
     def _generate_routing_rules(cls, modules, converters):
         # Override to inject custom endpoint rules.
         return chain(
             super()._generate_routing_rules(modules, converters),
             cls._endpoint_routing_rules(),
         )
 
     @classmethod
     def _endpoint_routing_rules(cls):
         """Yield custom endpoint rules"""
-        cr = http.request.env.cr
-        e_registry = EndpointRegistry.registry_for(cr.dbname)
+        e_registry = cls._endpoint_route_registry(http.request.env)
         for endpoint_rule in e_registry.get_rules():
             _logger.debug("LOADING %s", endpoint_rule)
             endpoint = endpoint_rule.endpoint
             for url in endpoint_rule.routing["routes"]:
                 yield (url, endpoint, endpoint_rule.routing)
 
     @classmethod
     def routing_map(cls, key=None):
-        cr = http.request.env.cr
-        e_registry = EndpointRegistry.registry_for(cr.dbname)
-
-        # Each `env` will have its own `ir.http` "class instance"
-        # thus, each instance will have its own routing map.
-        # Hence, we must keep track of which instances have been updated
-        # to make sure routing rules are always up to date across envs.
-        #
-        # In the original `routing_map` method it's reported in a comment
-        # that the routing map should be unique instead of being duplicated
-        # across envs... well, this is how it works today so we have to deal w/ it.
-        http_id = cls._endpoint_make_http_id()
-
-        is_routing_map_new = not hasattr(cls, "_routing_map")
-        if is_routing_map_new or not e_registry.ir_http_seen(http_id):
-            # When the routing map is not ready yet, simply track current instance
-            e_registry.ir_http_track(http_id)
-            _logger.debug("ir_http instance `%s` tracked", http_id)
-        elif e_registry.ir_http_seen(http_id) and e_registry.routing_update_required(
-            http_id
-        ):
-            # This instance was already tracked
-            # and meanwhile the registry got updated:
-            # ensure all routes are re-loaded.
-            _logger.info(
-                "Endpoint registry updated, reset routing ma for `%s`", http_id
-            )
+        last_version = cls._get_routing_map_last_version(http.request.env)
+        if not hasattr(cls, "_routing_map"):
+            # routing map just initialized, store last update for this env
+            cls._endpoint_route_last_version = last_version
+        elif cls._endpoint_route_last_version < last_version:
+            _logger.info("Endpoint registry updated, reset routing map")
             cls._routing_map = {}
             cls._rewrite_len = {}
-            e_registry.reset_update_required(http_id)
+            cls._endpoint_route_last_version = last_version
         return super().routing_map(key=key)
 
     @classmethod
-    def _endpoint_make_http_id(cls):
-        """Generate current ir.http class ID."""
-        return id(cls)
+    def _get_routing_map_last_version(cls, env):
+        return cls._endpoint_route_registry(env).last_version()
+
+    @classmethod
+    def _clear_routing_map(cls):
+        super()._clear_routing_map()
+        if hasattr(cls, "_endpoint_route_last_version"):
+            cls._endpoint_route_last_version = 0
 
     @classmethod
     def _auth_method_user_endpoint(cls):
         """Special method for user auth which raises Unauthorized when needed.
 
         If you get an HTTP request (instead of a JSON one),
         the standard `user` method raises `SessionExpiredException`
```

## odoo/addons/endpoint_route_handler/readme/USAGE.rst

```diff
@@ -6,32 +6,55 @@
     class MyModel(models.Model):
         _name = "my.model"
         _inherit = "endpoint.route.handler"
 
 Once you have this, each `my.model` record will generate a route.
 You can have a look at the `endpoint` module to see a real life example.
 
+The options of the routing rules are defined by the method `_default_endpoint_options`.
+Here's an example from the `endpoint` module::
+
+    def _default_endpoint_options_handler(self):
+        return {
+            "klass_dotted_path": "odoo.addons.endpoint.controllers.main.EndpointController",
+            "method_name": "auto_endpoint",
+            "default_pargs": (self.route,),
+        }
+
+As you can see, you have to pass the references to the controller class and the method to use
+when the endpoint is called. And you can prepare some default arguments to pass.
+In this case, the route of the current record.
+
 
 As a tool
 ~~~~~~~~~
 
 Initialize non stored route handlers and generate routes from them.
 For instance::
 
-    route_handler = self.env["endpoint.route.handler"]
+    route_handler = self.env["endpoint.route.handler.tool"]
     endpoint_handler = MyController()._my_handler
     vals = {
         "name": "My custom route",
         "route": "/my/custom/route",
         "request_method": "GET",
         "auth_type": "public",
     }
     new_route = route_handler.new(vals)
-    new_route._refresh_endpoint_data()  # required only for NewId records
-    new_route._register_controller(endpoint_handler=endpoint_handler, key="my-custom-route")
+    new_route._register_controller()
+
+You can override options and define - for instance - a different controller method::
+
+    options = {
+        "handler": {
+            "klass_dotted_path": "odoo.addons.my_module.controllers.SpecialController",
+            "method_name": "my_special_handler",
+        }
+    }
+    new_route._register_controller(options=options)
 
 Of course, what happens when the endpoint gets called
 depends on the logic defined on the controller method.
 
 In both cases (mixin and tool) when a new route is generated or an existing one is updated,
 the `ir.http.routing_map` (which holds all Odoo controllers) will be updated.
```

## odoo/addons/endpoint_route_handler/security/ir.model.access.csv

```diff
@@ -1,3 +1,5 @@
 id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
-access_endpoint_route_handler_mngr_edit,endpoint_route_handler mngr edit,model_endpoint_route_handler,base.group_system,1,1,1,1
-access_endpoint_route_handler_edit,endpoint_route_handler edit,model_endpoint_route_handler,,1,0,0,0
+access_endpoint_route_handler_tool_mngr_edit,endpoint_route_handler mngr edit,model_endpoint_route_handler,base.group_system,1,1,1,1
+access_endpoint_route_handler_tool_edit,endpoint_route_handler edit,model_endpoint_route_handler,,1,0,0,0
+access_endpoint_route_handler_mngr_edit,endpoint_route_handler_tool mngr edit,model_endpoint_route_handler_tool,base.group_system,1,1,1,1
+access_endpoint_route_handler_edit,endpoint_route_handler_tool edit,model_endpoint_route_handler_tool,,1,0,0,0
```

## odoo/addons/endpoint_route_handler/static/description/index.html

### odoo/addons/endpoint_route_handler/static/description/index.html

```diff
@@ -2,15 +2,15 @@
 <!DOCTYPE html
   PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
   'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
   <head>
     <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
     <meta name="generator" content="Docutils 0.15.1: http://docutils.sourceforge.net/"/>
-    <title>Route route handler</title>
+    <title>Endpoint route handler</title>
     <style type="text/css">/*
 :Author: David Goodger (goodger@python.org)
 :Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
 :Copyright: This stylesheet has been placed in the public domain.
 
 Default cascading style sheet for the HTML output of Docutils.
 
@@ -354,16 +354,16 @@
 h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
   font-size: 100% }
 
 ul.auto-toc {
   list-style-type: none }</style>
   </head>
   <body>
-    <div class="document" id="route-route-handler">
-      <h1 class="title">Route route handler</h1>
+    <div class="document" id="endpoint-route-handler">
+      <h1 class="title">Endpoint route handler</h1>
       <!-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !! This file is generated by oca-gen-addon-readme !!
 !! changes will be overwritten.                   !!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -->
       <p>
         <a class="reference external" href="https://odoo-community.org/page/development-status">
           <img alt="Beta" src="https://img.shields.io/badge/maturity-Beta-yellow.png"/>
@@ -435,32 +435,56 @@
             Once you have this, each
             <cite>my.model</cite>
             record will generate a route.
 You can have a look at the
             <cite>endpoint</cite>
             module to see a real life example.
           </p>
+          <p>
+            The options of the routing rules are defined by the method
+            <cite>_default_endpoint_options</cite>
+            .
+Heres an example from the
+            <cite>endpoint</cite>
+            module:
+          </p>
+          <pre class="literal-block">def _default_endpoint_options_handler(self):
+    return {
+        &quot;klass_dotted_path&quot;: &quot;odoo.addons.endpoint.controllers.main.EndpointController&quot;,
+        &quot;method_name&quot;: &quot;auto_endpoint&quot;,
+        &quot;default_pargs&quot;: (self.route,),
+    }</pre>
+          <p>As you can see, you have to pass the references to the controller class and the method to use
+when the endpoint is called. And you can prepare some default arguments to pass.
+In this case, the route of the current record.</p>
         </div>
         <div class="section" id="as-a-tool">
           <h2>
             <a class="toc-backref" href="#id3">As a tool</a>
           </h2>
           <p>Initialize non stored route handlers and generate routes from them.
 For instance:</p>
-          <pre class="literal-block">route_handler = self.env[&quot;endpoint.route.handler&quot;]
+          <pre class="literal-block">route_handler = self.env[&quot;endpoint.route.handler.tool&quot;]
 endpoint_handler = MyController()._my_handler
 vals = {
     &quot;name&quot;: &quot;My custom route&quot;,
     &quot;route&quot;: &quot;/my/custom/route&quot;,
     &quot;request_method&quot;: &quot;GET&quot;,
     &quot;auth_type&quot;: &quot;public&quot;,
 }
 new_route = route_handler.new(vals)
-new_route._refresh_endpoint_data()  # required only for NewId records
-new_route._register_controller(endpoint_handler=endpoint_handler, key=&quot;my-custom-route&quot;)</pre>
+new_route._register_controller()</pre>
+          <p>You can override options and define - for instance - a different controller method:</p>
+          <pre class="literal-block">options = {
+    &quot;handler&quot;: {
+        &quot;klass_dotted_path&quot;: &quot;odoo.addons.my_module.controllers.SpecialController&quot;,
+        &quot;method_name&quot;: &quot;my_special_handler&quot;,
+    }
+}
+new_route._register_controller(options=options)</pre>
           <p>Of course, what happens when the endpoint gets called
 depends on the logic defined on the controller method.</p>
           <p>
             In both cases (mixin and tool) when a new route is generated or an existing one is updated,
 the
             <cite>ir.http.routing_map</cite>
             (which holds all Odoo controllers) will be updated.
```

## odoo/addons/endpoint_route_handler/tests/__init__.py

```diff
@@ -1,2 +1,3 @@
+from . import test_registry
 from . import test_endpoint
 from . import test_endpoint_controller
```

## odoo/addons/endpoint_route_handler/tests/common.py

```diff
@@ -32,17 +32,17 @@
 
     @classmethod
     def _setup_records(cls):
         pass
 
     @contextlib.contextmanager
     def _get_mocked_request(
-        self, httprequest=None, extra_headers=None, request_attrs=None
+        self, env=None, httprequest=None, extra_headers=None, request_attrs=None
     ):
-        with MockRequest(self.env) as mocked_request:
+        with MockRequest(env or self.env) as mocked_request:
             mocked_request.httprequest = (
                 DotDict(httprequest) if httprequest else mocked_request.httprequest
             )
             headers = {}
             headers.update(extra_headers or {})
             mocked_request.httprequest.headers = headers
             request_attrs = request_attrs or {}
```

## odoo/addons/endpoint_route_handler/tests/test_endpoint.py

```diff
@@ -1,85 +1,176 @@
 # Copyright 2021 Camptocamp SA
 # @author: Simone Orsi <simone.orsi@camptocamp.com>
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
+from contextlib import contextmanager
 
-
-from functools import partial
-
-from odoo.http import Controller
+import odoo
+from odoo.tools import mute_logger
 
 from ..registry import EndpointRegistry
 from .common import CommonEndpoint
+from .fake_controllers import CTRLFake
+
+
+@contextmanager
+def new_rollbacked_env():
+    # Borrowed from `component`
+    registry = odoo.registry(odoo.tests.common.get_db_name())
+    uid = odoo.SUPERUSER_ID
+    cr = registry.cursor()
+    try:
+        yield odoo.api.Environment(cr, uid, {})
+    finally:
+        cr.rollback()  # we shouldn't have to commit anything
+        cr.close()
+
+
+def make_new_route(env, **kw):
+    model = env["endpoint.route.handler.tool"]
+    vals = {
+        "name": "Test custom route",
+        "route": "/my/test/route",
+        "request_method": "GET",
+    }
+    vals.update(kw)
+    new_route = model.new(vals)
+    return new_route
 
 
 class TestEndpoint(CommonEndpoint):
     def tearDown(self):
         self.env["ir.http"]._clear_routing_map()
-        EndpointRegistry.wipe_registry_for(self.env.cr.dbname)
+        EndpointRegistry.wipe_registry_for(self.env.cr)
         super().tearDown()
 
-    def _make_new_route(self, **kw):
-        vals = {
-            "name": "Test custom route",
-            "route": "/my/test/route",
-            "request_method": "GET",
-        }
-        vals.update(kw)
-        new_route = self.route_handler.new(vals)
-        new_route._refresh_endpoint_data()
-        return new_route
-
     def test_as_tool_base_data(self):
-        new_route = self._make_new_route()
+        new_route = make_new_route(self.env)
         self.assertEqual(new_route.route, "/my/test/route")
         first_hash = new_route.endpoint_hash
         self.assertTrue(first_hash)
         new_route.route += "/new"
-        new_route._refresh_endpoint_data()
         self.assertNotEqual(new_route.endpoint_hash, first_hash)
 
-    def test_as_tool_register_controller_no_default(self):
-        new_route = self._make_new_route()
-        # No specific controller
-        with self.assertRaisesRegex(
-            NotImplementedError, "No default endpoint handler defined."
-        ):
-            new_route._register_controller()
-
-    def test_as_tool_register_controller(self):
-        new_route = self._make_new_route()
-
-        class TestController(Controller):
-            def _do_something(self, route):
-                return "ok"
+    @mute_logger("odoo.addons.base.models.ir_http")
+    def test_as_tool_register_single_controller(self):
+        new_route = make_new_route(self.env)
+        options = {
+            "handler": {
+                "klass_dotted_path": CTRLFake._path,
+                "method_name": "custom_handler",
+            }
+        }
 
-        endpoint_handler = partial(TestController()._do_something, new_route.route)
         with self._get_mocked_request():
-            new_route._register_controller(endpoint_handler=endpoint_handler)
+            new_route._register_single_controller(options=options, init=True)
             # Ensure the routing rule is registered
             rmap = self.env["ir.http"].routing_map()
             self.assertIn("/my/test/route", [x.rule for x in rmap._rules])
+
         # Ensure is updated when needed
         new_route.route += "/new"
-        new_route._refresh_endpoint_data()
         with self._get_mocked_request():
-            new_route._register_controller(endpoint_handler=endpoint_handler)
+            new_route._register_single_controller(options=options, init=True)
+            rmap = self.env["ir.http"]._clear_routing_map()
             rmap = self.env["ir.http"].routing_map()
             self.assertNotIn("/my/test/route", [x.rule for x in rmap._rules])
             self.assertIn("/my/test/route/new", [x.rule for x in rmap._rules])
 
-    def test_as_tool_register_controller_dynamic_route(self):
-        route = "/my/app/<model(app.model):foo>"
-        new_route = self._make_new_route(route=route)
+    @mute_logger("odoo.addons.base.models.ir_http")
+    def test_as_tool_register_controllers(self):
+        new_route = make_new_route(self.env)
+        options = {
+            "handler": {
+                "klass_dotted_path": CTRLFake._path,
+                "method_name": "custom_handler",
+            }
+        }
 
-        class TestController(Controller):
-            def _do_something(self, foo=None):
-                return "ok"
+        with self._get_mocked_request():
+            new_route._register_controllers(options=options, init=True)
+            # Ensure the routing rule is registered
+            rmap = self.env["ir.http"].routing_map()
+            self.assertIn("/my/test/route", [x.rule for x in rmap._rules])
 
-        endpoint_handler = TestController()._do_something
+        # Ensure is updated when needed
+        new_route.route += "/new"
         with self._get_mocked_request():
-            new_route._register_controller(endpoint_handler=endpoint_handler)
+            new_route._register_controllers(options=options, init=True)
+            rmap = self.env["ir.http"]._clear_routing_map()
+            rmap = self.env["ir.http"].routing_map()
+            self.assertNotIn("/my/test/route", [x.rule for x in rmap._rules])
+            self.assertIn("/my/test/route/new", [x.rule for x in rmap._rules])
+
+    @mute_logger("odoo.addons.base.models.ir_http")
+    def test_as_tool_register_controllers_dynamic_route(self):
+        route = "/my/app/<model(app.model):foo>"
+        new_route = make_new_route(self.env, route=route)
+        options = {
+            "handler": {
+                "klass_dotted_path": CTRLFake._path,
+                "method_name": "custom_handler",
+            }
+        }
+
+        with self._get_mocked_request():
+            new_route._register_controllers(options=options, init=True)
             # Ensure the routing rule is registered
             rmap = self.env["ir.http"].routing_map()
             self.assertIn(route, [x.rule for x in rmap._rules])
 
+
+class TestEndpointCrossEnv(CommonEndpoint):
+    def setUp(self):
+        super().setUp()
+        self.env["ir.http"]._clear_routing_map()
+        EndpointRegistry.wipe_registry_for(self.env.cr)
+
+    @mute_logger("odoo.addons.base.models.ir_http", "odoo.modules.registry")
+    def test_cross_env_consistency(self):
+        """Ensure route updates are propagated to all envs."""
+        route = "/my/app/<model(app.model):foo>"
+        new_route = make_new_route(self.env, route=route)
+        options = {
+            "handler": {
+                "klass_dotted_path": CTRLFake._path,
+                "method_name": "custom_handler",
+            }
+        }
+
+        env1 = self.env
+        reg = EndpointRegistry.registry_for(self.env.cr)
+        new_route._register_controllers(options=options)
+
+        last_version0 = reg.last_version()
+        with self._get_mocked_request():
+            with new_rollbacked_env() as env2:
+                # Load maps
+                env1["ir.http"].routing_map()
+                env2["ir.http"].routing_map()
+                self.assertEqual(
+                    env1["ir.http"]._endpoint_route_last_version, last_version0
+                )
+                self.assertEqual(
+                    env2["ir.http"]._endpoint_route_last_version, last_version0
+                )
+                rmap = self.env["ir.http"].routing_map()
+                self.assertIn(route, [x.rule for x in rmap._rules])
+                rmap = env2["ir.http"].routing_map()
+                self.assertIn(route, [x.rule for x in rmap._rules])
+
+                # add new route
+                route = "/my/new/<model(app.model):foo>"
+                new_route = make_new_route(self.env, route=route)
+                new_route._register_controllers(options=options)
+
+                rmap = self.env["ir.http"].routing_map()
+                self.assertIn(route, [x.rule for x in rmap._rules])
+                rmap = env2["ir.http"].routing_map()
+                self.assertIn(route, [x.rule for x in rmap._rules])
+                self.assertTrue(
+                    env1["ir.http"]._endpoint_route_last_version > last_version0
+                )
+                self.assertTrue(
+                    env2["ir.http"]._endpoint_route_last_version > last_version0
+                )
+
     # TODO: test unregister
```

## odoo/addons/endpoint_route_handler/tests/test_endpoint_controller.py

```diff
@@ -1,72 +1,67 @@
 # Copyright 2021 Camptocamp SA
 # @author: Simone Orsi <simone.orsi@camptocamp.com>
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
 
 import os
 import unittest
-from functools import partial
 
-from odoo.http import Controller
 from odoo.tests.common import HttpCase
 
 from ..registry import EndpointRegistry
-
-
-class TestController(Controller):
-    def _do_something1(self, foo=None):
-        return f"Got: {foo}"
-
-    def _do_something2(self, default_arg, foo=None):
-        return f"{default_arg} -> got: {foo}"
+from .fake_controllers import TestController
 
 
 @unittest.skipIf(os.getenv("SKIP_HTTP_CASE"), "EndpointHttpCase skipped")
 class EndpointHttpCase(HttpCase):
     def setUp(self):
         super().setUp()
-        self.route_handler = self.env["endpoint.route.handler"]
+        self.route_handler = self.env["endpoint.route.handler.tool"]
 
     def tearDown(self):
-        EndpointRegistry.wipe_registry_for(self.env.cr.dbname)
+        EndpointRegistry.wipe_registry_for(self.env.cr)
         self.env["ir.http"]._clear_routing_map()
         super().tearDown()
 
-    def _make_new_route(self, register=True, **kw):
+    def _make_new_route(self, options=None, **kw):
         vals = {
             "name": "Test custom route",
             "request_method": "GET",
         }
         vals.update(kw)
         new_route = self.route_handler.new(vals)
-        new_route._refresh_endpoint_data()
+        new_route._register_controllers(options=options)
         return new_route
 
-    def _register_controller(self, route_obj, endpoint_handler=None):
-        endpoint_handler = endpoint_handler or TestController()._do_something1
-        route_obj._register_controller(endpoint_handler=endpoint_handler)
-
     def test_call(self):
-        new_route = self._make_new_route(route="/my/test/<string:foo>")
-        self._register_controller(new_route)
-
+        options = {
+            "handler": {
+                "klass_dotted_path": TestController._path,
+                "method_name": "_do_something1",
+            }
+        }
+        self._make_new_route(route="/my/test/<string:foo>", options=options)
         route = "/my/test/working"
         response = self.url_open(route)
         self.assertEqual(response.status_code, 401)
         # Let's login now
         self.authenticate("admin", "admin")
         response = self.url_open(route)
         self.assertEqual(response.status_code, 200)
         self.assertEqual(response.content, b"Got: working")
 
     def test_call_advanced_endpoint_handler(self):
-        new_route = self._make_new_route(route="/my/advanced/test/<string:foo>")
-        endpoint_handler = partial(TestController()._do_something2, "DEFAULT")
-        self._register_controller(new_route, endpoint_handler=endpoint_handler)
-
+        options = {
+            "handler": {
+                "klass_dotted_path": TestController._path,
+                "method_name": "_do_something2",
+                "default_pargs": ("DEFAULT",),
+            }
+        }
+        self._make_new_route(route="/my/advanced/test/<string:foo>", options=options)
         route = "/my/advanced/test/working"
         response = self.url_open(route)
         self.assertEqual(response.status_code, 401)
         # Let's login now
         self.authenticate("admin", "admin")
         response = self.url_open(route)
         self.assertEqual(response.status_code, 200)
```

## Comparing `odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/METADATA` & `odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/METADATA`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 Metadata-Version: 2.1
 Name: odoo14-addon-endpoint-route-handler
-Version: 14.0.1.1.1.dev4
+Version: 14.0.2.0.1.dev2
 Summary: Provide mixin and tool to generate custom endpoints on the fly.
 Home-page: https://github.com/OCA/web-api
 Author: Camptocamp,Odoo Community Association (OCA)
 Author-email: support@odoo-community.org
 License: LGPL-3
 Platform: UNKNOWN
 Classifier: Programming Language :: Python
 Classifier: Framework :: Odoo
 Classifier: Framework :: Odoo :: 14.0
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
 Classifier: Development Status :: 4 - Beta
 Requires-Python: >=3.6
 Requires-Dist: odoo (<14.1dev,>=14.0a)
 
-====================
- Route route handler
-====================
+======================
+Endpoint route handler
+======================
 
 .. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !! This file is generated by oca-gen-addon-readme !!
    !! changes will be overwritten.                   !!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 .. |badge1| image:: https://img.shields.io/badge/maturity-Beta-yellow.png
@@ -60,32 +60,55 @@
     class MyModel(models.Model):
         _name = "my.model"
         _inherit = "endpoint.route.handler"
 
 Once you have this, each `my.model` record will generate a route.
 You can have a look at the `endpoint` module to see a real life example.
 
+The options of the routing rules are defined by the method `_default_endpoint_options`.
+Here's an example from the `endpoint` module::
+
+    def _default_endpoint_options_handler(self):
+        return {
+            "klass_dotted_path": "odoo.addons.endpoint.controllers.main.EndpointController",
+            "method_name": "auto_endpoint",
+            "default_pargs": (self.route,),
+        }
+
+As you can see, you have to pass the references to the controller class and the method to use
+when the endpoint is called. And you can prepare some default arguments to pass.
+In this case, the route of the current record.
+
 
 As a tool
 ~~~~~~~~~
 
 Initialize non stored route handlers and generate routes from them.
 For instance::
 
-    route_handler = self.env["endpoint.route.handler"]
+    route_handler = self.env["endpoint.route.handler.tool"]
     endpoint_handler = MyController()._my_handler
     vals = {
         "name": "My custom route",
         "route": "/my/custom/route",
         "request_method": "GET",
         "auth_type": "public",
     }
     new_route = route_handler.new(vals)
-    new_route._refresh_endpoint_data()  # required only for NewId records
-    new_route._register_controller(endpoint_handler=endpoint_handler, key="my-custom-route")
+    new_route._register_controller()
+
+You can override options and define - for instance - a different controller method::
+
+    options = {
+        "handler": {
+            "klass_dotted_path": "odoo.addons.my_module.controllers.SpecialController",
+            "method_name": "my_special_handler",
+        }
+    }
+    new_route._register_controller(options=options)
 
 Of course, what happens when the endpoint gets called
 depends on the logic defined on the controller method.
 
 In both cases (mixin and tool) when a new route is generated or an existing one is updated,
 the `ir.http.routing_map` (which holds all Odoo controllers) will be updated.
```

## Comparing `odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/RECORD` & `odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,23 +1,32 @@
-odoo/addons/endpoint_route_handler/README.rst,sha256=WNvFu45I70gzLqgx9-a7Ihwl-oKKAnQSKd6xNDSFkFs,4413
-odoo/addons/endpoint_route_handler/__init__.py,sha256=X9EJGOE2GtZbS0G82PtSXmWSZ_R8jEM0rlJTDliQjp4,21
-odoo/addons/endpoint_route_handler/__manifest__.py,sha256=hoOQ91jckgf3IGoC4xsThaAzT0hvhvXnVPRPu0L5SoM,514
-odoo/addons/endpoint_route_handler/registry.py,sha256=kmKeZPHvxhAR5-ueNB1YETp-N70qniIEbA99TH9NkeE,3392
-odoo/addons/endpoint_route_handler/i18n/endpoint_route_handler.pot,sha256=YG_Wy1f602e61ucCou-7evZIs-FfdHKvnSGYjCZmTLg,4525
-odoo/addons/endpoint_route_handler/models/__init__.py,sha256=BNENFAI_JGokcog-bT0OS-V1nKxoL5jMRayU7K4MeIM,59
-odoo/addons/endpoint_route_handler/models/endpoint_route_handler.py,sha256=-rnyuHLNqwlYEX-Da0rtxKzuUWKwgf1B1_Eh9r80Z9U,10394
-odoo/addons/endpoint_route_handler/models/ir_http.py,sha256=S8kVYgXvNAjBiMQyni2ZODksaMnw_jiFSrVVjIoSBeI,3523
+odoo/addons/endpoint_route_handler/README.rst,sha256=MDOVu6ppUCIFvtvZZP9UJZ6qY9Eheg5YlmxKn6Q6Sw0,5240
+odoo/addons/endpoint_route_handler/__init__.py,sha256=H1e7Gzkkfna_-EqFuUmogV7KvtvW-2BclGbcwkkHhq8,64
+odoo/addons/endpoint_route_handler/__manifest__.py,sha256=Eo0ZoYaKU8ju_vCek2cJgArWh85mqmHkFpTmb9YXCrg,556
+odoo/addons/endpoint_route_handler/exceptions.py,sha256=Lftj9Q3v6qyg4_qrc5TQS4NpWyhGHBuFm-qR2FskjXQ,246
+odoo/addons/endpoint_route_handler/post_init_hook.py,sha256=6j-DMUVh2lkefTQoDfr28qyQPhWAvvLkZ1V43bNbjSw,362
+odoo/addons/endpoint_route_handler/registry.py,sha256=yPEU5LMatCoggarzoUeqCajiQP6x2oxgsBq_EsfYBAo,11835
+odoo/addons/endpoint_route_handler/controllers/__init__.py,sha256=4KFqEP2QHFbPN66eQJMdGsmNz2v7ywWv_FR1pW_kkLk,19
+odoo/addons/endpoint_route_handler/controllers/main.py,sha256=WmAsO2OqTwlbQQApm13l592Z4nD6_mwcJX06WlnSTeM,474
+odoo/addons/endpoint_route_handler/i18n/endpoint_route_handler.pot,sha256=4m0Cqklz8b-WwUfD0gkO9D7DROm6au0ECQB0M4c_Mdg,8735
+odoo/addons/endpoint_route_handler/migrations/14.0.2.0.0/pre-migrate.py,sha256=-23UuAvMCgWgCUO2_I4Wh4eUnAxk_Cj2AbRdtpLXLhw,429
+odoo/addons/endpoint_route_handler/models/__init__.py,sha256=cX87W7PNJu4xVJzCXnfpCrqFTN2RSwfyn2DK8x9tru0,141
+odoo/addons/endpoint_route_handler/models/endpoint_route_handler.py,sha256=USuU9ix3RyJW7sUqKnIjby-2e2AZRyifBqRMJnytXYw,8887
+odoo/addons/endpoint_route_handler/models/endpoint_route_handler_tool.py,sha256=0d9EZJbhlOy5YGhueXPmx2WmaRlrsQ8_OIhGOFnQCzE,1536
+odoo/addons/endpoint_route_handler/models/endpoint_route_sync_mixin.py,sha256=DgQVoSC21GdawlipSvhwhQr9RG65Oq4XlfoP2aEMbHI,4121
+odoo/addons/endpoint_route_handler/models/ir_http.py,sha256=sAuHUtEzkbwNiqCEcgDAcmBRdgG08pVUOaCTBYT-EPg,2829
 odoo/addons/endpoint_route_handler/readme/CONTRIBUTORS.rst,sha256=1ADhmOLCMAtDVg9t5Fstl0AwYHMzEiFSenM8tO5AtqY,43
 odoo/addons/endpoint_route_handler/readme/DESCRIPTION.rst,sha256=H9idg9XjbYovDOXV_fRFF8Kt0qBfQqbdCnf-fuDoTys,138
 odoo/addons/endpoint_route_handler/readme/ROADMAP.rst,sha256=2cGVJWJM_eWAec8OcZG14HyRL-BBJ7m5grgqk5EN3CI,372
-odoo/addons/endpoint_route_handler/readme/USAGE.rst,sha256=E4EDS-7Z6WSAuvQqQ-L_XOXKPAnJVStWiy38_S4shi4,1214
-odoo/addons/endpoint_route_handler/security/ir.model.access.csv,sha256=g1lhOqKndSznLCHjjtVPei9SV0S6VUY9U9MDNWd0Z1Y,306
+odoo/addons/endpoint_route_handler/readme/USAGE.rst,sha256=cAIFvvLV64TssTwGqMUAsqV8yB2Du--eycoa9U7pXik,2035
+odoo/addons/endpoint_route_handler/security/ir.model.access.csv,sha256=rVSuBZ2BXEyK5f2Q4c9dHYyrB3IiMSpaDp1xWKlMWkU,565
 odoo/addons/endpoint_route_handler/static/description/icon.png,sha256=6xBPJauaFOF0KDHfHgQopSc28kKvxMaeoQFQWZtfZDo,9455
-odoo/addons/endpoint_route_handler/static/description/index.html,sha256=LH8Yl90EbI9u-Zfdp1R9htqkxo_i9Gj4HCCDHPIKLhg,14468
-odoo/addons/endpoint_route_handler/tests/__init__.py,sha256=-_pIt_B8gTI0YknCT1q7lZZs23uNH_VoQCgl9Nyey4o,67
-odoo/addons/endpoint_route_handler/tests/common.py,sha256=QmWNiytbT8yY_at56vyuuh0ivwuYlOFAF2xOHSGVKuw,1630
-odoo/addons/endpoint_route_handler/tests/test_endpoint.py,sha256=GoteUffofoGqn7Hr1LZF83uWmql5CaX-X5acypaVIww,3176
-odoo/addons/endpoint_route_handler/tests/test_endpoint_controller.py,sha256=L4xkPaWmRiZE8h-b4crLcoGWK8qnILVOuSJw1jJKwhw,2584
-odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/METADATA,sha256=Gb0PZ--D6L97koYPCXMB2iSv4PhRpS_3EsFthbSJJyA,5048
-odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
-odoo14_addon_endpoint_route_handler-14.0.1.1.1.dev4.dist-info/RECORD,,
+odoo/addons/endpoint_route_handler/static/description/index.html,sha256=0HNdYvjtZWc236SD9CFXm4M9u5-pl2UuZr_0yuvW95o,15448
+odoo/addons/endpoint_route_handler/tests/__init__.py,sha256=C_DcxSLSqZi03vk6eJb6RHXtwFx-3WPI2XIr8w1ONCg,95
+odoo/addons/endpoint_route_handler/tests/common.py,sha256=Oy_vfq-_VJUlCDotTkmu8UdC_S7-pZ_yZlBPQ3SQ6mM,1647
+odoo/addons/endpoint_route_handler/tests/fake_controllers.py,sha256=EFtKYYPGXAz8cRcCQUe_kFD3Cy_uFeK6ov7NRXK4Ick,821
+odoo/addons/endpoint_route_handler/tests/test_endpoint.py,sha256=lrMlFGERLITlfUa-FPLdRwTJl8A79DqT067UB5jE2pQ,6641
+odoo/addons/endpoint_route_handler/tests/test_endpoint_controller.py,sha256=VTNZEH2wvErDhra3V0qf6MeQeWc5wAGYfF6qIqZJHmY,2353
+odoo/addons/endpoint_route_handler/tests/test_registry.py,sha256=jh8RDaxDZO4k49acmOrStFnis3mZDKNzCmX7NAFZBLc,8001
+odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/METADATA,sha256=J_B0M8ogPMmPJJAsPdNtP_k33mUNjgamd4K3M3db5OI,5875
+odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
+odoo14_addon_endpoint_route_handler-14.0.2.0.1.dev2.dist-info/RECORD,,
```

